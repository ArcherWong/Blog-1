<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rxliuli blog</title>
  
  
  <link href="https://blog.rxliuli.com/atom.xml" rel="self"/>
  
  <link href="https://blog.rxliuli.com/"/>
  <updated>2021-06-19T04:39:42.555Z</updated>
  <id>https://blog.rxliuli.com/</id>
  
  <author>
    <name>rxliuli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写兼容 nodejs/浏览器的库</title>
    <link href="https://blog.rxliuli.com/p/b8a95af9134a488e9d94463bd18768c9/"/>
    <id>https://blog.rxliuli.com/p/b8a95af9134a488e9d94463bd18768c9/</id>
    <published>2021-06-04T16:04:05.510Z</published>
    <updated>2021-06-19T04:39:42.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>兼容问题是由于使用了平台特定的功能导致，会导致下面几种情况</p><ul><li>不同的模块化规范：rollup 打包时指定</li><li>平台限定的代码：例如包含不同平台的适配代码</li><li>平台限定的依赖：例如在 nodejs 需要填充 <code>fetch/FormData</code></li><li>平台限定的类型定义：例如浏览器中的 <code>Blob</code> 和 nodejs 中的 <code>Buffer</code></li></ul><h2 id="不同的模块化规范"><a href="#不同的模块化规范" class="headerlink" title="不同的模块化规范"></a>不同的模块化规范</h2><p>这是很常见的一件事，现在就已经有包括 cjs/amd/iife/umd/esm 多种规范了，所以支持它们（或者说，至少支持主流的 cjs/esm）也成为必须做的一件事。幸运的是，打包工具 rollup 提供了相应的配置支持不同格式的输出文件。</p><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/multiple-module-format">GitHub 示例项目</a></p></blockquote><p>形如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig(&#123;<br>  input: <span class="hljs-string">&quot;src/index.ts&quot;</span>,<br>  output: [<br>    &#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>, <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;dist/index.js&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>    &#123; <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;esm&quot;</span>, <span class="hljs-attr">file</span>: <span class="hljs-string">&quot;dist/index.esm.js&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>  ],<br>  plugins: [typescript()],<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在 package.json 中指定即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;dist/index.esm.js&quot;</span>,<br>  <span class="hljs-attr">&quot;types&quot;</span>: <span class="hljs-string">&quot;dist/index.d.ts&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>许多库都支持 cjs/esm，例如 <a href="https://github.com/rollup/rollup/blob/master/package.json">rollup</a>，但也有仅支持 esm 的库，例如 <a href="https://github.com/unifiedjs">unified.js 系列</a></p></blockquote><h2 id="平台限定的代码"><a href="#平台限定的代码" class="headerlink" title="平台限定的代码"></a>平台限定的代码</h2><ul><li>通过不同的入口文件打包不同的出口文件，并通过 <code>browser</code> 指定环境相关的代码，例如 <code>dist/browser.js</code>/<code>dist/node.js</code>：使用时需要注意打包工具（将成本转嫁给使用者）</li><li>使用代码判断运行环境动态加载</li></ul><table><thead><tr><th>对比</th><th>不同出口</th><th>代码判断</th></tr></thead><tbody><tr><td>优点</td><td>代码隔离的更彻底</td><td>不依赖于打包工具行为</td></tr><tr><td></td><td>最终代码仅包含当前环境的代码</td><td></td></tr><tr><td>缺点</td><td>依赖于使用者的打包工具的行为</td><td>判断环境的代码可能并不准确</td></tr><tr><td></td><td></td><td>最终代码包含所有代码，只是选择性加载</td></tr></tbody></table><blockquote><p>axios 结合以上两种方式实现了浏览器、nodejs 支持，但同时导致有着两种方式的缺点而且有点迷惑行为，参考 <a href="https://github.com/axios/axios/blob/e9965bfafc82d8b42765705061b9ebe2d5532493/dist/axios.js#L872-L882">getDefaultAdapter</a>。例如在 jsdom 环境会认为是浏览器环境，参考 <a href="https://github.com/axios/axios/issues/1180">detect jest and use http adapter instead of XMLHTTPRequest</a></p></blockquote><h3 id="通过不同的入口文件打包不同的出口文件"><a href="#通过不同的入口文件打包不同的出口文件" class="headerlink" title="通过不同的入口文件打包不同的出口文件"></a>通过不同的入口文件打包不同的出口文件</h3><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-code-multiple-bundle">GitHub 示例项目</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig(&#123;<br>  input: [<span class="hljs-string">&quot;src/index.ts&quot;</span>, <span class="hljs-string">&quot;src/browser.ts&quot;</span>],<br>  output: [<br>    &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>    &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/esm&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;esm&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>  ],<br>  plugins: [typescript()],<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/cjs/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;dist/esm/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;types&quot;</span>: <span class="hljs-string">&quot;dist/index.d.ts&quot;</span>,<br>  <span class="hljs-attr">&quot;browser&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;dist/cjs/index.js&quot;</span>: <span class="hljs-string">&quot;dist/cjs/browser.js&quot;</span>,<br>    <span class="hljs-attr">&quot;dist/esm/index.js&quot;</span>: <span class="hljs-string">&quot;dist/esm/browser.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用代码判断运行环境动态加载"><a href="#使用代码判断运行环境动态加载" class="headerlink" title="使用代码判断运行环境动态加载"></a>使用代码判断运行环境动态加载</h3><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-code-dynamic-judgment">GitHub 示例项目</a></p></blockquote><p>基本上就是在代码中判断然后 <code>await import</code> 而已</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; BaseAdapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./adapters/BaseAdapter&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Class &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;type-fest&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseAdapter</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> adapter?: BaseAdapter;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.adapter) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> Adapter: Class&lt;BaseAdapter&gt;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fetch === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>      Adapter = (<span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./adapters/NodeAdapter&quot;</span>)).NodeAdapter;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Adapter = (<span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./adapters/BrowserAdapter&quot;</span>)).BrowserAdapter;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.adapter = <span class="hljs-keyword">new</span> Adapter();<br>  &#125;<br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(url: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.init();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.adapter!.get(url);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig(&#123;<br>  input: <span class="hljs-string">&quot;src/index.ts&quot;</span>,<br>  output: &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>  plugins: [typescript()],<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注: vitejs 无法捆绑处理这种包，因为 nodejs 原生包在浏览器环境确实不存在，这是一个已知错误，参考：<a href="https://github.com/aws-amplify/amplify-js/issues/7499">Cannot use amplify-js in browser environment (breaking vite/snowpack/esbuild)</a>。</p></blockquote><h2 id="平台限定的依赖"><a href="#平台限定的依赖" class="headerlink" title="平台限定的依赖"></a>平台限定的依赖</h2><ul><li>直接 <code>import</code> 依赖使用：会导致在不同的环境炸掉（例如 <code>node-fetch</code> 在浏览器就会炸掉）</li><li>在代码中判断运行时通过 <code>require</code> 动态 引入依赖：会导致即便用不到，也仍然会被打包加载</li><li>在代码中判断运行时通过 <code>import()</code> 动态引入依赖：会导致代码分割，依赖作为单独的文件选择性加载</li><li>通过不同的入口文件打包不同的出口文件，例如 <code>dist/browser.js</code>/<code>dist/node.js</code>：使用时需要注意（将成本转嫁给使用者）</li><li>声明 <code>peerDependencies</code> 可选依赖，让使用者自行填充：使用时需要注意（将成本转嫁给使用者）</li></ul><table><thead><tr><th>对比</th><th>require</th><th>import</th></tr></thead><tbody><tr><td>是否一定会加载</td><td>是</td><td>否</td></tr><tr><td>是否需要开发者注意</td><td>否</td><td>否</td></tr><tr><td>是否会多次加载</td><td>否</td><td>是</td></tr><tr><td>是否同步</td><td>是</td><td>否</td></tr><tr><td>rollup 支持</td><td>是</td><td>是</td></tr></tbody></table><h2 id="在代码中判断运行时通过-require-动态引入依赖"><a href="#在代码中判断运行时通过-require-动态引入依赖" class="headerlink" title="在代码中判断运行时通过 require 动态引入依赖"></a>在代码中判断运行时通过 <code>require</code> 动态引入依赖</h2><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-lib-require">GitHub 项目示例</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/adapters/BaseAdapter.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseAdapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./BaseAdapter&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserAdapter</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseAdapter</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fetch === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> globalVar: <span class="hljs-built_in">any</span> =<br>        (<span class="hljs-keyword">typeof</span> globalThis !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; globalThis) ||<br>        (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; self) ||<br>        (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">global</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-built_in">global</span>) ||<br>        &#123;&#125;;<br>      <span class="hljs-comment">// 关键在于这里的动态 require</span><br>      <span class="hljs-built_in">Reflect</span>.set(globalVar, <span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;node-fetch&quot;</span>).default);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(url: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;T&gt; &#123;<br>    BrowserAdapter.init();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> fetch(url)).json();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/resource/1a7d05ea9c1e4978bcc540c2eb8cca6f.png" alt="1624018106300"></p><h2 id="在代码中判断运行时通过-import-动态引入依赖"><a href="#在代码中判断运行时通过-import-动态引入依赖" class="headerlink" title="在代码中判断运行时通过 import() 动态引入依赖"></a>在代码中判断运行时通过 <code>import()</code> 动态引入依赖</h2><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-lib-import">GitHub 项目示例</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/adapters/BaseAdapter.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseAdapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./BaseAdapter&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserAdapter</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseAdapter</span> </span>&#123;<br>  <span class="hljs-comment">// 注意，这里变成异步的函数了</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fetch === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> globalVar: <span class="hljs-built_in">any</span> =<br>        (<span class="hljs-keyword">typeof</span> globalThis !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; globalThis) ||<br>        (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; self) ||<br>        (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">global</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-built_in">global</span>) ||<br>        &#123;&#125;;<br>      <span class="hljs-built_in">Reflect</span>.set(globalVar, <span class="hljs-string">&quot;fetch&quot;</span>, (<span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;node-fetch&quot;</span>)).default);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> get&lt;T&gt;(url: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">await</span> BrowserAdapter.init();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> fetch(url)).json();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打包结果</p><p><img src="/resource/a5134edf1c7b4742aed1a0914faa45ad.png" alt="1624018026889"></p><h3 id="遇到的一些子问题"><a href="#遇到的一些子问题" class="headerlink" title="遇到的一些子问题"></a>遇到的一些子问题</h3><ul><li><p>怎么判断是否存在全局变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">typeof</span> fetch === <span class="hljs-string">&quot;undefined&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>怎么为不同环境的全局变量写入 ployfill</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> globalVar: <span class="hljs-built_in">any</span> =<br>  (<span class="hljs-keyword">typeof</span> globalThis !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; globalThis) ||<br>  (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; self) ||<br>  (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">global</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-built_in">global</span>) ||<br>  &#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>TypeError: Right-hand side of &#39;instanceof&#39; is not callable</code>: 主要是 axios 会判断 <code>FormData</code>，而 <code>form-data</code> 则存在默认导出，所以需要使用 <code>(await import(&#39;form-data&#39;)).default</code>（吾辈总有种在给自己挖坑的感觉）<br><img src="/resource/2085a6a480124ea8b0fdddf4877f75c7.png" alt="1622828175546"></p></li></ul><p>使用者在使用 rollup 打包时可能会遇到兼容性的问题，实际上就是需要选择内联到代码还是单独打包成一个文件，参考：<a href="https://rollupjs.org/guide/en/#inlinedynamicimports">https://rollupjs.org/guide/en/#inlinedynamicimports</a></p><p>内联 =&gt; 外联</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 内联</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  output: &#123;<br>    file: <span class="hljs-string">&quot;dist/extension.js&quot;</span>,<br>    format: <span class="hljs-string">&quot;cjs&quot;</span>,<br>    sourcemap: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 外联</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  output: &#123;<br>    dir: <span class="hljs-string">&quot;dist&quot;</span>,<br>    format: <span class="hljs-string">&quot;cjs&quot;</span>,<br>    sourcemap: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="平台限定的类型定义"><a href="#平台限定的类型定义" class="headerlink" title="平台限定的类型定义"></a>平台限定的类型定义</h2><p>以下解决方案本质上都是多个 bundle</p><ul><li>混合类型定义。例如 axios</li><li>打包不同的出口文件和类型定义，要求使用者自行指定需要的文件。例如通过 <code>module/node</code>/<code>module/browser</code> 加载不同的功能（其实和插件系统非常接近，无非是否分离多个模块罢了）</li><li>使用插件系统将不同环境的适配代码分离为多个子模块。例如 remark.js 社区</li></ul><table><thead><tr><th>对比</th><th>多个类型定义文件</th><th>混合类型定义</th><th>多模块</th></tr></thead><tbody><tr><td>优点</td><td>环境指定更明确</td><td>统一入口</td><td>环境指定更明确</td></tr><tr><td>缺点</td><td>需要使用者自行选择</td><td>类型定义冗余</td><td>需要使用者自行选择</td></tr><tr><td></td><td>dependencies 冗余</td><td></td><td>维护起来相对麻烦（尤其是维护者不是一个人的时候）</td></tr></tbody></table><h3 id="打包不同的出口文件和类型定义，要求使用者自行指定需要的文件"><a href="#打包不同的出口文件和类型定义，要求使用者自行指定需要的文件" class="headerlink" title="打包不同的出口文件和类型定义，要求使用者自行指定需要的文件"></a>打包不同的出口文件和类型定义，要求使用者自行指定需要的文件</h3><blockquote><p><a href="https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-type-definition-multiple-bundle">GitHub 项目示例</a></p></blockquote><p>主要是在核心代码做一层抽象，然后将平台特定的代码抽离出去单独打包。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/index.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseAdapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./adapters/BaseAdapter&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">BaseAdapter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  upload: BaseAdapter&lt;T&gt;[<span class="hljs-string">&quot;upload&quot;</span>];<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> base: BaseAdapter&lt;T&gt;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.upload = <span class="hljs-built_in">this</span>.base.upload;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig([<br>  &#123;<br>    input: <span class="hljs-string">&quot;src/index.ts&quot;</span>,<br>    output: [<br>      &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/esm&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;esm&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>    ],<br>    plugins: [typescript()],<br>  &#125;,<br>  &#123;<br>    input: [<span class="hljs-string">&quot;src/adapters/BrowserAdapter.ts&quot;</span>, <span class="hljs-string">&quot;src/adapters/NodeAdapter.ts&quot;</span>],<br>    output: [<br>      &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/cjs/adapters&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;cjs&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">dir</span>: <span class="hljs-string">&quot;dist/esm/adapters&quot;</span>, <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;esm&quot;</span>, <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span> &#125;,<br>    ],<br>    plugins: [typescript()],<br>  &#125;,<br>]);<br></code></pre></td></tr></table></figure><p>使用者示例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Adapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;platform-specific-type-definition-multiple-bundle&quot;</span>;<br><br><span class="hljs-keyword">import</span> &#123; BrowserAdapter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;platform-specific-type-definition-multiple-bundle/dist/esm/adapters/BrowserAdapter&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">browser</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> adapter = <span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> BrowserAdapter());<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;browser: &quot;</span>, <span class="hljs-keyword">await</span> adapter.upload(<span class="hljs-keyword">new</span> Blob()));<br>&#125;<br><br><span class="hljs-comment">// import &#123; NodeAdapter &#125; from &#x27;platform-specific-type-definition-multiple-bundle/dist/esm/adapters/NodeAdapter&#x27;</span><br><span class="hljs-comment">// export async function node() &#123;</span><br><span class="hljs-comment">//   const adapter = new Adapter(new NodeAdapter())</span><br><span class="hljs-comment">//   console.log(&#x27;node: &#x27;, await adapter.upload(new Buffer(10)))</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="使用插件系统将不同环境的适配代码分离为多个子模块"><a href="#使用插件系统将不同环境的适配代码分离为多个子模块" class="headerlink" title="使用插件系统将不同环境的适配代码分离为多个子模块"></a>使用插件系统将不同环境的适配代码分离为多个子模块</h3><p>简单来说，如果你希望将运行时依赖分散到不同的子模块中（例如上面那个 <code>node-fetch</code>），或者你的插件 API 非常强大，那么便可以将一些<strong>官方</strong>适配代码分离为插件子模块。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><img src="/resource/1fb8606dac2c487eafca45ecc4e3a9a3.svg" alt="兼容 nodejs 与浏览器的库的技术方案选择.drawio.svg"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="javascript" scheme="https://blog.rxliuli.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何看待新事物</title>
    <link href="https://blog.rxliuli.com/p/4a6736bffd064ed9b46d2021870039ec/"/>
    <id>https://blog.rxliuli.com/p/4a6736bffd064ed9b46d2021870039ec/</id>
    <published>2021-05-13T05:03:35.771Z</published>
    <updated>2021-06-13T11:22:48.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>以使用者的角度看待问题</li><li>包含技术和一些工具</li></ul><h2 id="新的事物一定会更好么？"><a href="#新的事物一定会更好么？" class="headerlink" title="新的事物一定会更好么？"></a>新的事物一定会更好么？</h2><blockquote><p>历史是螺旋上升的，新事物总是解决一些问题，然后带来新的问题。</p></blockquote><ul><li>工具软件：<a href="https://meta.appinn.net/">小众软件</a>，<a href="https://www.iplaysoft.com/">异次元软件世界</a>，<a href="https://xbeta.info/">善用佳软</a></li><li>大而全还是小而美: 应该选择 IDE 还是库提供的功能？: eslint/prettier/git hooks</li></ul><p>技术</p><ul><li>babel: 在 v5 可以一次引入全部，在 v6 划分为许多零碎的小模块，由于对开发者使用及其不友好，v7 又支持了类似 v5 的使用方式</li><li>husky: v4 支持在 package.json 中定义 git hooks，v5 突发奇想使用原生 git hooks 语法，v6 又撤销回去了</li><li>mobx: 在 v5 使用装饰器，v6 再次回到了高阶函数</li><li>tailwind css: 几年前就有 atomic css 的概念了，不过那时候被喷，但最近似乎又流行了</li><li>vscode: 开源的 eclipse 被 JetBrains IDE 干掉之后，后面 vscode 又流行了起来</li><li>客户端: 原生程序(windows/qt) =&gt; web(react/vue) =&gt; web 技术跨平台(electron/react-native) =&gt; 非 web 技术跨平台(flutter/kotlin desktop)</li><li>虚拟 dom: 模板引擎 =&gt; react/vue =&gt; svelte</li><li>状态管理: 可变 ng =&gt; 不可变 react/redux/immer =&gt; 可变 vue/mobx</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>对比</p><table><thead><tr><th>类型</th><th>基于 DSL</th><th>所见即所得</th></tr></thead><tbody><tr><td>文档</td><td>markdown</td><td>word/google docs</td></tr><tr><td>绘图</td><td>mermaid/uml/c4model</td><td>drawio/思维导图/google 绘图</td></tr><tr><td>笔记</td><td>vscode/基于 markdown 的工具</td><td>notion/印象笔记</td></tr><tr><td>PPT</td><td>revealjs/slidev</td><td>PPT</td></tr></tbody></table><p>问题：如何平衡自由度和易用性？</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>问题</p><ul><li>是否使用富文本？</li><li>是否支持所见即所得？</li></ul><p>选择</p><ul><li>markdown 限制了富文本的功能，并将允许的功能做到最好。</li><li>然而 markdown 抛弃了富文本而使用纯文本，所以也衍生出 UI 是富文本，底层是 markdown 的思路所见即所得编辑器，例如 Typora、Notion 这些。</li><li>word/google docs 这种富文本工具有个痛苦的点是布局非常烦人，想要实现精美的布局需要非常高的熟练度和大量的时间，甚至可以做到 markdown 无法做的效果。但话又说回来，很多人并不能把 word 玩的非常熟，只能制作简单的文档罢了。</li></ul><p>下图为在 vscode 中编辑 markdown</p><p><img src="/resource/b4963c306548404b867137d261c19e36.png" alt="1622211928274"></p><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>问题</p><ul><li>是否要使用 DSL 渲染绘图？</li><li>是否使用自动布局算法？</li></ul><p>选择</p><ul><li>mermaid/uml/c4model：通过 DSL 渲染各种图表，但通常编辑能力非常有限。由于实际数据是文本，所以能够非常方便的编程式处理。</li><li>drawio/google 绘图：完全自由的一块画布，可以任意拖拽自由布局，但为了减轻调整细节的麻烦，所以都实现了自动对齐的功能。扩展性方面取决于官方支持，如果有 sdk 就还好。</li><li>思维导图：比较好的平衡了布局的自由和便利，可以拖拽控制位置，但布局仍然是自动的，这是吾辈认为绘图工具中最好的一种实现。</li></ul><p>下面是使用 drawio 绘制流程图和使用百度脑图绘制思维导图的区别</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-code">```mermaid</span><br><span class="hljs-code">graph TD;</span><br><span class="hljs-code">id1[start]</span><br><span class="hljs-code">id2[step 1]</span><br><span class="hljs-code">id3[step 2]</span><br><span class="hljs-code">id4[end]</span><br><span class="hljs-code">id1 --&gt; id2 --&gt; id3 --&gt; id4</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><p><img src="/resource/5ae6c3b90e464d75975cb492a123d98b.png" alt="1622643314587"></p><p><img src="/resource/0dd48273156a4cf18ceb7753a004f3b7.gif" alt="使用 drawio 绘制流程图"></p><p><img src="/resource/b6e75d38e1974b06b1d95a70e6417a30.gif" alt="使用百度脑图绘制思维导图"></p><p>一些需求</p><ul><li>所见即所得</li><li>实际存储的是文本（或提供 sdk 支持）</li><li>支持控制相对位置，但仍然自动布局</li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><table><thead><tr><th>类型</th><th>新兴技术</th><th>相对传统的技术</th></tr></thead><tbody><tr><td>打包工具</td><td>esbuild</td><td>rollup/webpack</td></tr><tr><td>框架</td><td>svelte</td><td>react/vue</td></tr></tbody></table><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><p>问题</p><ul><li>是否使用 js 编写？</li><li>是否灵活优先于用户体验？</li></ul><p>选择</p><p>esbuild、rollup、webpack 它们的选择其实很有意思。</p><ul><li>webpack：生来就以强大的灵活性自居，在 2018 年尝试接触 webpack 时感觉很麻烦，转而使用不需要 webpack 的 vue。但由于其它打包工具的影响（rollup/parcel），后来也声称支持了零配置，但实际上还是有非常非常多的配置，甚至衍生出了 <a href="https://www.zhihu.com/question/267908710">webpack 配置工程师</a> 这个梗。正因如此，create-react-app/vue-cli 都以 webpack 作为底层二次封装 cli。</li><li>rollup: rollup 本身相比于 webpack 没有那么多配置，复杂度要低得多。尤其是它的许多插件都是真正意义上的支持开箱即用，默认不需要配置即可使用。而且它没有什么难懂的概念，基本上就是指定 input 和 output 就打包好了。但它仍然是使用 js 实现，所以性能方面有一些提升，但不是质的变化。</li><li>esbuild: 完全采取了新的做法，使用 golang 编写，利用多线程加速，导致它比基于 js 的方案快 10-100 倍，实测单独使用时也确实可以做到。而且 vite/snowpack 这些新型的脚手架都使用它去编译 ts/js 以提高性能，最近更是出现了爆发式的生态建设（吾辈之前也在 <a href="https://www.npmjs.com/package/@liuli-util/cli">@liuli-util/cli</a> 中尝试过）。但这样做也不是全无问题，首先它脱离了现有生态重新实现，导致打包功能并不完善，所以 vite 仅利用它去编译 ts/js 而非整个打包，参考：<a href="https://cn.vitejs.dev/guide/why.html#why-not-bundle-with-esbuild">为何不用 ESBuild 打包？</a>。</li></ul><p>总的来说，rollup 是目前最好用的基于 js 的打包工具，而 esbuild 则非常值得观望 – 如果社区生态能够成熟起来，则打包性能会飞速提升，前端开发也可能不得不多学一两门其它语言了（golang/rust）。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>问题</p><ul><li>是否基于虚拟 dom？</li><li>生态是否成熟？</li><li>官方的设计理念是怎么样的？</li></ul><p>选择</p><blockquote><p>关于这三个框架 vue 作者曾经也做过一些对比，参考 <a href="https://youtu.be/bOdfo5SmQc8">dotJS 2019 - Evan You - State of Components</a><br>吾辈曾经从 vue =&gt; react 的一些想法：<a href="/p/f7599ffb024149e1a8928b61e8fdcd42">面相 vue 开发者的 react 入坑指南</a></p></blockquote><ul><li>react: 最流行的前端框架，生态非常成熟，但官方更倾向于无为而治，强调哲学与设计理念而非开发者体验。</li><li>svelte: 去年非常火的一个前端框架，倾向于使用编译器在编译阶段做更多的事，避免虚拟 dom 运行时的存在。生态上还非常小，jetbrains 目前没有官方支持它。</li></ul><h3 id="前端那些曾经流行过的技术"><a href="#前端那些曾经流行过的技术" class="headerlink" title="前端那些曾经流行过的技术"></a>前端那些曾经流行过的技术</h3><blockquote><p>参考：<a href="https://www.zhihu.com/question/35069742">2015 有哪些目前流行的前端框架？</a></p></blockquote><p>看看还认识几个</p><p><img src="/resource/64440cbe1f2943e2ab20067b09150b0f.png" alt="1622214639959"></p><ul><li>模块加载方案：CommonJS、AMD、UMD、System</li><li>打包工具：Gulp、Grunt、browserify</li><li>框架：jQuery、Prototype、AngularJS、BootStrap、Underscore.js</li></ul><p>正在衰落的技术</p><ul><li>Webpack：Vue 作者的脚手架工具已经彻底放弃，这带来了非常大的变化，参考：<a href="https://twitter.com/TheLarkInn/status/1255686575121330176">https://twitter.com/TheLarkInn/status/1255686575121330176</a></li><li>Redux：同样的，redux 作者也表示 redux 过度灵活和复杂化了，参考：<a href="https://twitter.com/dan_abramov/status/1039570011986321408">https://twitter.com/dan_abramov/status/1039570011986321408</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>新事物不断出现，有些是更好的，但有更多会湮没在历史中。选择合适的新事物去学习和使用，比单纯的东做一点、西做一点更有效果（选择比努力更重要）。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么现在还要选择盗版</title>
    <link href="https://blog.rxliuli.com/p/b91c8378f6594f2996bc437e587c0420/"/>
    <id>https://blog.rxliuli.com/p/b91c8378f6594f2996bc437e587c0420/</id>
    <published>2021-03-31T19:27:31.261Z</published>
    <updated>2021-04-03T06:15:35.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可能是一位正版的受害者</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总的来说，在工作之后力所能及的情况下，对于支持正版，吾辈是举双手赞成的，因为吾辈作为创作者的一类–开发者，确实明白为有价值的事物付费是理所当然的。对于各类服务、软件、App，吾辈并不吝于付费。</p><p>简要列出一些</p><ul><li>Steam 游戏：2446 软妹币/去年</li><li>JetBrains IDE 系列：$199/y</li><li>Wallaby/Quokka：$150/y</li><li>Proxifier 透明代理：$39.95</li><li>BosLife 机场云服务：459 软妹币/y</li><li>Nexitally 机场云服务：798 软妹币/y</li><li>百度网盘：198 软妹币/y</li><li>GitHub 捐款：$24/y</li><li>App 购买<ul><li>不做手机控（未使用）</li><li>Sleep Cycle</li><li>欧路词典</li><li>NeatReader</li><li>静读天下</li></ul></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>但是，这并非代表吾辈不再使用盗版了，不如说，至今为止，在网络小说、日本动画方面，吾辈仍然会优先选择盗版。<br>是的，不管是网络小说的订阅也好，网站的会员也罢，它们对于已然工作的人而言成本并不算高 – 当然，这并不代表成本为 0。</p><p>吾辈不想入正的真正原因是：<strong>不想成为正版的受害者。</strong></p><ol><li> 事实上，没有一家网站拥有所有小说、动画的版权，这意味着想看的内容分散到各个网站中时，那么必须在不同的平台上多次付费，这点不管是从使用体验上，还是从成本上而言，都是难以接受的。</li><li> 动画方面在平台上随时有可能被和谐、下架或整改，而小说，由于数量之多，导致被删除的数不胜数，即便你已经付费了，在删除后仍然无法查看（这里必须顶一下 Steam，至少，吾辈现在还能玩<strong>还愿</strong>）</li></ol><p>这里还必须点名批评 bilibili 和 刺猬猫（原名书客）</p><h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h2><p>bilibili 自从某个时期开始，就已经变成了自己最讨厌的样子，有多久没有使用过 b 站了呢？吾辈也忘记了呢</p><ul><li>新番资源不全</li><li>新番存在删减</li><li>旧番（没有版权）被删除</li><li>整体氛围随着更多人的涌入严重下降</li></ul><blockquote><ul><li><a href="https://zh.wikipedia.org/wiki/Bilibili%E7%9B%B8%E5%85%B3%E4%BA%89%E8%AE%AE">bilibili 相关争议</a></li><li>国内任何产品都是用户多了就一定变烂，参考：<a href="http://www.gov.cn/xinwen/2020-09/29/content_5548176.htm">第 46 次《中国互联网络发展状况统计报告》</a> <strong>网民结构</strong> 一节</li></ul></blockquote><h2 id="刺猬猫"><a href="#刺猬猫" class="headerlink" title="刺猬猫"></a>刺猬猫</h2><p>刺猬猫的话，相比于起点，令人讨厌之处在于将文字转图片的方式显示，以致于很难找到盗版网站。简而言之，互联网上的信息不再公开，也基本难以长存，人们常说，互联网是有记忆的，那么，像这种事情又算什么呢？</p><p>吾辈已经不是第一次遇到查看小说时看到这个页面的情况了</p><p><img src="/resource/3b4cc0d9ba694947bed9aa224cfc5c04.png" alt="1617220590795"></p><p>起点有时候似乎更聪明了一些，小说首页仍然可见，但无法阅读任何章节。嗯，在封禁了作品之后，仍然使用作品来吸引流量，真是厉害了。</p><p>简单列举一些吾辈看过且和谐的作品</p><ul><li>事象的宏图</li><li>逃亡犯报告</li><li>永不解密</li><li>腹黑三无少女日记</li><li>科技超能王</li><li>法师伊凡</li><li>迷失在星空</li><li>细胞渗透</li><li>独游</li><li>天麻・续章</li><li>今夜，爱丽丝加入狩猎</li><li>天才麻将少女之岭上雪花</li><li>幻想乡玩家</li></ul><p>有些小说吾辈甚至没想明白为什么会和谐，毕竟看美少女打超能力麻将会有什么问题呢？</p><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>那么，下面简要列出一些吾辈的替代方案</p><p>动画</p><ul><li>新番 bt 网站：<a href="https://dmhy.org/">动漫花园</a></li><li>老番百度网盘下载论坛：<a href="https://www.tsdm39.net/">天使动漫论坛</a></li><li>bt 下载工具：<a href="https://www.qbittorrent.org/">qBittorrent</a></li></ul><p>小说</p><ul><li>查找方式：<a href="http://google.com/">Google</a></li><li>阅读器：<a href="https://play.google.com/store/apps/details?id=com.flyersoft.moonreaderp&hl=zh&gl=US">静读天下 Pro</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有时候，不是不肯付费，而是即便付费成为正版之后体验比盗版更烂，当然你也可以说吾辈是在找借口就是了。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://blog.rxliuli.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2021 第十二周</title>
    <link href="https://blog.rxliuli.com/p/f6802ba280a8479abe0cf6f908a2f273/"/>
    <id>https://blog.rxliuli.com/p/f6802ba280a8479abe0cf6f908a2f273/</id>
    <published>2021-03-29T07:15:30.494Z</published>
    <updated>2021-04-02T04:07:38.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速一览"><a href="#快速一览" class="headerlink" title="快速一览"></a>快速一览</h2><ul><li>回到老家</li><li>看望姥姥</li><li>继续购买睡衣（其实是购物减压啦）</li><li>饭局 * 2</li><li>算法：尝试理解<strong>高楼扔鸡蛋</strong>的问题</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>好吧，这（上）周的记录好像写的有些晚了，不过吾辈今天才离开家里，所以便在高铁上写下了这篇。<br>这周完全是在老家度过的，本以为现在家里的天气会很冷，为之吾辈还带了一件厚衣服，但实际上仅仅只有早晨和傍晚才会比较冷，白天最高 20+°C 的温度让吾辈仅仅能穿一件薄外套，幸好考虑到从广州出发会不太冷所以带了。这么说吧，回家的时间还是很无聊的，没有网络（虽然可以使用流量）、没有人玩（小孩子也都在上学）。</p><hr><p>虽然仅仅只有 3 年，但家里的样子已然有了许多变化。曾经家乡小伙伴的奶奶死了，房子的围墙也倒掉了。家里的池塘已经变成了肉眼可见的污浊，据说是因为之前有人养猪直接将粪便之类的排入到水中所致。村庄里面的小路已经有许多不再是路，不是被堵住，就是被当成田地种上了油菜花。看到曾经童年时的一大片草地被人用挖土机挖了一个大坑卖土壤，就觉得家乡人真是无药可救了。</p><blockquote><p>感觉从丰富程度上而言，上学时期几乎占据了人生一半的长度</p></blockquote><p><img src="/resource/4b8b5e37ff5b452dba33ffc68d781b3c.png" alt="1617010201279"><br><img src="/resource/ce0f530357dd4ca3b4a6a3cf06476284.png" alt="1617010212626"></p><hr><p>比较麻烦的是奶奶，由于她的耳朵不太好，再加上吾辈说的是普通话，所以非常难以交流，而且总是容易出现<strong>表达与行动的错位</strong>，即好心办坏事。下面说一个简单的例子：</p><ul><li>吾辈：奶奶你做饭太多了，吃不完。</li><li>奶奶：不够吃怎么办？</li><li>吾辈：我能吃多少啊</li><li>奶奶：你不吃谁吃呢？</li><li>吾辈（心声）：做多了吾辈也只能吃掉避免浪费，到底如何让她明白合适才是最好的呢？</li></ul><p>虽然和母上也会有类似的情况，但次数少的多，毕竟可以通过交流让她清除吾辈的饭量，但对于难以沟通的奶奶这种方法便没有了效果。</p><hr><p>当吾辈心情有些烦躁时，就会想去购物，是不是向奇怪的方向变化了？<br>这周主要是买了三件睡衣</p><p><img src="/resource/02e2a8b1563c494e8799cc6d753ceac2.png" alt="1617008270263"></p><hr><p>找到了吾辈曾经的秘密宝箱（开玩笑的），翻出了一些有趣的东西。</p><p><img src="/resource/15109e9b841d4a7e862f230907335460.png" alt="曾经喜欢的东西"><br><img src="/resource/498d35a6b71f47fc86fc9fdc6e5d8fd8.png" alt="学习日语的记录"><br><img src="/resource/4d86955cfa7746d79e8cbfe69f30a567.png" alt="喜欢二次元萝莉的本子"></p><p>其实还有一些上个世纪爷爷辈的<strong>东西</strong>，不过这里就不放出来了，毕竟是一些麻烦的东西。</p><hr><p>拍的几张家里的照片，就莫名觉得还不错</p><p><img src="/resource/5e3bf3cc18124c0f963b3fbcaef52d0d.png" alt="1617010003098"><br><img src="/resource/8f2d8b72748a4d6cbd6ca2002f97b662.png" alt="1617010072110"><br><img src="/resource/8c25384a4b8d467e8228581a01dfd8ec.png" alt="1617010153382"><br><img src="/resource/a99dac276deb4d68ac8bcd2c181215f8.png" alt="1617010109606"><br><img src="/resource/234d2e51d52d4547add5852e58769b9f.png" alt="1617010120241"><br><img src="/resource/4eec707c2eb9407785aa7be74cc85538.png" alt="1617010044579"></p><h2 id="一些认知"><a href="#一些认知" class="headerlink" title="一些认知"></a>一些认知</h2><h3 id="亲戚"><a href="#亲戚" class="headerlink" title="亲戚"></a>亲戚</h3><p>因为吾辈的爷爷有许多姐姐，所以从爷爷辈的算起，大概总的亲戚数量超过 100 人。而吾辈能记住的，不过寥寥十数人罢了，可能某些亲戚吾辈几乎没见过。是说，明明可能很久没有见过的人，却说自己是亲戚，然后就自来熟的说起话，吾辈很讨厌。</p><p>经过周六晚上的一顿饭局，吾辈明白了为什么吾辈之前不喜欢参加家乡饭局的原因</p><ul><li>铺张浪费的食物</li><li>吹牛</li><li>擅自对别人评头论足</li><li>不分轻重的开玩笑</li></ul><p>无论如何，吾辈回家仅仅是为了看望记忆中的那些人，并不是很在乎别人是怎么想的。</p><h3 id="金钱"><a href="#金钱" class="headerlink" title="金钱"></a>金钱</h3><p>不管是吾辈，还是家乡的人，现在真是一切向钱看了。几乎每个吾辈见到的亲戚，在和吾辈聊天时很快就会转到工作，和婚姻上。</p><p>他们对计算机行业的基本认知是</p><ul><li>高收入</li><li>跳槽可以涨薪</li></ul><p>但他们却并不了解这个行业的内卷，吾辈感受到的压力、焦虑和痛苦。</p><blockquote><p>人类的悲欢并不相通</p></blockquote><h3 id="婚姻"><a href="#婚姻" class="headerlink" title="婚姻"></a>婚姻</h3><p>悲剧的螺旋。</p><p>在吾辈看来，在很年轻的时候就去相亲、结婚、生孩子，早早地定下一切，最终不过是让自己的孩子面临着和自己相同的问题。简而言之，就是变成留守儿童。<br>曾经有句谚语：<strong>龙生龙，凤生凤，老鼠生来会打洞</strong>，那么，有人愿意自己的孩子和自己一样因为各种原因（教育、医疗资源、房贷），导致生活困顿么？<br>不会，为人父母者，总是期望自己的孩子能比自己过的更好。但是啊，但是呢，如果自己都做不到的事情，为什么会有孩子能够做到的期望呢？<br>那么破局的方法在哪里？<br>改变阶层、或者离开，但这些都很难，以至于妥协和放弃反而是一件更容易的事情。<br>或许在看不到希望的时候死掉也是一种不错的选择吧</p><blockquote><p>你们不肯入教（生韭菜）又不肯去死，我（国家）很为难啊</p></blockquote><h3 id="习俗"><a href="#习俗" class="headerlink" title="习俗"></a>习俗</h3><p>这次回家碰巧遇到了一位亲戚，大抵是吾辈姥姥的姐姐，他们回来过清明节，修坟、扫墓。但老实说，吾辈感觉家里的这些习俗还是声势浩大、铺张浪费了。</p><p><img src="/resource/be00fdc1e1434359a23b631e7aba3f0a.png" alt="1617003181100"></p><p><a href="/resource/86a75805195648188a93c3a69c42c94d.ogg">audio_2021-03-29_15-39-24.ogg</a></p><p>放炮之后，好吵、好难闻</p><p><img src="/resource/4052bf77bb3e40d88c358d10d759431b.png" alt="1617003644844"></p><p><a href="/resource/f71d62e8084f4288958ece97635aaabd.ogg">audio_2021-03-29_15-39-51.ogg</a></p><p>搞得像是打仗了一样 xd</p><blockquote><p>众所周知，土著这东西，一般都与盲目短视，愚昧落后，闭关自守这些美好品德紧密联系在一起。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
    <category term="周报" scheme="https://blog.rxliuli.com/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2021 第十一周</title>
    <link href="https://blog.rxliuli.com/p/b363e4f8f1c04983b35860ae09c6377a/"/>
    <id>https://blog.rxliuli.com/p/b363e4f8f1c04983b35860ae09c6377a/</id>
    <published>2021-03-21T07:09:36.620Z</published>
    <updated>2021-03-21T08:46:28.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速一览"><a href="#快速一览" class="headerlink" title="快速一览"></a>快速一览</h2><ul><li>周五正式离职</li><li>阿里云 DataV 内推失败</li><li>一家中小公司面试失败</li><li>周三请几位同事一起吃了顿饭</li><li>打算下周回老家休息一周</li><li>GitHub 评级上升至 A++</li><li>joplin-search-integration 功能已基本实现</li><li>尝试 git 约定式提交</li></ul><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>天空中不会留下飞鸟的痕迹。这周五，吾辈已然从公司离职了，和吾辈相关的东西都会随着时间慢慢消失吧。<br>曾经有人对吾辈说：“年轻真好，没有房贷家庭的压力，可以来一场说走就走的旅行呢！” 这句话不能说完全没有道理，因为吾辈认识的两个人都因为家庭（其实可能主要是房贷）的原因不敢离职，一位朋友借钱贷款导致 3 年内不敢离职，而另一位前同事则自称离职两个月就要破产了。<br>但吾辈却并不认为未成家就没有压力了，作为一个稍微有点努力的普通人，看到一丝机会便想抓住，但却一直未能得偿所愿的情况下，也会焦虑、迷惘与痛苦。另一位博主在 <a href="https://innei.ren/notes/81">极限</a> 一文中也曾经发出过对内卷的感慨。我们既是（内卷）受害者，但亦为加害者。</p><p>那么，吾辈想要去什么样的公司呢？</p><p>拥有优秀 team 的公司</p><ul><li>不是外包：吾辈不是针对谁，是说所有的外包公司都是垃圾</li><li>公司有一定的规模：一个人闭门造车不可取</li><li>公司能够正常盈利：不能盈利的公司是万恶之源</li><li>公司的技术栈比较新：jq/ng1 项目根本不值得去维护</li><li>不是 996：虽然互联网公司加班已经难以避免，但吾辈仍然不想去 996 福报，身体会首先撑不住</li></ul><p>这周也面试了另一家在做低代码平台的公司，老实说吾辈确实有点想去了，但似乎最终吾辈要求的薪资超过了它们的预算。。。想想都知道想找到合适的公司非常困难，但如果不去找合适的公司会变成什么样子呢？</p><ul><li>一直在做业务性的工作，到头来一直在低层次徘徊，突破不了自身的天花板</li><li>经历过这些事情之后，感慨国内不能做纯技术路线，遂转技术管理方向</li><li>按照父母的期望相亲结婚，然后终生为经济（房贷）所困</li></ul><p>这周工作日基本上有时间就在刷算法，但第一章的最后两小节，算法分析和连通性算法部分还是让吾辈感觉麻烦了，练习基本上只完成了 1.4.10-1.4.19。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>周三和公司的三位同事吃了一顿饭，发现公司的管理层也有非常多的内耗，这是吾辈之前没想到或者说没有察觉到的。</p><ul><li>两位管理层的矛盾</li><li>公司老人与新人的矛盾</li><li>老板的理想与现实的矛盾</li></ul><p>打算回老家休息一周，常年呆在这边，为了抓住渺茫的机会，不断地尝试和努力，或许，适时后退一步也好。毕竟人类，总是贪婪而不知足的生物啊。</p><p><img src="/resource/1ef24ee24f444202955ab68dd94c6b1b.png" alt="1616313126720"></p><p>这周不知道为什么 GitHub 的评级反而上升了，可能是吾辈最近活跃 GitHub 变得比较多了？总而言之吾辈还是很开心啦！</p><p><img src="https://github-readme-stats.vercel.app/api?username=rxliuli&show_icons=true&theme=tokyonight&line_height=40&v=5" alt="github status"></p><p><a href="https://github.com/rxliuli/joplin-search-integration">joplin-search-integration</a> 是一个将 joplin 的笔记结果集成到 google 搜索的一个 chrome 插件（理论上所有 chromium base 的浏览器应该都 ok），是从上上周开始的一个计划，至今为止发布了 v0.1.4 版本，功能性已然足够，不过细节方面仍然存在许多优化之处。</p><p>由于看到了一篇文章 <a href="https://cythilya.github.io/2021/03/16/conventional-commits/">約定式提交 Conventional Commits</a>，发现其中博主面临的问题吾辈也曾经遇到过，然而并未解决，所以在个人项目中进行了尝试，感觉还不错，和吾辈<strong>不是强制的规范就不是规范</strong>的想法很接近。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="周报" scheme="https://blog.rxliuli.com/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>2021 第十周</title>
    <link href="https://blog.rxliuli.com/p/72128a195d8f4f45a3d1ed895a50ecb5/"/>
    <id>https://blog.rxliuli.com/p/72128a195d8f4f45a3d1ed895a50ecb5/</id>
    <published>2021-03-14T07:25:54.235Z</published>
    <updated>2021-03-14T08:42:54.514Z</updated>
    
    <content type="html"><![CDATA[<p>距离提出离职已然过去三周了，但现在仍未找到合适的工作。也不是没有面试过，但确实没有找到合适的 – 对于吾辈而言，合适指的是优秀的 team，最好是平台而非业务 team。</p><p>吾辈也找到了一些大佬帮忙内推，包括</p><ul><li>快手 基础平台建设</li><li>百度 YY 直播</li><li>腾讯 微众银行</li><li>阿里云 DataV 数据可视化</li></ul><p>但最让吾辈感觉难过的不是面试之后因为能力不足而失败，而是即便内推也仍然没有面试的机会。当然吾辈也能理解，毕竟不拘一格降人才确实存在风险，更不用说吾辈只是一个努力的普通人 – 左耳朵耗子在 <a href="https://coolshell.cn/articles/19464.html">如何超过大多数人</a> 所说的第四类人。尽管吾辈也逐渐明白低层次的努力收效甚微，也因而离开现在的舒适区，但曾经确实没能制定合理完备的计划，然后实践和改进让自己变得更好。</p><p>之前尝试面试过两家小公司恢复状态，但公司真的是比烂，对比之下反而现在的公司还更好一点</p><p>目前还在面试的是 CVTE，是一个家在招聘网站上邀投然后拒掉简历然后再邀投的神奇公司，大概是不同产品线的 HR 吧。有趣的是，当吾辈问及 leader 对于 team 的评分时，也仍然是只有 6、7 分，这是吾辈第四次听到这个答案了，看来大部分 leader 都觉得自己的 team 不太行 xd</p><p>工作日一边补充公司相关文档以供交接，另一方面则是在看 <a href="https://book.douban.com/subject/19952400/">算法 4</a> 上的一些内容，练习链表相关的那些问题，但到了算法复杂度分析方面，仍旧看的比较乏味，曾几何时吾辈对数学还算感兴趣，后面放弃确实太糟糕了。</p><p>目前完成进度是 <a href="https://github.com/rxliuli/algorithm/pulse">1.3.34-1.3.49</a></p><p><img src="/resource/8c59e5f2be54498cb7953eed337338b5.png" alt="1615709481022"></p><p>个人项目方面，吾辈创建了 <a href="https://github.com/rxliuli/joplin-search-intergration">joplin-search-integrated</a> chrome 插件，用于将 joplin 的笔记展现在网页搜索中，便于使用同一个搜索引擎搜索到互联网上的内容和自己的笔记，灵感来自 EvenNote Web Clipper。另外一个就是将之前的几个 joplin 相关的工具整合到一个 monorepo 项目 <a href="https://github.com/rxliuli/joplin-utils">joplin-utils</a> 中，不仅仅是为了可以更简单的复用代码，更是为了继续实践 monorepo 如何管理多个应用模块，例如如何在 release 中发布多个应用，因为 GitHub release 只有一条线。</p><blockquote><p>吾辈因需要而开发的一些 joplin 周边工具，使用 monorepo 进行管理。</p><ul><li>joplin-vscode-plugin: 在 vscode 中管理和编辑 joplin 笔记</li><li>joplin-search-integration: 在网页搜索中插入相关的 joplin 笔记</li><li>joplin-blog: 将 joplin 笔记导出为 blog</li><li>joplin-charts: joplin 一些数据可视化图表</li><li>joplin-api: joplin ts api</li></ul></blockquote><p>其他事情</p><ul><li>这周利用地铁上的通勤时间把 <a href="https://book.douban.com/subject/26575643/">《颓废与沉默》</a> 看完了，一些感想在 <a href="/p/77c1a4a91a354db8abdf747f74a8b300">读书-[颓废与沉默：透视犬儒文化]</a></li><li>kigurumi 的皮肤到了，照片已发 <a href="/p/9eb819d95b5143c7844cacb6d6650c59">立个 Flag，今年入坑 Kigurumi 并出一次漫展</a></li><li>正常作息坚持了 5 天，睡眠质量基本都在 75% 之上，统计使用的是 Sleep Cycle</li><li>正式购买了 Proxifier，虽然数码荔枝很便宜，但为了避免麻烦吾辈直接去官网购买了，不到 300 软妹币还能接受</li><li>这周使用了 20+h 的手机，这是个糟糕的信号，吾辈下周要砍掉一半浪费的时间。Pass：其中占用时间最长的 twitter 已卸载</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
    <category term="周报" scheme="https://blog.rxliuli.com/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>读书-[颓废与沉默：透视犬儒文化]</title>
    <link href="https://blog.rxliuli.com/p/77c1a4a91a354db8abdf747f74a8b300/"/>
    <id>https://blog.rxliuli.com/p/77c1a4a91a354db8abdf747f74a8b300/</id>
    <published>2021-03-12T15:32:28.277Z</published>
    <updated>2021-03-12T15:41:50.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当今世界上不同国家社会和国民文化中的犬儒主义可以分为两大类:公开的犬儒主义和戴面具的犬儒主义。它们的基本区别在于,当一个人因为犬儒主义而不相信统治意识形态、制度、权威、信仰体系以及由权力或习俗规定和主导的法律或价值规范时,尤其是怀疑和鄙视政府、政治权力和政治人物的时候,公开的犬儒主义会在公共言论和行为中表示出来,而戴面具的犬儒主义则通常不会,不仅不会表示不相信,而且还会假装成相信的样子。公开的犬儒主义对那些什么都不相信,所以公然怀疑,公然拒绝,不相信就是不相信。戴面具的犬儒主义对那些也是什么都不相信,但正因为对什么都不相信,所以对什么都可以装作相信。他们玩世不恭,随波逐流,最后有的连自己都弄不清到底是相信还是不相信,于是索性不去管相信不相信,”难得糊涂”地过一天算一天。当然,这不等于戴面具的犬儒主义在任何情况下都不会摘下面具露出不相信的真面目。他们在私下或在不那么公开的场合中也会有不戴假面的时候。这时候,不加掩饰的犬儒主义就会成为同道者之间互相联络的接头暗号。这使得原本以怀疑和不信任为特征的犬儒主义反倒成为一种人际联系方式,也形成一种有群体特征的社会文化。</p></blockquote><p>开局王炸。这让吾辈想到了 1984 里面的男女主角的认知和世界观，男主就是怀疑政府，但带上了面具。而（新生代的）女主则一方面装作相信，但背地里却又不在乎，看的时候觉得简直就是精神分裂。</p><hr><blockquote><p>在所有这 13 种”病态”中,没有一处提及犬儒,可见犬儒并不是一个普通中国人常用的概念。然而,这些病态中至少有八九种都是犬儒主义的典型表现:（1）娱乐至死（没有目标或信仰,得过且过）；（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；（8）”鸵鸟心态”（多一事不如少一事,被宣传的现实反正是假的,不如”躲进小楼成一统”）;（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是”自虐”,这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。</p></blockquote><p>躺枪，感觉吾辈中了好多枪。过去的经历造就了现今的吾辈，社会的经验和认知中的道理偏差太大了。</p><hr><blockquote><p>假面社会里的犬儒者们揣着明白装糊涂（”难得糊涂”）,明明在心里不相信,但却还公开做出相信的样子。他们戴上自己参与制作的假面,顺从地配合统治者的愿望表演。这也是一种将顺从和抵抗合为一体的犬儒主义。波兰诗人米沃什在《被禁锢的头脑》中称此为”蒙蔽对手”的策略。他写道,”有些情况,保持沉默还不够,沉默可能被认为是主动招供,那时候就不应有丝毫犹豫,不仅要公开否认自己真正的观点,而且必须采取一切手段来蒙蔽对手。那时候就得宣布一切能取悦对手的信条,参与所有被认为是最荒唐的仪式 ⋯⋯ 终于,在蒙骗对手后,使对手在其错误中越陷越深的同时,使其承受应得的羞辱和精神痛苦。”这可能只是一种精神胜利法,但它却能”让践行它的人感到自豪,因为有了它,践行者才能把自己提升到超越被蒙骗者之上,并持久获得比对手优越的地位,哪怕是部长或有权有势的国王。⋯⋯ 你表面上还在被你巧妙欺骗的强权者脚下颤抖,眼睛却闪闪发亮。你在光明中走在敌人面前,你嘲笑一个愚蠢的家伙,解除了一头危险野兽的武装。这一下获得多少慰藉！”</p></blockquote><p>吾辈想到了某段话：“如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。”<br>—— 柏拉图</p><hr><blockquote><p>马基雅维利说,害怕是比爱戴更有效的统治工具,这话很适合今天的犬儒社会。有权者和无权者的犬儒主义总是在恶性循环,形成一种恶吏统治刁民的强制性秩序,稳固这一秩序的唯一办法就是层层加码的所谓”乱世用重典”。</p></blockquote><p>这让吾辈想到刚过完的春节之前返乡政策：<br>中央要求 “从低风险区返乡持绿码即可”，到一些省份变成 “持核酸检测阴性证明”，到市里就变成 “核酸阴性证明 + 居家隔离”，到镇上变成 “核酸证明 + 集中隔离 + 居家隔离”，最后到村里就成了 “禁止返乡”。</p><hr><blockquote><p>权力随时防范着学术,设置重重障碍。但是,由于”学术”对权力有利用价情,所以还会被允许存在,甚至加以鼓励。当然,首要的条件是学术必须无害于权力统治,而最受稿赏的则是有助于或能配合权力统治的学术。权力的咸胁与利诱造就体制性的”学术义儒”,它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。</p></blockquote><p>哈哈，这是在指某位小学生么 xd</p><hr><blockquote><p>先入为主（preconception）和刻板印象（stereotype）之间有联系,但又有所区别。先入为主经常是因为某种先例而形成的一种习惯性推断,以为以前曾经发生过的,现在也就一定会发生。”先例”是先入为主思维的条件。先入为主又称偏见（prejudice）,也就是在还没有弄清情况之前就下定论（prejudgment）。</p></blockquote><p>这点吾辈深有感触。在吾辈高二那年活跃于贴吧之中时，曾被人认为是女生，后面与一些人建立了相关的 QQ 同好群，里面的许多人也会这样认为–因为之前有人这样认为了，如果有人怀疑，那么前面已经如此认定的人就会反对。甚至到了现在，吾辈虽然没有刻意伪装，但却也没有主动说明过。</p><hr><blockquote><p>美国的现实民主制度保障了普通美国人讨论”什么是爱国主义”,”美国需要怎样的爱国主义”的权利。政府权力不能垄断在这些问题上的话语权。普通人如果有与政府或主流社会不同的爱国主义看法,可以发表自己的意见,不会因此被当作”美奸”或其他国家的”走狗”。而且,美国是一个多元民族文化的国家,爱国主义比较容易与文化民族主义区别开来,不容易被民族文化主义所限制或绑架。在美国,爱国主义与民族主义也是有区别的。法国总统戴高乐说过,在爱国主义那里,爱护自己国家的人民是第一位的；在民族主义那里,仇恨其他国家和其他国家的人是第一位的。美国的爱国主义里很少混杂戴高乐所说的那种仇恨性的民族主义。</p></blockquote><p>那么问题来了，国内现在究竟是爱国主义，还是民族主义呢？</p><hr><blockquote><p>冯小刚在微博里说,”我是觉得这么多年一部接一部地拍电影,没有其他的生活。在一个特别窄的胡同里,我长跑,还不是短跑。你怎么跑,你感觉两边都是这么一个墙,越跑越窄,越跑越窄。”他是个会说话的人,一句话同时说给两种不同的人听,让他们各自听出自己想要的意思。你可以认为他是在抱怨拍电影太辛苦,以至于”没有其他的生活”；你也可以认为他是在抱怨有”墙”不让他自由奔跑,以至于他电影生涯逼仄,只有辛苦而无乐趣。</p></blockquote><p>好的电影都在上个世纪拍完了，国内电影拍摄在两千年后是逐渐退步的。<br>或者说，所有的艺术在国内基本都是在退步的？电影、电视剧、音乐、动画这些，虽说过去的回忆有同年加成，但后来者无法居上也是不争的事实。例如新白之后再也没有更好的《白娘子传奇》了，电视剧的发展更是相当迷惑，完全看不懂粉圈喜欢的电视剧。</p><hr><blockquote><p>人们往往从现代社会工作压力大、人际交往频繁、信息更新流通速度快等实用原因来解释”离不开手机”的现象,而忽视了一个非常重要的心理因素——无聊。</p></blockquote><p>是的，吾辈一天玩手机的时间超过两个小时，工作日最长甚至会达到四个小时。</p><hr><blockquote><p>一般来说,有三种无聊,都与难以集中精神注意力有关。一、被阻止去做想做的事情；二、不得不去做不想做的事情；三、没有明确原因,只是对任何事情都没有兴趣,不想去做。一种或不止一种的无聊会让人觉得空虚、抑郁、百无聊赖。无聊不仅是一种此时此刻的心情,而且还是一种对生活状态的看法和生存环境的感受。无聊使人感觉到沉闷、压抑、无可作为、没有出路或希望,因而也焦虑、冷漠、忧虑、不安,甚至惶惶不可终日。人们经常把无聊与太多的闲暇、无所事事、缺乏审美兴趣联系在一起,但是,工作和做事并不一定就是解除无聊的良药。许多的工作对人对有异化作用,人变成了完成某种工作任务的工具。这样的工作机械乏味、没有意义,更让人觉得无聊。</p></blockquote><p>所以吾辈总是说：“没有变化就是在等死”，而等死它好么？它不好。工作如果一直做自己不感兴趣的或不能做自己感兴趣的事情的话，那么离开便是唯一的选择了。</p><hr><blockquote><p>人们从自己以往的经验发现,再怎么求也不会起作用,所以天大的事也只好忍受,不再有所要求或希望。在心理学里,这叫”习得性无助”（learned helplessness）。</p></blockquote><p>这与现在基本放弃希望混吃等死的咸鱼思想不谋而合，既然卷不过别人，政府也不顾及一般人的死活，那么我为什么还要继续卷下去呢？作为一个加害者和受害者的身份。</p><hr><blockquote><p>如果一个人总是在一项工作上失败。他就会在这项工作上放弃努力。甚至还会因此对自身产生怀疑,觉得自己”这也不行,那也不行”,彻底无望。典型的例子是,学习成绩经常不好的学生会怪自己”天生就笨”,所以不再努力；经常失恋的人会责备自己”天生令人讨厌”,所以干脆放弃找对象的打算。他们都是因为有屡屡受挫的经验,所以陷入了无为无助的绝望之中。</p></blockquote><p>所以需要做一些有趣的事情，恢复信心，建立信心。吾辈在 joplin 周边生态上的建设便是如此了。<br>而且，新的一年，新的开始，一切都可以从零算起了呢！</p><hr><blockquote><p>知识分子用”新理论”来粉饰和淡化统治者自己都不好意思否认的以往错误,这是一种非常巧妙的”光天化日之下献媚讨好”,既献媚讨好,又显得不失自己的”学者”身份。例如,把”文革”时的”忠字舞”说成是相当于今天跳迪斯科的”大众文化”。毛泽东说的文革每 5 年搞一次,被说成是相当于”定期的民主选举”。这是一种非常犬儒的学术话语把戏和游戏。</p></blockquote><p>哈，总是有人会这样做呢，一本正经的胡说八道，不外如是。</p><hr><blockquote><p>不同的国家有不同的国情,公共知识分子的专业造诣、职业特征和公共活动方式也会有很大的不同。中国大学教授受体制的限制比美国大,升等评级、决定科研项目的权利掌握在领导和人事部门手里,教授被逼着在自己的一亩三分地里小心耕作,巴望着能出一些符合体制规定的”成果”,所以容易变得思想狭隘,目光短浅,心灵猥琐,浅薄弱智。他们既不能成为”世界的眼睛”,也不敢站在体制的边缘,扰乱它的安宁。</p></blockquote><p>对上级负责而不是事情负责，上下五千年的老传统了。<br>一般（小）公司 996 的形式主义大于实际效益，任何能够量化的事情想想办法总是能够完成，加班未必就是在忙实际负责的事情。话虽如此，这也确实将人局限在公司，严重减小了交际面，绝非长久可为之计。</p><hr><blockquote><p>“文革”中盛行言辞激烈、慷慨激昂的”革命歌曲”或”诗朗诵”,运用的就是这种非说理话语,形成了具有中国特色的”标语体”写作。例如,”东风吹战鼓擂,现世界上究竟谁怕谁?不是人民怕美帝,而是美帝怕人民, 得道多助失道寡助,历史的规律不可抗拒,不可抗拒……”标语体写作是口号式思维的产物,二者相辅相成。</p></blockquote><p>太尬了，让吾辈想到去年的“武汉加油”与“山川异域，日月同天”的事情了。– 历史不会重演，它只会押韵。</p><hr><blockquote><p>“文革”高潮时期,人们说话都必须以”毛主席教导我们”开始,说上一段语录,然后才言归正传,这是正确的说话规范。王小波在《沉默的大多数》一文中写道:”古代和近代有两种方法可以壮我的胆。古代的方法是,文章要从‘夫子曰’开始。近代的方法是从‘毛主席教导我们说’开始。”所谓”壮胆”,也就是必须这么说才能被别人接受,才不至于出错,因为这就是”规范”.</p></blockquote><p>沉默的却是永远都是大多数，就像互联网上的幽灵一样，仅仅消费而不生产内容。另外，吾辈只听说过【吴晓波】</p><hr><blockquote><p>心理学研究早就归纳了人的七种性格缺陷,它们分别是,一、自我贬损（Self-Deprecation）:自甘下流、唾面自干；二、自暴自弃（Self-Destruction）:自我糟践、自我伤害；三、受害者心结（Martyrdom）:老觉得别人在算计和迫害自己；四、顽固和一意孤行（Stubbornness）:拒绝改变自己；五、贪得无厌（Greed）:自我放纵、欲壑难填；六、狂妄自大（Arrogance）:老子天下第一,谁也说不得；七、极不耐烦（Impatience）,像是谁都在跟自己作对,跟自己有仇。这七种性格缺陷在当今中国都不陌生,而其中的自我贬损则直接与一些人在人格上无自尊的”下流化”有关。</p></blockquote><p>躺枪 * 2 <em>(:з)∠)</em></p><hr><blockquote><p>我因此想到读过的一篇博文《生活就像被强奸一样,既然不能反抗,那就好好享受吧》。</p></blockquote><p>生活就是这么糟糕，那么吾辈还是做条安静的咸鱼，躺平吧！<br>话虽如此，面对现实环境，能做的无非就是三件事</p><ol><li> 改变自己</li><li> 改变世界</li><li> 离开这儿</li></ol><p>其中，改变自己，做个安静的咸鱼显然是最容易实现的呢</p><hr><blockquote><p>颓废与沉默:透视犬儒文化</p></blockquote><p>看完了这本书，这是在看了两本这种哲学类型的书之后，终于碰到一本感兴趣的了。里面真是描绘了当下国内的各种问题啊。而且旁征博引，引用了许多现实示例。<br>另外，这本书似乎已然绝版了。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://blog.rxliuli.com/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="读书" scheme="https://blog.rxliuli.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-在渲染、主进程间共享数据</title>
    <link href="https://blog.rxliuli.com/p/5ce7d75fe2dc46838b49f9e5e14ac738/"/>
    <id>https://blog.rxliuli.com/p/5ce7d75fe2dc46838b49f9e5e14ac738/</id>
    <published>2021-03-02T02:39:22.958Z</published>
    <updated>2021-03-02T05:13:59.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候我们需要在主进程和渲染层共享某些数据，而 <a href="/p/76393a60949c47c7add910df0206734c">electron ipc 通信</a> 显然更适合传递消息而不适合共享数据。</p><h2 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h2><p>事实上，我们这个需求已经有人考虑过了，例如 electron-store 就已经实现了可以在渲染层、主进程均可使用。</p><ul><li><a href="https://www.npmjs.com/package/is-electron">is-electron</a>: 判断是否 electron 环境</li><li><a href="https://www.npmjs.com/package/electron-store">electron-store</a>: 在 electron 应用中存储数据</li></ul><p>那么，我们直接用 electron-store 有什么问题么？<br>是的，electron 仅能在 electron 中使用，所以在浏览器上会报错，而这对于开发环境而言是无法接受的，故而还需要检测环境使用不同的实现。</p><h2 id="创建浏览器兼容层"><a href="#创建浏览器兼容层" class="headerlink" title="创建浏览器兼容层"></a>创建浏览器兼容层</h2><p>使用策略模式实现不同环境下使用不同的存储</p><ul><li>浏览器使用 localStorage 实现</li><li>electron 中则使用 electron-store 实现</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> Store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron-store&quot;</span>;<br><span class="hljs-keyword">import</span> isElectron <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;is-electron&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; DeepReadonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;utility-types&quot;</span>;<br><br><span class="hljs-keyword">interface</span> BaseStore &#123;<br>  get(key: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStoreImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> store: Store;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> Store = <span class="hljs-built_in">window</span>.require(<span class="hljs-string">&quot;electron-store&quot;</span>);<br>    <span class="hljs-built_in">this</span>.store = <span class="hljs-keyword">new</span> Store();<br>  &#125;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.store.set(key, value);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.store.get(key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalStorageImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">localStorage</span>.getItem(key);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">localStorage</span>.setItem(key, value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;ElectronStore.store&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> [symbol]: BaseStore = isElectron()<br>    ? <span class="hljs-keyword">new</span> ElectronStoreImpl()<br>    : <span class="hljs-keyword">new</span> LocalStorageImpl();<br><br>  <span class="hljs-keyword">static</span> getInstance&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt;(<br>    init?: Partial&lt;T&gt;<br>  ): Partial&lt;&#123; [P <span class="hljs-keyword">in</span> keyof T]: DeepReadonly&lt;T[P]&gt; &#125;&gt; &#123;<br>    <span class="hljs-keyword">const</span> electronStore = <span class="hljs-keyword">new</span> ElectronStore();<br><br>    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, &#123;<br>      get(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(p);<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(text);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;,<br>      set(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">boolean</span> &#123;<br>        electronStore[symbol].set(<br>          p,<br>          value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-literal">null</span> ? <span class="hljs-built_in">JSON</span>.stringify(value) : value<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (init) &#123;<br>      <span class="hljs-built_in">Object</span>.entries(init).forEach(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(k);<br>        <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>          proxy[k] = v;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> proxy;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能发现了，为了简化使用的 API，这里使用了代理模式拦截了对实例的访问，修改为使用 <code>get/set</code> 方法取值和设值。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来和一个普通的对象没什么区别，直接通过 <code>.</code> 访问或设置属性即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> userStore = ElectronStore.getInstance&lt;&#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> &#125;&gt;();<br>userStore.name = <span class="hljs-string">&quot;liuli&quot;</span>;<br><span class="hljs-built_in">console</span>.log(userStore.name === <span class="hljs-string">&quot;liuli&quot;</span>);<br>userStore.age = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(userStore.age === <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>具体代码在 <a href="https://github.com/rxliuli/electron_example/blob/ed158e9d013d7138697c76b52ddefb4748fe1af0/libs/electron-util/src/ElectronStore.ts#L40">electron_example</a>，由于是一个浅层封装，所以并未发布，但可以直接将模块复制到项目中使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>2020 吾辈在公司推动的前端技术演进</title>
    <link href="https://blog.rxliuli.com/p/5ea2552c67d34130b68cc11143d6191c/"/>
    <id>https://blog.rxliuli.com/p/5ea2552c67d34130b68cc11143d6191c/</id>
    <published>2021-02-26T23:39:54.612Z</published>
    <updated>2021-03-14T06:40:20.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上古时期"><a href="#上古时期" class="headerlink" title="上古时期"></a>上古时期</h2><blockquote><p>吾辈来的时候已然不多，但部分 mobile 嵌入的静态页面仍然是这种形式</p></blockquote><p>后端模板（JSP/FreeMarker）+ 前端静态 HTML 页面。那是个前端开发非常卑微的时代，除了还原 UI 和兼容性之外，所有业务逻辑、路由跳转、状态管理、部署维护都由后端包办完成。前端能做的事情非常有限，UI 还原、CSS 样式以及浏览器兼容性（例如传统前端需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧）是所需的关键技能点，或许还要负责 UI 相关的任务。但这其中，<strong>许多更偏向于「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值</strong>。</p><blockquote><p>参考: <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a><br>CSS 不是正交的，所以很麻烦，参考: <a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>问题</p><ul><li>难以应对大规模的项目开发，几乎没有工程化可言</li><li>前后端耦合导致修改、发布困难（就我们公司有个 gw 项目就是反例）</li><li>前端能做的事情非常有限，几近是后端的附属（App 有趣的一点就是极大的增强了客户端的能力，许多独立 App 开发者的工具类产品可能对后端的依赖极少）</li></ul><h2 id="跨入现代前端-vue-webpack"><a href="#跨入现代前端-vue-webpack" class="headerlink" title="跨入现代前端: vue + webpack"></a>跨入现代前端: vue + webpack</h2><ul><li>框架: vue</li><li>项目组织: git 分支 + 目录</li></ul><blockquote><p>在吾辈进来的时候基本是这样的</p></blockquote><p><img src="/resource/1e8dc3a95f054ef3b404bdc39f95e099.png" alt="1614382963380"></p><p>无论如何，前后端分离都已然是大势所趋，公司的项目也不例外，也从 jq 升级为了 vue。vue 是一个及其新手友好的框架，官方文档在前端开源框架中无出其右，所以选择它对招聘确实有一定的帮助（准入门槛低）。</p><p>但这里确实存在一些问题，主要如下</p><ul><li>vue 和 ts 结合的不好，所有前端项目，不是已经用了 ts，就是在走向 ts 的路上（去年 vue3 选择使用 ts 重写 v3）<ul><li>这是一个设计失误，因为 vue 作者更相信另一个 facebook 的静态类型脚本语言 flow.js，但它最终失败了</li></ul></li><li>vue 不是一个创新者，更像是一个现有技术的整合者，更新相比于 react v17/angular v11 慢得多（v3）</li><li>vue 和 ant design 结合的不好，因为蚂蚁金服使用 react 实现，vue 版本并非官方实现（关于这个 UI 框架的选择其实令吾辈有些困惑）</li><li>项目组织方面使用 git 分支 + 目录的形式可能是模仿了后端，但由于目录之间并非模块的形式加上 git 没有规范可言导致没有利用本地模块的优势反而只有劣势</li><li>有些项目使用原生 webpack 进行配置打包，而这实际上非常难以维护，参考: <a href="https://zhuanlan.zhihu.com/p/32148338">webpack 为什么这么难用？</a></li></ul><blockquote><p>典型项目: 前端旧项目</p></blockquote><h2 id="静态类型-引入-typescript"><a href="#静态类型-引入-typescript" class="headerlink" title="静态类型: 引入 typescript"></a>静态类型: 引入 typescript</h2><ul><li>语言: typescript</li><li>项目组织: 分散的 git 项目</li></ul><p>由于使用目录+分支管理的项目组织非常麻烦，所以后面的一些项目采用了每个业务创建一个 git 项目，然后最终将之打包整合到官网（其实就是不同的子路由），独立每个项目的开发和部署。而后希望通过 ts 的静态类型增强前端开发的效率及开发体验（主要是 IDE 在提示、重构和导航方面的支持），所以将之引入了进来，吾辈有自信可以解决任何遇到的 ts 问题。</p><p><img src="/resource/86bcfe6872864bd282703cbb5522ff27.png" alt="1614383048466"></p><p>但老实说，问题仍然没有完全解决</p><ul><li>ts 和 vue 2 结合的不好，甚至 vue 3 中 ts 也没能解决模板层面的问题，参考: <a href="https://github.com/JetBrains/web-types/issues/15">web-types 讨论</a></li><li>分散的 git 项目之间如果存在相同代码，比较难以共享（但因为有 npm 私服所以还不太明显）</li><li>组件粒度较粗，比较小的组件难以抽取</li></ul><blockquote><p>典型项目: 新管理后台</p></blockquote><h2 id="替换框架为-react"><a href="#替换框架为-react" class="headerlink" title="替换框架为 react"></a>替换框架为 react</h2><p>事实上，引入 react 没有 ts 那么安全，因为这次吾辈不能说<strong>吾辈有自信可以解决任何遇到的 react 问题</strong>，因为吾辈也没有实际生产环境的经验。但吾辈仍然引入了，有以下几个考量</p><ul><li>更好的结合 ts 使用</li><li>直接使用官方维护的 ant design for react 版本</li><li>相比于 vue 好得多的 IDE 支持</li><li>更好的开发大型项目（报告系统）</li><li>尝试变化，使用最新的技术</li></ul><p>但这仍然并非终点，在报告系统项目中，单个前端项目的代码量首次达到了 2w+ 行（至今已到 4w+），分割模块势在必行，这里就提到了需要使用到 lerna 了。</p><blockquote><p>典型项目: 公开图库</p></blockquote><h2 id="引入-lerna-以使用-monorepo"><a href="#引入-lerna-以使用-monorepo" class="headerlink" title="引入 lerna 以使用 monorepo"></a>引入 lerna 以使用 monorepo</h2><ul><li>项目组织: monorepo</li></ul><p>Java 后端的项目天然是 monorepo（因为 maven 的原因），而前端在很长时间内都没有类似的工具，直到吾辈遇到了 lerna。这点某位离职的同事有曾提及，但直到几个月后报告系统第一版基本结束时进行重构才真正实用。<br>使用它吾辈改进了以下几点问题</p><ul><li>使用 monorepo 更好的组织模块，保证项目在超过 4w 行代码、20 个模块时仍然保持可维护性</li><li>更简单的共享和复用代码，只要抽离一个模块即可在所有模块直接引用它了</li><li>更加容易统一整个项目的技术栈，引入一个依赖的不同版本几乎不可能出现了</li><li>更加容易容易统一项目的配置，保证整个项目的代码风格都是一致的（例如 eslint/prettier）</li></ul><p><img src="/resource/a5cc319a00a144349c494b91edb92079.png" alt="1614383172095"></p><blockquote><p>典型项目: 旧版报告系统</p></blockquote><h2 id="引入-gh-pages-简化打包"><a href="#引入-gh-pages-简化打包" class="headerlink" title="引入 gh-pages 简化打包"></a>引入 gh-pages 简化打包</h2><p>事实上，生产环境的发布一直非常麻烦，即便建宏已经实现了两版的发布系统，但目前使用体验仍然不算好（gw 项目必须要用），但前后端分离的项目却不尽然。后来在一个偶然的情况下，吾辈发现了一种更高效的方式: <a href="/p/7b0fe35b00b345618a9323977a2e552a">使用 gh-pages 发布前端项目</a>，同时喜获冰淇淋一个。</p><blockquote><p>当然，由于后来主要在开发 electron 客户端，web 项目在生产环境的发布变得较少，但这件事仍然证明只要将现有的工具整合起来，仍然可能极大的提高生产力</p></blockquote><p><img src="/resource/3654c8048cb14577a2097aa0294fe4f3.png" alt="1614383397001"></p><blockquote><p>典型项目-大屏看板</p></blockquote><h2 id="rushstack-标准化的前端-monorepo"><a href="#rushstack-标准化的前端-monorepo" class="headerlink" title="rushstack: 标准化的前端 monorepo"></a>rushstack: 标准化的前端 monorepo</h2><ul><li>项目组织: lerna monorepo =&gt; <a href="https://rushstack.io/">rushstack</a></li></ul><p>虽然 lerna 可以分割模块，但它并没有所谓的最佳实践，事实上，吾辈在微软的 monorepo 工具 rush 的相关项目 rushstack 中找到了一种最佳实践，在形式上有许多参考价值（虽然由于大而全且包含许多问题的原因导致没有 lerna 使用广泛），最新的两个生产项目均已重构成这种形式的 monorepo 项目，稍晚一些会将它们合并，便于之后它们的整合。</p><p><img src="/resource/40a90f19f74143d3a676e7afdec3c658.png" alt="1614431686700"></p><p>在 rushstack 的介绍中有这么一段话非常有趣：<br>灵活性有其缺点。Node.js 工具因其令人困惑的选项而臭名昭著：选择您的编译器、linter 工具、打包工具、包管理器、任务引擎、单元测试工具、测试断言库等。一旦决定（<strong>下了赌注</strong>），整合所有这些组件就变成了自己的软件项目。随着规模的扩大，这些成本可能会迅速增加！<br>核心就是前端定制需求过多，要求工具链非常灵活，进而导致无法标准化（和现在的报告系统业务面临的问题多么相似。。。）</p><blockquote><p>典型项目 miis</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="统一和规范"><a href="#统一和规范" class="headerlink" title="统一和规范"></a>统一和规范</h3><ul><li>定义统一的业务目录的结构，形成约定俗成</li><li>通过更高层的 cli 抽象强制统一 <code>lib</code> 的项目结构，例如入口文件一定是 <code>lib/src/index.ts</code>，出口一定是 <code>dist/index.js</code>，而打包出来的一定默认支持 <code>esm/commonjs</code></li><li>使用 prettier+git hooks 统一项目中的代码风格</li><li>通过 syncpack 统一多个模块之间的依赖版本</li><li>通过多个模块中的 npm script，例如启动 web 项目的开发环境是 <code>start</code>，启动 electron 开发环境则是 <code>dev:win/mac</code>，打包项目是 <code>build</code>，而 <code>libs</code> 的模块打包发布是 <code>pub</code>，打包 electron 项目是 <code>pkg:*</code></li></ul><h3 id="分层和解耦"><a href="#分层和解耦" class="headerlink" title="分层和解耦"></a>分层和解耦</h3><ul><li>通过 monorepo 分割 electron 项目不同的进程，将之作为单独的 nodejs 项目和 react 项目管理和发布</li><li>通过使用 api class 的形式，将与后端的连接封装在单独的逻辑层，定义参数、返回值的类型，业务层直接引用相关的单例对象调用方法即可</li></ul><blockquote><p>吾辈也好奇现代前端框架强绑定、重 UI 层的现在，如何更好的分离 UI 与业务逻辑</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用 lerna 的 <code>--include-dependencies --stream</code> 参数尽可能按照依赖顺序并发运行命令，例如打包所有模块</li><li>为了减少安装依赖上的麻烦，尝试过 <code>nrm/yrm</code> 改源，<code>npmrc</code> 配置镜像，但最终还是要求所有前端必须能够使用 SSR+透明代理工具，否则无法启动项目</li><li>在公司 blog 上分享一些自己的心得和感触</li><li>通过使用 docsify 提升文档维护者的体验，使用 VSCode 编辑文档，然后使用 git 提交便自动部署了</li><li>引入 storybook 为通用组件编写交互式文档</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>公司前端文档: 公司的前端项目在线文档，使用 git + markdown 增强开发者编辑体验，希望更多人在更好的维护它</li><li>common-util: 前端工具库，近期使用 monorepo 将之彻底重构<br>至少优化了以下几项<ul><li><input checked="" disabled="" type="checkbox"> 清理不需要的功能，减少了 60% 的代码</li><li><input checked="" disabled="" type="checkbox"> 使用 monorepo 增强项目的可维护性</li><li><input checked="" disabled="" type="checkbox"> 支持 nodejs 引入</li><li><input disabled="" type="checkbox"> 使用 monorepo 分割打包减小在项目中的引入成本 – babel 的 567 三个版本转变的惨剧历历在目</li><li><input disabled="" type="checkbox"> 找到对用户更友好的使用方式 class vs function – 面向对象 vs 函数式</li></ul></li><li>web-logger: 前端日志，已在报告系统及之后后所有的前端项目中实用，目前还未支持 nodejs</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="公司" scheme="https://blog.rxliuli.com/tags/%E5%85%AC%E5%8F%B8/"/>
    
    <category term="经验" scheme="https://blog.rxliuli.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>实践 lerna monorepo</title>
    <link href="https://blog.rxliuli.com/p/1a6dda43a5a84e61b4b16865d8e52373/"/>
    <id>https://blog.rxliuli.com/p/1a6dda43a5a84e61b4b16865d8e52373/</id>
    <published>2021-02-23T03:03:23.125Z</published>
    <updated>2021-06-06T17:09:11.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>上古时期，前端没有工程化的概念可言，复用代码也不过是将某些 css、js 代码片段保存到笔记，需要时复制到项目中，仅此而已。参考：<a href="https://github.com/Wscats/CV/issues/29">55 个提高你 CSS 开发效率的必备片段</a>，或是 <a href="http://www.htmleaf.com/jQuery/">jquery 库</a></li><li>莽荒时代，前端出现了 nodejs 和 npm，于是一大批通用代码被发布到了 npm 平台，可以在项目中简单配置即可使用通用的库，任何人都可以简单的将代码发布到 npm。参考：<a href="https://www.npmjs.com/package/lodash">lodash</a></li><li>现代，由于前端项目的复杂度逐渐上升，所以出现了 monorepo 工具以更简单的复用代码。例如层出不穷的 monorepo 支持工具 <a href="https://lerna.js.org/">lerna</a>、<a href="https://rushjs.io/">@microsoft/rush</a>、<a href="https://yarnpkg.com/features/workspaces">yarn 2</a>、<a href="https://pnpm.js.org/en/workspaces">pnpm</a>、<a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><blockquote><p>自去年 10 月开始，吾辈使用 lerna 重构个人和公司的项目，以应对愈加复杂的前端项目。</p></blockquote><h2 id="为什么需要-monorepo？"><a href="#为什么需要-monorepo？" class="headerlink" title="为什么需要 monorepo？"></a>为什么需要 monorepo？</h2><blockquote><p>借用一下 lerna 官网的简介：</p><p>将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。</p><p>为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel、 React、Angular、Ember、Meteor、Jest 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。</p></blockquote><p>你可能会认为除了大型开源项目之外，monorepo 对于小型项目和生产环境的业务项目没有太多价值。但这是错的，前者我在微型工具库 <a href="https://github.com/rxliuli/liuli-util">liuli-util</a> 上进行了实践，确定了它对于维护和使用确实有帮助。而后者，甚至出现了专门为业务项目的 monorepo 工具 <a href="https://rushjs.io/pages/intro/why_mono/">@microsoft/rush</a>，微软在 <a href="https://github.com/microsoft/rushstack">rushstack</a> 项目中大规模使用了它。</p><h2 id="为什么选择-lerna？"><a href="#为什么选择-lerna？" class="headerlink" title="为什么选择 lerna？"></a>为什么选择 lerna？</h2><p>那么，有了这么多 monorepo 工具，为什么我们选择 lerna？</p><ul><li><a href="https://lerna.js.org/">lerna</a></li><li><a href="https://rushjs.io/">@microsoft/rush</a></li><li><a href="https://yarnpkg.com/features/workspaces">yarn 2</a></li><li><a href="https://pnpm.js.org/en/workspaces">pnpm</a></li><li><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><p>其实，除了 lerna 与 @microsoft/rush 之外，其它竞争对手都是包管理器，仅仅只是提供了 workspace 的工作空间，并未提供更高级功能。</p><blockquote><p>lerna 和 @microsoft/rush 的 npm 趋势对比参考: <a href="https://www.npmtrends.com/lerna-vs-@microsoft/rush">https://www.npmtrends.com/lerna-vs-@microsoft/rush</a></p></blockquote><p>下图是一个对比</p><table><thead><tr><th>对比项</th><th>lerna</th><th>@microsoft/rush</th></tr></thead><tbody><tr><td>star</td><td>26,824</td><td>2,392</td></tr><tr><td>周下载</td><td>1,155,241</td><td>100,386</td></tr><tr><td>使用者</td><td>知名开源项目</td><td>微软系产品</td></tr></tbody></table><p>就吾辈的实际使用体验而言，相比于 lerna，rush 默认包含了更多的东西，而非通过组合一系列可选的工具支持，这增长了相当的门槛。</p><p>下面是吾辈对其的一些认知过程</p><ul><li>rush.js 是真的感觉很【专业】，限定了很多很多东西</li><li><a href="https://rushjs.io/pages/maintainer/setup_policies/">https://rushjs.io/pages/maintainer/setup_policies/</a></li><li>像是这里，通过 allowedPackagesPolicy 的方式对 team 中所有开发人员都可以直接引入新的 npm 包做出了限制</li><li>唉，rush 比 lerna 复杂多了，做了很多很多的预定义的事情，这就意味着，它对项目维护者（而非开发者）的要求更高</li><li>和 ide 没完全集成真痛苦.JPG</li><li>吾辈总算明白这些配置为什么是【推荐配置】而不是【默认配置】了，引发的错误太多了（毕竟 npm 包很多并不规范）</li><li>rush monorepo 的一个问题是，某些包总喜欢强制指定依赖包的特定版本（例如 react-scripts），而 rush 总是“聪明”的仅安装最新的，导致添加的项目莫名其妙的炸掉</li><li>吾辈的锅，它在最后给了方法 <a href="https://rushjs.io/pages/advanced/installation_variants/">https://rushjs.io/pages/advanced/installation_variants/</a></li><li>但一整个进阶主题都是在处理这个问题。。。</li><li>算了，吾辈放弃了，rush + pnpm 感觉上维护配置成本太高了，滚回 lerna + yarn 了</li></ul><blockquote><p>rush 在功能、目标和文档方面更好，但现阶段而言还是 lerna 更成熟。</p></blockquote><h2 id="lerna-是什么？"><a href="#lerna-是什么？" class="headerlink" title="lerna 是什么？"></a>lerna 是什么？</h2><p>简而言之，Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。可以在一个项目中创建多个模块（基本上模块也可以认为是一个项目），并且可以在本地的模块之间互相关联。</p><p>lerna 项目的基本结构如下</p><p>生产项目</p><ul><li>根目录<ul><li><code>apps</code>: 生产项目<ul><li><code>app-1</code></li><li><code>app-2</code></li></ul></li><li><code>libs</code>: 通用模块<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><p>开源库</p><ul><li>根目录<ul><li><code>libs</code>: 模块根目录<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><blockquote><p>目录的名字灵感来源于 <a href="https://github.com/microsoft/rushstack">rushstack</a></p></blockquote><h2 id="使用-lerna-的优点"><a href="#使用-lerna-的优点" class="headerlink" title="使用 lerna 的优点"></a>使用 lerna 的优点</h2><blockquote><p>其中部分优点是 monorepo 固有的优势，但也有 lerna 独有的功能。</p></blockquote><ul><li>更容易抽离公共代码: 模块之间可以互相引用并且即时生效</li><li>更容易统一<ul><li>项目配置: <code>tsconfig.json/prettier.json/git hooks</code></li><li>管理和发布一系列包: <code>lerna publish</code></li><li>修改依赖立刻生效: <code>lerna bootstrap</code></li><li>依赖版本: 和默认合并不同版本的依赖</li><li>文档生成和合并: <code>fliegdoc</code></li><li>代码风格: <code>prettier/git hooks</code></li><li>在一个模块运行另一个模块的命令: <code>lerna run &lt;cmd&gt; --scope &lt;pkg&gt;</code></li><li>打包工具和流程: 封装更适合项目的打包 cli</li></ul></li></ul><p>目前稍微大点的开源项目不是已经转为了 lerna monorepo，就是已经在转换的路上（很像最近流行的使用 typescript 重构库）。包括但不限于以下这些：</p><p><img src="/resource/1481553a70764d679f18841199b9db09.png" alt="1614158368615"></p><blockquote><p>吾辈目前使用的笔记工具 Joplin 也在去年使用 lerna 重构了，参考：<a href="https://github.com/laurent22/joplin/pull/4039">Lerna migration</a>。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="根据依赖图并行运行-npm-命令"><a href="#根据依赖图并行运行-npm-命令" class="headerlink" title="根据依赖图并行运行 npm 命令"></a>根据依赖图并行运行 npm 命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lerna run &lt;npm script&gt; --include-dependencies --stream<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://github.com/lerna/lerna/blob/main/commands/run/README.md#--stream">–stream</a> 和 <a href="https://github.com/lerna/lerna/blob/main/core/filter-options/README.md#--include-dependencies">–include-dependencies</a></p></blockquote><h3 id="git-规范"><a href="#git-规范" class="headerlink" title="git 规范"></a>git 规范</h3><p>在单体项目中，只需要简单的分为 dev/master 即可开发，但在 monorepo 中，可能存在多个 apps，这种时候，简单的 dev/master 策略便不太好用了，主要原因是</p><ul><li>dev 包含了所有的开发阶段的代码，所以合并的时候会合并到不希望合并的其他 apps 的修改</li><li>提交记录看不出来是哪个分支的</li></ul><blockquote><p>吾辈的个人项目 <a href="https://github.com/rxliuli/joplin-utils">joplin-utils</a> 就面临这种问题。</p></blockquote><p>下面是吾辈的一些想法，目前还正在实践中</p><ul><li>规范化分支<ul><li>master: 生产环境分支，任何时候都应该是可部署的</li><li>dev: 指代正在开发环境进行测试的功能</li><li><code>feat-*</code>: 正在开发的功能分支</li><li><code>fix-*</code>: 修复线上 bug 的分支</li></ul></li><li>规范化流程<ul><li>分支一定是从 master 拉取</li><li>分支一定是合并到 dev 测试</li><li>分支一定是合并到 master 部署生产</li></ul></li><li>规范化提交信息<ul><li>基本采用 <a href="https://github.com/conventional-changelog/commitlint">commitlint</a> 控制提交格式，包括 <strong>类型(模块): 提交说明</strong></li></ul></li></ul><h3 id="模块规范"><a href="#模块规范" class="headerlink" title="模块规范"></a>模块规范</h3><ul><li>目录<ul><li><code>apps</code>: 最终用户可以使用的程序或 cli</li><li><code>libs</code>: 一些依赖项，根据需要发布到 npm</li><li><code>examples</code>: 一些示例项目</li></ul></li><li>scripts<ul><li><code>setup</code>: 项目初始化的一些脚本</li><li><code>dev</code>: 开发阶段运行的脚本</li><li><code>build</code>: 打包代码</li><li><code>docs:dev</code>: 启动本地文档预览服务</li><li><code>docs:build</code>: 将文档捆绑为静态文件</li><li><code>docs:deploy</code>: 部署文档到线上</li></ul></li></ul><h3 id="rollup-捆绑-monorepo-仍然存在错误"><a href="#rollup-捆绑-monorepo-仍然存在错误" class="headerlink" title="rollup 捆绑 monorepo 仍然存在错误"></a>rollup 捆绑 monorepo 仍然存在错误</h3><p>目前 rollup + node-resolve 插件捆绑本地依赖时仍然存在一些问题，参考：<a href="https://github.com/rollup/plugins/issues/743">https://github.com/rollup/plugins/issues/743</a>，目前的替代方案是 <a href="https://esbuild.github.io/">esbuild</a>。</p><h3 id="有时候会始终无法安装正确的版本"><a href="#有时候会始终无法安装正确的版本" class="headerlink" title="有时候会始终无法安装正确的版本"></a>有时候会始终无法安装正确的版本</h3><p>例如在 package.json 中声明了依赖</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;rollup&quot;</span>: <span class="hljs-string">&quot;^2.51.0&quot;</span> <span class="hljs-comment">// 实际安装的可能是 2.50.6</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/resource/019d27e1c9224c39b2214fb943dd3c06.png" alt="1622999313766"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 lerna 虽然会增加一些复杂度，但带来的优点仍然是超过缺点的。</p><blockquote><p>吾辈之所以相信 monorepo 会成为主流的原因是后端已经使用了这么多年的 maven/gradle，如果真的有什么问题，那不会直到现在还在使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>blog 评论系统推荐</title>
    <link href="https://blog.rxliuli.com/p/5f38eae3a61242e698684620e82fb6f7/"/>
    <id>https://blog.rxliuli.com/p/5f38eae3a61242e698684620e82fb6f7/</id>
    <published>2021-02-21T01:51:27.632Z</published>
    <updated>2021-02-21T02:37:27.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>长期以来，吾辈通过 RSS 阅读各种 blog，想要评论时却发现很麻烦，所以来推荐一下 blog 的评论系统。</p><p>评论系统大概有如下几种形式</p><ul><li>基于第三方评论服务</li><li>输入名字邮箱即可发表评论</li><li>注入博客用户才可以发布评论（没怎么用过，不予置评）</li></ul><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><p>基于第三方评论服务这里选择的是吾辈目前正在使用的 disqus，而评论选择是某位博主的评论系统。</p><p>两者截图如下</p><p><img src="/resource/1d7c7c27c4b34f59964dcb5bf964919e.png" alt="基于第三方评论服务"><br><img src="/resource/a0af65b841d3440b95043d3254928518.png" alt="输入名字邮箱即可发表评论"></p><table><thead><tr><th>对比项</th><th>基于第三方评论服务</th><th>输入名字邮箱即可发表评论</th></tr></thead><tbody><tr><td>UI 对比</td><td>标准 UI</td><td>与网站更契合的比较萌的 UI</td></tr><tr><td>账户系统</td><td>需要注册 disqus</td><td>不需要账号</td></tr><tr><td>修改/删除评论</td><td>是</td><td>否</td></tr><tr><td>需要代理</td><td>是</td><td>取决于博客的部署方式</td></tr></tbody></table><p>就吾辈个人而言，最不能忍受的是无法修改评论，即使存在一些错误，例如截图中吾辈的评论中就有一个错别字，但却无法修改。而另一方面，disqus 的 UI 确实不可能和网站整体风格完全一致，这也是自定义博客评论系统更强大的地方。但老实说，相比于 UI，吾辈更在意的是功能性，disqus 已经有许许多多的人注册过，所以有天生的用户群。至于代理的问题，吾辈找不到好的解决方案，国内的类似产品，不是已经死了（多说），就是已经变成垃圾。</p><blockquote><p>实际上代理的问题还是有办法的，虽然还是有点麻烦。参考：<a href="https://blog.fooleap.org/use-disqus-correctly.html">科学使用 Disqus</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://blog.rxliuli.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2021 读书计划</title>
    <link href="https://blog.rxliuli.com/p/6b5ef22cfbc9438c94db843d199bdcfa/"/>
    <id>https://blog.rxliuli.com/p/6b5ef22cfbc9438c94db843d199bdcfa/</id>
    <published>2021-02-20T13:07:28.998Z</published>
    <updated>2021-02-21T01:54:43.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>由于受到 <a href="https://blog.k8s.li/2020-booklist.html">木子(读书机器人)</a> 的影响，所以吾辈打算 2021 读更多的书，希望能达到以下几个目标。</p><ul><li>将读书变成一个习惯</li><li>提升自己的认知</li><li>学习更多计算机基础知识</li><li>坚持读比较难读的书</li></ul><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><ul><li>这就是投资人</li><li>这就是保险代理人</li><li>TCP 详解（1）</li><li>网络是怎么连接的</li><li>论人类不平等的起源</li><li>规模</li><li>爆裂</li><li>原则</li><li>金字塔原理</li><li>上帝造人有多难</li><li>大学之路</li><li>女士品茶</li><li>增长的极限</li><li>被讨厌的勇气</li><li>来自新世界</li><li>异类</li><li>宇宙-从起源到未来</li><li>修改代码的艺术</li><li>解忧杂货铺</li><li>朝花夕拾</li><li>地铁</li><li>家有女友</li><li>神雕侠侣</li><li>数学女孩</li><li>什么是数学</li><li>SICP 计算机程序的构造和解释</li><li>算法 4(在读)</li></ul><blockquote><p>读书历史将在 <a href="https://blog.rxliuli.com/about/">关于页面</a> 更新。</p></blockquote><h2 id="实行"><a href="#实行" class="headerlink" title="实行"></a>实行</h2><p>在上下班通勤、中午以及晚上回去时多读点书（当然还是不能影响休息），反正读书总比将时间浪费在 Youtube、小说、游戏上要好，不是么？</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="读书" scheme="https://blog.rxliuli.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>立个 Flag，今年入坑 Kigurumi 并出一次漫展</title>
    <link href="https://blog.rxliuli.com/p/9eb819d95b5143c7844cacb6d6650c59/"/>
    <id>https://blog.rxliuli.com/p/9eb819d95b5143c7844cacb6d6650c59/</id>
    <published>2021-02-19T03:56:07.294Z</published>
    <updated>2021-04-20T12:37:53.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Kigurumi 是什么？能吃么？</li><li>是一种 cosplay 服装扮演，不能吃谢谢。</li></ul><p>借用 <a href="https://en.wikipedia.org/wiki/Animegao_kigurumi">Wiki</a> 中的描述：“人偶扮演（着ぐるみ Kigurumi ?），是一种透过穿着类似 吉祥物服装的全身套装以在现实世界中达成还原卡通或动漫人物的 cosplay 形式。和 cosplay 不一样的是，表演者的脸会被 面具完整的包住，所穿着的服装也会掩盖住全身，借此表演者得以完全隐藏自己原本的身份，完全成为所要扮演的角色。早年 Kigurumi 只会出现在舞台秀上，近年来则逐渐变成 cosplayer 的一种扮演模式。在日本，这种形式的角色扮演又被称为是アニメ顔（中文：动漫颜），但一直以来都只有少数的玩家参与其中。约在 2005 年后，Kigurumi 慢慢地在各个国家和地区流行开来，包括中国，甚至是美国、加拿大与欧洲等地区。”</p><p>预定 cosplay 角色是 <a href="https://zh.moegirl.org.cn/zh-cn/%E6%98%A5%E6%97%A5%E9%87%8E%E7%A9%B9">春日野穹</a></p><p><img src="/resource/35276870c5974ef78bf55004376104af.png" alt="1613708879214"></p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><ul><li><a href="https://item.taobao.com/item.htm?id=35058414957">头壳</a></li><li><a href="https://item.taobao.com/item.htm?id=26710864059">Kigurumi 皮肤</a></li><li><a href="https://item.taobao.com/item.htm?id=45759058514">Kigurumi 义乳</a></li><li><a href="https://item.taobao.com/item.htm?id=45035590608">Cosplay 服装</a></li><li>其他杂费，包括但不限于鞋子、玩偶、额外材料费等</li></ul><p>预计花费 7038 软妹币，入坑门槛是真的高 XD。</p><blockquote><p>算是弥补不去吃糖的一些遗憾吧</p></blockquote><hr><h2 id="已购"><a href="#已购" class="headerlink" title="已购"></a>已购</h2><p>确定了，大概要两个月吧</p><p><img src="/resource/90ab8d5fa24a4612a40d73807bec8cb1.png" alt="1614431297462"><br><img src="/resource/50811848a3f34cd1ad44173be01b88c6.png" alt="1614431308200"></p><p>暂时还未购买服装之类的东西，但这也是因为需要后续再确认一下身体尺码的参数是否正确之类的而已（另外吾辈已然有了 xd）。</p><h2 id="衣服到了"><a href="#衣服到了" class="headerlink" title="衣服到了"></a>衣服到了</h2><p>f 居然有 4 斤，看来女生确实很辛苦呢</p><p><img src="/resource/ac037581e08947959ef7db5bb593f4ba.png" alt="1615473034848"></p><blockquote><p>由于身高问题，所以显得很小而已。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>CSS Grid 与图片共存时的布局问题</title>
    <link href="https://blog.rxliuli.com/p/0e07cf985f5d4437b2e4f90b73612b2b/"/>
    <id>https://blog.rxliuli.com/p/0e07cf985f5d4437b2e4f90b73612b2b/</id>
    <published>2021-01-27T02:36:31.484Z</published>
    <updated>2021-01-27T03:06:08.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在生产中遇到的一个 css 问题，css 不正交的问题一直有人吐槽，吾辈今天总算也是遇到了，实在是不吐不快。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>如下一个简单的二维横向图片列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  * &#123;<br>    padding: 0;<br>    margin: 0;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.rows</span> &#123;</span><br>    height: 500px;<br>    display: grid;<br>    grid-template-rows: repeat(5, 1fr);<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.cols</span> &#123;</span><br>    height: 100%;<br>    display: flex;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> &#123;</span><br>    height: 100%;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> <span class="hljs-selector-tag">img</span> &#123;</span><br>    max-height: 100%;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rows&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;items of list&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cols&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of items&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.url&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 下面是生成一些测试数据，不需要关心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/faker@5.2.0/dist/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&quot;.rows&quot;</span>,</span><br>    data: &#123;<br><span class="javascript">      list: <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>)</span><br>        .fill(0)<br><span class="javascript">        .map(<span class="hljs-function">() =&gt;</span></span><br><span class="javascript">          <span class="hljs-built_in">Array</span>(faker.random.number(&#123; <span class="hljs-attr">min</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">20</span> &#125;))</span><br>            .fill(0)<br><span class="javascript">            .map(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-keyword">const</span> getNumber = <span class="hljs-function">() =&gt;</span></span><br>                faker.random.number(&#123; min: 200, max: 300 &#125;);<br><span class="javascript">              <span class="hljs-keyword">return</span> [getNumber(), getNumber()];</span><br>            &#125;)<br><span class="javascript">            .map(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> (&#123;</span><br>              width: x,<br>              height: y,<br><span class="javascript">              url: <span class="hljs-string">`https://picsum.photos/seed/picsum/<span class="hljs-subst">$&#123;x&#125;</span>/<span class="hljs-subst">$&#123;y&#125;</span>`</span>,</span><br>            &#125;))<br>        ),<br>    &#125;,<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但显示的效果却并非预想中那样五等份，而是会超过最大高度 – 被图片撑高了。</p><p><img src="/resource/ab035c3bd9314c17ad6ec4390a6b00b7.png" alt="1611716016173.png"></p><p>而在经过一番摸索和讨论后，吾辈找到了这个规范：<a href="https://drafts.csswg.org/css-grid/#algo-terms">https://drafts.csswg.org/css-grid/#algo-terms</a></p><p>grid 的 fr 单位实际上是个弹性值，如果内容过大，则会撑开。。。而图片的默认大小就是过大的内容。如果显式声明了最小值，就不受图片尺寸的影响了。</p><p>修改 <code>grid-template-rows: repeat(5, 1fr);</code> =&gt; <code>grid-template-rows: repeat(5, minmax(0, 1fr));</code> 就好了。</p><p>效果</p><p><img src="/resource/f315fce582304158b1913b4f2c947a84.png" alt="1611716716541.png"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>发明 CSS 的人就是一个智障，这么多不正交的规则纯靠经验真的太恶心了（不是每个人都了解或者说希望了解那些奇奇怪怪的规范）。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="css" scheme="https://blog.rxliuli.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-electron 自定义协议</title>
    <link href="https://blog.rxliuli.com/p/0a4259c97ca440d1b5375f4e21eaaace/"/>
    <id>https://blog.rxliuli.com/p/0a4259c97ca440d1b5375f4e21eaaace/</id>
    <published>2021-01-11T03:18:19.598Z</published>
    <updated>2021-03-21T23:36:17.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候需要与其他程序进行交互时，自定义协议是一个不错的选择 – 它能在程序为启动时启动程序然后处理其它程序的动作，而这是其它解决方案，包括 HTTP 请求、共享数据库不能比的。其实日常生活中也有现成的例子，迅雷的自定义协议下载链接、BitTorrent 协议、百度网盘启动本地客户端等等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">将当前可执行文件设置为协议的默认处理程序（注册表级别）</a></p></blockquote><ol><li> 让程序保持单例启动</li><li> 设置客户端支持的协议（在 Windows 中会写入到注册表）</li><li> 处理命令行参数找到其中需要的 <code>url</code> 信息</li><li> 监听 <code>ready</code> 和 <code>second-instance</code> 事件</li></ol><h3 id="让程序保持单例启动"><a href="#让程序保持单例启动" class="headerlink" title="让程序保持单例启动"></a>让程序保持单例启动</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock">app.requestSingleInstanceLock()</a><br>注: 仅在单例模式下才能监听 <code>second-instance</code> 事件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 请求单例锁，避免打开多个 electron 实例</span><br><span class="hljs-keyword">const</span> gotTheLock = app.requestSingleInstanceLock();<br><span class="hljs-keyword">if</span> (!gotTheLock) &#123;<br>  app.quit();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置客户端支持的协议（在-Windows-中会写入到注册表）"><a href="#设置客户端支持的协议（在-Windows-中会写入到注册表）" class="headerlink" title="设置客户端支持的协议（在 Windows 中会写入到注册表）"></a>设置客户端支持的协议（在 Windows 中会写入到注册表）</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">app.setAsDefaultProtocolClient(protocol[, path, args])</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端默认支持的协议</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultProtocolClient</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> protocol: <span class="hljs-built_in">string</span></span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 注册一个默认支持打开的协议</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 开发模式下在 window 运行需要做兼容</span><br>    <span class="hljs-keyword">if</span> (<br>      process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span> &amp;&amp;<br>      process.platform === <span class="hljs-string">&quot;win32&quot;</span><br>    ) &#123;<br>      <span class="hljs-comment">// 设置 electron.exe 和 app 的路径</span><br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol, process.execPath, [<br>        path.resolve(process.argv[<span class="hljs-number">1</span>]),<br>      ]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 从命令行参数中找到 url</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment">   */</span><br>  findUrl(argv: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#123;<br>    <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.protocol&#125;</span>://`</span>);<br>    <span class="hljs-keyword">return</span> argv.find(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> regExp.test(str));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaultProtocolClient = <span class="hljs-keyword">new</span> DefaultProtocolClient(<span class="hljs-string">&quot;custom-protocol&quot;</span>);<br><br><span class="hljs-keyword">await</span> defaultProtocolClient.register();<br></code></pre></td></tr></table></figure><h3 id="处理命令行参数找到其中需要的-url-信息"><a href="#处理命令行参数找到其中需要的-url-信息" class="headerlink" title="处理命令行参数找到其中需要的 url 信息"></a>处理命令行参数找到其中需要的 <code>url</code> 信息</h3><p>添加函数 <code>handleDefaultProtocol</code> 从命令行参数中找到 url 然后处理它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理客户端支持的默认协议</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDefaultProtocol</span>(<span class="hljs-params">argv: <span class="hljs-built_in">string</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> url = defaultProtocolClient.findUrl(argv);<br>  <span class="hljs-keyword">if</span> (!url) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">await</span> dialog.showMessageBox(&#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;info&quot;</span>,<br>    message: <span class="hljs-string">&quot;window protocol 自定义协议打开&quot;</span>,<br>    detail: <span class="hljs-string">` 链接:<span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听-ready-和-second-instance-事件"><a href="#监听-ready-和-second-instance-事件" class="headerlink" title="监听 ready 和 second-instance 事件"></a>监听 <code>ready</code> 和 <code>second-instance</code> 事件</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#%E4%BA%8B%E4%BB%B6-second-instance">事件: ‘second-instance’</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">app.addListener(<span class="hljs-string">&quot;second-instance&quot;</span>, <span class="hljs-keyword">async</span> (event, argv) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(argv);<br>&#125;);<br>app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> createMainWindow();<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(process.argv);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><p>既然我们自定义协议的目的是让外部程序调用，那么如何使用外部调用就很重要了。</p><p>首先检查注册表中是否已经包含它了，操作 <em>ctrl+s =&gt; 搜索注册表 =&gt; 进入注册表 =&gt; ctrl+f 查找 <code>custom-protocol</code></em></p><p><img src="/resource/8445c03f200d46229abaab35ef6c4ea7.png" alt="注册表"></p><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><p>如上图所示，可以简单在浏览器中输入 <a href="custom-protocol://test">custom-protocol://test</a> 来启动程序。</p><p><img src="/resource/46116b80afd84b45a11b57ac67e1550e.gif" alt="自定义协议效果"></p><h3 id="nodejs-示例"><a href="#nodejs-示例" class="headerlink" title="nodejs 示例"></a>nodejs 示例</h3><p>在 nodejs 中使用 npm 包 <a href="https://www.npmjs.com/package/open">open</a> 可以轻易打开自定义默认链接。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> open <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;open&quot;</span>;<br><br>open(<span class="hljs-string">&quot;custom-protocol://test&quot;</span>);<br></code></pre></td></tr></table></figure><p>其实本质上就是拼接命令，然后执行系统命令打开 url，参考<a href="https://github.com/sindresorhus/open/blob/master/index.js">它的实现</a>。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>前端与后端的选择（个人理解）</title>
    <link href="https://blog.rxliuli.com/p/1a01dae8fd924bb6a0d5f4ee7f6847cf/"/>
    <id>https://blog.rxliuli.com/p/1a01dae8fd924bb6a0d5f4ee7f6847cf/</id>
    <published>2021-01-07T16:14:10.576Z</published>
    <updated>2021-02-19T14:08:50.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>吾辈就是一个从 Java Web 后端转到前端的人。</p></blockquote><p>吾辈今天又在看到人说 <strong>前端很简单，而且还比后端工资高</strong>，这里吾辈还是想做一些澄清的。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><ul><li>后端 A: 我发现这两年前端的工作特别好找，而且工资很高</li><li>后端 A：后端内卷太严重了。</li><li>后端 B: #无语</li><li>后端 B: 前端要会啥啊到底才能称得上前端</li><li>后端 A: 我们这边。H5+小程序 就行了</li><li>后端 A: 主要是 CSS 要能处理好。。。</li><li>后端 A: 设计做出来的东西要不能有折扣的做出来。。而不是向组件找不到妥协。。。。</li><li>后端 B：我感觉我很合适唉，虽然我没怎么做过小程序</li><li>后端 B: 有没有 Java 转前端的啊</li><li>吾辈：吾辈就是 @后端 B</li><li>吾辈：可能泥萌那是 2c 的业务，像吾辈这边偏向于 2b 的，业务和架构的复杂度相当高，事实上，吾辈这边的前端架构都已经需要微服务化了（即所谓的微前端）</li><li>后端 C：微前端</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。</li><li>吾辈: 这其实有个错觉就是，前端开发岗位多，开发人员多，就一定好找工作。Java 还不是有很多培训班为市场注入了许多后端，而 web 其实也很糟糕，因为似乎所有人都开始觉得前端只要会 vuejs 加点 html/css/js 就可以开始工作了，恰好市场这两年的缺口还很大，所以培训班其实也为市场注入了相当的人员，导致招聘很难招，工作很难找。（不过不吹不黑，吾辈确实因为转到前端发生了发生了很多变化，尤其是在开源项目方面，之前基本不做，现在嘛，有时间就会做一些 #本质原因可能还是因为前端还不够成熟吧）</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。。@吾辈</li><li>后端 D: 不是说前端比较抗骂嘛</li><li>吾辈：你什么时候产生了前端比后端工资高的错觉，就那吾辈的公司来说，前端 10-20，后端 golang 15-20，Java 18-35 (´-ι_-｀)</li><li>吾辈：另外前端技术栈迭代非常快，前后端的边界正在后移，想想之前后端还要负责模板引擎，路由，状态管理，逻辑代码，工程化方面的任务，现在，这些都成为了前端的任务，而且之前的任务 ui 还原还没少，而后端在吾辈看来的一个主要问题在于用户量不够的情况下基本没得折腾，意味着许多 idea 无法在生产环境落地，后端技术栈迭代也很慢（主要是由于风险更高以及成熟度），现在还是 Java 8，而前端，基本都是跟着版本跑（当然这会带来 js 疲劳暂且不说），生产环境吾辈已经上了 ts 4（半年之前更新的大版本）。还有一点我不确定是否是常事，一般后端似乎没有自己维护的开源项目，这很显然是没法在生产之外尝鲜新技术的，一年经验用十年，不外如是。</li><li>吾辈：另外觉得前端简单的可以看一下这一系列谈话（前后端之间的，2016 年的，现在前端更加复杂化了）<a href="/p/333051b25bd047e8864d161a9a6982de">2016 年里做前端是怎样一种体验</a></li></ul><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>就吾辈个人的感觉而言，似乎许多后端还不清楚前端领域到底发生了什么，觉得前端还仅仅是 <strong>切图</strong>，而这显然是个错误。</p><p>前端近几年发展迅速，几乎可以说是日新月异，尽管可能大部分都会被扫进历史的垃圾堆，但至少能够切身参与到发展的历史进程中。而且，现在前端要解决的问题域也在发生变化，在传统前端眼里，CSS（UI 还原）和兼容性问题是最重要的，但现在，已然天翻地覆，前端本身的知识领域也在发生割裂，参考: <a href="https://css-tricks.com/the-great-divide/">大分裂</a>。</p><blockquote><p>当然在很久以前，前端也有独特的「复杂问题」，比如我刚工作那会需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧，但这类问题更偏向「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值。</p></blockquote><p>而后端，经过几十年的长足发展，已经非常完善，似乎没有太大的变化了。当然，就像 <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a> 所言，<strong>「后端是在业务方面革自己的命，使劲在平台化、中台化发展，然后把具体业务这块解放给前端」</strong>。</p><table><thead><tr><th>分类</th><th>前端</th><th>后端</th></tr></thead><tbody><tr><td>发展速度</td><td>迅速</td><td>缓慢</td></tr><tr><td>发展程度</td><td>发展中</td><td>成熟</td></tr><tr><td>试错成本</td><td>低</td><td>高（后台服务炸掉是很难被接受的）</td></tr><tr><td>知识价值</td><td>低（发展迅速带来的疲劳）</td><td>高</td></tr><tr><td>入门难度</td><td>低（学会三大件就能写）</td><td>高</td></tr><tr><td>个人成长机会</td><td>一般</td><td>低（很难有机会应用自己的轮子）</td></tr></tbody></table><blockquote><p>注：以上均为吾辈在小公司的一些体会，并不一定意味着<strong>正确</strong>。而且，前端并不一定意味着简单，也有可能是根本没有接触过复杂的应用场景。例如前端工程化、智能化、编辑器、富文本、可视化图表之类的。当然，前后端其实面临着相似的问题：在小公司很多东西并没有使用场景，低层次的工作重复十年也做不出来一个 <a href="https://juejin.cn/post/6924591257452806152/">设计稿智能生成代码 imgcook</a><br>注 2：但同时，吾辈也不得不承认两者确实在天花板上有着差异，尤其而且是在大型互联网公司（例如阿里），参考：<a href="https://blog.alswl.com/2019/07/frontend-backend-ceiling/">漫谈前后端天花板</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="杂谈" scheme="https://blog.rxliuli.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-自定义窗口顶栏</title>
    <link href="https://blog.rxliuli.com/p/85f539d2cc4e4ae89093df537111cec8/"/>
    <id>https://blog.rxliuli.com/p/85f539d2cc4e4ae89093df537111cec8/</id>
    <published>2021-01-07T12:12:44.784Z</published>
    <updated>2021-02-19T14:31:20.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在很多生产项目中，我们希望自定义 electron 窗口顶栏，因为它确实非常简陋。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="在渲染层实现自定义顶栏"><a href="#在渲染层实现自定义顶栏" class="headerlink" title="在渲染层实现自定义顶栏"></a>在渲染层实现自定义顶栏</h3><p>实际上，核心的代码就是添加一个为顶栏的元素添加 css 样式。在 electron 环境，有 <code>-webkit-app-region: drag;</code> 属性的元素可以拖动整个窗口。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: drag;<br>&#125;<br><span class="hljs-selector-class">.toolbar</span> &gt; * &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: no-drag;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 css 看起来有点奇怪，但这是为了避免子元素（例如关闭按钮）也可以拖动的错误。</p><blockquote><p><a href="https://www.electronjs.org/docs/api/browser-window#event-system-context-menu-windows">参考文档</a>, <a href="https://github.com/rxliuli/electron_example/blob/18a1a756e5c82e87ef1c8755a0be036b6765f04b/apps/renderer/src/components/router/component/BasicLayout.module.css#L13">参考代码</a></p></blockquote><h3 id="使用-electron-通信实现窗口的三个操作"><a href="#使用-electron-通信实现窗口的三个操作" class="headerlink" title="使用 electron 通信实现窗口的三个操作"></a>使用 electron 通信实现窗口的三个操作</h3><p>其实，electron 本身支持在渲染层暴露 <code>remote</code> 模块，但这里我们选择使用 <code>ipcRenderer/ipcMain</code> 手动实现，remote 模块因为安全原因默认被禁用了。</p><p>下面的步骤基本和 <a href="/p/76393a60949c47c7add910df0206734c">渲染、主进程通信</a> 所属一样，下面贴一些关键代码</p><p>共享类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// WindowDefine.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseDefine &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron_ipc_type&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> WindowDefine <span class="hljs-keyword">extends</span> BaseDefine&lt;&quot;WindowApi&quot;&gt; &#123;<br>  action(<span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowApi</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">action</span>(<span class="hljs-params">e: IpcMainInvokeEvent, <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> win = BrowserWindow.fromWebContents(e.sender);<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;min&quot;</span>:<br>        win.minimize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;max&quot;</span>:<br>        win.isMaximized() ? win.unmaximize() : win.maximize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>        win.close();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// BasicLayout.tsx</span><br><span class="hljs-keyword">const</span> windowApi = IpcRendererClient.gen&lt;WindowDefine&gt;(<span class="hljs-string">&quot;WindowApi&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装 electron 的窗口控制 hooks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useElectronWindowControl</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    handleMin: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;min&quot;</span>),<br>    handleMax: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;max&quot;</span>),<br>    handleClose: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;close&quot;</span>),<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/rxliuli/electron_example/tree/3aea837b0c7661e030406a0c20d306694402a26f">参考代码</a></p></blockquote><h3 id="隐藏掉默认的顶栏"><a href="#隐藏掉默认的顶栏" class="headerlink" title="隐藏掉默认的顶栏"></a>隐藏掉默认的顶栏</h3><p>实际上，只要在创建 electron 的 <code>BrowserWindow</code> 实例时配置即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>  webPreferences: &#123;<br>    nodeIntegration: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  frame: <span class="hljs-literal">false</span>,<br>  autoHideMenuBar: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在，electron 程序就有自定义顶栏啦</p><p><img src="/resource/92f7aa2fcd894107b05056f5c662e051.png" alt="1611134001681.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然自定义窗口顶栏有很多优点，但也并非尽善尽美，已知缺点如下</p><ul><li>占有了一定高度，导致一些 UI 组件的位置很奇怪，例如顶部的消息提示框和侧边抽屉，会遮挡住窗口顶栏的一部分。</li><li>可能随着系统升级与系统风格不搭，早有人吐槽过 Windows 所有程序的自定义顶栏都是不一样的高度和大小，非常丑</li><li>需要重新实现窗口菜单相关的快捷键，例如 <code>ctrl+shift+i</code> 打开开发者工具</li><li>在 mac 上需要进行特别的兼容，否则和其他程序会显得格格不入</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-开发环境优化</title>
    <link href="https://blog.rxliuli.com/p/5cc9156517484576a64b4d253ae28af8/"/>
    <id>https://blog.rxliuli.com/p/5cc9156517484576a64b4d253ae28af8/</id>
    <published>2021-01-07T11:59:34.617Z</published>
    <updated>2021-02-19T14:31:28.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-react-devtool-插件调试"><a href="#使用-react-devtool-插件调试" class="headerlink" title="使用 react devtool 插件调试"></a>使用 react devtool 插件调试</h2><!-- TODO 需要将这两个函数抽离成静态工具类 --><p>前言</p><p>虽然绝大多数时候，我们都可以也应该在浏览器调试渲染层的功能，但确实也会有需要在 electron 程序中调试的需求，这里就说明一下 electron 如何安装 chrome 插件 react devtool 调试项目。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-devtools-installer">electron-devtools-installer</a></p></blockquote><p>步骤</p><p>1、安装依赖</p><p>cd 到 <em>apps/main</em> 目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-devtools-installer @types/electron-devtools-installer<br></code></pre></td></tr></table></figure><p>2、添加环境变量 <code>&quot;NODE_ENV&quot;: &quot;development&quot;</code> 标识为开发环境</p><p>修改 <em>.env-cmdrc.json</em> 配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;NODE_ENV&quot;</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、修改 <code>main</code> 函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>      <span class="hljs-comment">// 安装 devtool 扩展</span><br>      <span class="hljs-keyword">await</span> installExtension(REACT_DEVELOPER_TOOLS);<br>    &#125;<br><br>    <span class="hljs-keyword">await</span> createMainWindow();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 <code>createMainWindow</code> 函数</p><p>一般，我们在开发环境还习惯打开控制台，这里也可以在创建窗口后自动打开它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    process.env.ELECTRON_START_URL || path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>  );<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>    mainWindow.webContents.openDevTools();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可能的错误参考: <a href="/p/c68829779f5449d0afe0e67806dc7fc1">常见问题</a> <strong>安装浏览器扩展报错</strong></p></blockquote><p>5、启动 electron 开发环境</p><p>启动后可以看到自动打开了控制台，然后可以看到 react devtool</p><p><img src="/resource/4bdfd0cdf55c4e098b1f5b3a92fb7947.png" alt="实际效果"></p><h2 id="让主进程的代码也能热更新"><a href="#让主进程的代码也能热更新" class="headerlink" title="让主进程的代码也能热更新"></a>让主进程的代码也能热更新</h2><p>前言</p><p>可能你也发现了，渲染层使用 cra 创建的项目默认包含了热更新，这都要得益于 webpack HMR 技术，但主进程并非如此，即便使用 <code>tsc -w</code> 监听并编译 ts 代码，但想要生效仍然需要重启 electron，不厌其烦。幸运的是，有人已经实现了这个需求。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-reloader">electron-reloader</a></p></blockquote><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-reloader<br></code></pre></td></tr></table></figure><p>2、在主进程入口文件载入 electron-reloader</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//添加热更新功能</span><br><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron-reloader&quot;</span>)(<span class="hljs-built_in">module</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、启动 electron 开发环境</p><p><img src="/resource/d2a07efc8ff24354b49289c2d4210b79.gif" alt="效果"></p><blockquote><p>注 2: 当修改代码时，重启 electron 应用是由 electron-reloader 负责，即它不在 WebStorm 的控制之下了。<br>注 2: 目前另一个 <a href="https://www.npmjs.com/package/electron-reload">electron-reload</a> 还存在一些小问题。</p></blockquote><h2 id="使用-esbuild-优化渲染层打包性能"><a href="#使用-esbuild-优化渲染层打包性能" class="headerlink" title="使用 esbuild 优化渲染层打包性能"></a>使用 esbuild 优化渲染层打包性能</h2><blockquote><p>如果你还没有感觉到 cra 打包很慢，可以跳过这一节。</p></blockquote><h3 id="禁止-ts-babel-将代码编译为-ES5"><a href="#禁止-ts-babel-将代码编译为-ES5" class="headerlink" title="禁止 ts/babel 将代码编译为 ES5"></a>禁止 ts/babel 将代码编译为 ES5</h3><p>由于 electron 捆绑的浏览器和 nodejs 版本都比较新，所以实际上渲染层我们基本不需要 babel 转义，可以优化一些配置项。</p><ul><li><p>将 <code>browserslist</code> 设置为仅支持最后一个 chrome 版本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;browserslist&quot;</span>: [<span class="hljs-string">&quot;last 1 chrome version&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <em>tsconfig.json</em> 中的配置，将编译目标修改为 <code>ESNext</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ESNext&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-esbuild-编译-typescript-代码"><a href="#使用-esbuild-编译-typescript-代码" class="headerlink" title="使用 esbuild 编译 typescript 代码"></a>使用 esbuild 编译 typescript 代码</h3></li></ul><blockquote><p>核心依赖: <a href="https://github.com/evanw/esbuild">esbuild</a>, <a href="https://github.com/gsoft-inc/craco">craco</a></p></blockquote><p>esbuild 是一个使用 golang 编写前端打包工具，官方在性能测试中提出比现有工具快 10-100 倍。</p><p>在 cra 创建的项目中，我们可以通过 craco 将 esbuild 仅用作 ts 编译之用（不会检查类型）。</p><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D @craco/craco craco-esbuild<br></code></pre></td></tr></table></figure><p>2、修改 npm script，使用 <code>craco</code> 替换 <code>react-scripts</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;craco start&quot;</span>,<br>    <span class="hljs-attr">&quot;build:cra&quot;</span>: <span class="hljs-string">&quot;react-scripts build&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;craco build&quot;</span>,<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;craco test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产项目中的对比测试结果（6000+ 行 ts 代码）</p><table><thead><tr><th>分类</th><th>ESBuild</th><th>tsc</th></tr></thead><tbody><tr><td>无缓存</td><td>17.61</td><td>36.57</td></tr><tr><td>有缓存（运行 5 次）</td><td>15252.8</td><td>17095.2</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-使用 electron-builder 打包</title>
    <link href="https://blog.rxliuli.com/p/33dd9a3fccaf4666b04935237f885772/"/>
    <id>https://blog.rxliuli.com/p/33dd9a3fccaf4666b04935237f885772/</id>
    <published>2021-01-07T11:55:42.965Z</published>
    <updated>2021-02-19T14:31:33.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="/p/23ec4673a06f41b59bfaf5a7da6d98db">基本项目搭建</a> 中，我们已经能够启动一个 electron 应用程序了（开发环境），现在来看如何将之打包为二进制程序便于分发给最终用户。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><a href="https://www.electron.build/">electron-builder</a>: 打包的主要工具库，负责这个 electron 的跨平台打包工作<blockquote><p>事实上，还有一些其它的打包工具，但目前还没有比它更好的，参考: <a href="https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager">https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager</a></p></blockquote></li></ul><h2 id="渲染层打包"><a href="#渲染层打包" class="headerlink" title="渲染层打包"></a>渲染层打包</h2><p>直接使用 cra 的打包工具即可，没什么大不了的，但确实存在一些注意事项</p><ul><li>因为 electron 在生产环境会从文件系统中加载静态资源，所以打包出来的静态资源必须支持相对路径，下面是常见的两个设置。<ul><li>必须在 <em>apps/renderer/package.json</em> 中声明 <code>&quot;homepage&quot;: &quot;.&quot;</code>，参考: <a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Building for Relative Paths</a></li><li>路由必须是 <code>hash</code> 模式</li></ul></li></ul><h2 id="主进程打包"><a href="#主进程打包" class="headerlink" title="主进程打包"></a>主进程打包</h2><p>electron-builder 打包需要以下几个步骤</p><h3 id="更新-package-json-的一些配置"><a href="#更新-package-json-的一些配置" class="headerlink" title="更新 package.json 的一些配置"></a>更新 package.json 的一些配置</h3><ol><li> 使用 package.json 中的 <code>build</code> 字段作为配置项，参考: <a href="https://www.electron.build/">https://www.electron.build/</a></li><li> electron-builder 使用 <code>main</code> 字段作为启动脚本文件</li><li> electron-builder 要求必须使用固定的版本号，意味着 electron 依赖需要指定为 <code>&quot;electron&quot;: &quot;10.2.0&quot;</code></li></ol><p>下面是一个基本的配置示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 一个非常基本的打包脚本</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;electron-builder&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;electron&quot;</span>: <span class="hljs-string">&quot;10.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.9.1&quot;</span>,<br>    <span class="hljs-comment">// electron 主进程实际上是 nodejs 环境，所以为了更好的开发体验，安装 nodejs 的类型定义</span><br>    <span class="hljs-attr">&quot;@types/node&quot;</span>: <span class="hljs-string">&quot;^12.19.12&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-comment">// 程序的唯一标识符</span><br>    <span class="hljs-attr">&quot;appId&quot;</span>: <span class="hljs-string">&quot;com.rxliuli.electron_example&quot;</span>,<br>    <span class="hljs-comment">// 打包出来的 exe 名字</span><br>    <span class="hljs-attr">&quot;productName&quot;</span>: <span class="hljs-string">&quot;electron 示例应用&quot;</span>,<br>    <span class="hljs-comment">// 打包的目录</span><br>    <span class="hljs-attr">&quot;directories&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;output&quot;</span>: <span class="hljs-string">&quot;release&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;win&quot;</span>: &#123;<br>      <span class="hljs-comment">// 打包目标，参考: https://www.electron.build/</span><br>      <span class="hljs-attr">&quot;target&quot;</span>: [<span class="hljs-string">&quot;nsis&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制静态资源"><a href="#复制静态资源" class="headerlink" title="复制静态资源"></a>复制静态资源</h3><p>现在，我们需要打包静态资源并复制到主进程模块里面</p><ol><li> <code>cd apps/renderer</code> 目录</li><li> <code>yarn build</code> 打包静态资源</li><li> 将静态资源复制到 <code>build/dist</code> 目录下</li></ol><h3 id="修改主进程入口文件-main-ts"><a href="#修改主进程入口文件-main-ts" class="headerlink" title="修改主进程入口文件 main.ts"></a>修改主进程入口文件 main.ts</h3><p>还需要修改 <em>src/main.ts</em> 代码，主要修改 BrowserWindow 对象载入的 <code>url</code> 地址</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">import</span> &#123; URL &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    <span class="hljs-keyword">new</span> URL(path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)).href<br>  );<br>&#125;<br><br><span class="hljs-comment">// 其他代码...</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，这个 url 路径是相对于打包后的 <code>dist/main.js</code> 而言的，因为最终打包的程序运行时的相对路径也是这样。</p></blockquote><h3 id="打包主进程的-exe-程序"><a href="#打包主进程的-exe-程序" class="headerlink" title="打包主进程的 exe 程序"></a>打包主进程的 exe 程序</h3><blockquote><p>因为 electron-builder 需要下载基本的 electron 程序，所以请提前设置好透明代理，如果不知道它是什么，参考: <a href="https://github.com/rxliuli/haoel.github.io#7-%E9%80%8F%E6%98%8E%E7%BD%91%E5%85%B3">透明网关</a>，<a href="http://www.proxifier.com/">Proxifier</a></p></blockquote><ol><li> 使用 <code>yarn compile</code> 编译 ts 代码</li><li> 使用 <code>yarn pkg</code> 打包 electron 应用</li></ol><p>现在，我们应该可以在 <em>apps/main/release/win-unpacked</em> 下看到 exe 程序，双击它即可看到之前在开发环境的首页了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main">https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main</a></p></blockquote><h2 id="优化打包"><a href="#优化打包" class="headerlink" title="优化打包"></a>优化打包</h2><p>虽然打包已经实现，但确实还存在一些问题</p><ul><li>打包脚本仍然不是一键的</li><li>不能兼容开发、生产环境</li></ul><p>下面我们来解决这两个问题</p><h3 id="实现一键打包二进制程序"><a href="#实现一键打包二进制程序" class="headerlink" title="实现一键打包二进制程序"></a>实现一键打包二进制程序</h3><p>使用 gulp 复制渲染层的静态资源</p><p>1、添加 gulp 相关依赖 <code>yarn add -D gulp ts-node @types/gulp fs-extra @types/fs-extra</code></p><ul><li><code>gulp @types/gulp</code>: gulp 核心依赖</li><li><code>ts-node</code>: 使用 ts 编写 gulp 脚本必须的依赖</li><li><code>fs-extra @types/fs-extra</code>: fs 的扩展增强，使用 Promise 包装异步 api</li></ul><p>2、添加 gulp 脚本文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; copy, remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs-extra&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyByMap</span>(<span class="hljs-params">copyMap: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>][]</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>    copyMap.map(<span class="hljs-keyword">async</span> ([src, destDir]) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> srcPath = path.resolve(__dirname, src);<br>      <span class="hljs-keyword">const</span> destPath = path.resolve(__dirname, destDir, path.basename(srcPath));<br>      <span class="hljs-keyword">await</span> copy(srcPath, destPath);<br>    &#125;)<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理最终生成目录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clean</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>));<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;release&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 复制一些资源到 dist 目录中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyStatic</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> copyByMap([[<span class="hljs-string">&quot;../renderer/build&quot;</span>, <span class="hljs-string">&quot;dist/&quot;</span>]]);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、添加 npm script</p><blockquote><p>注: lerna 的好处之一就是可以运行其它模块的 npm script。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 打包渲染层的静态资源</span><br>    <span class="hljs-attr">&quot;build:web&quot;</span>: <span class="hljs-string">&quot;lerna run --scope renderer build&quot;</span>,<br>    <span class="hljs-comment">// 打包渲染层的静态资源之后复制然后使用 electron-builder 打包 exe 程序</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;gulp clean &amp;&amp; yarn compile &amp;&amp; yarn build:web &amp;&amp; gulp copyStatic &amp;&amp; electron-builder&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 tsconfig.json</p><p>此时在 <em>apps/main</em> 模块根目录下也有 ts 文件了，所以 tsc 翻译代码会将它们也包含进去，但实际上不需要。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以使用一个命令打包 exe 程序了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json">https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json</a></p></blockquote><h3 id="使用环境变量来兼容开发、生产环境"><a href="#使用环境变量来兼容开发、生产环境" class="headerlink" title="使用环境变量来兼容开发、生产环境"></a>使用环境变量来兼容开发、生产环境</h3><p>解决方案简单来说就一句话：使用环境变量指定开发环境的 URL。<br>这里使用 <a href="https://github.com/toddbluhm/env-cmd">env-cmd</a> 来跨平台写入环境变量（不使用 <a href="https://github.com/motdotla/dotenv">dotenv</a> 的原因在于自定义环境使用起来有点麻烦，不像 env-cmd 那么直观），而另一个 <a href="https://github.com/kentcdodds/cross-env">cross-env</a> 并未提供管理环境变量的解决方案。下面说一下使用 env-cmd 的步骤</p><ol><li><p> 安装依赖 <code>yarn add -D env-cmd</code></p></li><li><p>添加配置文件 <em>.env-cmdrc.json</em><br> 基本上是一个键值映射文件，键是环境，值对象是环境变量</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 在 <code>dev:electron</code> 命令之前设定环境变量 <code>env-cmd -e dev electron ./dist/main.js</code></p></li><li><p>修改 <em>src/main.ts</em> 读取环境变量</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> mainWindow.loadURL(<br>  process.env.ELECTRON_START_URL ||<br>    path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>现在，像 <a href="/p/23ec4673a06f41b59bfaf5a7da6d98db">基本项目搭建</a> 中 <strong>更新 <em>package.json</em> 添加几个 npm script</strong> 说的那样启动开发环境就会显示开发环境的页面，打包后显示的则是打包后的静态资源。</p></li></ol><p><img src="/resource/866c4124afe04289b88972507b3f6743.png" alt="效果"></p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json">https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 electron-builder 已经足够好用了，但它仍然不能解决 electron 项目工程上的问题，所以这里结合了 <code>lerna/gulp/env-cmd</code> 打包。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-自动更新</title>
    <link href="https://blog.rxliuli.com/p/bf7621c04d9f45098fb0ecf2acad336e/"/>
    <id>https://blog.rxliuli.com/p/bf7621c04d9f45098fb0ecf2acad336e/</id>
    <published>2021-01-05T00:46:44.689Z</published>
    <updated>2021-02-19T14:31:17.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于生产应用希望在有新版本时，自动为用户推送更新，所以此处便写一下如何让 electron 程序自动更新。</p><h2 id="安装-npm-包"><a href="#安装-npm-包" class="headerlink" title="安装 npm 包"></a>安装 npm 包</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> apps/main/ &amp;&amp; yarn add electron-updater<br></code></pre></td></tr></table></figure><h2 id="配置-electron-builder"><a href="#配置-electron-builder" class="headerlink" title="配置 electron-builder"></a>配置 electron-builder</h2><blockquote><p>参考: <a href="https://www.electron.build/auto-update">https://www.electron.build/auto-update</a></p></blockquote><p>其实本质上就是配置一个网络可以访问到的静态资源目录，这里使用了一个本地的静态资源服务器，指向目录是 _apps/main/release_（即打包而进程程序的目录）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;publish&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;provider&quot;</span>: <span class="hljs-string">&quot;generic&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/&quot;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动时检查更新"><a href="#启动时检查更新" class="headerlink" title="启动时检查更新"></a>启动时检查更新</h2><p>在主进程添加检查更新的代码，并自定义提示文案。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> autoUpdater.checkForUpdates();<br>autoUpdater.addListener(<span class="hljs-string">&quot;update-downloaded&quot;</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">new</span> Notification(&#123;<br>    title: <span class="hljs-string">&quot;更新提醒&quot;</span>,<br>    body: <span class="hljs-string">`新版本 <span class="hljs-subst">$&#123;info.version&#125;</span> 已经准备好，点击立刻更新！`</span>,<br>  &#125;)<br>    .addListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      autoUpdater.quitAndInstall();<br>    &#125;)<br>    .show();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>现在，你可以启动一个本地静态服务器指向 _apps/main/release_，例如 <a href="https://www.npmjs.com/package/live-server">live-server</a>，然后打包一个新版本，再启动旧的程序就可以了。</p><p><img src="/resource/6a33797917e34056b95238471ff0c06b.gif" alt="效果"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="wiki" scheme="https://blog.rxliuli.com/tags/wiki/"/>
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
</feed>
