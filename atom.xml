<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rxliuli blog</title>
  
  
  <link href="https://blog.rxliuli.com/atom.xml" rel="self"/>
  
  <link href="https://blog.rxliuli.com/"/>
  <updated>2021-03-13T20:42:54.000Z</updated>
  <id>https://blog.rxliuli.com/</id>
  
  <author>
    <name>rxliuli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 第十周</title>
    <link href="https://blog.rxliuli.com/p/8fb2d58463ae4191ac064a76e15bffbd/"/>
    <id>https://blog.rxliuli.com/p/8fb2d58463ae4191ac064a76e15bffbd/</id>
    <published>2021-03-13T19:25:54.000Z</published>
    <updated>2021-03-13T20:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离提出离职已然过去三周了，但现在仍未找到合适的工作。也不是没有面试过，但确实没有找到合适的 – 对于吾辈而言，合适指的是优秀的 team，最好是平台而非业务 team。</p><p>吾辈也找到了一些大佬帮忙内推，包括</p><ul><li>快手 基础平台建设</li><li>百度 YY 直播</li><li>腾讯 微众银行</li><li>阿里云 DataV 数据可视化</li></ul><p>但最让吾辈感觉难过的不是面试之后因为能力不足而失败，而是即便内推也仍然没有面试的机会。当然吾辈也能理解，毕竟不拘一格降人才确实存在风险，更不用说吾辈只是一个努力的普通人 – 左耳朵耗子在 <a href="https://coolshell.cn/articles/19464.html">如何超过大多数人</a> 所说的第四类人。尽管吾辈也逐渐明白低层次的努力收效甚微，也因而离开现在的舒适区，但曾经确实没能制定合理完备的计划，然后实践和改进让自己变得更好。</p><p>之前尝试面试过两家小公司恢复状态，但公司真的是比烂，对比之下反而现在的公司还更好一点</p><p>目前还在面试的是 CVTE，是一个家在招聘网站上邀投然后拒掉简历然后再邀投的神奇公司，大概是不同产品线的 HR 吧。有趣的是，当吾辈问及 leader 对于 team 的评分时，也仍然是只有 6、7 分，这是吾辈第四次听到这个答案了，看来大部分 leader 都觉得自己的 team 不太行 xd</p><p>工作日一边补充公司相关文档以供交接，另一方面则是在看 <a href="https://book.douban.com/subject/19952400/">算法 4</a> 上的一些内容，练习链表相关的那些问题，但到了算法复杂度分析方面，仍旧看的比较乏味，曾几何时吾辈对数学还算感兴趣，后面放弃确实太糟糕了。</p><p>目前完成进度是 <a href="https://github.com/rxliuli/algorithm/pulse">1.3.34-1.3.49</a></p><p><img src="/resource/d056070b843641ea939933d245810c75.png" alt="1615709481022"></p><p>个人项目方面，吾辈创建了 <a href="https://github.com/rxliuli/joplin-search-intergration">joplin-search-integrated</a> chrome 插件，用于将 joplin 的笔记展现在网页搜索中，便于使用同一个搜索引擎搜索到互联网上的内容和自己的笔记，灵感来自 EvenNote Web Clipper。另外一个就是将之前的几个 joplin 相关的工具整合到一个 monorepo 项目 <a href="https://github.com/rxliuli/joplin-utils">joplin-utils</a> 中，不仅仅是为了可以更简单的复用代码，更是为了继续实践 monorepo 如何管理多个应用模块，例如如何在 release 中发布多个应用，因为 GitHub release 只有一条线。</p><blockquote><p>吾辈因需要而开发的一些 joplin 周边工具，使用 monorepo 进行管理。</p><ul><li>joplin-vscode-plugin: 在 vscode 中管理和编辑 joplin 笔记</li><li>joplin-search-integration: 在网页搜索中插入相关的 joplin 笔记</li><li>joplin-blog: 将 joplin 笔记导出为 blog</li><li>joplin-charts: joplin 一些数据可视化图表</li><li>joplin-api: joplin ts api</li></ul></blockquote><p>其他事情</p><ul><li>这周利用地铁上的通勤时间把 <a href="https://book.douban.com/subject/26575643/">《颓废与沉默》</a> 看完了，一些感想在 <a href="/p/7e7131c07c984d928ba3fefa7a9cef06">读书-[颓废与沉默：透视犬儒文化]</a></li><li>kigurumi 的皮肤到了，照片已发 <a href="/p/78d7cae2e92e4e518b2aa89337be85d8">立个 Flag，今年入坑 Kigurumi 并出一次漫展</a></li><li>正常作息坚持了 5 天，睡眠质量基本都在 75% 之上，统计使用的是 Sleep Cycle</li><li>正式购买了 Proxifier，虽然数码荔枝很便宜，但为了避免麻烦吾辈直接去官网购买了，不到 300 软妹币还能接受</li><li>这周使用了 20+h 的手机，这是个糟糕的信号，吾辈下周要砍掉一半浪费的时间。Pass：其中占用时间最长的 twitter 已卸载</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
    <category term="周报" scheme="https://blog.rxliuli.com/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>读书-[颓废与沉默：透视犬儒文化]</title>
    <link href="https://blog.rxliuli.com/p/7e7131c07c984d928ba3fefa7a9cef06/"/>
    <id>https://blog.rxliuli.com/p/7e7131c07c984d928ba3fefa7a9cef06/</id>
    <published>2021-03-12T03:32:28.000Z</published>
    <updated>2021-03-12T03:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当今世界上不同国家社会和国民文化中的犬儒主义可以分为两大类:公开的犬儒主义和戴面具的犬儒主义。它们的基本区别在于,当一个人因为犬儒主义而不相信统治意识形态、制度、权威、信仰体系以及由权力或习俗规定和主导的法律或价值规范时,尤其是怀疑和鄙视政府、政治权力和政治人物的时候,公开的犬儒主义会在公共言论和行为中表示出来,而戴面具的犬儒主义则通常不会,不仅不会表示不相信,而且还会假装成相信的样子。公开的犬儒主义对那些什么都不相信,所以公然怀疑,公然拒绝,不相信就是不相信。戴面具的犬儒主义对那些也是什么都不相信,但正因为对什么都不相信,所以对什么都可以装作相信。他们玩世不恭,随波逐流,最后有的连自己都弄不清到底是相信还是不相信,于是索性不去管相信不相信,”难得糊涂”地过一天算一天。当然,这不等于戴面具的犬儒主义在任何情况下都不会摘下面具露出不相信的真面目。他们在私下或在不那么公开的场合中也会有不戴假面的时候。这时候,不加掩饰的犬儒主义就会成为同道者之间互相联络的接头暗号。这使得原本以怀疑和不信任为特征的犬儒主义反倒成为一种人际联系方式,也形成一种有群体特征的社会文化。</p></blockquote><p>开局王炸。这让吾辈想到了 1984 里面的男女主角的认知和世界观，男主就是怀疑政府，但带上了面具。而（新生代的）女主则一方面装作相信，但背地里却又不在乎，看的时候觉得简直就是精神分裂。</p><hr><blockquote><p>在所有这 13 种”病态”中,没有一处提及犬儒,可见犬儒并不是一个普通中国人常用的概念。然而,这些病态中至少有八九种都是犬儒主义的典型表现:（1）娱乐至死（没有目标或信仰,得过且过）；（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；（8）”鸵鸟心态”（多一事不如少一事,被宣传的现实反正是假的,不如”躲进小楼成一统”）;（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是”自虐”,这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。</p></blockquote><p>躺枪，感觉吾辈中了好多枪。过去的经历造就了现今的吾辈，社会的经验和认知中的道理偏差太大了。</p><hr><blockquote><p>假面社会里的犬儒者们揣着明白装糊涂（”难得糊涂”）,明明在心里不相信,但却还公开做出相信的样子。他们戴上自己参与制作的假面,顺从地配合统治者的愿望表演。这也是一种将顺从和抵抗合为一体的犬儒主义。波兰诗人米沃什在《被禁锢的头脑》中称此为”蒙蔽对手”的策略。他写道,”有些情况,保持沉默还不够,沉默可能被认为是主动招供,那时候就不应有丝毫犹豫,不仅要公开否认自己真正的观点,而且必须采取一切手段来蒙蔽对手。那时候就得宣布一切能取悦对手的信条,参与所有被认为是最荒唐的仪式 ⋯⋯ 终于,在蒙骗对手后,使对手在其错误中越陷越深的同时,使其承受应得的羞辱和精神痛苦。”这可能只是一种精神胜利法,但它却能”让践行它的人感到自豪,因为有了它,践行者才能把自己提升到超越被蒙骗者之上,并持久获得比对手优越的地位,哪怕是部长或有权有势的国王。⋯⋯ 你表面上还在被你巧妙欺骗的强权者脚下颤抖,眼睛却闪闪发亮。你在光明中走在敌人面前,你嘲笑一个愚蠢的家伙,解除了一头危险野兽的武装。这一下获得多少慰藉！”</p></blockquote><p>吾辈想到了某段话：“如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。”<br>—— 柏拉图</p><hr><blockquote><p>马基雅维利说,害怕是比爱戴更有效的统治工具,这话很适合今天的犬儒社会。有权者和无权者的犬儒主义总是在恶性循环,形成一种恶吏统治刁民的强制性秩序,稳固这一秩序的唯一办法就是层层加码的所谓”乱世用重典”。</p></blockquote><p>这让吾辈想到刚过完的春节之前返乡政策：<br>中央要求 “从低风险区返乡持绿码即可”，到一些省份变成 “持核酸检测阴性证明”，到市里就变成 “核酸阴性证明 + 居家隔离”，到镇上变成 “核酸证明 + 集中隔离 + 居家隔离”，最后到村里就成了 “禁止返乡”。</p><hr><blockquote><p>权力随时防范着学术,设置重重障碍。但是,由于”学术”对权力有利用价情,所以还会被允许存在,甚至加以鼓励。当然,首要的条件是学术必须无害于权力统治,而最受稿赏的则是有助于或能配合权力统治的学术。权力的咸胁与利诱造就体制性的”学术义儒”,它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。</p></blockquote><p>哈哈，这是在指某位小学生么 xd</p><hr><blockquote><p>先入为主（preconception）和刻板印象（stereotype）之间有联系,但又有所区别。先入为主经常是因为某种先例而形成的一种习惯性推断,以为以前曾经发生过的,现在也就一定会发生。”先例”是先入为主思维的条件。先入为主又称偏见（prejudice）,也就是在还没有弄清情况之前就下定论（prejudgment）。</p></blockquote><p>这点吾辈深有感触。在吾辈高二那年活跃于贴吧之中时，曾被人认为是女生，后面与一些人建立了相关的 QQ 同好群，里面的许多人也会这样认为–因为之前有人这样认为了，如果有人怀疑，那么前面已经如此认定的人就会反对。甚至到了现在，吾辈虽然没有刻意伪装，但却也没有主动说明过。</p><hr><blockquote><p>美国的现实民主制度保障了普通美国人讨论”什么是爱国主义”,”美国需要怎样的爱国主义”的权利。政府权力不能垄断在这些问题上的话语权。普通人如果有与政府或主流社会不同的爱国主义看法,可以发表自己的意见,不会因此被当作”美奸”或其他国家的”走狗”。而且,美国是一个多元民族文化的国家,爱国主义比较容易与文化民族主义区别开来,不容易被民族文化主义所限制或绑架。在美国,爱国主义与民族主义也是有区别的。法国总统戴高乐说过,在爱国主义那里,爱护自己国家的人民是第一位的；在民族主义那里,仇恨其他国家和其他国家的人是第一位的。美国的爱国主义里很少混杂戴高乐所说的那种仇恨性的民族主义。</p></blockquote><p>那么问题来了，国内现在究竟是爱国主义，还是民族主义呢？</p><hr><blockquote><p>冯小刚在微博里说,”我是觉得这么多年一部接一部地拍电影,没有其他的生活。在一个特别窄的胡同里,我长跑,还不是短跑。你怎么跑,你感觉两边都是这么一个墙,越跑越窄,越跑越窄。”他是个会说话的人,一句话同时说给两种不同的人听,让他们各自听出自己想要的意思。你可以认为他是在抱怨拍电影太辛苦,以至于”没有其他的生活”；你也可以认为他是在抱怨有”墙”不让他自由奔跑,以至于他电影生涯逼仄,只有辛苦而无乐趣。</p></blockquote><p>好的电影都在上个世纪拍完了，国内电影拍摄在两千年后是逐渐退步的。<br>或者说，所有的艺术在国内基本都是在退步的？电影、电视剧、音乐、动画这些，虽说过去的回忆有同年加成，但后来者无法居上也是不争的事实。例如新白之后再也没有更好的《白娘子传奇》了，电视剧的发展更是相当迷惑，完全看不懂粉圈喜欢的电视剧。</p><hr><blockquote><p>人们往往从现代社会工作压力大、人际交往频繁、信息更新流通速度快等实用原因来解释”离不开手机”的现象,而忽视了一个非常重要的心理因素——无聊。</p></blockquote><p>是的，吾辈一天玩手机的时间超过两个小时，工作日最长甚至会达到四个小时。</p><hr><blockquote><p>一般来说,有三种无聊,都与难以集中精神注意力有关。一、被阻止去做想做的事情；二、不得不去做不想做的事情；三、没有明确原因,只是对任何事情都没有兴趣,不想去做。一种或不止一种的无聊会让人觉得空虚、抑郁、百无聊赖。无聊不仅是一种此时此刻的心情,而且还是一种对生活状态的看法和生存环境的感受。无聊使人感觉到沉闷、压抑、无可作为、没有出路或希望,因而也焦虑、冷漠、忧虑、不安,甚至惶惶不可终日。人们经常把无聊与太多的闲暇、无所事事、缺乏审美兴趣联系在一起,但是,工作和做事并不一定就是解除无聊的良药。许多的工作对人对有异化作用,人变成了完成某种工作任务的工具。这样的工作机械乏味、没有意义,更让人觉得无聊。</p></blockquote><p>所以吾辈总是说：“没有变化就是在等死”，而等死它好么？它不好。工作如果一直做自己不感兴趣的或不能做自己感兴趣的事情的话，那么离开便是唯一的选择了。</p><hr><blockquote><p>人们从自己以往的经验发现,再怎么求也不会起作用,所以天大的事也只好忍受,不再有所要求或希望。在心理学里,这叫”习得性无助”（learned helplessness）。</p></blockquote><p>这与现在基本放弃希望混吃等死的咸鱼思想不谋而合，既然卷不过别人，政府也不顾及一般人的死活，那么我为什么还要继续卷下去呢？作为一个加害者和受害者的身份。</p><hr><blockquote><p>如果一个人总是在一项工作上失败。他就会在这项工作上放弃努力。甚至还会因此对自身产生怀疑,觉得自己”这也不行,那也不行”,彻底无望。典型的例子是,学习成绩经常不好的学生会怪自己”天生就笨”,所以不再努力；经常失恋的人会责备自己”天生令人讨厌”,所以干脆放弃找对象的打算。他们都是因为有屡屡受挫的经验,所以陷入了无为无助的绝望之中。</p></blockquote><p>所以需要做一些有趣的事情，恢复信心，建立信心。吾辈在 joplin 周边生态上的建设便是如此了。<br>而且，新的一年，新的开始，一切都可以从零算起了呢！</p><hr><blockquote><p>知识分子用”新理论”来粉饰和淡化统治者自己都不好意思否认的以往错误,这是一种非常巧妙的”光天化日之下献媚讨好”,既献媚讨好,又显得不失自己的”学者”身份。例如,把”文革”时的”忠字舞”说成是相当于今天跳迪斯科的”大众文化”。毛泽东说的文革每 5 年搞一次,被说成是相当于”定期的民主选举”。这是一种非常犬儒的学术话语把戏和游戏。</p></blockquote><p>哈，总是有人会这样做呢，一本正经的胡说八道，不外如是。</p><hr><blockquote><p>不同的国家有不同的国情,公共知识分子的专业造诣、职业特征和公共活动方式也会有很大的不同。中国大学教授受体制的限制比美国大,升等评级、决定科研项目的权利掌握在领导和人事部门手里,教授被逼着在自己的一亩三分地里小心耕作,巴望着能出一些符合体制规定的”成果”,所以容易变得思想狭隘,目光短浅,心灵猥琐,浅薄弱智。他们既不能成为”世界的眼睛”,也不敢站在体制的边缘,扰乱它的安宁。</p></blockquote><p>对上级负责而不是事情负责，上下五千年的老传统了。<br>一般（小）公司 996 的形式主义大于实际效益，任何能够量化的事情想想办法总是能够完成，加班未必就是在忙实际负责的事情。话虽如此，这也确实将人局限在公司，严重减小了交际面，绝非长久可为之计。</p><hr><blockquote><p>“文革”中盛行言辞激烈、慷慨激昂的”革命歌曲”或”诗朗诵”,运用的就是这种非说理话语,形成了具有中国特色的”标语体”写作。例如,”东风吹战鼓擂,现世界上究竟谁怕谁?不是人民怕美帝,而是美帝怕人民, 得道多助失道寡助,历史的规律不可抗拒,不可抗拒……”标语体写作是口号式思维的产物,二者相辅相成。</p></blockquote><p>太尬了，让吾辈想到去年的“武汉加油”与“山川异域，日月同天”的事情了。– 历史不会重演，它只会押韵。</p><hr><blockquote><p>“文革”高潮时期,人们说话都必须以”毛主席教导我们”开始,说上一段语录,然后才言归正传,这是正确的说话规范。王小波在《沉默的大多数》一文中写道:”古代和近代有两种方法可以壮我的胆。古代的方法是,文章要从‘夫子曰’开始。近代的方法是从‘毛主席教导我们说’开始。”所谓”壮胆”,也就是必须这么说才能被别人接受,才不至于出错,因为这就是”规范”.</p></blockquote><p>沉默的却是永远都是大多数，就像互联网上的幽灵一样，仅仅消费而不生产内容。另外，吾辈只听说过【吴晓波】</p><hr><blockquote><p>心理学研究早就归纳了人的七种性格缺陷,它们分别是,一、自我贬损（Self-Deprecation）:自甘下流、唾面自干；二、自暴自弃（Self-Destruction）:自我糟践、自我伤害；三、受害者心结（Martyrdom）:老觉得别人在算计和迫害自己；四、顽固和一意孤行（Stubbornness）:拒绝改变自己；五、贪得无厌（Greed）:自我放纵、欲壑难填；六、狂妄自大（Arrogance）:老子天下第一,谁也说不得；七、极不耐烦（Impatience）,像是谁都在跟自己作对,跟自己有仇。这七种性格缺陷在当今中国都不陌生,而其中的自我贬损则直接与一些人在人格上无自尊的”下流化”有关。</p></blockquote><p>躺枪 * 2 <em>(:з)∠)</em></p><hr><blockquote><p>我因此想到读过的一篇博文《生活就像被强奸一样,既然不能反抗,那就好好享受吧》。</p></blockquote><p>生活就是这么糟糕，那么吾辈还是做条安静的咸鱼，躺平吧！<br>话虽如此，面对现实环境，能做的无非就是三件事</p><ol><li> 改变自己</li><li> 改变世界</li><li> 离开这儿</li></ol><p>其中，改变自己，做个安静的咸鱼显然是最容易实现的呢</p><hr><blockquote><p>颓废与沉默:透视犬儒文化</p></blockquote><p>看完了这本书，这是在看了两本这种哲学类型的书之后，终于碰到一本感兴趣的了。里面真是描绘了当下国内的各种问题啊。而且旁征博引，引用了许多现实示例。<br>另外，这本书似乎已然绝版了。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://blog.rxliuli.com/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="读书" scheme="https://blog.rxliuli.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-在渲染、主进程间共享数据</title>
    <link href="https://blog.rxliuli.com/p/db74e6e5d2444bc3b6e185a7b338bbf6/"/>
    <id>https://blog.rxliuli.com/p/db74e6e5d2444bc3b6e185a7b338bbf6/</id>
    <published>2021-03-02T02:39:22.000Z</published>
    <updated>2021-03-01T17:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候我们需要在主进程和渲染层共享某些数据，而 <a href="/p/6e778ce220e042a0902e7a85976e7e47">electron ipc 通信</a> 显然更适合传递消息而不适合共享数据。</p><h2 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h2><p>事实上，我们这个需求已经有人考虑过了，例如 electron-store 就已经实现了可以在渲染层、主进程均可使用。</p><ul><li><a href="https://www.npmjs.com/package/is-electron">is-electron</a>: 判断是否 electron 环境</li><li><a href="https://www.npmjs.com/package/electron-store">electron-store</a>: 在 electron 应用中存储数据</li></ul><p>那么，我们直接用 electron-store 有什么问题么？<br>是的，electron 仅能在 electron 中使用，所以在浏览器上会报错，而这对于开发环境而言是无法接受的，故而还需要检测环境使用不同的实现。</p><h2 id="创建浏览器兼容层"><a href="#创建浏览器兼容层" class="headerlink" title="创建浏览器兼容层"></a>创建浏览器兼容层</h2><p>使用策略模式实现不同环境下使用不同的存储</p><ul><li>浏览器使用 localStorage 实现</li><li>electron 中则使用 electron-store 实现</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> Store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron-store&quot;</span>;<br><span class="hljs-keyword">import</span> isElectron <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;is-electron&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; DeepReadonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;utility-types&quot;</span>;<br><br><span class="hljs-keyword">interface</span> BaseStore &#123;<br>  get(key: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStoreImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> store: Store;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> Store = <span class="hljs-built_in">window</span>.require(<span class="hljs-string">&quot;electron-store&quot;</span>);<br>    <span class="hljs-built_in">this</span>.store = <span class="hljs-keyword">new</span> Store();<br>  &#125;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.store.set(key, value);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.store.get(key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalStorageImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">localStorage</span>.getItem(key);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">localStorage</span>.setItem(key, value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;ElectronStore.store&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> [symbol]: BaseStore = isElectron()<br>    ? <span class="hljs-keyword">new</span> ElectronStoreImpl()<br>    : <span class="hljs-keyword">new</span> LocalStorageImpl();<br><br>  <span class="hljs-keyword">static</span> getInstance&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt;(<br>    init?: Partial&lt;T&gt;<br>  ): Partial&lt;&#123; [P <span class="hljs-keyword">in</span> keyof T]: DeepReadonly&lt;T[P]&gt; &#125;&gt; &#123;<br>    <span class="hljs-keyword">const</span> electronStore = <span class="hljs-keyword">new</span> ElectronStore();<br><br>    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, &#123;<br>      get(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(p);<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(text);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;,<br>      set(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">boolean</span> &#123;<br>        electronStore[symbol].set(<br>          p,<br>          value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-literal">null</span> ? <span class="hljs-built_in">JSON</span>.stringify(value) : value<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (init) &#123;<br>      <span class="hljs-built_in">Object</span>.entries(init).forEach(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(k);<br>        <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>          proxy[k] = v;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> proxy;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能发现了，为了简化使用的 API，这里使用了代理模式拦截了对实例的访问，修改为使用 <code>get/set</code> 方法取值和设值。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来和一个普通的对象没什么区别，直接通过 <code>.</code> 访问或设置属性即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> userStore = ElectronStore.getInstance&lt;&#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> &#125;&gt;();<br>userStore.name = <span class="hljs-string">&quot;liuli&quot;</span>;<br><span class="hljs-built_in">console</span>.log(userStore.name === <span class="hljs-string">&quot;liuli&quot;</span>);<br>userStore.age = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(userStore.age === <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>具体代码在 <a href="https://github.com/rxliuli/electron_example/blob/ed158e9d013d7138697c76b52ddefb4748fe1af0/libs/electron-util/src/ElectronStore.ts#L40">electron_example</a>，由于是一个浅层封装，所以并未发布，但可以直接将模块复制到项目中使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>2020 吾辈在公司推动的前端技术演进</title>
    <link href="https://blog.rxliuli.com/p/06cb464179cf45c598208534705aae3c/"/>
    <id>https://blog.rxliuli.com/p/06cb464179cf45c598208534705aae3c/</id>
    <published>2021-02-26T23:39:54.000Z</published>
    <updated>2021-03-13T18:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上古时期"><a href="#上古时期" class="headerlink" title="上古时期"></a>上古时期</h2><blockquote><p>吾辈来的时候已然不多，但部分 mobile 嵌入的静态页面仍然是这种形式</p></blockquote><p>后端模板（JSP/FreeMarker）+ 前端静态 HTML 页面。那是个前端开发非常卑微的时代，除了还原 UI 和兼容性之外，所有业务逻辑、路由跳转、状态管理、部署维护都由后端包办完成。前端能做的事情非常有限，UI 还原、CSS 样式以及浏览器兼容性（例如传统前端需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧）是所需的关键技能点，或许还要负责 UI 相关的任务。但这其中，<strong>许多更偏向于「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值</strong>。</p><blockquote><p>参考: <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a><br>CSS 不是正交的，所以很麻烦，参考: <a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>问题</p><ul><li>难以应对大规模的项目开发，几乎没有工程化可言</li><li>前后端耦合导致修改、发布困难（就我们公司有个 gw 项目就是反例）</li><li>前端能做的事情非常有限，几近是后端的附属（App 有趣的一点就是极大的增强了客户端的能力，许多独立 App 开发者的工具类产品可能对后端的依赖极少）</li></ul><h2 id="跨入现代前端-vue-webpack"><a href="#跨入现代前端-vue-webpack" class="headerlink" title="跨入现代前端: vue + webpack"></a>跨入现代前端: vue + webpack</h2><ul><li>框架: vue</li><li>项目组织: git 分支 + 目录</li></ul><blockquote><p>在吾辈进来的时候基本是这样的</p></blockquote><p><img src="/resource/35bfc5fb414946209bf6cfeb33755e83.png" alt="1614382963380"></p><p>无论如何，前后端分离都已然是大势所趋，公司的项目也不例外，也从 jq 升级为了 vue。vue 是一个及其新手友好的框架，官方文档在前端开源框架中无出其右，所以选择它对招聘确实有一定的帮助（准入门槛低）。</p><p>但这里确实存在一些问题，主要如下</p><ul><li>vue 和 ts 结合的不好，所有前端项目，不是已经用了 ts，就是在走向 ts 的路上（去年 vue3 选择使用 ts 重写 v3）<ul><li>这是一个设计失误，因为 vue 作者更相信另一个 facebook 的静态类型脚本语言 flow.js，但它最终失败了</li></ul></li><li>vue 不是一个创新者，更像是一个现有技术的整合者，更新相比于 react v17/angular v11 慢得多（v3）</li><li>vue 和 ant design 结合的不好，因为蚂蚁金服使用 react 实现，vue 版本并非官方实现（关于这个 UI 框架的选择其实令吾辈有些困惑）</li><li>项目组织方面使用 git 分支 + 目录的形式可能是模仿了后端，但由于目录之间并非模块的形式加上 git 没有规范可言导致没有利用本地模块的优势反而只有劣势</li><li>有些项目使用原生 webpack 进行配置打包，而这实际上非常难以维护，参考: <a href="https://zhuanlan.zhihu.com/p/32148338">webpack 为什么这么难用？</a></li></ul><blockquote><p>典型项目: 前端旧项目</p></blockquote><h2 id="静态类型-引入-typescript"><a href="#静态类型-引入-typescript" class="headerlink" title="静态类型: 引入 typescript"></a>静态类型: 引入 typescript</h2><ul><li>语言: typescript</li><li>项目组织: 分散的 git 项目</li></ul><p>由于使用目录+分支管理的项目组织非常麻烦，所以后面的一些项目采用了每个业务创建一个 git 项目，然后最终将之打包整合到官网（其实就是不同的子路由），独立每个项目的开发和部署。而后希望通过 ts 的静态类型增强前端开发的效率及开发体验（主要是 IDE 在提示、重构和导航方面的支持），所以将之引入了进来，吾辈有自信可以解决任何遇到的 ts 问题。</p><p><img src="/resource/16eb9eef10704ee49b7097e04bf8344f.png" alt="1614383048466"></p><p>但老实说，问题仍然没有完全解决</p><ul><li>ts 和 vue 2 结合的不好，甚至 vue 3 中 ts 也没能解决模板层面的问题，参考: <a href="https://github.com/JetBrains/web-types/issues/15">web-types 讨论</a></li><li>分散的 git 项目之间如果存在相同代码，比较难以共享（但因为有 npm 私服所以还不太明显）</li><li>组件粒度较粗，比较小的组件难以抽取</li></ul><blockquote><p>典型项目: 新管理后台</p></blockquote><h2 id="替换框架为-react"><a href="#替换框架为-react" class="headerlink" title="替换框架为 react"></a>替换框架为 react</h2><p>事实上，引入 react 没有 ts 那么安全，因为这次吾辈不能说<strong>吾辈有自信可以解决任何遇到的 react 问题</strong>，因为吾辈也没有实际生产环境的经验。但吾辈仍然引入了，有以下几个考量</p><ul><li>更好的结合 ts 使用</li><li>直接使用官方维护的 ant design for react 版本</li><li>相比于 vue 好得多的 IDE 支持</li><li>更好的开发大型项目（报告系统）</li><li>尝试变化，使用最新的技术</li></ul><p>但这仍然并非终点，在报告系统项目中，单个前端项目的代码量首次达到了 2w+ 行（至今已到 4w+），分割模块势在必行，这里就提到了需要使用到 lerna 了。</p><blockquote><p>典型项目: 公开图库</p></blockquote><h2 id="引入-lerna-以使用-monorepo"><a href="#引入-lerna-以使用-monorepo" class="headerlink" title="引入 lerna 以使用 monorepo"></a>引入 lerna 以使用 monorepo</h2><ul><li>项目组织: monorepo</li></ul><p>Java 后端的项目天然是 monorepo（因为 maven 的原因），而前端在很长时间内都没有类似的工具，直到吾辈遇到了 lerna。这点某位离职的同事有曾提及，但直到几个月后报告系统第一版基本结束时进行重构才真正实用。<br>使用它吾辈改进了以下几点问题</p><ul><li>使用 monorepo 更好的组织模块，保证项目在超过 4w 行代码、20 个模块时仍然保持可维护性</li><li>更简单的共享和复用代码，只要抽离一个模块即可在所有模块直接引用它了</li><li>更加容易统一整个项目的技术栈，引入一个依赖的不同版本几乎不可能出现了</li><li>更加容易容易统一项目的配置，保证整个项目的代码风格都是一致的（例如 eslint/prettier）</li></ul><p><img src="/resource/81950aa48e2b4885b3be6ade3c3d745b.png" alt="1614383172095"></p><blockquote><p>典型项目: 旧版报告系统</p></blockquote><h2 id="引入-gh-pages-简化打包"><a href="#引入-gh-pages-简化打包" class="headerlink" title="引入 gh-pages 简化打包"></a>引入 gh-pages 简化打包</h2><p>事实上，生产环境的发布一直非常麻烦，即便建宏已经实现了两版的发布系统，但目前使用体验仍然不算好（gw 项目必须要用），但前后端分离的项目却不尽然。后来在一个偶然的情况下，吾辈发现了一种更高效的方式: <a href="/p/32a5980cdf284cf2b107a3ee04ff71f4">使用 gh-pages 发布前端项目</a>，同时喜获冰淇淋一个。</p><blockquote><p>当然，由于后来主要在开发 electron 客户端，web 项目在生产环境的发布变得较少，但这件事仍然证明只要将现有的工具整合起来，仍然可能极大的提高生产力</p></blockquote><p><img src="/resource/456f8dc4b70f4acea94b7351a9a23f69.png" alt="1614383397001"></p><blockquote><p>典型项目-大屏看板</p></blockquote><h2 id="rushstack-标准化的前端-monorepo"><a href="#rushstack-标准化的前端-monorepo" class="headerlink" title="rushstack: 标准化的前端 monorepo"></a>rushstack: 标准化的前端 monorepo</h2><ul><li>项目组织: lerna monorepo =&gt; <a href="https://rushstack.io/">rushstack</a></li></ul><p>虽然 lerna 可以分割模块，但它并没有所谓的最佳实践，事实上，吾辈在微软的 monorepo 工具 rush 的相关项目 rushstack 中找到了一种最佳实践，在形式上有许多参考价值（虽然由于大而全且包含许多问题的原因导致没有 lerna 使用广泛），最新的两个生产项目均已重构成这种形式的 monorepo 项目，稍晚一些会将它们合并，便于之后它们的整合。</p><p><img src="/resource/57039ed47d574e088cc572d68ec6fad7.png" alt="1614431686700"></p><p>在 rushstack 的介绍中有这么一段话非常有趣：<br>灵活性有其缺点。Node.js 工具因其令人困惑的选项而臭名昭著：选择您的编译器、linter 工具、打包工具、包管理器、任务引擎、单元测试工具、测试断言库等。一旦决定（<strong>下了赌注</strong>），整合所有这些组件就变成了自己的软件项目。随着规模的扩大，这些成本可能会迅速增加！<br>核心就是前端定制需求过多，要求工具链非常灵活，进而导致无法标准化（和现在的报告系统业务面临的问题多么相似。。。）</p><blockquote><p>典型项目 miis</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="统一和规范"><a href="#统一和规范" class="headerlink" title="统一和规范"></a>统一和规范</h3><ul><li>定义统一的业务目录的结构，形成约定俗成</li><li>通过更高层的 cli 抽象强制统一 <code>lib</code> 的项目结构，例如入口文件一定是 <code>lib/src/index.ts</code>，出口一定是 <code>dist/index.js</code>，而打包出来的一定默认支持 <code>esm/commonjs</code></li><li>使用 prettier+git hooks 统一项目中的代码风格</li><li>通过 syncpack 统一多个模块之间的依赖版本</li><li>通过多个模块中的 npm script，例如启动 web 项目的开发环境是 <code>start</code>，启动 electron 开发环境则是 <code>dev:win/mac</code>，打包项目是 <code>build</code>，而 <code>libs</code> 的模块打包发布是 <code>pub</code>，打包 electron 项目是 <code>pkg:*</code></li></ul><h3 id="分层和解耦"><a href="#分层和解耦" class="headerlink" title="分层和解耦"></a>分层和解耦</h3><ul><li>通过 monorepo 分割 electron 项目不同的进程，将之作为单独的 nodejs 项目和 react 项目管理和发布</li><li>通过使用 api class 的形式，将与后端的连接封装在单独的逻辑层，定义参数、返回值的类型，业务层直接引用相关的单例对象调用方法即可</li></ul><blockquote><p>吾辈也好奇现代前端框架强绑定、重 UI 层的现在，如何更好的分离 UI 与业务逻辑</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用 lerna 的 <code>--include-dependencies --stream</code> 参数尽可能按照依赖顺序并发运行命令，例如打包所有模块</li><li>为了减少安装依赖上的麻烦，尝试过 <code>nrm/yrm</code> 改源，<code>npmrc</code> 配置镜像，但最终还是要求所有前端必须能够使用 SSR+透明代理工具，否则无法启动项目</li><li>在公司 blog 上分享一些自己的心得和感触</li><li>通过使用 docsify 提升文档维护者的体验，使用 VSCode 编辑文档，然后使用 git 提交便自动部署了</li><li>引入 storybook 为通用组件编写交互式文档</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>公司前端文档: 公司的前端项目在线文档，使用 git + markdown 增强开发者编辑体验，希望更多人在更好的维护它</li><li>common-util: 前端工具库，近期使用 monorepo 将之彻底重构<br>至少优化了以下几项<ul><li>[x] 清理不需要的功能，减少了 60% 的代码</li><li>[x] 使用 monorepo 增强项目的可维护性</li><li>[x] 支持 nodejs 引入</li><li>[ ] 使用 monorepo 分割打包减小在项目中的引入成本 – babel 的 567 三个版本转变的惨剧历历在目</li><li>[ ] 找到对用户更友好的使用方式 class vs function – 面向对象 vs 函数式</li></ul></li><li>web-logger: 前端日志，已在报告系统及之后后所有的前端项目中实用，目前还未支持 nodejs</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="经验" scheme="https://blog.rxliuli.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="公司" scheme="https://blog.rxliuli.com/tags/%E5%85%AC%E5%8F%B8/"/>
    
  </entry>
  
  <entry>
    <title>实践 lerna monorepo</title>
    <link href="https://blog.rxliuli.com/p/cd66150d2b86448590fcc9bb2419c0b2/"/>
    <id>https://blog.rxliuli.com/p/cd66150d2b86448590fcc9bb2419c0b2/</id>
    <published>2021-02-23T03:03:23.000Z</published>
    <updated>2021-03-01T17:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>上古时期，前端没有工程化的概念可言，复用代码也不过是将某些 css、js 代码片段保存到笔记，需要时复制到项目中，仅此而已。参考：<a href="https://github.com/Wscats/CV/issues/29">55 个提高你 CSS 开发效率的必备片段</a>，或是 <a href="http://www.htmleaf.com/jQuery/">jquery 库</a></li><li>莽荒时代，前端出现了 nodejs 和 npm，于是一大批通用代码被发布到了 npm 平台，可以在项目中简单配置即可使用通用的库，任何人都可以简单的将代码发布到 npm。参考：<a href="https://www.npmjs.com/package/lodash">lodash</a></li><li>现代，由于前端项目的复杂度逐渐上升，所以出现了 monorepo 工具以更简单的复用代码。例如层出不穷的 monorepo 支持工具 <a href="https://lerna.js.org/">lerna</a>、<a href="https://rushjs.io/">@microsoft/rush</a>、<a href="https://yarnpkg.com/features/workspaces">yarn 2</a>、<a href="https://pnpm.js.org/en/workspaces">pnpm</a>、<a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><blockquote><p>自去年 10 月开始，吾辈使用 lerna 重构个人和公司的项目，以应对愈加复杂的前端项目。</p></blockquote><h2 id="为什么需要-monorepo？"><a href="#为什么需要-monorepo？" class="headerlink" title="为什么需要 monorepo？"></a>为什么需要 monorepo？</h2><blockquote><p>借用一下 lerna 官网的简介：</p><p>将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。</p><p>为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel、 React、Angular、Ember、Meteor、Jest 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。</p></blockquote><p>你可能会认为除了大型开源项目之外，monorepo 对于小型项目和生产环境的业务项目没有太多价值。但这是错的，前者我在微型工具库 <a href="https://github.com/rxliuli/liuli-util">liuli-util</a> 上进行了实践，确定了它对于维护和使用确实有帮助。而后者，甚至出现了专门为业务项目的 monorepo 工具 <a href="https://rushjs.io/pages/intro/why_mono/">@microsoft/rush</a>，微软在 <a href="https://github.com/microsoft/rushstack">rushstack</a> 项目中大规模使用了它。</p><h2 id="为什么选择-lerna？"><a href="#为什么选择-lerna？" class="headerlink" title="为什么选择 lerna？"></a>为什么选择 lerna？</h2><p>那么，有了这么多 monorepo 工具，为什么我们选择 lerna？</p><ul><li><a href="https://lerna.js.org/">lerna</a></li><li><a href="https://rushjs.io/">@microsoft/rush</a></li><li><a href="https://yarnpkg.com/features/workspaces">yarn 2</a></li><li><a href="https://pnpm.js.org/en/workspaces">pnpm</a></li><li><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><p>其实，除了 lerna 与 @microsoft/rush 之外，其它竞争对手都是包管理器，仅仅只是提供了 workspace 的工作空间，并未提供更高级功能。</p><blockquote><p>lerna 和 @microsoft/rush 的 npm 趋势对比参考: <a href="https://www.npmtrends.com/lerna-vs-@microsoft/rush">https://www.npmtrends.com/lerna-vs-@microsoft/rush</a></p></blockquote><p>下图是一个对比</p><table><thead><tr><th>对比项</th><th>lerna</th><th>@microsoft/rush</th></tr></thead><tbody><tr><td>star</td><td>26,824</td><td>2,392</td></tr><tr><td>周下载</td><td>1,155,241</td><td>100,386</td></tr><tr><td>使用者</td><td>知名开源项目</td><td>微软系产品</td></tr></tbody></table><p>就吾辈的实际使用体验而言，相比于 lerna，rush 默认包含了更多的东西，而非通过组合一系列可选的工具支持，这增长了相当的门槛。</p><p>下面是吾辈对其的一些认知过程</p><ul><li>rush.js 是真的感觉很【专业】，限定了很多很多东西</li><li><a href="https://rushjs.io/pages/maintainer/setup_policies/">https://rushjs.io/pages/maintainer/setup_policies/</a></li><li>像是这里，通过 allowedPackagesPolicy 的方式对 team 中所有开发人员都可以直接引入新的 npm 包做出了限制</li><li>唉，rush 比 lerna 复杂多了，做了很多很多的预定义的事情，这就意味着，它对项目维护者（而非开发者）的要求更高</li><li>和 ide 没完全集成真痛苦.JPG</li><li>吾辈总算明白这些配置为什么是【推荐配置】而不是【默认配置】了，引发的错误太多了（毕竟 npm 包很多并不规范）</li><li>rush monorepo 的一个问题是，某些包总喜欢强制指定依赖包的特定版本（例如 react-scripts），而 rush 总是“聪明”的仅安装最新的，导致添加的项目莫名其妙的炸掉</li><li>吾辈的锅，它在最后给了方法 <a href="https://rushjs.io/pages/advanced/installation_variants/">https://rushjs.io/pages/advanced/installation_variants/</a></li><li>但一整个进阶主题都是在处理这个问题。。。</li><li>算了，吾辈放弃了，rush + pnpm 感觉上维护配置成本太高了，滚回 lerna + yarn 了</li></ul><blockquote><p>rush 在功能、目标和文档方面更好，但现阶段而言还是 lerna 更成熟。</p></blockquote><h2 id="lerna-是什么？"><a href="#lerna-是什么？" class="headerlink" title="lerna 是什么？"></a>lerna 是什么？</h2><p>简而言之，Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。可以在一个项目中创建多个模块（基本上模块也可以认为是一个项目），并且可以在本地的模块之间互相关联。</p><p>lerna 项目的基本结构如下</p><p>生产项目</p><ul><li>根目录<ul><li><code>apps</code>: 生产项目<ul><li><code>app-1</code></li><li><code>app-2</code></li></ul></li><li><code>libs</code>: 通用模块<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><p>开源库</p><ul><li>根目录<ul><li><code>libs</code>: 模块根目录<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><blockquote><p>目录的名字灵感来源于 <a href="https://github.com/microsoft/rushstack">rushstack</a></p></blockquote><h2 id="使用-lerna-的优点"><a href="#使用-lerna-的优点" class="headerlink" title="使用 lerna 的优点"></a>使用 lerna 的优点</h2><blockquote><p>其中部分优点是 monorepo 固有的优势，但也有 lerna 独有的功能。</p></blockquote><ul><li>更容易抽离公共代码: 模块之间可以互相引用并且即时生效</li><li>更容易统一<ul><li>项目配置: <code>tsconfig.json/prettier.json/git hooks</code></li><li>管理和发布一系列包: <code>lerna publish</code></li><li>修改依赖立刻生效: <code>lerna bootstrap</code></li><li>依赖版本: 和默认合并不同版本的依赖</li><li>文档生成和合并: <code>fliegdoc</code></li><li>代码风格: <code>prettier/git hooks</code></li><li>在一个模块运行另一个模块的命令: <code>lerna run &lt;cmd&gt; --scope &lt;pkg&gt;</code></li><li>打包工具和流程: 封装更适合项目的打包 cli</li></ul></li></ul><p>目前稍微大点的开源项目不是已经转为了 lerna monorepo，就是已经在转换的路上（很像最近流行的使用 typescript 重构库）。包括但不限于以下这些：</p><p><img src="/resource/24e42e4188d24083b7ecf647048793f3.png" alt="1614158368615"></p><blockquote><p>吾辈目前使用的笔记工具 Joplin 也在去年使用 lerna 重构了，参考：<a href="https://github.com/laurent22/joplin/pull/4039">Lerna migration</a>。</p></blockquote><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="根据依赖图并行运行-npm-命令"><a href="#根据依赖图并行运行-npm-命令" class="headerlink" title="根据依赖图并行运行 npm 命令"></a>根据依赖图并行运行 npm 命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lerna run &lt;npm script&gt; --include-dependencies --stream<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://github.com/lerna/lerna/blob/main/commands/run/README.md#--stream">–stream</a> 和 <a href="https://github.com/lerna/lerna/blob/main/core/filter-options/README.md#--include-dependencies">–include-dependencies</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 lerna 虽然会增加一些复杂度，但带来的优点仍然是超过缺点的。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>blog 评论系统推荐</title>
    <link href="https://blog.rxliuli.com/p/d85bf515106f437b8dfe59ae27b8a999/"/>
    <id>https://blog.rxliuli.com/p/d85bf515106f437b8dfe59ae27b8a999/</id>
    <published>2021-02-21T01:51:27.000Z</published>
    <updated>2021-02-21T02:37:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>长期以来，吾辈通过 RSS 阅读各种 blog，想要评论时却发现很麻烦，所以来推荐一下 blog 的评论系统。</p><p>评论系统大概有如下几种形式</p><ul><li>基于第三方评论服务</li><li>输入名字邮箱即可发表评论</li><li>注入博客用户才可以发布评论（没怎么用过，不予置评）</li></ul><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><p>基于第三方评论服务这里选择的是吾辈目前正在使用的 disqus，而评论选择是某位博主的评论系统。</p><p>两者截图如下</p><p><img src="/resource/7a30349574774784bd3652275e86b6f1.png" alt="基于第三方评论服务"><br><img src="/resource/4835d7ba3ae24f8fa176e25a0541dcd9.png" alt="输入名字邮箱即可发表评论"></p><table><thead><tr><th>对比项</th><th>基于第三方评论服务</th><th>输入名字邮箱即可发表评论</th></tr></thead><tbody><tr><td>UI 对比</td><td>标准 UI</td><td>与网站更契合的比较萌的 UI</td></tr><tr><td>账户系统</td><td>需要注册 disqus</td><td>不需要账号</td></tr><tr><td>修改/删除评论</td><td>是</td><td>否</td></tr><tr><td>需要代理</td><td>是</td><td>取决于博客的部署方式</td></tr></tbody></table><p>就吾辈个人而言，最不能忍受的是无法修改评论，即使存在一些错误，例如截图中吾辈的评论中就有一个错别字，但却无法修改。而另一方面，disqus 的 UI 确实不可能和网站整体风格完全一致，这也是自定义博客评论系统更强大的地方。但老实说，相比于 UI，吾辈更在意的是功能性，disqus 已经有许许多多的人注册过，所以有天生的用户群。至于代理的问题，吾辈找不到好的解决方案，国内的类似产品，不是已经死了（多说），就是已经变成垃圾。</p><blockquote><p>实际上代理的问题还是有办法的，虽然还是有点麻烦。参考：<a href="https://blog.fooleap.org/use-disqus-correctly.html">科学使用 Disqus</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021 读书计划</title>
    <link href="https://blog.rxliuli.com/p/c6c709f7b7594e7e999ca24e5afee060/"/>
    <id>https://blog.rxliuli.com/p/c6c709f7b7594e7e999ca24e5afee060/</id>
    <published>2021-02-20T01:07:28.000Z</published>
    <updated>2021-02-21T01:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>由于受到 <a href="https://blog.k8s.li/2020-booklist.html">木子(读书机器人)</a> 的影响，所以吾辈打算 2021 读更多的书，希望能达到以下几个目标。</p><ul><li>将读书变成一个习惯</li><li>提升自己的认知</li><li>学习更多计算机基础知识</li><li>坚持读比较难读的书</li></ul><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><ul><li>这就是投资人</li><li>这就是保险代理人</li><li>TCP 详解（1）</li><li>网络是怎么连接的</li><li>论人类不平等的起源</li><li>规模</li><li>爆裂</li><li>原则</li><li>金字塔原理</li><li>上帝造人有多难</li><li>大学之路</li><li>女士品茶</li><li>增长的极限</li><li>被讨厌的勇气</li><li>来自新世界</li><li>异类</li><li>宇宙-从起源到未来</li><li>修改代码的艺术</li><li>解忧杂货铺</li><li>朝花夕拾</li><li>地铁</li><li>家有女友</li><li>神雕侠侣</li><li>数学女孩</li><li>什么是数学</li><li>SICP 计算机程序的构造和解释</li><li>算法 4(在读)</li></ul><blockquote><p>读书历史将在 <a href="https://blog.rxliuli.com/about/">关于页面</a> 更新。</p></blockquote><h2 id="实行"><a href="#实行" class="headerlink" title="实行"></a>实行</h2><p>在上下班通勤、中午以及晚上回去时多读点书（当然还是不能影响休息），反正读书总比将时间浪费在 Youtube、小说、游戏上要好，不是么？</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>立个 Flag，今年入坑 Kigurumi 并出一次漫展</title>
    <link href="https://blog.rxliuli.com/p/78d7cae2e92e4e518b2aa89337be85d8/"/>
    <id>https://blog.rxliuli.com/p/78d7cae2e92e4e518b2aa89337be85d8/</id>
    <published>2021-02-19T03:56:07.000Z</published>
    <updated>2021-03-12T03:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Kigurumi 是什么？能吃么？</li><li>是一种 cosplay 服装扮演，不能吃谢谢。</li></ul><p>借用 <a href="https://en.wikipedia.org/wiki/Animegao_kigurumi">Wiki</a> 中的描述：“人偶扮演（着ぐるみ Kigurumi ?），是一种透过穿着类似 吉祥物服装的全身套装以在现实世界中达成还原卡通或动漫人物的 cosplay 形式。和 cosplay 不一样的是，表演者的脸会被 面具完整的包住，所穿着的服装也会掩盖住全身，借此表演者得以完全隐藏自己原本的身份，完全成为所要扮演的角色。早年 Kigurumi 只会出现在舞台秀上，近年来则逐渐变成 cosplayer 的一种扮演模式。在日本，这种形式的角色扮演又被称为是アニメ顔（中文：动漫颜），但一直以来都只有少数的玩家参与其中。约在 2005 年后，Kigurumi 慢慢地在各个国家和地区流行开来，包括中国，甚至是美国、加拿大与欧洲等地区。”</p><p>预定 cosplay 角色是 <a href="https://zh.moegirl.org.cn/zh-cn/%E6%98%A5%E6%97%A5%E9%87%8E%E7%A9%B9">春日野穹</a></p><p><img src="/resource/eca6e2291609442092bb642d71361621.png" alt="1613708879214"></p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><ul><li><a href="https://item.taobao.com/item.htm?id=35058414957">头壳</a></li><li><a href="https://item.taobao.com/item.htm?id=26710864059">Kigurumi 皮肤</a></li><li><a href="https://item.taobao.com/item.htm?id=45759058514">Kigurumi 义乳</a></li><li><a href="https://item.taobao.com/item.htm?id=45035590608">Cosplay 服装</a></li><li>其他杂费，包括但不限于鞋子、玩偶、额外材料费等</li></ul><p>预计花费 7038 软妹币，入坑门槛是真的高 XD。</p><blockquote><p>算是弥补不去吃糖的一些遗憾吧</p></blockquote><hr><h2 id="已购"><a href="#已购" class="headerlink" title="已购"></a>已购</h2><p>确定了，大概要两个月吧</p><p><img src="/resource/9d806143ded14c91838f14a0e32a9463.png" alt="1614431297462"><br><img src="/resource/939e92e7508b4b86b7c86dbf1d26ea32.png" alt="1614431308200"></p><p>暂时还未购买服装之类的东西，但这也是因为需要后续再确认一下身体尺码的参数是否正确之类的而已（另外吾辈已然有了 xd）。</p><h2 id="衣服到了"><a href="#衣服到了" class="headerlink" title="衣服到了"></a>衣服到了</h2><p>f 居然有 4 斤，看来女生确实很辛苦呢</p><p><img src="/resource/505568ee19524c2fa12a29cfe629f9a4.png" alt="1615473034848"></p><blockquote><p>由于身高问题，所以显得很小而已。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>CSS Grid 与图片共存时的布局问题</title>
    <link href="https://blog.rxliuli.com/p/5440a5dfdf654d6bbff36614afda98fc/"/>
    <id>https://blog.rxliuli.com/p/5440a5dfdf654d6bbff36614afda98fc/</id>
    <published>2021-01-27T02:36:31.000Z</published>
    <updated>2021-01-27T03:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在生产中遇到的一个 css 问题，css 不正交的问题一直有人吐槽，吾辈今天总算也是遇到了，实在是不吐不快。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>如下一个简单的二维横向图片列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  * &#123;<br>    padding: 0;<br>    margin: 0;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.rows</span> &#123;</span><br>    height: 500px;<br>    display: grid;<br>    grid-template-rows: repeat(5, 1fr);<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.cols</span> &#123;</span><br>    height: 100%;<br>    display: flex;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> &#123;</span><br>    height: 100%;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> <span class="hljs-selector-tag">img</span> &#123;</span><br>    max-height: 100%;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rows&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;items of list&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cols&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of items&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.url&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 下面是生成一些测试数据，不需要关心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/faker@5.2.0/dist/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&quot;.rows&quot;</span>,</span><br>    data: &#123;<br><span class="javascript">      list: <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>)</span><br>        .fill(0)<br><span class="javascript">        .map(<span class="hljs-function">() =&gt;</span></span><br><span class="javascript">          <span class="hljs-built_in">Array</span>(faker.random.number(&#123; <span class="hljs-attr">min</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">20</span> &#125;))</span><br>            .fill(0)<br><span class="javascript">            .map(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-keyword">const</span> getNumber = <span class="hljs-function">() =&gt;</span></span><br>                faker.random.number(&#123; min: 200, max: 300 &#125;);<br><span class="javascript">              <span class="hljs-keyword">return</span> [getNumber(), getNumber()];</span><br>            &#125;)<br><span class="javascript">            .map(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> (&#123;</span><br>              width: x,<br>              height: y,<br><span class="javascript">              url: <span class="hljs-string">`https://picsum.photos/seed/picsum/<span class="hljs-subst">$&#123;x&#125;</span>/<span class="hljs-subst">$&#123;y&#125;</span>`</span>,</span><br>            &#125;))<br>        ),<br>    &#125;,<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但显示的效果却并非预想中那样五等份，而是会超过最大高度 – 被图片撑高了。</p><p><img src="/resource/cf0f928264d2469ab22f6e4d999f6319.png" alt="1611716016173.png"></p><p>而在经过一番摸索和讨论后，吾辈找到了这个规范：<a href="https://drafts.csswg.org/css-grid/#algo-terms">https://drafts.csswg.org/css-grid/#algo-terms</a></p><p>grid 的 fr 单位实际上是个弹性值，如果内容过大，则会撑开。。。而图片的默认大小就是过大的内容。如果显式声明了最小值，就不受图片尺寸的影响了。</p><p>修改 <code>grid-template-rows: repeat(5, 1fr);</code> =&gt; <code>grid-template-rows: repeat(5, minmax(0, 1fr));</code> 就好了。</p><p>效果</p><p><img src="/resource/ad26ac5cd11b4a558ee1cdc674f942a7.png" alt="1611716716541.png"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>发明 CSS 的人就是一个智障，这么多不正交的规则纯靠经验真的太恶心了（不是每个人都了解或者说希望了解那些奇奇怪怪的规范）。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-electron 自定义协议</title>
    <link href="https://blog.rxliuli.com/p/ff86c5343d38460a8e78a62617f9eace/"/>
    <id>https://blog.rxliuli.com/p/ff86c5343d38460a8e78a62617f9eace/</id>
    <published>2021-01-11T03:18:19.000Z</published>
    <updated>2021-02-19T02:31:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候需要与其他程序进行交互时，自定义协议是一个不错的选择 – 它能在程序为启动时启动程序然后处理其它程序的动作，而这是其它解决方案，包括 HTTP 请求、共享数据库不能比的。其实日常生活中也有现成的例子，迅雷的自定义协议下载链接、BitTorrent 协议、百度网盘启动本地客户端等等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">将当前可执行文件设置为协议的默认处理程序（注册表级别）</a></p></blockquote><ol><li> 让程序保持单例启动</li><li> 设置客户端支持的协议（在 Windows 中会写入到注册表）</li><li> 处理命令行参数找到其中需要的 <code>url</code> 信息</li><li> 监听 <code>ready</code> 和 <code>second-instance</code> 事件</li></ol><h3 id="让程序保持单例启动"><a href="#让程序保持单例启动" class="headerlink" title="让程序保持单例启动"></a>让程序保持单例启动</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock">app.requestSingleInstanceLock()</a><br>注: 仅在单例模式下才能监听 <code>second-instance</code> 事件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 请求单例锁，避免打开多个 electron 实例</span><br><span class="hljs-keyword">const</span> gotTheLock = app.requestSingleInstanceLock();<br><span class="hljs-keyword">if</span> (!gotTheLock) &#123;<br>  app.quit();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置客户端支持的协议（在-Windows-中会写入到注册表）"><a href="#设置客户端支持的协议（在-Windows-中会写入到注册表）" class="headerlink" title="设置客户端支持的协议（在 Windows 中会写入到注册表）"></a>设置客户端支持的协议（在 Windows 中会写入到注册表）</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">app.setAsDefaultProtocolClient(protocol[, path, args])</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端默认支持的协议</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultProtocolClient</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> protocol: <span class="hljs-built_in">string</span></span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 注册一个默认支持打开的协议</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 开发模式下在 window 运行需要做兼容</span><br>    <span class="hljs-keyword">if</span> (<br>      process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span> &amp;&amp;<br>      process.platform === <span class="hljs-string">&quot;win32&quot;</span><br>    ) &#123;<br>      <span class="hljs-comment">// 设置 electron.exe 和 app 的路径</span><br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol, process.execPath, [<br>        path.resolve(process.argv[<span class="hljs-number">1</span>]),<br>      ]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 从命令行参数中找到 url</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment">   */</span><br>  findUrl(argv: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#123;<br>    <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.protocol&#125;</span>://`</span>);<br>    <span class="hljs-keyword">return</span> argv.find(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> regExp.test(str));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaultProtocolClient = <span class="hljs-keyword">new</span> DefaultProtocolClient(<span class="hljs-string">&quot;custom-protocol&quot;</span>);<br><br><span class="hljs-keyword">await</span> defaultProtocolClient.register();<br></code></pre></td></tr></table></figure><h3 id="处理命令行参数找到其中需要的-url-信息"><a href="#处理命令行参数找到其中需要的-url-信息" class="headerlink" title="处理命令行参数找到其中需要的 url 信息"></a>处理命令行参数找到其中需要的 <code>url</code> 信息</h3><p>添加函数 <code>handleDefaultProtocol</code> 从命令行参数中找到 url 然后处理它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理客户端支持的默认协议</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDefaultProtocol</span>(<span class="hljs-params">argv: <span class="hljs-built_in">string</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> url = defaultProtocolClient.findUrl(argv);<br>  <span class="hljs-keyword">if</span> (!url) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">await</span> dialog.showMessageBox(&#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;info&quot;</span>,<br>    message: <span class="hljs-string">&quot;window protocol 自定义协议打开&quot;</span>,<br>    detail: <span class="hljs-string">` 链接:<span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听-ready-和-second-instance-事件"><a href="#监听-ready-和-second-instance-事件" class="headerlink" title="监听 ready 和 second-instance 事件"></a>监听 <code>ready</code> 和 <code>second-instance</code> 事件</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#%E4%BA%8B%E4%BB%B6-second-instance">事件: ‘second-instance’</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">app.addListener(<span class="hljs-string">&quot;second-instance&quot;</span>, <span class="hljs-keyword">async</span> (event, argv) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(argv);<br>&#125;);<br>app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> createMainWindow();<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(process.argv);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><p>既然我们自定义协议的目的是让外部程序调用，那么如何使用外部调用就很重要了。</p><p>首先检查注册表中是否已经包含它了，操作 <em>ctrl+s =&gt; 搜索注册表 =&gt; 进入注册表 =&gt; ctrl+f 查找 <code>custom-protocol</code></em></p><p><img src="/resource/79c71d68b3af4760b30d9778e24876f1.png" alt="注册表"></p><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><p>如上图所示，可以简单在浏览器中输入 <a href="custom-protocol://test">custom-protocol://test</a> 来启动程序。</p><p><img src="/resource/90ebe2632f0f441c9c1c39bdecb1f5d3.gif" alt="自定义协议效果"></p><h3 id="nodejs-示例"><a href="#nodejs-示例" class="headerlink" title="nodejs 示例"></a>nodejs 示例</h3><p>在 nodejs 中使用 npm 包 <a href="https://www.npmjs.com/package/open">open</a> 可以轻易打开自定义默认链接。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> open <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;open&quot;</span>;<br><br>open(<span class="hljs-string">&quot;custom-protocol://test&quot;</span>);<br></code></pre></td></tr></table></figure><p>其实本质上就是拼接命令，然后执行系统命令打开 url，参考<a href="https://github.com/sindresorhus/open/blob/master/index.js">它的实现</a>。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>前端与后端的选择（个人理解）</title>
    <link href="https://blog.rxliuli.com/p/e6718c0c7fba4b84a6d3a712a6b1910b/"/>
    <id>https://blog.rxliuli.com/p/e6718c0c7fba4b84a6d3a712a6b1910b/</id>
    <published>2021-01-08T04:14:10.000Z</published>
    <updated>2021-02-19T02:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>吾辈就是一个从 Java Web 后端转到前端的人。</p></blockquote><p>吾辈今天又在看到人说 <strong>前端很简单，而且还比后端工资高</strong>，这里吾辈还是想做一些澄清的。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><ul><li>后端 A: 我发现这两年前端的工作特别好找，而且工资很高</li><li>后端 A：后端内卷太严重了。</li><li>后端 B: #无语</li><li>后端 B: 前端要会啥啊到底才能称得上前端</li><li>后端 A: 我们这边。H5+小程序 就行了</li><li>后端 A: 主要是 CSS 要能处理好。。。</li><li>后端 A: 设计做出来的东西要不能有折扣的做出来。。而不是向组件找不到妥协。。。。</li><li>后端 B：我感觉我很合适唉，虽然我没怎么做过小程序</li><li>后端 B: 有没有 Java 转前端的啊</li><li>吾辈：吾辈就是 @后端 B</li><li>吾辈：可能泥萌那是 2c 的业务，像吾辈这边偏向于 2b 的，业务和架构的复杂度相当高，事实上，吾辈这边的前端架构都已经需要微服务化了（即所谓的微前端）</li><li>后端 C：微前端</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。</li><li>吾辈: 这其实有个错觉就是，前端开发岗位多，开发人员多，就一定好找工作。Java 还不是有很多培训班为市场注入了许多后端，而 web 其实也很糟糕，因为似乎所有人都开始觉得前端只要会 vuejs 加点 html/css/js 就可以开始工作了，恰好市场这两年的缺口还很大，所以培训班其实也为市场注入了相当的人员，导致招聘很难招，工作很难找。（不过不吹不黑，吾辈确实因为转到前端发生了发生了很多变化，尤其是在开源项目方面，之前基本不做，现在嘛，有时间就会做一些 #本质原因可能还是因为前端还不够成熟吧）</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。。@吾辈</li><li>后端 D: 不是说前端比较抗骂嘛</li><li>吾辈：你什么时候产生了前端比后端工资高的错觉，就那吾辈的公司来说，前端 10-20，后端 golang 15-20，Java 18-35 (´-ι_-｀)</li><li>吾辈：另外前端技术栈迭代非常快，前后端的边界正在后移，想想之前后端还要负责模板引擎，路由，状态管理，逻辑代码，工程化方面的任务，现在，这些都成为了前端的任务，而且之前的任务 ui 还原还没少，而后端在吾辈看来的一个主要问题在于用户量不够的情况下基本没得折腾，意味着许多 idea 无法在生产环境落地，后端技术栈迭代也很慢（主要是由于风险更高以及成熟度），现在还是 Java 8，而前端，基本都是跟着版本跑（当然这会带来 js 疲劳暂且不说），生产环境吾辈已经上了 ts 4（半年之前更新的大版本）。还有一点我不确定是否是常事，一般后端似乎没有自己维护的开源项目，这很显然是没法在生产之外尝鲜新技术的，一年经验用十年，不外如是。</li><li>吾辈：另外觉得前端简单的可以看一下这一系列谈话（前后端之间的，2016 年的，现在前端更加复杂化了）<a href="/p/9970e725452b49e496324842a7e283dd">2016 年里做前端是怎样一种体验</a></li></ul><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>就吾辈个人的感觉而言，似乎许多后端还不清楚前端领域到底发生了什么，觉得前端还仅仅是 <strong>切图</strong>，而这显然是个错误。</p><p>前端近几年发展迅速，几乎可以说是日新月异，尽管可能大部分都会被扫进历史的垃圾堆，但至少能够切身参与到发展的历史进程中。而且，现在前端要解决的问题域也在发生变化，在传统前端眼里，CSS（UI 还原）和兼容性问题是最重要的，但现在，已然天翻地覆，前端本身的知识领域也在发生割裂，参考: <a href="https://css-tricks.com/the-great-divide/">大分裂</a>。</p><blockquote><p>当然在很久以前，前端也有独特的「复杂问题」，比如我刚工作那会需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧，但这类问题更偏向「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值。</p></blockquote><p>而后端，经过几十年的长足发展，已经非常完善，似乎没有太大的变化了。当然，就像 <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a> 所言，<strong>「后端是在业务方面革自己的命，使劲在平台化、中台化发展，然后把具体业务这块解放给前端」</strong>。</p><table><thead><tr><th>分类</th><th>前端</th><th>后端</th></tr></thead><tbody><tr><td>发展速度</td><td>迅速</td><td>缓慢</td></tr><tr><td>发展程度</td><td>发展中</td><td>成熟</td></tr><tr><td>试错成本</td><td>低</td><td>高（后台服务炸掉是很难被接受的）</td></tr><tr><td>知识价值</td><td>低（发展迅速带来的疲劳）</td><td>高</td></tr><tr><td>入门难度</td><td>低（学会三大件就能写）</td><td>高</td></tr><tr><td>个人成长机会</td><td>一般</td><td>低（很难有机会应用自己的轮子）</td></tr></tbody></table><blockquote><p>注：以上均为吾辈在小公司的一些体会，并不一定意味着<strong>正确</strong>。而且，前端并不一定意味着简单，也有可能是根本没有接触过复杂的应用场景。例如前端工程化、智能化、编辑器、富文本、可视化图表之类的。当然，前后端其实面临着相似的问题：在小公司很多东西并没有使用场景，低层次的工作重复十年也做不出来一个 <a href="https://juejin.cn/post/6924591257452806152/">设计稿智能生成代码 imgcook</a><br>注 2：但同时，吾辈也不得不承认两者确实在天花板上有着差异，尤其而且是在大型互联网公司（例如阿里），参考：<a href="https://blog.alswl.com/2019/07/frontend-backend-ceiling/">漫谈前后端天花板</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-自定义窗口顶栏</title>
    <link href="https://blog.rxliuli.com/p/9d55c013167a4e6d802fde969291c34b/"/>
    <id>https://blog.rxliuli.com/p/9d55c013167a4e6d802fde969291c34b/</id>
    <published>2021-01-07T00:12:44.000Z</published>
    <updated>2021-02-19T02:31:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在很多生产项目中，我们希望自定义 electron 窗口顶栏，因为它确实非常简陋。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="在渲染层实现自定义顶栏"><a href="#在渲染层实现自定义顶栏" class="headerlink" title="在渲染层实现自定义顶栏"></a>在渲染层实现自定义顶栏</h3><p>实际上，核心的代码就是添加一个为顶栏的元素添加 css 样式。在 electron 环境，有 <code>-webkit-app-region: drag;</code> 属性的元素可以拖动整个窗口。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: drag;<br>&#125;<br><span class="hljs-selector-class">.toolbar</span> &gt; * &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: no-drag;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 css 看起来有点奇怪，但这是为了避免子元素（例如关闭按钮）也可以拖动的错误。</p><blockquote><p><a href="https://www.electronjs.org/docs/api/browser-window#event-system-context-menu-windows">参考文档</a>, <a href="https://github.com/rxliuli/electron_example/blob/18a1a756e5c82e87ef1c8755a0be036b6765f04b/apps/renderer/src/components/router/component/BasicLayout.module.css#L13">参考代码</a></p></blockquote><h3 id="使用-electron-通信实现窗口的三个操作"><a href="#使用-electron-通信实现窗口的三个操作" class="headerlink" title="使用 electron 通信实现窗口的三个操作"></a>使用 electron 通信实现窗口的三个操作</h3><p>其实，electron 本身支持在渲染层暴露 <code>remote</code> 模块，但这里我们选择使用 <code>ipcRenderer/ipcMain</code> 手动实现，remote 模块因为安全原因默认被禁用了。</p><p>下面的步骤基本和 <a href="/p/6e778ce220e042a0902e7a85976e7e47">渲染、主进程通信</a> 所属一样，下面贴一些关键代码</p><p>共享类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// WindowDefine.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseDefine &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron_ipc_type&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> WindowDefine <span class="hljs-keyword">extends</span> BaseDefine&lt;&quot;WindowApi&quot;&gt; &#123;<br>  action(<span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowApi</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">action</span>(<span class="hljs-params">e: IpcMainInvokeEvent, <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> win = BrowserWindow.fromWebContents(e.sender);<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;min&quot;</span>:<br>        win.minimize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;max&quot;</span>:<br>        win.isMaximized() ? win.unmaximize() : win.maximize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>        win.close();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// BasicLayout.tsx</span><br><span class="hljs-keyword">const</span> windowApi = IpcRendererClient.gen&lt;WindowDefine&gt;(<span class="hljs-string">&quot;WindowApi&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装 electron 的窗口控制 hooks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useElectronWindowControl</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    handleMin: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;min&quot;</span>),<br>    handleMax: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;max&quot;</span>),<br>    handleClose: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;close&quot;</span>),<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/rxliuli/electron_example/tree/3aea837b0c7661e030406a0c20d306694402a26f">参考代码</a></p></blockquote><h3 id="隐藏掉默认的顶栏"><a href="#隐藏掉默认的顶栏" class="headerlink" title="隐藏掉默认的顶栏"></a>隐藏掉默认的顶栏</h3><p>实际上，只要在创建 electron 的 <code>BrowserWindow</code> 实例时配置即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>  webPreferences: &#123;<br>    nodeIntegration: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  frame: <span class="hljs-literal">false</span>,<br>  autoHideMenuBar: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在，electron 程序就有自定义顶栏啦</p><p><img src="/resource/14a1d8bbb1ca452092c384ca7cbec4c4.png" alt="1611134001681.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然自定义窗口顶栏有很多优点，但也并非尽善尽美，已知缺点如下</p><ul><li>占有了一定高度，导致一些 UI 组件的位置很奇怪，例如顶部的消息提示框和侧边抽屉，会遮挡住窗口顶栏的一部分。</li><li>可能随着系统升级与系统风格不搭，早有人吐槽过 Windows 所有程序的自定义顶栏都是不一样的高度和大小，非常丑</li><li>需要重新实现窗口菜单相关的快捷键，例如 <code>ctrl+shift+i</code> 打开开发者工具</li><li>在 mac 上需要进行特别的兼容，否则和其他程序会显得格格不入</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-开发环境优化</title>
    <link href="https://blog.rxliuli.com/p/1527b67fbd78494cb716e2db4b8fb688/"/>
    <id>https://blog.rxliuli.com/p/1527b67fbd78494cb716e2db4b8fb688/</id>
    <published>2021-01-06T23:59:34.000Z</published>
    <updated>2021-02-19T02:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-react-devtool-插件调试"><a href="#使用-react-devtool-插件调试" class="headerlink" title="使用 react devtool 插件调试"></a>使用 react devtool 插件调试</h2><!-- TODO 需要将这两个函数抽离成静态工具类 --><p>前言</p><p>虽然绝大多数时候，我们都可以也应该在浏览器调试渲染层的功能，但确实也会有需要在 electron 程序中调试的需求，这里就说明一下 electron 如何安装 chrome 插件 react devtool 调试项目。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-devtools-installer">electron-devtools-installer</a></p></blockquote><p>步骤</p><p>1、安装依赖</p><p>cd 到 <em>apps/main</em> 目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-devtools-installer @types/electron-devtools-installer<br></code></pre></td></tr></table></figure><p>2、添加环境变量 <code>&quot;NODE_ENV&quot;: &quot;development&quot;</code> 标识为开发环境</p><p>修改 <em>.env-cmdrc.json</em> 配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;NODE_ENV&quot;</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、修改 <code>main</code> 函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>      <span class="hljs-comment">// 安装 devtool 扩展</span><br>      <span class="hljs-keyword">await</span> installExtension(REACT_DEVELOPER_TOOLS);<br>    &#125;<br><br>    <span class="hljs-keyword">await</span> createMainWindow();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 <code>createMainWindow</code> 函数</p><p>一般，我们在开发环境还习惯打开控制台，这里也可以在创建窗口后自动打开它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    process.env.ELECTRON_START_URL || path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>  );<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>    mainWindow.webContents.openDevTools();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可能的错误参考: <a href="/p/76072311817b4c1985ab5746e8f91d87">常见问题</a> <strong>安装浏览器扩展报错</strong></p></blockquote><p>5、启动 electron 开发环境</p><p>启动后可以看到自动打开了控制台，然后可以看到 react devtool</p><p><img src="/resource/46612cfedc3643d98e11b1b6a4e99e1a.png" alt="实际效果"></p><h2 id="让主进程的代码也能热更新"><a href="#让主进程的代码也能热更新" class="headerlink" title="让主进程的代码也能热更新"></a>让主进程的代码也能热更新</h2><p>前言</p><p>可能你也发现了，渲染层使用 cra 创建的项目默认包含了热更新，这都要得益于 webpack HMR 技术，但主进程并非如此，即便使用 <code>tsc -w</code> 监听并编译 ts 代码，但想要生效仍然需要重启 electron，不厌其烦。幸运的是，有人已经实现了这个需求。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-reloader">electron-reloader</a></p></blockquote><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-reloader<br></code></pre></td></tr></table></figure><p>2、在主进程入口文件载入 electron-reloader</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//添加热更新功能</span><br><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron-reloader&quot;</span>)(<span class="hljs-built_in">module</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、启动 electron 开发环境</p><p><img src="/resource/2cdd0ecc96ec46e095bd132c32675521.gif" alt="效果"></p><blockquote><p>注 2: 当修改代码时，重启 electron 应用是由 electron-reloader 负责，即它不在 WebStorm 的控制之下了。<br>注 2: 目前另一个 <a href="https://www.npmjs.com/package/electron-reload">electron-reload</a> 还存在一些小问题。</p></blockquote><h2 id="使用-esbuild-优化渲染层打包性能"><a href="#使用-esbuild-优化渲染层打包性能" class="headerlink" title="使用 esbuild 优化渲染层打包性能"></a>使用 esbuild 优化渲染层打包性能</h2><blockquote><p>如果你还没有感觉到 cra 打包很慢，可以跳过这一节。</p></blockquote><h3 id="禁止-ts-babel-将代码编译为-ES5"><a href="#禁止-ts-babel-将代码编译为-ES5" class="headerlink" title="禁止 ts/babel 将代码编译为 ES5"></a>禁止 ts/babel 将代码编译为 ES5</h3><p>由于 electron 捆绑的浏览器和 nodejs 版本都比较新，所以实际上渲染层我们基本不需要 babel 转义，可以优化一些配置项。</p><ul><li><p>将 <code>browserslist</code> 设置为仅支持最后一个 chrome 版本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;browserslist&quot;</span>: [<span class="hljs-string">&quot;last 1 chrome version&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <em>tsconfig.json</em> 中的配置，将编译目标修改为 <code>ESNext</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ESNext&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-esbuild-编译-typescript-代码"><a href="#使用-esbuild-编译-typescript-代码" class="headerlink" title="使用 esbuild 编译 typescript 代码"></a>使用 esbuild 编译 typescript 代码</h3></li></ul><blockquote><p>核心依赖: <a href="https://github.com/evanw/esbuild">esbuild</a>, <a href="https://github.com/gsoft-inc/craco">craco</a></p></blockquote><p>esbuild 是一个使用 golang 编写前端打包工具，官方在性能测试中提出比现有工具快 10-100 倍。</p><p>在 cra 创建的项目中，我们可以通过 craco 将 esbuild 仅用作 ts 编译之用（不会检查类型）。</p><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D @craco/craco craco-esbuild<br></code></pre></td></tr></table></figure><p>2、修改 npm script，使用 <code>craco</code> 替换 <code>react-scripts</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;craco start&quot;</span>,<br>    <span class="hljs-attr">&quot;build:cra&quot;</span>: <span class="hljs-string">&quot;react-scripts build&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;craco build&quot;</span>,<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;craco test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产项目中的对比测试结果（6000+ 行 ts 代码）</p><table><thead><tr><th>分类</th><th>ESBuild</th><th>tsc</th></tr></thead><tbody><tr><td>无缓存</td><td>17.61</td><td>36.57</td></tr><tr><td>有缓存（运行 5 次）</td><td>15252.8</td><td>17095.2</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-使用 electron-builder 打包</title>
    <link href="https://blog.rxliuli.com/p/63f0a26fdd3743668b11410a10625c1b/"/>
    <id>https://blog.rxliuli.com/p/63f0a26fdd3743668b11410a10625c1b/</id>
    <published>2021-01-06T23:55:42.000Z</published>
    <updated>2021-02-19T02:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="/p/475d21afd2404d5ba1f71f600c44da09">基本项目搭建</a> 中，我们已经能够启动一个 electron 应用程序了（开发环境），现在来看如何将之打包为二进制程序便于分发给最终用户。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><a href="https://www.electron.build/">electron-builder</a>: 打包的主要工具库，负责这个 electron 的跨平台打包工作<blockquote><p>事实上，还有一些其它的打包工具，但目前还没有比它更好的，参考: <a href="https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager">https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager</a></p></blockquote></li></ul><h2 id="渲染层打包"><a href="#渲染层打包" class="headerlink" title="渲染层打包"></a>渲染层打包</h2><p>直接使用 cra 的打包工具即可，没什么大不了的，但确实存在一些注意事项</p><ul><li>因为 electron 在生产环境会从文件系统中加载静态资源，所以打包出来的静态资源必须支持相对路径，下面是常见的两个设置。<ul><li>必须在 <em>apps/renderer/package.json</em> 中声明 <code>&quot;homepage&quot;: &quot;.&quot;</code>，参考: <a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Building for Relative Paths</a></li><li>路由必须是 <code>hash</code> 模式</li></ul></li></ul><h2 id="主进程打包"><a href="#主进程打包" class="headerlink" title="主进程打包"></a>主进程打包</h2><p>electron-builder 打包需要以下几个步骤</p><h3 id="更新-package-json-的一些配置"><a href="#更新-package-json-的一些配置" class="headerlink" title="更新 package.json 的一些配置"></a>更新 package.json 的一些配置</h3><ol><li> 使用 package.json 中的 <code>build</code> 字段作为配置项，参考: <a href="https://www.electron.build/">https://www.electron.build/</a></li><li> electron-builder 使用 <code>main</code> 字段作为启动脚本文件</li><li> electron-builder 要求必须使用固定的版本号，意味着 electron 依赖需要指定为 <code>&quot;electron&quot;: &quot;10.2.0&quot;</code></li></ol><p>下面是一个基本的配置示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 一个非常基本的打包脚本</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;electron-builder&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;electron&quot;</span>: <span class="hljs-string">&quot;10.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.9.1&quot;</span>,<br>    <span class="hljs-comment">// electron 主进程实际上是 nodejs 环境，所以为了更好的开发体验，安装 nodejs 的类型定义</span><br>    <span class="hljs-attr">&quot;@types/node&quot;</span>: <span class="hljs-string">&quot;^12.19.12&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-comment">// 程序的唯一标识符</span><br>    <span class="hljs-attr">&quot;appId&quot;</span>: <span class="hljs-string">&quot;com.rxliuli.electron_example&quot;</span>,<br>    <span class="hljs-comment">// 打包出来的 exe 名字</span><br>    <span class="hljs-attr">&quot;productName&quot;</span>: <span class="hljs-string">&quot;electron 示例应用&quot;</span>,<br>    <span class="hljs-comment">// 打包的目录</span><br>    <span class="hljs-attr">&quot;directories&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;output&quot;</span>: <span class="hljs-string">&quot;release&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;win&quot;</span>: &#123;<br>      <span class="hljs-comment">// 打包目标，参考: https://www.electron.build/</span><br>      <span class="hljs-attr">&quot;target&quot;</span>: [<span class="hljs-string">&quot;nsis&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制静态资源"><a href="#复制静态资源" class="headerlink" title="复制静态资源"></a>复制静态资源</h3><p>现在，我们需要打包静态资源并复制到主进程模块里面</p><ol><li> <code>cd apps/renderer</code> 目录</li><li> <code>yarn build</code> 打包静态资源</li><li> 将静态资源复制到 <code>build/dist</code> 目录下</li></ol><h3 id="修改主进程入口文件-main-ts"><a href="#修改主进程入口文件-main-ts" class="headerlink" title="修改主进程入口文件 main.ts"></a>修改主进程入口文件 main.ts</h3><p>还需要修改 <em>src/main.ts</em> 代码，主要修改 BrowserWindow 对象载入的 <code>url</code> 地址</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">import</span> &#123; URL &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    <span class="hljs-keyword">new</span> URL(path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)).href<br>  );<br>&#125;<br><br><span class="hljs-comment">// 其他代码...</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，这个 url 路径是相对于打包后的 <code>dist/main.js</code> 而言的，因为最终打包的程序运行时的相对路径也是这样。</p></blockquote><h3 id="打包主进程的-exe-程序"><a href="#打包主进程的-exe-程序" class="headerlink" title="打包主进程的 exe 程序"></a>打包主进程的 exe 程序</h3><blockquote><p>因为 electron-builder 需要下载基本的 electron 程序，所以请提前设置好透明代理，如果不知道它是什么，参考: <a href="https://github.com/rxliuli/haoel.github.io#7-%E9%80%8F%E6%98%8E%E7%BD%91%E5%85%B3">透明网关</a>，<a href="http://www.proxifier.com/">Proxifier</a></p></blockquote><ol><li> 使用 <code>yarn compile</code> 编译 ts 代码</li><li> 使用 <code>yarn pkg</code> 打包 electron 应用</li></ol><p>现在，我们应该可以在 <em>apps/main/release/win-unpacked</em> 下看到 exe 程序，双击它即可看到之前在开发环境的首页了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main">https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main</a></p></blockquote><h2 id="优化打包"><a href="#优化打包" class="headerlink" title="优化打包"></a>优化打包</h2><p>虽然打包已经实现，但确实还存在一些问题</p><ul><li>打包脚本仍然不是一键的</li><li>不能兼容开发、生产环境</li></ul><p>下面我们来解决这两个问题</p><h3 id="实现一键打包二进制程序"><a href="#实现一键打包二进制程序" class="headerlink" title="实现一键打包二进制程序"></a>实现一键打包二进制程序</h3><p>使用 gulp 复制渲染层的静态资源</p><p>1、添加 gulp 相关依赖 <code>yarn add -D gulp ts-node @types/gulp fs-extra @types/fs-extra</code></p><ul><li><code>gulp @types/gulp</code>: gulp 核心依赖</li><li><code>ts-node</code>: 使用 ts 编写 gulp 脚本必须的依赖</li><li><code>fs-extra @types/fs-extra</code>: fs 的扩展增强，使用 Promise 包装异步 api</li></ul><p>2、添加 gulp 脚本文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; copy, remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs-extra&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyByMap</span>(<span class="hljs-params">copyMap: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>][]</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>    copyMap.map(<span class="hljs-keyword">async</span> ([src, destDir]) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> srcPath = path.resolve(__dirname, src);<br>      <span class="hljs-keyword">const</span> destPath = path.resolve(__dirname, destDir, path.basename(srcPath));<br>      <span class="hljs-keyword">await</span> copy(srcPath, destPath);<br>    &#125;)<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理最终生成目录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clean</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>));<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;release&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 复制一些资源到 dist 目录中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyStatic</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> copyByMap([[<span class="hljs-string">&quot;../renderer/build&quot;</span>, <span class="hljs-string">&quot;dist/&quot;</span>]]);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、添加 npm script</p><blockquote><p>注: lerna 的好处之一就是可以运行其它模块的 npm script。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 打包渲染层的静态资源</span><br>    <span class="hljs-attr">&quot;build:web&quot;</span>: <span class="hljs-string">&quot;lerna run --scope renderer build&quot;</span>,<br>    <span class="hljs-comment">// 打包渲染层的静态资源之后复制然后使用 electron-builder 打包 exe 程序</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;gulp clean &amp;&amp; yarn compile &amp;&amp; yarn build:web &amp;&amp; gulp copyStatic &amp;&amp; electron-builder&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 tsconfig.json</p><p>此时在 <em>apps/main</em> 模块根目录下也有 ts 文件了，所以 tsc 翻译代码会将它们也包含进去，但实际上不需要。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以使用一个命令打包 exe 程序了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json">https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json</a></p></blockquote><h3 id="使用环境变量来兼容开发、生产环境"><a href="#使用环境变量来兼容开发、生产环境" class="headerlink" title="使用环境变量来兼容开发、生产环境"></a>使用环境变量来兼容开发、生产环境</h3><p>解决方案简单来说就一句话：使用环境变量指定开发环境的 URL。<br>这里使用 <a href="https://github.com/toddbluhm/env-cmd">env-cmd</a> 来跨平台写入环境变量（不使用 <a href="https://github.com/motdotla/dotenv">dotenv</a> 的原因在于自定义环境使用起来有点麻烦，不像 env-cmd 那么直观），而另一个 <a href="https://github.com/kentcdodds/cross-env">cross-env</a> 并未提供管理环境变量的解决方案。下面说一下使用 env-cmd 的步骤</p><ol><li><p> 安装依赖 <code>yarn add -D env-cmd</code></p></li><li><p>添加配置文件 <em>.env-cmdrc.json</em><br> 基本上是一个键值映射文件，键是环境，值对象是环境变量</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 在 <code>dev:electron</code> 命令之前设定环境变量 <code>env-cmd -e dev electron ./dist/main.js</code></p></li><li><p>修改 <em>src/main.ts</em> 读取环境变量</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> mainWindow.loadURL(<br>  process.env.ELECTRON_START_URL ||<br>    path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>现在，像 <a href="/p/475d21afd2404d5ba1f71f600c44da09">基本项目搭建</a> 中 <strong>更新 <em>package.json</em> 添加几个 npm script</strong> 说的那样启动开发环境就会显示开发环境的页面，打包后显示的则是打包后的静态资源。</p></li></ol><p><img src="/resource/addf49c903f840bfa59ebaa1513ec689.png" alt="效果"></p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json">https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 electron-builder 已经足够好用了，但它仍然不能解决 electron 项目工程上的问题，所以这里结合了 <code>lerna/gulp/env-cmd</code> 打包。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-自动更新</title>
    <link href="https://blog.rxliuli.com/p/0f342a17caae4f1e845a543770008e35/"/>
    <id>https://blog.rxliuli.com/p/0f342a17caae4f1e845a543770008e35/</id>
    <published>2021-01-05T00:46:44.000Z</published>
    <updated>2021-02-19T02:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于生产应用希望在有新版本时，自动为用户推送更新，所以此处便写一下如何让 electron 程序自动更新。</p><h2 id="安装-npm-包"><a href="#安装-npm-包" class="headerlink" title="安装 npm 包"></a>安装 npm 包</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> apps/main/ &amp;&amp; yarn add electron-updater<br></code></pre></td></tr></table></figure><h2 id="配置-electron-builder"><a href="#配置-electron-builder" class="headerlink" title="配置 electron-builder"></a>配置 electron-builder</h2><blockquote><p>参考: <a href="https://www.electron.build/auto-update">https://www.electron.build/auto-update</a></p></blockquote><p>其实本质上就是配置一个网络可以访问到的静态资源目录，这里使用了一个本地的静态资源服务器，指向目录是 _apps/main/release_（即打包而进程程序的目录）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;publish&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;provider&quot;</span>: <span class="hljs-string">&quot;generic&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/&quot;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动时检查更新"><a href="#启动时检查更新" class="headerlink" title="启动时检查更新"></a>启动时检查更新</h2><p>在主进程添加检查更新的代码，并自定义提示文案。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> autoUpdater.checkForUpdates();<br>autoUpdater.addListener(<span class="hljs-string">&quot;update-downloaded&quot;</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">new</span> Notification(&#123;<br>    title: <span class="hljs-string">&quot;更新提醒&quot;</span>,<br>    body: <span class="hljs-string">`新版本 <span class="hljs-subst">$&#123;info.version&#125;</span> 已经准备好，点击立刻更新！`</span>,<br>  &#125;)<br>    .addListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      autoUpdater.quitAndInstall();<br>    &#125;)<br>    .show();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>现在，你可以启动一个本地静态服务器指向 _apps/main/release_，例如 <a href="https://www.npmjs.com/package/live-server">live-server</a>，然后打包一个新版本，再启动旧的程序就可以了。</p><p><img src="/resource/2c95743b50f445758d6cb8ef5db5a838.gif" alt="效果"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-渲染、主进程通信</title>
    <link href="https://blog.rxliuli.com/p/6e778ce220e042a0902e7a85976e7e47/"/>
    <id>https://blog.rxliuli.com/p/6e778ce220e042a0902e7a85976e7e47/</id>
    <published>2021-01-05T00:46:26.000Z</published>
    <updated>2021-02-19T02:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于 electron 应用分为主进程、渲染进程，所以它们之间需要通信。而 electron 本身实现了一个简单的 event emitter 通信模型，虽然能用，但并不足够好。</p><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/ipc-renderer">https://www.electronjs.org/docs/api/ipc-renderer</a></p></blockquote><p>问题</p><ul><li>基于字符串和约定进行通信本质上和当下前后端通信差不多，没有利用同构优势</li><li>使用起来没有任何限制，意味着很难维护（非强制性的约定基本上都很难生效）</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么一共 electron 进程通信有哪些情况呢？</p><ul><li>渲染进程 =&gt; 主进程</li><li>主进程 =&gt; 渲染进程</li><li>渲染进程 =&gt; 渲染进程</li></ul><p>而其中最常用的便是 <code>渲染进程 =&gt; 主进程</code></p><blockquote><p>其实吾辈也看过许多 electron 进程通信的 <a href="https://www.npmjs.com/package/electron-rpc-api">封装库</a> 或者类似场景的 rpc 实现 <a href="https://www.npmjs.com/package/comlink">comlink</a>，但最终还是决定使用接口 + 主进程实现 + 渲染层根据接口生成 Client 的方式实现。</p></blockquote><p>最终，吾辈选择了接口 + 实现类的基本模式</p><p><a href="/resource/5639a097671248d2a674f8524b050b81.drawio">设计图.drawio</a></p><h2 id="实现渲染进程-gt-主进程"><a href="#实现渲染进程-gt-主进程" class="headerlink" title="实现渲染进程 =&gt; 主进程"></a>实现渲染进程 =&gt; 主进程</h2><p>首先在创建 <em>libs</em> 目录用以存放通用模块（非业务），然后创建三个模块</p><ul><li><code>electron_ipc_type</code>: 一些需要引入的类型</li><li><code>electron_ipc_main</code>: 主进程封装</li><li><code>electron_ipc_renderer</code>: 渲染层封装</li></ul><blockquote><p>此处使用 rollup 进行打包</p></blockquote><p>大致实现</p><p>electron_ipc_type: 通用的基本接口定义，必须包含一个 <code>namespace</code> 属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BaseDefine&lt;T <span class="hljs-keyword">extends</span> string&gt; &#123;<br>  <span class="hljs-keyword">namespace</span>: T;<br>&#125;<br></code></pre></td></tr></table></figure><p>electron_ipc_main: 封装主进程实现相关代码，主要保证类型安全</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> FilteredKeys&lt;T, U&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]: T[P] <span class="hljs-keyword">extends</span> U ? P : <span class="hljs-built_in">never</span>;<br>&#125;[keyof T];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个主进程可以实现的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcMainDefine&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FilteredKeys&lt;T, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;]: (<br>    e: IpcMainInvokeEvent,<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcMainProvider</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> clazzMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">object</span>&gt;();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 计算主进程监听的 key</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">method</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> getKey&lt;T&gt;(<span class="hljs-keyword">namespace</span>: string, method: PropertyKey) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">namespace</span> + &quot;.&quot; + method.toString();<br>  &#125;<br><br>  register&lt;T extends BaseDefine&lt;string&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    api: IpcMainDefine&lt;T&gt;<br>  ): IpcMainDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">const</span> instance = ClassUtil.bindMethodThis(api);<br>    <span class="hljs-keyword">const</span> methods = ClassUtil.scan(instance);<br>    methods.forEach(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> key = IpcMainProvider.getKey(<span class="hljs-keyword">namespace</span>, method);<br>      ipcMain.handle(key, instance[method] as any);<br>      console.log(&quot;Register ipcMain.handle: &quot;, key);<br>    &#125;);<br>    this.clazzMap.set(<span class="hljs-keyword">namespace</span>, instance);<br>    return instance;<br>  &#125;<br><br>  unregister&lt;T extends BaseDefine&lt;string&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    api: IpcMainDefine&lt;T&gt;<br>  ): void &#123;<br>    <span class="hljs-keyword">const</span> methods = ClassUtil.scan(api);<br>    methods.forEach(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> key = IpcMainProvider.getKey(<span class="hljs-keyword">namespace</span>, method);<br>      ipcMain.removeHandler(key);<br>    &#125;);<br>    this.clazzMap.delete(<span class="hljs-keyword">namespace</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>electron_ipc_renderer: 渲染进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> FilteredKeys&lt;T, U&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]: T[P] <span class="hljs-keyword">extends</span> U ? P : <span class="hljs-built_in">never</span>;<br>&#125;[keyof T];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个渲染进程可以调用的 Proxy 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcRendererDefine&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FilteredKeys&lt;T, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;]: (<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotElectronEnvError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcRendererClient</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成一个客户端实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> gen&lt;T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;]<br>  ): IpcRendererDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), &#123;<br>      get(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">api</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">namespace</span> + &quot;.&quot; + api;<br>        return function (...args: any[]) &#123;<br>          <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>          <span class="hljs-keyword">if</span> (!ipcRenderer) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotElectronEnvError(<span class="hljs-string">&quot;当前你不在 electron 进程中&quot;</span>);<br>          &#125;<br>          <span class="hljs-keyword">return</span> ipcRenderer.invoke(key, ...args);<br>        &#125;;<br>      &#125;,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取 electron ipc renderer 实例</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> getRenderer(): IpcRenderer | <span class="hljs-literal">null</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isElectron()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.require(<span class="hljs-string">&quot;electron&quot;</span>).ipcRenderer <span class="hljs-keyword">as</span> IpcRenderer;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>使用</p><p>在 apps 下创建一个模块 <code>shared_type</code>，里面包含一些渲染进程与主进程之间共享的类型，下面是一个简单的示例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// HelloDefine.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> HelloDefine <span class="hljs-keyword">extends</span> BaseDefine&lt;&quot;HelloApi&quot;&gt; &#123;<br>  hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主进程中使用 class 实现它并注册</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApi</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params">e: IpcMainInvokeEvent, name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> ipcMainProvider = <span class="hljs-keyword">new</span> IpcMainProvider();<br><br>ipcMainProvider.register&lt;HelloDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>, <span class="hljs-keyword">new</span> HelloApi());<br></code></pre></td></tr></table></figure><p>在渲染进程中创建客户端对象并使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> helloApi = IpcRendererClient.gen&lt;HelloDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>);<br><br><span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> helloApi.hello(<span class="hljs-string">&quot;liuli&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="实现主进程-gt-渲染进程"><a href="#实现主进程-gt-渲染进程" class="headerlink" title="实现主进程 =&gt; 渲染进程"></a>实现主进程 =&gt; 渲染进程</h2><p>由于吾辈的 ui 层框架使用了 react，所以基于 class 的模式在此并不适用，需要使用某种变通的方式（吾辈仍然不愿意放弃将 class 作为命名空间的想法）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IpcRendererProviderDefine&lt;<br>  T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;,<br>  P <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt; = FunctionKeys&lt;T&gt;<br>&gt; = [<br>  <span class="hljs-keyword">type</span>: P,<br>  callback: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span>, ...args: Parameters&lt;T[P]&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;<br>];<br><br><span class="hljs-keyword">type</span> IpcRendererProviderHooksDefine&lt;<br>  T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;,<br>  P <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt; = FunctionKeys&lt;T&gt;<br>&gt; = [<br>  <span class="hljs-keyword">type</span>: P,<br>  callback: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span>, ...args: Parameters&lt;T[P]&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;,<br>  deps?: DependencyList<br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在渲染层管理提供者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcRendererProvider</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDefine</span>&lt;<span class="hljs-title">any</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> apiMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">any</span>&gt;();<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">namespace</span>: T[<span class="hljs-string">&quot;namespace&quot;</span>]</span>)</span> &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">...[<span class="hljs-keyword">type</span>, callback]: IpcRendererProviderDefine&lt;T&gt;</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>    <span class="hljs-keyword">if</span> (ipcRenderer === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&quot;不在 electron 环境，取消注册: &quot;</span>, <span class="hljs-keyword">type</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">this</span>.namespace + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">type</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;IpcRendererProvider.register: &quot;</span>, key);<br>    <span class="hljs-keyword">const</span> listener = <span class="hljs-keyword">async</span> (event: <span class="hljs-built_in">any</span>, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, ...args: <span class="hljs-built_in">any</span>[]) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;IpcRendererProvider.listener: &quot;</span>, event, id, args);<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> callback(event, ...(args <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>));<br>        <span class="hljs-keyword">await</span> ipcRenderer.send(id, <span class="hljs-literal">null</span>, res);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">await</span> ipcRenderer.send(id, e);<br>      &#125;<br>    &#125;;<br>    ipcRenderer.on(key, listener);<br>    <span class="hljs-built_in">this</span>.apiMap.set(key, listener);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: IpcRendererProviderDefine&lt;T&gt;[<span class="hljs-number">0</span>]</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>    <span class="hljs-keyword">if</span> (ipcRenderer === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">this</span>.namespace + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">type</span>;<br>    ipcRenderer.off(key, <span class="hljs-built_in">this</span>.apiMap.get(key)!);<br>    <span class="hljs-built_in">this</span>.apiMap.delete(key);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * react 中的注册钩子，自动管理清理的操作</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">type</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">callback</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">deps</span></span></span><br><span class="hljs-comment">   */</span><br>  useIpcProvider(<br>    ...[<span class="hljs-keyword">type</span>, callback, deps = []]: IpcRendererProviderHooksDefine&lt;T&gt;<br>  ) &#123;<br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.register(<span class="hljs-keyword">type</span>, callback);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.unregister(<span class="hljs-keyword">type</span>);<br>    &#125;, deps);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个渲染进程可以调用的 Proxy 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcClientDefine&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FunctionKeys&lt;T&gt;]: (<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcMainClient</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成一个客户端实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">win</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> gen&lt;T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    win: BrowserWindow<br>  ): IpcClientDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), &#123;<br>      get&lt;K <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt;&gt;(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">api</span>: K): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">namespace</span> + &quot;.&quot; + api;<br>        return function (...args: any[]) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[K]&gt;&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">Date</span>.now() + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-built_in">Math</span>.random();<br>            ipcMain.once(id, <span class="hljs-function">(<span class="hljs-params">event, err, res</span>) =&gt;</span> &#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;callback: &quot;</span>, err, res);<br>              <span class="hljs-keyword">if</span> (err) &#123;<br>                reject(err);<br>                <span class="hljs-keyword">return</span>;<br>              &#125;<br>              resolve(res);<br>            &#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;send: &quot;</span>, key, id, args);<br>            win.webContents.send(key, id, ...(args <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>));<br>          &#125;);<br>        &#125;;<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>使用</p><p>在渲染进程使用 hooks 注册它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> ipcRendererProvider = <span class="hljs-keyword">new</span> IpcRendererProvider&lt;HelloApiDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>);<br><br>ipcRendererProvider.useIpcProvider(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">async</span> (e, name) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在主进程生成客户端实例调用它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> helloApi = IpcMainClient.gen&lt;HelloApiDefine&gt;(<br>  <span class="hljs-string">&quot;HelloApi&quot;</span>,<br>  <span class="hljs-keyword">new</span> BrowserWindow()<br>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> helloApi.hello(<span class="hljs-string">&quot;liuli&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="约定俗成"><a href="#约定俗成" class="headerlink" title="约定俗成"></a>约定俗成</h2><ul><li>在 <code>shared_type</code> 模块中的接口定义总是 <code>*Define</code> 形式，且实现的 <code>BaseDefine&lt;T&gt;</code> 泛型参数是 <code>*Api</code> 形式</li><li>在 <code>main</code> 模块中实现的 class 总是 <code>*Api</code> 形式</li><li>在 <code>renderer</code> 模块中获取的 client 实例总是 <code>*Api</code> 小写驼峰形式</li><li>实现 <code>BaseDefine&lt;T&gt;</code> 传入的命名空间参数不应该重复</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>electron 本身的进程通信 api 在逐渐发展，但目前仍然没有足够好用，所以吾辈不得不进行了封装。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-基本项目搭建</title>
    <link href="https://blog.rxliuli.com/p/475d21afd2404d5ba1f71f600c44da09/"/>
    <id>https://blog.rxliuli.com/p/475d21afd2404d5ba1f71f600c44da09/</id>
    <published>2021-01-05T00:46:18.000Z</published>
    <updated>2021-02-19T02:31:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Windows 10</li><li>NodeJS 12</li><li>WebStorm</li><li>VSCode（编写 markdown 文档）</li></ul><h2 id="创建-lerna-项目"><a href="#创建-lerna-项目" class="headerlink" title="创建 lerna 项目"></a>创建 lerna 项目</h2><p>创建目录 _electron_example_，然后使用 yarn 初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir electron_example &amp;&amp; <span class="hljs-built_in">cd</span> electron_example<br>yarn init -y<br></code></pre></td></tr></table></figure><p>修改 <em>package.json</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;electron_example&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>,<br>  <span class="hljs-attr">&quot;workspaces&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;packages&quot;</span>: [<span class="hljs-string">&quot;apps/*&quot;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后创建 <em>lerna.json</em> 配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;packages&quot;</span>: [<span class="hljs-string">&quot;apps/*&quot;</span>],<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;independent&quot;</span>,<br>  <span class="hljs-attr">&quot;npmClient&quot;</span>: <span class="hljs-string">&quot;yarn&quot;</span>,<br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化目录如下</p><ul><li><em>apps</em><ul><li><em>main</em>: 主进程</li><li><em>renderer</em>: 渲染进程</li></ul></li><li>_node_modules_</li><li><em>lerna.json</em></li><li><em>package.json</em></li><li><em>yarn.lock</em></li></ul><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/b9628e1fd16bb5b6807e55e9ca72fdf2daf5bfde">https://github.com/rxliuli/electron_example/tree/b9628e1fd16bb5b6807e55e9ca72fdf2daf5bfde</a></p></blockquote><h2 id="初始化渲染层模块"><a href="#初始化渲染层模块" class="headerlink" title="初始化渲染层模块"></a>初始化渲染层模块</h2><p>在 renderer 目录中使用 create-react-app 创建一个 react 项目，并添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npx create-react-app apps/renderer/ --template typescript<br></code></pre></td></tr></table></figure><p>不过还需要修改其中部分配置，主要包含</p><ul><li>删除 <em>yarn.lock</em> 或 <em>package-lock.json</em> 文件</li></ul><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/8e0920af985e1201fc05ca36302e094532843c2d">https://github.com/rxliuli/electron_example/tree/8e0920af985e1201fc05ca36302e094532843c2d</a></p></blockquote><p>尝试再 yarn 安装依赖，接着再使用 <code>yarn start</code> 启动开发环境，应该可以在浏览器中看到默认的页面。</p><p><img src="/resource/08869afb99594ede8c00d65ad4b65c19.png" alt="20210106194304.png"></p><h2 id="初始化主进程模块"><a href="#初始化主进程模块" class="headerlink" title="初始化主进程模块"></a>初始化主进程模块</h2><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/a78885b76de9322dfdac82e2c220b7c6e0a9617f">https://github.com/rxliuli/electron_example/tree/a78885b76de9322dfdac82e2c220b7c6e0a9617f</a><br>注：electron 版本选择双数，生命周期更长。</p></blockquote><p>初始化主进程模块，主要包括</p><h3 id="为主进程创建-package-json"><a href="#为主进程创建-package-json" class="headerlink" title="为主进程创建 package.json"></a>为主进程创建 package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加依赖-yarn-add-electron-electron-builder-typescript"><a href="#添加依赖-yarn-add-electron-electron-builder-typescript" class="headerlink" title="添加依赖 yarn add electron electron-builder typescript"></a>添加依赖 <code>yarn add electron electron-builder typescript</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;electron&quot;</span>: <span class="hljs-string">&quot;^10.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.9.1&quot;</span>,<br>    <span class="hljs-attr">&quot;typescript&quot;</span>: <span class="hljs-string">&quot;^4.1.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加-tsconfig-json-配置文件"><a href="#添加-tsconfig-json-配置文件" class="headerlink" title="添加 tsconfig.json 配置文件"></a>添加 <em>tsconfig.json</em> 配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tsconfig.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-comment">// nodejs 生态大多数都支持这种模块</span><br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>    <span class="hljs-comment">// 优先考虑输出 es5</span><br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,<br>    <span class="hljs-comment">// 但不要自缚手脚，仍然使用最新的 es 特性</span><br>    <span class="hljs-attr">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;ESNext&quot;</span>],<br>    <span class="hljs-comment">// 定义源目录与输出目录</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>,<br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;dist&quot;</span>,<br>    <span class="hljs-comment">// 生成 sourceMap 方便 IDE 本地调试</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 禁止 ts 检查 npm 依赖的类型定义（例如 electron 的类型定义就很容易被 ts 检查出错误，毕竟这个项目实在太大了）</span><br>    <span class="hljs-attr">&quot;skipLibCheck&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;skipDefaultLibCheck&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// 排除依赖目录与输出目录</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;node_modules&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加-src-main-ts-基本的启动文件"><a href="#添加-src-main-ts-基本的启动文件" class="headerlink" title="添加 src/main.ts 基本的启动文件"></a>添加 <em>src/main.ts</em> 基本的启动文件</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入开发环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<span class="hljs-string">&quot;http://localhost:3000/&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * main 函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  app.on(<span class="hljs-string">&quot;ready&quot;</span>, createMainWindow);<br>&#125;<br><br>main();<br></code></pre></td></tr></table></figure><h3 id="更新-package-json-添加几个-npm-script"><a href="#更新-package-json-添加几个-npm-script" class="headerlink" title="更新 package.json 添加几个 npm script"></a>更新 <em>package.json</em> 添加几个 npm script</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 编译 ts 代码</span><br>    <span class="hljs-attr">&quot;compile&quot;</span>: <span class="hljs-string">&quot;tsc&quot;</span>,<br>    <span class="hljs-comment">// 编译 tsc 代码且启动监听模式</span><br>    <span class="hljs-attr">&quot;watch&quot;</span>: <span class="hljs-string">&quot;yarn compile -w&quot;</span>,<br>    <span class="hljs-comment">// 在主进程通过 lerna 启动渲染进程模块的开发环境</span><br>    <span class="hljs-attr">&quot;dev:web&quot;</span>: <span class="hljs-string">&quot;lerna run --scope renderer start&quot;</span>,<br>    <span class="hljs-comment">// 启动主进程的开发环境</span><br>    <span class="hljs-attr">&quot;dev:electron&quot;</span>: <span class="hljs-string">&quot;electron ./dist/main.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们通过这些 npm script 启动 electron 开发环境</p><ol><li> 运行 <code>yarn watch</code></li><li> 运行 <code>dev:web</code></li><li> 等待以上两条命令都运行完成，再继续运行 <code>dev:electron</code></li></ol><p>现在，你应该可以看到一个 electron 窗口，其中显示着。</p><p><img src="/resource/8f2afb0c085a4d3c8c678c71bc128412.png" alt="20210106194102.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前，使用 lerna monorepo 似乎还看不出来明显的优点，不过实际上在后面逐步完善 Electron 程序的过程中我们会发现它的强大之处。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron 开发经验之谈系列-技术栈简介及选择</title>
    <link href="https://blog.rxliuli.com/p/74b1ec3c598940c2afbd17cdd50e31cb/"/>
    <id>https://blog.rxliuli.com/p/74b1ec3c598940c2afbd17cdd50e31cb/</id>
    <published>2021-01-05T00:46:08.000Z</published>
    <updated>2021-03-02T02:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><a href="https://electronjs.org/">electron</a>: 跨平台桌面开发</li><li><a href="https://reactjs.org/">react</a>: 视图层框架</li><li><a href="https://www.typescriptlang.org/">typescript</a>: 强类型的 js</li><li><a href="https://lerna.js.org/">lerna</a>: 前端 monorepo 管理工具</li><li><a href="https://classic.yarnpkg.com/">yarn</a>: 包管理器，workspace 与 lerna 搭配非常好</li><li><a href="https://create-react-app.dev/">create-react-app</a>: react 官方出品的 react 脚手架生成器，社区和活跃度都不是其它工具可比的</li></ul><h2 id="其他依赖库"><a href="#其他依赖库" class="headerlink" title="其他依赖库"></a>其他依赖库</h2><blockquote><p>参考: <a href="/p/4b666902cd1e45779448a76a71d0e2e5">前端资源管理</a></p></blockquote><ul><li><a href="https://rollupjs.org/">rollup</a>: 前端库打包工具</li><li>electron-builder: electron 打包工具</li><li>is-electron: 在渲染层判断是否为 electron 环境的微型库</li><li>fs-extra: nodejs api 的 Promise 化封装</li><li>react-use: react 中的通用 hooks 库</li><li><a href="https://www.npmjs.com/org/liuli-util">@liuli-util/*</a>: 吾辈个人的一系列通用工具库</li><li>jest: 单元测试工具</li><li>wallaby.js: 单元测试 IDE 集成</li><li>gulp: 流式任务管理工具</li><li>electron-store: 主进程和渲染层通用的 k-v 存储</li><li>electron-reloader: electron 热更新工具</li><li>electron-devtools-installer: electron 插件安装工具</li><li>utility-types: typescript 通用类型库</li></ul><h2 id="选择动机"><a href="#选择动机" class="headerlink" title="选择动机"></a>选择动机</h2><ul><li>electron: 想必来看到这篇文章的人都无需解释，基于 web 技术的跨平台足以解释一切。</li><li>react: 吾辈无意争论框架优劣，但 react 确实是目前最流行的解决方案，所以吾辈选择了它。</li><li>typescript: 由于吾辈有着 Java 后端的经验，所以对强类型情有独钟。</li><li>lerna: 这个确实需要解释一下，electron 应用分为主进程和渲染层，一般示例中是将它们在一个项目中通过目录区分，但这种隔离性并不好，还会污染 <code>package.json</code>。这时候就到了 lerna 出场了，它是由 babel 的作者开发，专门用以解决前端没有多模块工程的问题。<blockquote><p>PS1: 老实说，吾辈很想念 Java <a href="https://maven.apache.org/">maven</a> 多模块的支持，可以非常简单的抽取模块出来。<br>PS2: 前端有名的 electron-react 示例项目 <a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate/">electron-react-boilerplate</a> 就是单模块的。</p></blockquote></li><li>electron-builder: electron 官方其实更推荐 <a href="https://www.electronforge.io/">Electron Forge</a>，但目前而言，electron-builder 更好。</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="electron" scheme="https://blog.rxliuli.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>2020 复盘及 2021 计划</title>
    <link href="https://blog.rxliuli.com/p/01f6410c002840e9ba7bfca65c9611ee/"/>
    <id>https://blog.rxliuli.com/p/01f6410c002840e9ba7bfca65c9611ee/</id>
    <published>2021-01-01T00:54:31.000Z</published>
    <updated>2021-01-03T17:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-复盘"><a href="#2020-复盘" class="headerlink" title="2020 复盘"></a>2020 复盘</h2><blockquote><p><a href="/p/17b171a3184c479e97ba7df9bc118023">年初计划</a></p><p>明年，吾辈最想要接触的是 Web 桌面开发，以及机器学习。</p><ul><li>[x] NodeJS 后端开发</li><li>[x] Web 桌面开发 Electron</li><li>[ ] 机器学习 TensorFlow</li><li>[x] 继续维护 Blog</li><li>[ ] 继续坚持读书</li><li>[ ] 尝试网络小说写作</li><li>[ ] 尝试 Youtube 视频创作</li></ul></blockquote><p>实际上 Web 桌面开发由于工作的原因算是接触的非常多，但机器学习几乎没什么了解。</p><p>那么今年到底做了什么呢？</p><table><thead><tr><th>时间</th><th>公司</th><th>个人</th></tr></thead><tbody><tr><td>1 月</td><td>疫情发生</td><td>过了最惨的年</td></tr><tr><td>2 月</td><td>远程办公</td><td></td></tr><tr><td>3 月</td><td>业务开发</td><td></td></tr><tr><td>4 月</td><td>开始招人</td><td>替换技术栈 vue =&gt; ts+react</td></tr><tr><td>5 月</td><td>995 福报中</td><td>接触 Electron</td></tr><tr><td>6 月</td><td>995 福报中</td><td>开始使用 joplin 管理笔记</td></tr><tr><td>7 月</td><td>程序定制化修改</td><td>开发 joplin-vscode-plugin</td></tr><tr><td>8 月</td><td>程序定制化修改</td><td>开始了解 Monorepo 工程化</td></tr><tr><td>9 月</td><td>程序定制化修改</td><td></td></tr><tr><td>10 月</td><td>程序定制化修改</td><td>开发 joplin-charts</td></tr><tr><td>11 月</td><td>开始新的项目</td><td>完善 joplin 周边工具链</td></tr><tr><td>12 月</td><td>开始另一个新的项目</td><td>开发 joplin-blog</td></tr></tbody></table><p>今年主要入的一个大坑是 joplin，虽说一开始仅仅是作为笔记工具使用，但中途因为遇到了一些问题所以参与了部分周边工具的开发，占用了不少的业余时间。然而，开源程序的魅力就在于此：当不能满足需求时，吾辈可以通过开发来改变这一切。</p><p>开源项目</p><ul><li><a href="https://github.com/rxliuli/rx-util">rx-util</a>: 前端通用工具库，虽然今年没怎么更新，但也是因为逐渐变得完善的愿意</li><li><a href="https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin&ssr=false#overview">joplin-vscode-plugin</a>: joplin 的 vscode 插件，使用 vscode 接管自己的笔记管理，支持大多数 joplin 的功能（通过 web clipper service）</li><li><a href="https://github.com/rxliuli/joplin-blog">joplin-blog</a>: 将 joplin 作为数据源导出 blog</li><li><a href="https://rxliuli.com/joplin-charts/#/">joplin-charts</a>: 展示 joplin 的一些统计图表数据</li><li><a href="https://www.npmjs.com/package/joplin-api">joplin-api</a>: joplin 的 api 封装，适用于 web/nodejs，也是以上成果的基础</li><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>: 参与了一个类型定义包的错误修复，熟悉了基本的贡献流程（其实也挺繁琐的）</li><li><a href="https://github.com/rxliuli/userjs">user.js</a>: 一些自用的油猴脚本 – 仅维护常用的几个了</li><li><a href="https://github.com/rxliuli/liuli-cli">liuli-cli</a>: 前端 npm 包的脚手架生成 cli 工具 – 不怎么维护了</li><li><a href="https://github.com/rxliuli/vue-url-persist">vue-url-persist</a>: vue url 序列化参数的包 – 自从主要技术栈更换为 react 之后就不怎么维护了</li></ul><p>但显而易见，去年是吾辈工作的第三年，但成长速度确实不尽人意。至于原因，吾辈内里倒也十分清楚。</p><ul><li>客观原因：<ul><li>当公司的 team 不能为自己的成长提供帮助时，也只能一个人走着自己的探索之路，但这时常会感到灰心丧气，甚至破罐破摔式的放弃挣扎。– 然后在一段时间时间后回想起来感到后悔，仿若贤者时间一般。</li><li>疫情（是一个非常不好的开始）</li></ul></li><li>主观原因<ul><li>没找到一条明确的变得更好的途径，内心迷茫。上一次这样的时候吾辈从后端转职为了前端，但这一次，吾辈不清楚应该怎么做。</li><li>懒散、无法坚持，这些缺点今年切实的体现在了吾辈身上，而这却又无法轻易摆脱。</li><li>生活没有规律，睡得很晚，周末没有合理的安排时间出去活动。</li></ul></li></ul><h2 id="新的计划"><a href="#新的计划" class="headerlink" title="新的计划"></a>新的计划</h2><p>总体而言，核心目标仍然没有变化：<strong>活下去，活得更好</strong>。但执行层面确实需要发生一些变化。</p><p>目标</p><ul><li>[ ] 制定并坚持合理的时间计划</li><li>[ ] 切实地找到新的学习方法</li><li>[ ] 看完之前购买的书籍</li><li>[ ] 学习英语</li></ul><p>开源项目</p><ul><li>[ ] 编写 Electron 经验之谈系列博客 – 1 月</li><li>[ ] 完善 joplin-blog cli，提高效率，优化 UX – 2 月上旬</li><li>[ ] 重构 web logger 日志工具 – 2 月上旬</li><li>[ ] 重构 rx-util 工具包，将之分解为独立的一系列模块，避免耦合 nodejs/dom 和庞大难以引入的问题 – 春节</li></ul><p>希望今年自己能变得更好，在一切糟糕到无法挽回之前，离开这里 – 世界那么大，吾辈也想出去看看。</p><blockquote><p>2020 是过去十年最坏的一年，但或许，是今后十年最好的一年。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
    <category term="开源" scheme="https://blog.rxliuli.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>漫谈 反乌托邦</title>
    <link href="https://blog.rxliuli.com/p/a8e38f7f626943ab85ac911bf79ace1e/"/>
    <id>https://blog.rxliuli.com/p/a8e38f7f626943ab85ac911bf79ace1e/</id>
    <published>2020-12-31T01:42:31.000Z</published>
    <updated>2020-12-31T01:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1984"><a href="#1984" class="headerlink" title="1984"></a>1984</h2><p>最近看完了 <strong>1984</strong> 这本小说，在之后也补了一下电影</p><p>Youtube 正版电影</p><iframe width="560" height="315" src="https://www.youtube.com/embed/S0WSCZx6R6M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>一些设定令人惊奇</p><ul><li>真理部：负责新闻、娱乐、教育、艺术</li><li>和平部：负责战争</li><li>有爱不：负责维持法律和秩序</li><li>富裕部：负责经济事务</li></ul><p>一些名言令人印象深刻</p><ul><li>过去被禁止，控制过去的人控制未来，控制现在的人控制过去。</li><li>除了对集体的爱，没有其他的爱，与之竞争的都要被摧毁。</li><li>无产阶级就像牲口一样，什么办法都没有。</li><li>现代战争的本质，就是毁灭产品和人类的劳动，保持社会处于饥饿的边缘，一个分等级的社会只可能建立在贫穷和无知的基础上。</li><li>栗树荫下，我出卖你，你出卖我。</li></ul><p>里面小孩举报父母，被洗脑而不自知，或许，亦是因为一张白纸更容易染上颜色吧。</p><ul><li>低效的前进，高效的内斗</li></ul><p>现实场景</p><ul><li>这本书可以很容易买到</li><li>中文网络上没有国人影评/同人小说</li><li>1984 在微博已经成为非法内容了</li><li>举报父母已有现实案例（所谓的大义灭亲）</li></ul><h2 id="美丽新世界"><a href="#美丽新世界" class="headerlink" title="美丽新世界"></a>美丽新世界</h2><ul><li>人工胚胎，设置命运：感觉是个恐怖的极权世界</li><li>从小开始的 SEX 游戏与索麻，消费/享乐主义至上：或许是个天堂？</li><li>野人区：旧时代的信仰、肮脏的生活与 <strong>美丽新世界</strong> 对比，让人真不知道哪个是天堂？</li><li>野人疯了：发现自己苦苦追寻的事物、坚信的认知却一文不值时，疯掉了，<strong>天堂</strong> 对他而言也是地狱了</li><li><code>9/10</code> 的人口供养着 <code>1/10</code> 的人口是 <strong>阿尔法</strong>，无论是水上还是水下都会感到快乐，不提高产量的最大原因是为了避免闲暇时间造成资源的浪费</li></ul><p>那种 <strong>美丽新世界</strong> 和 <strong>野人区</strong> 真的很难说哪个更好，活到 60 岁，但一生都能保持年轻，并且 <strong>每个人属于每个人</strong> 的理念确实很厉害。</p><ul><li>要求 <strong>不快乐</strong> 的权力</li></ul><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>花了几年营造出来的中国梦，在一个春节就破碎的不成样子了。</p><ul><li>双重思想在现实中确实存在，而且很常见。<ul><li><a href="https://twitter.com/LiYing_2015/status/1227363930504196096">所以为歌颂伟大牺牲的时候，就防护服不足，以至于医护人员都不够用，为辟反动谣言的时候，就殡葬人员都必须有防护服。动动脑子想一想的结果就是如此的辩证</a></li><li>“我们要自由。我们反对香港游行、台湾独立。”，说这两句话的是同一批人。<ul><li>或许未曾意识到，香港、台湾他们也是为了自由，甚至于，或许只是跟风发泄一下情绪，并不明白自由是什么。。。</li></ul></li></ul></li><li>没有说 <code>1 + 1 = 2</code> 的权利<ul><li><a href="https://zh.wikipedia.org/wiki/%E6%9D%8E%E6%96%87%E4%BA%AE">李文亮</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A6%E6%BC%A2%E9%80%A0%E8%AC%A0%E5%85%AB%E5%90%9B%E5%AD%90">武汉「造谣」八君子</a></li></ul></li><li>未曾想过现实中真的有 <strong>新语</strong> 一说<ul><li><a href="https://mp.weixin.qq.com/s/bS_8xCR2bxpwWKcoAeo4pw">为什么日本人显得比中国人更懂中国文化</a><ul><li>“山川异域，风月同天。” 居然比不上 <strong>新语</strong> 的 “武汉加油”。</li><li>新世纪笑话：<blockquote><p>我举一个例子，比如你是给武汉捐助救灾物资的一位执行者，你在包装箱上写了八个字：山川异域，风月同天。领导看见了，会直接骂你：“你特么神经病吗？写这个干嘛？应该写武汉加油，还要加一个大感叹号。”<br>为什么不能用这八个字？因为这八个字不在那一套新话系统里面。这就超出了一位领导干部的思维边界。超出思维边界的事物，都是危险的、不可控的，是不可以使用的。<br>领导还要问你：你听明白了吗？能不能做到？<br>所以，你只能写个 “武汉加油”。</p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
</feed>
