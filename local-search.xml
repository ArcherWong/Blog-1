<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>读书-[颓废与沉默：透视犬儒文化]</title>
    <link href="/p/7e7131c07c984d928ba3fefa7a9cef06/"/>
    <url>/p/7e7131c07c984d928ba3fefa7a9cef06/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当今世界上不同国家社会和国民文化中的犬儒主义可以分为两大类:公开的犬儒主义和戴面具的犬儒主义。它们的基本区别在于,当一个人因为犬儒主义而不相信统治意识形态、制度、权威、信仰体系以及由权力或习俗规定和主导的法律或价值规范时,尤其是怀疑和鄙视政府、政治权力和政治人物的时候,公开的犬儒主义会在公共言论和行为中表示出来,而戴面具的犬儒主义则通常不会,不仅不会表示不相信,而且还会假装成相信的样子。公开的犬儒主义对那些什么都不相信,所以公然怀疑,公然拒绝,不相信就是不相信。戴面具的犬儒主义对那些也是什么都不相信,但正因为对什么都不相信,所以对什么都可以装作相信。他们玩世不恭,随波逐流,最后有的连自己都弄不清到底是相信还是不相信,于是索性不去管相信不相信,”难得糊涂”地过一天算一天。当然,这不等于戴面具的犬儒主义在任何情况下都不会摘下面具露出不相信的真面目。他们在私下或在不那么公开的场合中也会有不戴假面的时候。这时候,不加掩饰的犬儒主义就会成为同道者之间互相联络的接头暗号。这使得原本以怀疑和不信任为特征的犬儒主义反倒成为一种人际联系方式,也形成一种有群体特征的社会文化。</p></blockquote><p>开局王炸。这让吾辈想到了 1984 里面的男女主角的认知和世界观，男主就是怀疑政府，但带上了面具。而（新生代的）女主则一方面装作相信，但背地里却又不在乎，看的时候觉得简直就是精神分裂。</p><hr><blockquote><p>在所有这 13 种”病态”中,没有一处提及犬儒,可见犬儒并不是一个普通中国人常用的概念。然而,这些病态中至少有八九种都是犬儒主义的典型表现:（1）娱乐至死（没有目标或信仰,得过且过）；（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；（8）”鸵鸟心态”（多一事不如少一事,被宣传的现实反正是假的,不如”躲进小楼成一统”）;（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是”自虐”,这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。</p></blockquote><p>躺枪，感觉吾辈中了好多枪。过去的经历造就了现今的吾辈，社会的经验和认知中的道理偏差太大了。</p><hr><blockquote><p>假面社会里的犬儒者们揣着明白装糊涂（”难得糊涂”）,明明在心里不相信,但却还公开做出相信的样子。他们戴上自己参与制作的假面,顺从地配合统治者的愿望表演。这也是一种将顺从和抵抗合为一体的犬儒主义。波兰诗人米沃什在《被禁锢的头脑》中称此为”蒙蔽对手”的策略。他写道,”有些情况,保持沉默还不够,沉默可能被认为是主动招供,那时候就不应有丝毫犹豫,不仅要公开否认自己真正的观点,而且必须采取一切手段来蒙蔽对手。那时候就得宣布一切能取悦对手的信条,参与所有被认为是最荒唐的仪式 ⋯⋯ 终于,在蒙骗对手后,使对手在其错误中越陷越深的同时,使其承受应得的羞辱和精神痛苦。”这可能只是一种精神胜利法,但它却能”让践行它的人感到自豪,因为有了它,践行者才能把自己提升到超越被蒙骗者之上,并持久获得比对手优越的地位,哪怕是部长或有权有势的国王。⋯⋯ 你表面上还在被你巧妙欺骗的强权者脚下颤抖,眼睛却闪闪发亮。你在光明中走在敌人面前,你嘲笑一个愚蠢的家伙,解除了一头危险野兽的武装。这一下获得多少慰藉！”</p></blockquote><p>吾辈想到了某段话：“如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。”<br>—— 柏拉图</p><hr><blockquote><p>马基雅维利说,害怕是比爱戴更有效的统治工具,这话很适合今天的犬儒社会。有权者和无权者的犬儒主义总是在恶性循环,形成一种恶吏统治刁民的强制性秩序,稳固这一秩序的唯一办法就是层层加码的所谓”乱世用重典”。</p></blockquote><p>这让吾辈想到刚过完的春节之前返乡政策：<br>中央要求 “从低风险区返乡持绿码即可”，到一些省份变成 “持核酸检测阴性证明”，到市里就变成 “核酸阴性证明 + 居家隔离”，到镇上变成 “核酸证明 + 集中隔离 + 居家隔离”，最后到村里就成了 “禁止返乡”。</p><hr><blockquote><p>权力随时防范着学术,设置重重障碍。但是,由于”学术”对权力有利用价情,所以还会被允许存在,甚至加以鼓励。当然,首要的条件是学术必须无害于权力统治,而最受稿赏的则是有助于或能配合权力统治的学术。权力的咸胁与利诱造就体制性的”学术义儒”,它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。</p></blockquote><p>哈哈，这是在指某位小学生么 xd</p><hr><blockquote><p>先入为主（preconception）和刻板印象（stereotype）之间有联系,但又有所区别。先入为主经常是因为某种先例而形成的一种习惯性推断,以为以前曾经发生过的,现在也就一定会发生。”先例”是先入为主思维的条件。先入为主又称偏见（prejudice）,也就是在还没有弄清情况之前就下定论（prejudgment）。</p></blockquote><p>这点吾辈深有感触。在吾辈高二那年活跃于贴吧之中时，曾被人认为是女生，后面与一些人建立了相关的 QQ 同好群，里面的许多人也会这样认为–因为之前有人这样认为了，如果有人怀疑，那么前面已经如此认定的人就会反对。甚至到了现在，吾辈虽然没有刻意伪装，但却也没有主动说明过。</p><hr><blockquote><p>美国的现实民主制度保障了普通美国人讨论”什么是爱国主义”,”美国需要怎样的爱国主义”的权利。政府权力不能垄断在这些问题上的话语权。普通人如果有与政府或主流社会不同的爱国主义看法,可以发表自己的意见,不会因此被当作”美奸”或其他国家的”走狗”。而且,美国是一个多元民族文化的国家,爱国主义比较容易与文化民族主义区别开来,不容易被民族文化主义所限制或绑架。在美国,爱国主义与民族主义也是有区别的。法国总统戴高乐说过,在爱国主义那里,爱护自己国家的人民是第一位的；在民族主义那里,仇恨其他国家和其他国家的人是第一位的。美国的爱国主义里很少混杂戴高乐所说的那种仇恨性的民族主义。</p></blockquote><p>那么问题来了，国内现在究竟是爱国主义，还是民族主义呢？</p><hr><blockquote><p>冯小刚在微博里说,”我是觉得这么多年一部接一部地拍电影,没有其他的生活。在一个特别窄的胡同里,我长跑,还不是短跑。你怎么跑,你感觉两边都是这么一个墙,越跑越窄,越跑越窄。”他是个会说话的人,一句话同时说给两种不同的人听,让他们各自听出自己想要的意思。你可以认为他是在抱怨拍电影太辛苦,以至于”没有其他的生活”；你也可以认为他是在抱怨有”墙”不让他自由奔跑,以至于他电影生涯逼仄,只有辛苦而无乐趣。</p></blockquote><p>好的电影都在上个世纪拍完了，国内电影拍摄在两千年后是逐渐退步的。<br>或者说，所有的艺术在国内基本都是在退步的？电影、电视剧、音乐、动画这些，虽说过去的回忆有同年加成，但后来者无法居上也是不争的事实。例如新白之后再也没有更好的《白娘子传奇》了，电视剧的发展更是相当迷惑，完全看不懂粉圈喜欢的电视剧。</p><hr><blockquote><p>人们往往从现代社会工作压力大、人际交往频繁、信息更新流通速度快等实用原因来解释”离不开手机”的现象,而忽视了一个非常重要的心理因素——无聊。</p></blockquote><p>是的，吾辈一天玩手机的时间超过两个小时，工作日最长甚至会达到四个小时。</p><hr><blockquote><p>一般来说,有三种无聊,都与难以集中精神注意力有关。一、被阻止去做想做的事情；二、不得不去做不想做的事情；三、没有明确原因,只是对任何事情都没有兴趣,不想去做。一种或不止一种的无聊会让人觉得空虚、抑郁、百无聊赖。无聊不仅是一种此时此刻的心情,而且还是一种对生活状态的看法和生存环境的感受。无聊使人感觉到沉闷、压抑、无可作为、没有出路或希望,因而也焦虑、冷漠、忧虑、不安,甚至惶惶不可终日。人们经常把无聊与太多的闲暇、无所事事、缺乏审美兴趣联系在一起,但是,工作和做事并不一定就是解除无聊的良药。许多的工作对人对有异化作用,人变成了完成某种工作任务的工具。这样的工作机械乏味、没有意义,更让人觉得无聊。</p></blockquote><p>所以吾辈总是说：“没有变化就是在等死”，而等死它好么？它不好。工作如果一直做自己不感兴趣的或不能做自己感兴趣的事情的话，那么离开便是唯一的选择了。</p><hr><blockquote><p>人们从自己以往的经验发现,再怎么求也不会起作用,所以天大的事也只好忍受,不再有所要求或希望。在心理学里,这叫”习得性无助”（learned helplessness）。</p></blockquote><p>这与现在基本放弃希望混吃等死的咸鱼思想不谋而合，既然卷不过别人，政府也不顾及一般人的死活，那么我为什么还要继续卷下去呢？作为一个加害者和受害者的身份。</p><hr><blockquote><p>如果一个人总是在一项工作上失败。他就会在这项工作上放弃努力。甚至还会因此对自身产生怀疑,觉得自己”这也不行,那也不行”,彻底无望。典型的例子是,学习成绩经常不好的学生会怪自己”天生就笨”,所以不再努力；经常失恋的人会责备自己”天生令人讨厌”,所以干脆放弃找对象的打算。他们都是因为有屡屡受挫的经验,所以陷入了无为无助的绝望之中。</p></blockquote><p>所以需要做一些有趣的事情，恢复信心，建立信心。吾辈在 joplin 周边生态上的建设便是如此了。<br>而且，新的一年，新的开始，一切都可以从零算起了呢！</p><hr><blockquote><p>知识分子用”新理论”来粉饰和淡化统治者自己都不好意思否认的以往错误,这是一种非常巧妙的”光天化日之下献媚讨好”,既献媚讨好,又显得不失自己的”学者”身份。例如,把”文革”时的”忠字舞”说成是相当于今天跳迪斯科的”大众文化”。毛泽东说的文革每 5 年搞一次,被说成是相当于”定期的民主选举”。这是一种非常犬儒的学术话语把戏和游戏。</p></blockquote><p>哈，总是有人会这样做呢，一本正经的胡说八道，不外如是。</p><hr><blockquote><p>不同的国家有不同的国情,公共知识分子的专业造诣、职业特征和公共活动方式也会有很大的不同。中国大学教授受体制的限制比美国大,升等评级、决定科研项目的权利掌握在领导和人事部门手里,教授被逼着在自己的一亩三分地里小心耕作,巴望着能出一些符合体制规定的”成果”,所以容易变得思想狭隘,目光短浅,心灵猥琐,浅薄弱智。他们既不能成为”世界的眼睛”,也不敢站在体制的边缘,扰乱它的安宁。</p></blockquote><p>对上级负责而不是事情负责，上下五千年的老传统了。<br>一般（小）公司 996 的形式主义大于实际效益，任何能够量化的事情想想办法总是能够完成，加班未必就是在忙实际负责的事情。话虽如此，这也确实将人局限在公司，严重减小了交际面，绝非长久可为之计。</p><hr><blockquote><p>“文革”中盛行言辞激烈、慷慨激昂的”革命歌曲”或”诗朗诵”,运用的就是这种非说理话语,形成了具有中国特色的”标语体”写作。例如,”东风吹战鼓擂,现世界上究竟谁怕谁?不是人民怕美帝,而是美帝怕人民, 得道多助失道寡助,历史的规律不可抗拒,不可抗拒……”标语体写作是口号式思维的产物,二者相辅相成。</p></blockquote><p>太尬了，让吾辈想到去年的“武汉加油”与“山川异域，日月同天”的事情了。– 历史不会重演，它只会押韵。</p><hr><blockquote><p>“文革”高潮时期,人们说话都必须以”毛主席教导我们”开始,说上一段语录,然后才言归正传,这是正确的说话规范。王小波在《沉默的大多数》一文中写道:”古代和近代有两种方法可以壮我的胆。古代的方法是,文章要从‘夫子曰’开始。近代的方法是从‘毛主席教导我们说’开始。”所谓”壮胆”,也就是必须这么说才能被别人接受,才不至于出错,因为这就是”规范”.</p></blockquote><p>沉默的却是永远都是大多数，就像互联网上的幽灵一样，仅仅消费而不生产内容。另外，吾辈只听说过【吴晓波】</p><hr><blockquote><p>心理学研究早就归纳了人的七种性格缺陷,它们分别是,一、自我贬损（Self-Deprecation）:自甘下流、唾面自干；二、自暴自弃（Self-Destruction）:自我糟践、自我伤害；三、受害者心结（Martyrdom）:老觉得别人在算计和迫害自己；四、顽固和一意孤行（Stubbornness）:拒绝改变自己；五、贪得无厌（Greed）:自我放纵、欲壑难填；六、狂妄自大（Arrogance）:老子天下第一,谁也说不得；七、极不耐烦（Impatience）,像是谁都在跟自己作对,跟自己有仇。这七种性格缺陷在当今中国都不陌生,而其中的自我贬损则直接与一些人在人格上无自尊的”下流化”有关。</p></blockquote><p>躺枪 * 2 <em>(:з)∠)</em></p><hr><blockquote><p>我因此想到读过的一篇博文《生活就像被强奸一样,既然不能反抗,那就好好享受吧》。</p></blockquote><p>生活就是这么糟糕，那么吾辈还是做条安静的咸鱼，躺平吧！<br>话虽如此，面对现实环境，能做的无非就是三件事</p><ol><li> 改变自己</li><li> 改变世界</li><li> 离开这儿</li></ol><p>其中，改变自己，做个安静的咸鱼显然是最容易实现的呢</p><hr><blockquote><p>颓废与沉默:透视犬儒文化</p></blockquote><p>看完了这本书，这是在看了两本这种哲学类型的书之后，终于碰到一本感兴趣的了。里面真是描绘了当下国内的各种问题啊。而且旁征博引，引用了许多现实示例。<br>另外，这本书似乎已然绝版了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-在渲染、主进程间共享数据</title>
    <link href="/p/db74e6e5d2444bc3b6e185a7b338bbf6/"/>
    <url>/p/db74e6e5d2444bc3b6e185a7b338bbf6/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候我们需要在主进程和渲染层共享某些数据，而 <a href="/p/6e778ce220e042a0902e7a85976e7e47">electron ipc 通信</a> 显然更适合传递消息而不适合共享数据。</p><h2 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h2><p>事实上，我们这个需求已经有人考虑过了，例如 electron-store 就已经实现了可以在渲染层、主进程均可使用。</p><ul><li><a href="https://www.npmjs.com/package/is-electron">is-electron</a>: 判断是否 electron 环境</li><li><a href="https://www.npmjs.com/package/electron-store">electron-store</a>: 在 electron 应用中存储数据</li></ul><p>那么，我们直接用 electron-store 有什么问题么？<br>是的，electron 仅能在 electron 中使用，所以在浏览器上会报错，而这对于开发环境而言是无法接受的，故而还需要检测环境使用不同的实现。</p><h2 id="创建浏览器兼容层"><a href="#创建浏览器兼容层" class="headerlink" title="创建浏览器兼容层"></a>创建浏览器兼容层</h2><p>使用策略模式实现不同环境下使用不同的存储</p><ul><li>浏览器使用 localStorage 实现</li><li>electron 中则使用 electron-store 实现</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> Store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron-store&quot;</span>;<br><span class="hljs-keyword">import</span> isElectron <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;is-electron&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; DeepReadonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;utility-types&quot;</span>;<br><br><span class="hljs-keyword">interface</span> BaseStore &#123;<br>  get(key: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStoreImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> store: Store;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> Store = <span class="hljs-built_in">window</span>.require(<span class="hljs-string">&quot;electron-store&quot;</span>);<br>    <span class="hljs-built_in">this</span>.store = <span class="hljs-keyword">new</span> Store();<br>  &#125;<br><br>  set(key: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-built_in">this</span>.store.set(key, value);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.store.get(key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalStorageImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BaseStore</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">localStorage</span>.getItem(key);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">localStorage</span>.setItem(key, value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;ElectronStore.store&quot;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronStore</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> [symbol]: BaseStore = isElectron()<br>    ? <span class="hljs-keyword">new</span> ElectronStoreImpl()<br>    : <span class="hljs-keyword">new</span> LocalStorageImpl();<br><br>  <span class="hljs-keyword">static</span> getInstance&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt;(<br>    init?: Partial&lt;T&gt;<br>  ): Partial&lt;&#123; [P <span class="hljs-keyword">in</span> keyof T]: DeepReadonly&lt;T[P]&gt; &#125;&gt; &#123;<br>    <span class="hljs-keyword">const</span> electronStore = <span class="hljs-keyword">new</span> ElectronStore();<br><br>    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, &#123;<br>      get(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(p);<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(text);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;,<br>      set(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">boolean</span> &#123;<br>        electronStore[symbol].set(<br>          p,<br>          value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-literal">null</span> ? <span class="hljs-built_in">JSON</span>.stringify(value) : value<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;,<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (init) &#123;<br>      <span class="hljs-built_in">Object</span>.entries(init).forEach(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> text = electronStore[symbol].get(k);<br>        <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">null</span> || text === <span class="hljs-literal">undefined</span>) &#123;<br>          proxy[k] = v;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> proxy;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能发现了，为了简化使用的 API，这里使用了代理模式拦截了对实例的访问，修改为使用 <code>get/set</code> 方法取值和设值。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来和一个普通的对象没什么区别，直接通过 <code>.</code> 访问或设置属性即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> userStore = ElectronStore.getInstance&lt;&#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> &#125;&gt;();<br>userStore.name = <span class="hljs-string">&quot;liuli&quot;</span>;<br><span class="hljs-built_in">console</span>.log(userStore.name === <span class="hljs-string">&quot;liuli&quot;</span>);<br>userStore.age = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(userStore.age === <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>具体代码在 <a href="https://github.com/rxliuli/electron_example/blob/ed158e9d013d7138697c76b52ddefb4748fe1af0/libs/electron-util/src/ElectronStore.ts#L40">electron_example</a>，由于是一个浅层封装，所以并未发布，但可以直接将模块复制到项目中使用。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 吾辈在公司推动的前端技术演进</title>
    <link href="/p/06cb464179cf45c598208534705aae3c/"/>
    <url>/p/06cb464179cf45c598208534705aae3c/</url>
    
    <content type="html"><![CDATA[<h2 id="上古时期"><a href="#上古时期" class="headerlink" title="上古时期"></a>上古时期</h2><blockquote><p>吾辈来的时候已然不多，但部分 mobile 嵌入的静态页面仍然是这种形式</p></blockquote><p>后端模板（JSP/FreeMarker）+ 前端静态 HTML 页面。那是个前端开发非常卑微的时代，除了还原 UI 和兼容性之外，所有业务逻辑、路由跳转、状态管理、部署维护都由后端包办完成。前端能做的事情非常有限，UI 还原、CSS 样式以及浏览器兼容性（例如传统前端需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧）是所需的关键技能点，或许还要负责 UI 相关的任务。但这其中，<strong>许多更偏向于「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值</strong>。</p><blockquote><p>参考: <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a><br>CSS 不是正交的，所以很麻烦，参考: <a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>问题</p><ul><li>难以应对大规模的项目开发，几乎没有工程化可言</li><li>前后端耦合导致修改、发布困难（就我们公司有个 gw 项目就是反例）</li><li>前端能做的事情非常有限，几近是后端的附属（App 有趣的一点就是极大的增强了客户端的能力，许多独立 App 开发者的工具类产品可能对后端的依赖极少）</li></ul><h2 id="跨入现代前端-vue-webpack"><a href="#跨入现代前端-vue-webpack" class="headerlink" title="跨入现代前端: vue + webpack"></a>跨入现代前端: vue + webpack</h2><ul><li>框架: vue</li><li>项目组织: git 分支 + 目录</li></ul><blockquote><p>在吾辈进来的时候基本是这样的</p></blockquote><p><img src="/resource/35bfc5fb414946209bf6cfeb33755e83.png" alt="1614382963380"></p><p>无论如何，前后端分离都已然是大势所趋，公司的项目也不例外，也从 jq 升级为了 vue。vue 是一个及其新手友好的框架，官方文档在前端开源框架中无出其右，所以选择它对招聘确实有一定的帮助（准入门槛低）。</p><p>但这里确实存在一些问题，主要如下</p><ul><li>vue 和 ts 结合的不好，所有前端项目，不是已经用了 ts，就是在走向 ts 的路上（去年 vue3 选择使用 ts 重写 v3）<ul><li>这是一个设计失误，因为 vue 作者更相信另一个 facebook 的静态类型脚本语言 flow.js，但它最终失败了</li></ul></li><li>vue 不是一个创新者，更像是一个现有技术的整合者，更新相比于 react v17/angular v11 慢得多（v3）</li><li>vue 和 ant design 结合的不好，因为蚂蚁金服使用 react 实现，vue 版本并非官方实现（关于这个 UI 框架的选择其实令吾辈有些困惑）</li><li>项目组织方面使用 git 分支 + 目录的形式可能是模仿了后端，但由于目录之间并非模块的形式加上 git 没有规范可言导致没有利用本地模块的优势反而只有劣势</li><li>有些项目使用原生 webpack 进行配置打包，而这实际上非常难以维护，参考: <a href="https://zhuanlan.zhihu.com/p/32148338">webpack 为什么这么难用？</a></li></ul><blockquote><p>典型项目: 前端旧项目</p></blockquote><h2 id="静态类型-引入-typescript"><a href="#静态类型-引入-typescript" class="headerlink" title="静态类型: 引入 typescript"></a>静态类型: 引入 typescript</h2><ul><li>语言: typescript</li><li>项目组织: 分散的 git 项目</li></ul><p>由于使用目录+分支管理的项目组织非常麻烦，所以后面的一些项目采用了每个业务创建一个 git 项目，然后最终将之打包整合到官网（其实就是不同的子路由），独立每个项目的开发和部署。而后希望通过 ts 的静态类型增强前端开发的效率及开发体验（主要是 IDE 在提示、重构和导航方面的支持），所以将之引入了进来，吾辈有自信可以解决任何遇到的 ts 问题。</p><p><img src="/resource/16eb9eef10704ee49b7097e04bf8344f.png" alt="1614383048466"></p><p>但老实说，问题仍然没有完全解决</p><ul><li>ts 和 vue 2 结合的不好，甚至 vue 3 中 ts 也没能解决模板层面的问题，参考: <a href="https://github.com/JetBrains/web-types/issues/15">web-types 讨论</a></li><li>分散的 git 项目之间如果存在相同代码，比较难以共享（但因为有 npm 私服所以还不太明显）</li><li>组件粒度较粗，比较小的组件难以抽取</li></ul><blockquote><p>典型项目: 新管理后台</p></blockquote><h2 id="替换框架为-react"><a href="#替换框架为-react" class="headerlink" title="替换框架为 react"></a>替换框架为 react</h2><p>事实上，引入 react 没有 ts 那么安全，因为这次吾辈不能说<strong>吾辈有自信可以解决任何遇到的 react 问题</strong>，因为吾辈也没有实际生产环境的经验。但吾辈仍然引入了，有以下几个考量</p><ul><li>更好的结合 ts 使用</li><li>直接使用官方维护的 ant design for react 版本</li><li>相比于 vue 好得多的 IDE 支持</li><li>更好的开发大型项目（报告系统）</li><li>尝试变化，使用最新的技术</li></ul><p>但这仍然并非终点，在报告系统项目中，单个前端项目的代码量首次达到了 2w+ 行（至今已到 4w+），分割模块势在必行，这里就提到了需要使用到 lerna 了。</p><blockquote><p>典型项目: 公开图库</p></blockquote><h2 id="引入-lerna-以使用-monorepo"><a href="#引入-lerna-以使用-monorepo" class="headerlink" title="引入 lerna 以使用 monorepo"></a>引入 lerna 以使用 monorepo</h2><ul><li>项目组织: monorepo</li></ul><p>Java 后端的项目天然是 monorepo（因为 maven 的原因），而前端在很长时间内都没有类似的工具，直到吾辈遇到了 lerna。这点某位离职的同事有曾提及，但直到几个月后报告系统第一版基本结束时进行重构才真正实用。<br>使用它吾辈改进了以下几点问题</p><ul><li>使用 monorepo 更好的组织模块，保证项目在超过 4w 行代码、20 个模块时仍然保持可维护性</li><li>更简单的共享和复用代码，只要抽离一个模块即可在所有模块直接引用它了</li><li>更加容易统一整个项目的技术栈，引入一个依赖的不同版本几乎不可能出现了</li><li>更加容易容易统一项目的配置，保证整个项目的代码风格都是一致的（例如 eslint/prettier）</li></ul><p><img src="/resource/81950aa48e2b4885b3be6ade3c3d745b.png" alt="1614383172095"></p><blockquote><p>典型项目: 旧版报告系统</p></blockquote><h2 id="引入-gh-pages-简化打包"><a href="#引入-gh-pages-简化打包" class="headerlink" title="引入 gh-pages 简化打包"></a>引入 gh-pages 简化打包</h2><p>事实上，生产环境的发布一直非常麻烦，即便建宏已经实现了两版的发布系统，但目前使用体验仍然不算好（gw 项目必须要用），但前后端分离的项目却不尽然。后来在一个偶然的情况下，吾辈发现了一种更高效的方式: <a href="/p/32a5980cdf284cf2b107a3ee04ff71f4">使用 gh-pages 发布前端项目</a>，同时喜获冰淇淋一个。</p><blockquote><p>当然，由于后来主要在开发 electron 客户端，web 项目在生产环境的发布变得较少，但这件事仍然证明只要将现有的工具整合起来，仍然可能极大的提高生产力</p></blockquote><p><img src="/resource/456f8dc4b70f4acea94b7351a9a23f69.png" alt="1614383397001"></p><blockquote><p>典型项目-大屏看板</p></blockquote><h2 id="rushstack-标准化的前端-monorepo"><a href="#rushstack-标准化的前端-monorepo" class="headerlink" title="rushstack: 标准化的前端 monorepo"></a>rushstack: 标准化的前端 monorepo</h2><ul><li>项目组织: lerna monorepo =&gt; <a href="https://rushstack.io/">rushstack</a></li></ul><p>虽然 lerna 可以分割模块，但它并没有所谓的最佳实践，事实上，吾辈在微软的 monorepo 工具 rush 的相关项目 rushstack 中找到了一种最佳实践，在形式上有许多参考价值（虽然由于大而全且包含许多问题的原因导致没有 lerna 使用广泛），最新的两个生产项目均已重构成这种形式的 monorepo 项目，稍晚一些会将它们合并，便于之后它们的整合。</p><p><img src="/resource/57039ed47d574e088cc572d68ec6fad7.png" alt="1614431686700"></p><p>在 rushstack 的介绍中有这么一段话非常有趣：<br>灵活性有其缺点。Node.js 工具因其令人困惑的选项而臭名昭著：选择您的编译器、linter 工具、打包工具、包管理器、任务引擎、单元测试工具、测试断言库等。一旦决定（<strong>下了赌注</strong>），整合所有这些组件就变成了自己的软件项目。随着规模的扩大，这些成本可能会迅速增加！<br>核心就是前端定制需求过多，要求工具链非常灵活，进而导致无法标准化（和现在的报告系统业务面临的问题多么相似。。。）</p><blockquote><p>典型项目 miis</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="统一和规范"><a href="#统一和规范" class="headerlink" title="统一和规范"></a>统一和规范</h3><ul><li>定义统一的业务目录的结构，形成约定俗成</li><li>通过更高层的 cli 抽象强制统一 <code>lib</code> 的项目结构，例如入口文件一定是 <code>lib/src/index.ts</code>，出口一定是 <code>dist/index.js</code>，而打包出来的一定默认支持 <code>esm/commonjs</code></li><li>使用 prettier+git hooks 统一项目中的代码风格</li><li>通过 syncpack 统一多个模块之间的依赖版本</li><li>通过多个模块中的 npm script，例如启动 web 项目的开发环境是 <code>start</code>，启动 electron 开发环境则是 <code>dev:win/mac</code>，打包项目是 <code>build</code>，而 <code>libs</code> 的模块打包发布是 <code>pub</code>，打包 electron 项目是 <code>pkg:*</code></li></ul><h3 id="分层和解耦"><a href="#分层和解耦" class="headerlink" title="分层和解耦"></a>分层和解耦</h3><ul><li>通过 monorepo 分割 electron 项目不同的进程，将之作为单独的 nodejs 项目和 react 项目管理和发布</li><li>通过使用 api class 的形式，将与后端的连接封装在单独的逻辑层，定义参数、返回值的类型，业务层直接引用相关的单例对象调用方法即可</li></ul><blockquote><p>吾辈也好奇现代前端框架强绑定、重 UI 层的现在，如何更好的分离 UI 与业务逻辑</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>使用 lerna 的 <code>--include-dependencies --stream</code> 参数尽可能按照依赖顺序并发运行命令，例如打包所有模块</li><li>为了减少安装依赖上的麻烦，尝试过 <code>nrm/yrm</code> 改源，<code>npmrc</code> 配置镜像，但最终还是要求所有前端必须能够使用 SSR+透明代理工具，否则无法启动项目</li><li>在公司 blog 上分享一些自己的心得和感触</li><li>通过使用 docsify 提升文档维护者的体验，使用 VSCode 编辑文档，然后使用 git 提交便自动部署了</li><li>引入 storybook 为通用组件编写交互式文档</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>公司前端文档: 公司的前端项目在线文档，使用 git + markdown 增强开发者编辑体验，希望更多人在更好的维护它</li><li>common-util: 前端工具库，近期使用 monorepo 将之彻底重构<br>至少优化了以下几项<ul><li>[x] 清理不需要的功能，减少了 60% 的代码</li><li>[x] 使用 monorepo 增强项目的可维护性</li><li>[x] 支持 nodejs 引入</li><li>[ ] 使用 monorepo 分割打包减小在项目中的引入成本 – babel 的 567 三个版本转变的惨剧历历在目</li><li>[ ] 找到对用户更友好的使用方式 class vs function – 面向对象 vs 函数式</li></ul></li><li>web-logger: 前端日志，已在报告系统及之后后所有的前端项目中实用，目前还未支持 nodejs</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>经验</tag>
      
      <tag>公司</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践 lerna monorepo</title>
    <link href="/p/cd66150d2b86448590fcc9bb2419c0b2/"/>
    <url>/p/cd66150d2b86448590fcc9bb2419c0b2/</url>
    
    <content type="html"><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>上古时期，前端没有工程化的概念可言，复用代码也不过是将某些 css、js 代码片段保存到笔记，需要时复制到项目中，仅此而已。参考：<a href="https://github.com/Wscats/CV/issues/29">55 个提高你 CSS 开发效率的必备片段</a>，或是 <a href="http://www.htmleaf.com/jQuery/">jquery 库</a></li><li>莽荒时代，前端出现了 nodejs 和 npm，于是一大批通用代码被发布到了 npm 平台，可以在项目中简单配置即可使用通用的库，任何人都可以简单的将代码发布到 npm。参考：<a href="https://www.npmjs.com/package/lodash">lodash</a></li><li>现代，由于前端项目的复杂度逐渐上升，所以出现了 monorepo 工具以更简单的复用代码。例如层出不穷的 monorepo 支持工具 <a href="https://lerna.js.org/">lerna</a>、<a href="https://rushjs.io/">@microsoft/rush</a>、<a href="https://yarnpkg.com/features/workspaces">yarn 2</a>、<a href="https://pnpm.js.org/en/workspaces">pnpm</a>、<a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><blockquote><p>自去年 10 月开始，吾辈使用 lerna 重构个人和公司的项目，以应对愈加复杂的前端项目。</p></blockquote><h2 id="为什么需要-monorepo？"><a href="#为什么需要-monorepo？" class="headerlink" title="为什么需要 monorepo？"></a>为什么需要 monorepo？</h2><blockquote><p>借用一下 lerna 官网的简介：</p><p>将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。</p><p>为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel、 React、Angular、Ember、Meteor、Jest 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。</p></blockquote><p>你可能会认为除了大型开源项目之外，monorepo 对于小型项目和生产环境的业务项目没有太多价值。但这是错的，前者我在微型工具库 <a href="https://github.com/rxliuli/liuli-util">liuli-util</a> 上进行了实践，确定了它对于维护和使用确实有帮助。而后者，甚至出现了专门为业务项目的 monorepo 工具 <a href="https://rushjs.io/pages/intro/why_mono/">@microsoft/rush</a>，微软在 <a href="https://github.com/microsoft/rushstack">rushstack</a> 项目中大规模使用了它。</p><h2 id="为什么选择-lerna？"><a href="#为什么选择-lerna？" class="headerlink" title="为什么选择 lerna？"></a>为什么选择 lerna？</h2><p>那么，有了这么多 monorepo 工具，为什么我们选择 lerna？</p><ul><li><a href="https://lerna.js.org/">lerna</a></li><li><a href="https://rushjs.io/">@microsoft/rush</a></li><li><a href="https://yarnpkg.com/features/workspaces">yarn 2</a></li><li><a href="https://pnpm.js.org/en/workspaces">pnpm</a></li><li><a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm 7</a></li></ul><p>其实，除了 lerna 与 @microsoft/rush 之外，其它竞争对手都是包管理器，仅仅只是提供了 workspace 的工作空间，并未提供更高级功能。</p><blockquote><p>lerna 和 @microsoft/rush 的 npm 趋势对比参考: <a href="https://www.npmtrends.com/lerna-vs-@microsoft/rush">https://www.npmtrends.com/lerna-vs-@microsoft/rush</a></p></blockquote><p>下图是一个对比</p><table><thead><tr><th>对比项</th><th>lerna</th><th>@microsoft/rush</th></tr></thead><tbody><tr><td>star</td><td>26,824</td><td>2,392</td></tr><tr><td>周下载</td><td>1,155,241</td><td>100,386</td></tr><tr><td>使用者</td><td>知名开源项目</td><td>微软系产品</td></tr></tbody></table><p>就吾辈的实际使用体验而言，相比于 lerna，rush 默认包含了更多的东西，而非通过组合一系列可选的工具支持，这增长了相当的门槛。</p><p>下面是吾辈对其的一些认知过程</p><ul><li>rush.js 是真的感觉很【专业】，限定了很多很多东西</li><li><a href="https://rushjs.io/pages/maintainer/setup_policies/">https://rushjs.io/pages/maintainer/setup_policies/</a></li><li>像是这里，通过 allowedPackagesPolicy 的方式对 team 中所有开发人员都可以直接引入新的 npm 包做出了限制</li><li>唉，rush 比 lerna 复杂多了，做了很多很多的预定义的事情，这就意味着，它对项目维护者（而非开发者）的要求更高</li><li>和 ide 没完全集成真痛苦.JPG</li><li>吾辈总算明白这些配置为什么是【推荐配置】而不是【默认配置】了，引发的错误太多了（毕竟 npm 包很多并不规范）</li><li>rush monorepo 的一个问题是，某些包总喜欢强制指定依赖包的特定版本（例如 react-scripts），而 rush 总是“聪明”的仅安装最新的，导致添加的项目莫名其妙的炸掉</li><li>吾辈的锅，它在最后给了方法 <a href="https://rushjs.io/pages/advanced/installation_variants/">https://rushjs.io/pages/advanced/installation_variants/</a></li><li>但一整个进阶主题都是在处理这个问题。。。</li><li>算了，吾辈放弃了，rush + pnpm 感觉上维护配置成本太高了，滚回 lerna + yarn 了</li></ul><blockquote><p>rush 在功能、目标和文档方面更好，但现阶段而言还是 lerna 更成熟。</p></blockquote><h2 id="lerna-是什么？"><a href="#lerna-是什么？" class="headerlink" title="lerna 是什么？"></a>lerna 是什么？</h2><p>简而言之，Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。可以在一个项目中创建多个模块（基本上模块也可以认为是一个项目），并且可以在本地的模块之间互相关联。</p><p>lerna 项目的基本结构如下</p><p>生产项目</p><ul><li>根目录<ul><li><code>apps</code>: 生产项目<ul><li><code>app-1</code></li><li><code>app-2</code></li></ul></li><li><code>libs</code>: 通用模块<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><p>开源库</p><ul><li>根目录<ul><li><code>libs</code>: 模块根目录<ul><li><code>lib-1</code></li><li><code>lib-2</code></li></ul></li><li><code>package.json</code></li><li><code>lerna.json</code></li></ul></li></ul><blockquote><p>目录的名字灵感来源于 <a href="https://github.com/microsoft/rushstack">rushstack</a></p></blockquote><h2 id="使用-lerna-的优点"><a href="#使用-lerna-的优点" class="headerlink" title="使用 lerna 的优点"></a>使用 lerna 的优点</h2><blockquote><p>其中部分优点是 monorepo 固有的优势，但也有 lerna 独有的功能。</p></blockquote><ul><li>更容易抽离公共代码: 模块之间可以互相引用并且即时生效</li><li>更容易统一<ul><li>项目配置: <code>tsconfig.json/prettier.json/git hooks</code></li><li>管理和发布一系列包: <code>lerna publish</code></li><li>修改依赖立刻生效: <code>lerna bootstrap</code></li><li>依赖版本: 和默认合并不同版本的依赖</li><li>文档生成和合并: <code>fliegdoc</code></li><li>代码风格: <code>prettier/git hooks</code></li><li>在一个模块运行另一个模块的命令: <code>lerna run &lt;cmd&gt; --scope &lt;pkg&gt;</code></li><li>打包工具和流程: 封装更适合项目的打包 cli</li></ul></li></ul><p>目前稍微大点的开源项目不是已经转为了 lerna monorepo，就是已经在转换的路上（很像最近流行的使用 typescript 重构库）。包括但不限于以下这些：</p><p><img src="/resource/24e42e4188d24083b7ecf647048793f3.png" alt="1614158368615"></p><blockquote><p>吾辈目前使用的笔记工具 Joplin 也在去年使用 lerna 重构了，参考：<a href="https://github.com/laurent22/joplin/pull/4039">Lerna migration</a>。</p></blockquote><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="根据依赖图并行运行-npm-命令"><a href="#根据依赖图并行运行-npm-命令" class="headerlink" title="根据依赖图并行运行 npm 命令"></a>根据依赖图并行运行 npm 命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lerna run &lt;npm script&gt; --include-dependencies --stream<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://github.com/lerna/lerna/blob/main/commands/run/README.md#--stream">–stream</a> 和 <a href="https://github.com/lerna/lerna/blob/main/core/filter-options/README.md#--include-dependencies">–include-dependencies</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 lerna 虽然会增加一些复杂度，但带来的优点仍然是超过缺点的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blog 评论系统推荐</title>
    <link href="/p/d85bf515106f437b8dfe59ae27b8a999/"/>
    <url>/p/d85bf515106f437b8dfe59ae27b8a999/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>长期以来，吾辈通过 RSS 阅读各种 blog，想要评论时却发现很麻烦，所以来推荐一下 blog 的评论系统。</p><p>评论系统大概有如下几种形式</p><ul><li>基于第三方评论服务</li><li>输入名字邮箱即可发表评论</li><li>注入博客用户才可以发布评论（没怎么用过，不予置评）</li></ul><h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><p>基于第三方评论服务这里选择的是吾辈目前正在使用的 disqus，而评论选择是某位博主的评论系统。</p><p>两者截图如下</p><p><img src="/resource/7a30349574774784bd3652275e86b6f1.png" alt="基于第三方评论服务"><br><img src="/resource/4835d7ba3ae24f8fa176e25a0541dcd9.png" alt="输入名字邮箱即可发表评论"></p><table><thead><tr><th>对比项</th><th>基于第三方评论服务</th><th>输入名字邮箱即可发表评论</th></tr></thead><tbody><tr><td>UI 对比</td><td>标准 UI</td><td>与网站更契合的比较萌的 UI</td></tr><tr><td>账户系统</td><td>需要注册 disqus</td><td>不需要账号</td></tr><tr><td>修改/删除评论</td><td>是</td><td>否</td></tr><tr><td>需要代理</td><td>是</td><td>取决于博客的部署方式</td></tr></tbody></table><p>就吾辈个人而言，最不能忍受的是无法修改评论，即使存在一些错误，例如截图中吾辈的评论中就有一个错别字，但却无法修改。而另一方面，disqus 的 UI 确实不可能和网站整体风格完全一致，这也是自定义博客评论系统更强大的地方。但老实说，相比于 UI，吾辈更在意的是功能性，disqus 已经有许许多多的人注册过，所以有天生的用户群。至于代理的问题，吾辈找不到好的解决方案，国内的类似产品，不是已经死了（多说），就是已经变成垃圾。</p><blockquote><p>实际上代理的问题还是有办法的，虽然还是有点麻烦。参考：<a href="https://blog.fooleap.org/use-disqus-correctly.html">科学使用 Disqus</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2021 读书计划</title>
    <link href="/p/c6c709f7b7594e7e999ca24e5afee060/"/>
    <url>/p/c6c709f7b7594e7e999ca24e5afee060/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>由于受到 <a href="https://blog.k8s.li/2020-booklist.html">木子(读书机器人)</a> 的影响，所以吾辈打算 2021 读更多的书，希望能达到以下几个目标。</p><ul><li>将读书变成一个习惯</li><li>提升自己的认知</li><li>学习更多计算机基础知识</li><li>坚持读比较难读的书</li></ul><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><ul><li>这就是投资人</li><li>这就是保险代理人</li><li>TCP 详解（1）</li><li>网络是怎么连接的</li><li>论人类不平等的起源</li><li>规模</li><li>爆裂</li><li>原则</li><li>金字塔原理</li><li>上帝造人有多难</li><li>大学之路</li><li>女士品茶</li><li>增长的极限</li><li>被讨厌的勇气</li><li>来自新世界</li><li>异类</li><li>宇宙-从起源到未来</li><li>修改代码的艺术</li><li>解忧杂货铺</li><li>朝花夕拾</li><li>地铁</li><li>家有女友</li><li>神雕侠侣</li><li>数学女孩</li><li>什么是数学</li><li>SICP 计算机程序的构造和解释</li><li>算法 4(在读)</li></ul><blockquote><p>读书历史将在 <a href="https://blog.rxliuli.com/about/">关于页面</a> 更新。</p></blockquote><h2 id="实行"><a href="#实行" class="headerlink" title="实行"></a>实行</h2><p>在上下班通勤、中午以及晚上回去时多读点书（当然还是不能影响休息），反正读书总比将时间浪费在 Youtube、小说、游戏上要好，不是么？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立个 Flag，今年入坑 Kigurumi 并出一次漫展</title>
    <link href="/p/78d7cae2e92e4e518b2aa89337be85d8/"/>
    <url>/p/78d7cae2e92e4e518b2aa89337be85d8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Kigurumi 是什么？能吃么？</li><li>是一种 cosplay 服装扮演，不能吃谢谢。</li></ul><p>借用 <a href="https://en.wikipedia.org/wiki/Animegao_kigurumi">Wiki</a> 中的描述：“人偶扮演（着ぐるみ Kigurumi ?），是一种透过穿着类似 吉祥物服装的全身套装以在现实世界中达成还原卡通或动漫人物的 cosplay 形式。和 cosplay 不一样的是，表演者的脸会被 面具完整的包住，所穿着的服装也会掩盖住全身，借此表演者得以完全隐藏自己原本的身份，完全成为所要扮演的角色。早年 Kigurumi 只会出现在舞台秀上，近年来则逐渐变成 cosplayer 的一种扮演模式。在日本，这种形式的角色扮演又被称为是アニメ顔（中文：动漫颜），但一直以来都只有少数的玩家参与其中。约在 2005 年后，Kigurumi 慢慢地在各个国家和地区流行开来，包括中国，甚至是美国、加拿大与欧洲等地区。”</p><p>预定 cosplay 角色是 <a href="https://zh.moegirl.org.cn/zh-cn/%E6%98%A5%E6%97%A5%E9%87%8E%E7%A9%B9">春日野穹</a></p><p><img src="/resource/eca6e2291609442092bb642d71361621.png" alt="1613708879214"></p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><ul><li><a href="https://item.taobao.com/item.htm?id=35058414957">头壳</a></li><li><a href="https://item.taobao.com/item.htm?id=26710864059">Kigurumi 皮肤</a></li><li><a href="https://item.taobao.com/item.htm?id=45759058514">Kigurumi 义乳</a></li><li><a href="https://item.taobao.com/item.htm?id=45035590608">Cosplay 服装</a></li><li>其他杂费，包括但不限于鞋子、玩偶、额外材料费等</li></ul><p>预计花费 7038 软妹币，入坑门槛是真的高 XD。</p><blockquote><p>算是弥补不去吃糖的一些遗憾吧</p></blockquote><hr><h2 id="已购"><a href="#已购" class="headerlink" title="已购"></a>已购</h2><p>确定了，大概要两个月吧</p><p><img src="/resource/9d806143ded14c91838f14a0e32a9463.png" alt="1614431297462"><br><img src="/resource/939e92e7508b4b86b7c86dbf1d26ea32.png" alt="1614431308200"></p><p>暂时还未购买服装之类的东西，但这也是因为需要后续再确认一下身体尺码的参数是否正确之类的而已（另外吾辈已然有了 xd）。</p><h2 id="衣服到了"><a href="#衣服到了" class="headerlink" title="衣服到了"></a>衣服到了</h2><p>f 居然有 4 斤，看来女生确实很辛苦呢</p><p><img src="/resource/505568ee19524c2fa12a29cfe629f9a4.png" alt="1615473034848"></p><blockquote><p>由于身高问题，所以显得很小而已。。。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>个人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 与图片共存时的布局问题</title>
    <link href="/p/5440a5dfdf654d6bbff36614afda98fc/"/>
    <url>/p/5440a5dfdf654d6bbff36614afda98fc/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在生产中遇到的一个 css 问题，css 不正交的问题一直有人吐槽，吾辈今天总算也是遇到了，实在是不吐不快。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/29888231">CSS 为什么这么难学？</a></p></blockquote><p>如下一个简单的二维横向图片列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  * &#123;<br>    padding: 0;<br>    margin: 0;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.rows</span> &#123;</span><br>    height: 500px;<br>    display: grid;<br>    grid-template-rows: repeat(5, 1fr);<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.cols</span> &#123;</span><br>    height: 100%;<br>    display: flex;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> &#123;</span><br>    height: 100%;<br>  &#125;<br><span class="css">  <span class="hljs-selector-class">.item</span> <span class="hljs-selector-tag">img</span> &#123;</span><br>    max-height: 100%;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rows&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;items of list&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cols&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of items&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.url&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 下面是生成一些测试数据，不需要关心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/faker@5.2.0/dist/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&quot;.rows&quot;</span>,</span><br>    data: &#123;<br><span class="javascript">      list: <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>)</span><br>        .fill(0)<br><span class="javascript">        .map(<span class="hljs-function">() =&gt;</span></span><br><span class="javascript">          <span class="hljs-built_in">Array</span>(faker.random.number(&#123; <span class="hljs-attr">min</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">20</span> &#125;))</span><br>            .fill(0)<br><span class="javascript">            .map(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">              <span class="hljs-keyword">const</span> getNumber = <span class="hljs-function">() =&gt;</span></span><br>                faker.random.number(&#123; min: 200, max: 300 &#125;);<br><span class="javascript">              <span class="hljs-keyword">return</span> [getNumber(), getNumber()];</span><br>            &#125;)<br><span class="javascript">            .map(<span class="hljs-function">(<span class="hljs-params">[x, y]</span>) =&gt;</span> (&#123;</span><br>              width: x,<br>              height: y,<br><span class="javascript">              url: <span class="hljs-string">`https://picsum.photos/seed/picsum/<span class="hljs-subst">$&#123;x&#125;</span>/<span class="hljs-subst">$&#123;y&#125;</span>`</span>,</span><br>            &#125;))<br>        ),<br>    &#125;,<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但显示的效果却并非预想中那样五等份，而是会超过最大高度 – 被图片撑高了。</p><p><img src="/resource/cf0f928264d2469ab22f6e4d999f6319.png" alt="1611716016173.png"></p><p>而在经过一番摸索和讨论后，吾辈找到了这个规范：<a href="https://drafts.csswg.org/css-grid/#algo-terms">https://drafts.csswg.org/css-grid/#algo-terms</a></p><p>grid 的 fr 单位实际上是个弹性值，如果内容过大，则会撑开。。。而图片的默认大小就是过大的内容。如果显式声明了最小值，就不受图片尺寸的影响了。</p><p>修改 <code>grid-template-rows: repeat(5, 1fr);</code> =&gt; <code>grid-template-rows: repeat(5, minmax(0, 1fr));</code> 就好了。</p><p>效果</p><p><img src="/resource/ad26ac5cd11b4a558ee1cdc674f942a7.png" alt="1611716716541.png"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>发明 CSS 的人就是一个智障，这么多不正交的规则纯靠经验真的太恶心了（不是每个人都了解或者说希望了解那些奇奇怪怪的规范）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-electron 自定义协议</title>
    <link href="/p/ff86c5343d38460a8e78a62617f9eace/"/>
    <url>/p/ff86c5343d38460a8e78a62617f9eace/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候需要与其他程序进行交互时，自定义协议是一个不错的选择 – 它能在程序为启动时启动程序然后处理其它程序的动作，而这是其它解决方案，包括 HTTP 请求、共享数据库不能比的。其实日常生活中也有现成的例子，迅雷的自定义协议下载链接、BitTorrent 协议、百度网盘启动本地客户端等等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">将当前可执行文件设置为协议的默认处理程序（注册表级别）</a></p></blockquote><ol><li> 让程序保持单例启动</li><li> 设置客户端支持的协议（在 Windows 中会写入到注册表）</li><li> 处理命令行参数找到其中需要的 <code>url</code> 信息</li><li> 监听 <code>ready</code> 和 <code>second-instance</code> 事件</li></ol><h3 id="让程序保持单例启动"><a href="#让程序保持单例启动" class="headerlink" title="让程序保持单例启动"></a>让程序保持单例启动</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock">app.requestSingleInstanceLock()</a><br>注: 仅在单例模式下才能监听 <code>second-instance</code> 事件</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 请求单例锁，避免打开多个 electron 实例</span><br><span class="hljs-keyword">const</span> gotTheLock = app.requestSingleInstanceLock();<br><span class="hljs-keyword">if</span> (!gotTheLock) &#123;<br>  app.quit();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置客户端支持的协议（在-Windows-中会写入到注册表）"><a href="#设置客户端支持的协议（在-Windows-中会写入到注册表）" class="headerlink" title="设置客户端支持的协议（在 Windows 中会写入到注册表）"></a>设置客户端支持的协议（在 Windows 中会写入到注册表）</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args">app.setAsDefaultProtocolClient(protocol[, path, args])</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端默认支持的协议</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultProtocolClient</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> protocol: <span class="hljs-built_in">string</span></span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 注册一个默认支持打开的协议</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 开发模式下在 window 运行需要做兼容</span><br>    <span class="hljs-keyword">if</span> (<br>      process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span> &amp;&amp;<br>      process.platform === <span class="hljs-string">&quot;win32&quot;</span><br>    ) &#123;<br>      <span class="hljs-comment">// 设置 electron.exe 和 app 的路径</span><br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol, process.execPath, [<br>        path.resolve(process.argv[<span class="hljs-number">1</span>]),<br>      ]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      app.setAsDefaultProtocolClient(<span class="hljs-built_in">this</span>.protocol);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 从命令行参数中找到 url</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment">   */</span><br>  findUrl(argv: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#123;<br>    <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.protocol&#125;</span>://`</span>);<br>    <span class="hljs-keyword">return</span> argv.find(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> regExp.test(str));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaultProtocolClient = <span class="hljs-keyword">new</span> DefaultProtocolClient(<span class="hljs-string">&quot;custom-protocol&quot;</span>);<br><br><span class="hljs-keyword">await</span> defaultProtocolClient.register();<br></code></pre></td></tr></table></figure><h3 id="处理命令行参数找到其中需要的-url-信息"><a href="#处理命令行参数找到其中需要的-url-信息" class="headerlink" title="处理命令行参数找到其中需要的 url 信息"></a>处理命令行参数找到其中需要的 <code>url</code> 信息</h3><p>添加函数 <code>handleDefaultProtocol</code> 从命令行参数中找到 url 然后处理它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理客户端支持的默认协议</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">argv</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDefaultProtocol</span>(<span class="hljs-params">argv: <span class="hljs-built_in">string</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> url = defaultProtocolClient.findUrl(argv);<br>  <span class="hljs-keyword">if</span> (!url) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">await</span> dialog.showMessageBox(&#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;info&quot;</span>,<br>    message: <span class="hljs-string">&quot;window protocol 自定义协议打开&quot;</span>,<br>    detail: <span class="hljs-string">` 链接:<span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听-ready-和-second-instance-事件"><a href="#监听-ready-和-second-instance-事件" class="headerlink" title="监听 ready 和 second-instance 事件"></a>监听 <code>ready</code> 和 <code>second-instance</code> 事件</h3><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#%E4%BA%8B%E4%BB%B6-second-instance">事件: ‘second-instance’</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">app.addListener(<span class="hljs-string">&quot;second-instance&quot;</span>, <span class="hljs-keyword">async</span> (event, argv) =&gt; &#123;<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(argv);<br>&#125;);<br>app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> createMainWindow();<br>  <span class="hljs-keyword">await</span> handleDefaultProtocol(process.argv);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h2><p>既然我们自定义协议的目的是让外部程序调用，那么如何使用外部调用就很重要了。</p><p>首先检查注册表中是否已经包含它了，操作 <em>ctrl+s =&gt; 搜索注册表 =&gt; 进入注册表 =&gt; ctrl+f 查找 <code>custom-protocol</code></em></p><p><img src="/resource/79c71d68b3af4760b30d9778e24876f1.png" alt="注册表"></p><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><p>如上图所示，可以简单在浏览器中输入 <a href="custom-protocol://test">custom-protocol://test</a> 来启动程序。</p><p><img src="/resource/90ebe2632f0f441c9c1c39bdecb1f5d3.gif" alt="自定义协议效果"></p><h3 id="nodejs-示例"><a href="#nodejs-示例" class="headerlink" title="nodejs 示例"></a>nodejs 示例</h3><p>在 nodejs 中使用 npm 包 <a href="https://www.npmjs.com/package/open">open</a> 可以轻易打开自定义默认链接。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> open <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;open&quot;</span>;<br><br>open(<span class="hljs-string">&quot;custom-protocol://test&quot;</span>);<br></code></pre></td></tr></table></figure><p>其实本质上就是拼接命令，然后执行系统命令打开 url，参考<a href="https://github.com/sindresorhus/open/blob/master/index.js">它的实现</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端与后端的选择（个人理解）</title>
    <link href="/p/e6718c0c7fba4b84a6d3a712a6b1910b/"/>
    <url>/p/e6718c0c7fba4b84a6d3a712a6b1910b/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>吾辈就是一个从 Java Web 后端转到前端的人。</p></blockquote><p>吾辈今天又在看到人说 <strong>前端很简单，而且还比后端工资高</strong>，这里吾辈还是想做一些澄清的。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><ul><li>后端 A: 我发现这两年前端的工作特别好找，而且工资很高</li><li>后端 A：后端内卷太严重了。</li><li>后端 B: #无语</li><li>后端 B: 前端要会啥啊到底才能称得上前端</li><li>后端 A: 我们这边。H5+小程序 就行了</li><li>后端 A: 主要是 CSS 要能处理好。。。</li><li>后端 A: 设计做出来的东西要不能有折扣的做出来。。而不是向组件找不到妥协。。。。</li><li>后端 B：我感觉我很合适唉，虽然我没怎么做过小程序</li><li>后端 B: 有没有 Java 转前端的啊</li><li>吾辈：吾辈就是 @后端 B</li><li>吾辈：可能泥萌那是 2c 的业务，像吾辈这边偏向于 2b 的，业务和架构的复杂度相当高，事实上，吾辈这边的前端架构都已经需要微服务化了（即所谓的微前端）</li><li>后端 C：微前端</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。</li><li>吾辈: 这其实有个错觉就是，前端开发岗位多，开发人员多，就一定好找工作。Java 还不是有很多培训班为市场注入了许多后端，而 web 其实也很糟糕，因为似乎所有人都开始觉得前端只要会 vuejs 加点 html/css/js 就可以开始工作了，恰好市场这两年的缺口还很大，所以培训班其实也为市场注入了相当的人员，导致招聘很难招，工作很难找。（不过不吹不黑，吾辈确实因为转到前端发生了发生了很多变化，尤其是在开源项目方面，之前基本不做，现在嘛，有时间就会做一些 #本质原因可能还是因为前端还不够成熟吧）</li><li>后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。。@吾辈</li><li>后端 D: 不是说前端比较抗骂嘛</li><li>吾辈：你什么时候产生了前端比后端工资高的错觉，就那吾辈的公司来说，前端 10-20，后端 golang 15-20，Java 18-35 (´-ι_-｀)</li><li>吾辈：另外前端技术栈迭代非常快，前后端的边界正在后移，想想之前后端还要负责模板引擎，路由，状态管理，逻辑代码，工程化方面的任务，现在，这些都成为了前端的任务，而且之前的任务 ui 还原还没少，而后端在吾辈看来的一个主要问题在于用户量不够的情况下基本没得折腾，意味着许多 idea 无法在生产环境落地，后端技术栈迭代也很慢（主要是由于风险更高以及成熟度），现在还是 Java 8，而前端，基本都是跟着版本跑（当然这会带来 js 疲劳暂且不说），生产环境吾辈已经上了 ts 4（半年之前更新的大版本）。还有一点我不确定是否是常事，一般后端似乎没有自己维护的开源项目，这很显然是没法在生产之外尝鲜新技术的，一年经验用十年，不外如是。</li><li>吾辈：另外觉得前端简单的可以看一下这一系列谈话（前后端之间的，2016 年的，现在前端更加复杂化了）<a href="/p/9970e725452b49e496324842a7e283dd">2016 年里做前端是怎样一种体验</a></li></ul><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>就吾辈个人的感觉而言，似乎许多后端还不清楚前端领域到底发生了什么，觉得前端还仅仅是 <strong>切图</strong>，而这显然是个错误。</p><p>前端近几年发展迅速，几乎可以说是日新月异，尽管可能大部分都会被扫进历史的垃圾堆，但至少能够切身参与到发展的历史进程中。而且，现在前端要解决的问题域也在发生变化，在传统前端眼里，CSS（UI 还原）和兼容性问题是最重要的，但现在，已然天翻地覆，前端本身的知识领域也在发生割裂，参考: <a href="https://css-tricks.com/the-great-divide/">大分裂</a>。</p><blockquote><p>当然在很久以前，前端也有独特的「复杂问题」，比如我刚工作那会需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧，但这类问题更偏向「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值。</p></blockquote><p>而后端，经过几十年的长足发展，已经非常完善，似乎没有太大的变化了。当然，就像 <a href="https://www.zhihu.com/question/375448022">前端为什么会越来越复杂？</a> 所言，<strong>「后端是在业务方面革自己的命，使劲在平台化、中台化发展，然后把具体业务这块解放给前端」</strong>。</p><table><thead><tr><th>分类</th><th>前端</th><th>后端</th></tr></thead><tbody><tr><td>发展速度</td><td>迅速</td><td>缓慢</td></tr><tr><td>发展程度</td><td>发展中</td><td>成熟</td></tr><tr><td>试错成本</td><td>低</td><td>高（后台服务炸掉是很难被接受的）</td></tr><tr><td>知识价值</td><td>低（发展迅速带来的疲劳）</td><td>高</td></tr><tr><td>入门难度</td><td>低（学会三大件就能写）</td><td>高</td></tr><tr><td>个人成长机会</td><td>一般</td><td>低（很难有机会应用自己的轮子）</td></tr></tbody></table><blockquote><p>注：以上均为吾辈在小公司的一些体会，并不一定意味着<strong>正确</strong>。而且，前端并不一定意味着简单，也有可能是根本没有接触过复杂的应用场景。例如前端工程化、智能化、编辑器、富文本、可视化图表之类的。当然，前后端其实面临着相似的问题：在小公司很多东西并没有使用场景，低层次的工作重复十年也做不出来一个 <a href="https://juejin.cn/post/6924591257452806152/">设计稿智能生成代码 imgcook</a><br>注 2：但同时，吾辈也不得不承认两者确实在天花板上有着差异，尤其而且是在大型互联网公司（例如阿里），参考：<a href="https://blog.alswl.com/2019/07/frontend-backend-ceiling/">漫谈前后端天花板</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-自定义窗口顶栏</title>
    <link href="/p/9d55c013167a4e6d802fde969291c34b/"/>
    <url>/p/9d55c013167a4e6d802fde969291c34b/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在很多生产项目中，我们希望自定义 electron 窗口顶栏，因为它确实非常简陋。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="在渲染层实现自定义顶栏"><a href="#在渲染层实现自定义顶栏" class="headerlink" title="在渲染层实现自定义顶栏"></a>在渲染层实现自定义顶栏</h3><p>实际上，核心的代码就是添加一个为顶栏的元素添加 css 样式。在 electron 环境，有 <code>-webkit-app-region: drag;</code> 属性的元素可以拖动整个窗口。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: drag;<br>&#125;<br><span class="hljs-selector-class">.toolbar</span> &gt; * &#123;<br>  <span class="hljs-attribute">-webkit-app-region</span>: no-drag;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 css 看起来有点奇怪，但这是为了避免子元素（例如关闭按钮）也可以拖动的错误。</p><blockquote><p><a href="https://www.electronjs.org/docs/api/browser-window#event-system-context-menu-windows">参考文档</a>, <a href="https://github.com/rxliuli/electron_example/blob/18a1a756e5c82e87ef1c8755a0be036b6765f04b/apps/renderer/src/components/router/component/BasicLayout.module.css#L13">参考代码</a></p></blockquote><h3 id="使用-electron-通信实现窗口的三个操作"><a href="#使用-electron-通信实现窗口的三个操作" class="headerlink" title="使用 electron 通信实现窗口的三个操作"></a>使用 electron 通信实现窗口的三个操作</h3><p>其实，electron 本身支持在渲染层暴露 <code>remote</code> 模块，但这里我们选择使用 <code>ipcRenderer/ipcMain</code> 手动实现，remote 模块因为安全原因默认被禁用了。</p><p>下面的步骤基本和 <a href="/p/6e778ce220e042a0902e7a85976e7e47">渲染、主进程通信</a> 所属一样，下面贴一些关键代码</p><p>共享类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// WindowDefine.ts</span><br><span class="hljs-keyword">import</span> &#123; BaseDefine &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron_ipc_type&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> WindowDefine <span class="hljs-keyword">extends</span> BaseDefine&lt;&quot;WindowApi&quot;&gt; &#123;<br>  action(<span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowApi</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">action</span>(<span class="hljs-params">e: IpcMainInvokeEvent, <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;min&quot;</span> | <span class="hljs-string">&quot;max&quot;</span> | <span class="hljs-string">&quot;close&quot;</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> win = BrowserWindow.fromWebContents(e.sender);<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;min&quot;</span>:<br>        win.minimize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;max&quot;</span>:<br>        win.isMaximized() ? win.unmaximize() : win.maximize();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>        win.close();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// BasicLayout.tsx</span><br><span class="hljs-keyword">const</span> windowApi = IpcRendererClient.gen&lt;WindowDefine&gt;(<span class="hljs-string">&quot;WindowApi&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装 electron 的窗口控制 hooks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useElectronWindowControl</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    handleMin: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;min&quot;</span>),<br>    handleMax: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;max&quot;</span>),<br>    handleClose: <span class="hljs-function">() =&gt;</span> windowApi.action(<span class="hljs-string">&quot;close&quot;</span>),<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/rxliuli/electron_example/tree/3aea837b0c7661e030406a0c20d306694402a26f">参考代码</a></p></blockquote><h3 id="隐藏掉默认的顶栏"><a href="#隐藏掉默认的顶栏" class="headerlink" title="隐藏掉默认的顶栏"></a>隐藏掉默认的顶栏</h3><p>实际上，只要在创建 electron 的 <code>BrowserWindow</code> 实例时配置即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>  webPreferences: &#123;<br>    nodeIntegration: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  frame: <span class="hljs-literal">false</span>,<br>  autoHideMenuBar: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在，electron 程序就有自定义顶栏啦</p><p><img src="/resource/14a1d8bbb1ca452092c384ca7cbec4c4.png" alt="1611134001681.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然自定义窗口顶栏有很多优点，但也并非尽善尽美，已知缺点如下</p><ul><li>占有了一定高度，导致一些 UI 组件的位置很奇怪，例如顶部的消息提示框和侧边抽屉，会遮挡住窗口顶栏的一部分。</li><li>可能随着系统升级与系统风格不搭，早有人吐槽过 Windows 所有程序的自定义顶栏都是不一样的高度和大小，非常丑</li><li>需要重新实现窗口菜单相关的快捷键，例如 <code>ctrl+shift+i</code> 打开开发者工具</li><li>在 mac 上需要进行特别的兼容，否则和其他程序会显得格格不入</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-开发环境优化</title>
    <link href="/p/1527b67fbd78494cb716e2db4b8fb688/"/>
    <url>/p/1527b67fbd78494cb716e2db4b8fb688/</url>
    
    <content type="html"><![CDATA[<h2 id="使用-react-devtool-插件调试"><a href="#使用-react-devtool-插件调试" class="headerlink" title="使用 react devtool 插件调试"></a>使用 react devtool 插件调试</h2><!-- TODO 需要将这两个函数抽离成静态工具类 --><p>前言</p><p>虽然绝大多数时候，我们都可以也应该在浏览器调试渲染层的功能，但确实也会有需要在 electron 程序中调试的需求，这里就说明一下 electron 如何安装 chrome 插件 react devtool 调试项目。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-devtools-installer">electron-devtools-installer</a></p></blockquote><p>步骤</p><p>1、安装依赖</p><p>cd 到 <em>apps/main</em> 目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-devtools-installer @types/electron-devtools-installer<br></code></pre></td></tr></table></figure><p>2、添加环境变量 <code>&quot;NODE_ENV&quot;: &quot;development&quot;</code> 标识为开发环境</p><p>修改 <em>.env-cmdrc.json</em> 配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;NODE_ENV&quot;</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、修改 <code>main</code> 函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  app.addListener(<span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>      <span class="hljs-comment">// 安装 devtool 扩展</span><br>      <span class="hljs-keyword">await</span> installExtension(REACT_DEVELOPER_TOOLS);<br>    &#125;<br><br>    <span class="hljs-keyword">await</span> createMainWindow();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 <code>createMainWindow</code> 函数</p><p>一般，我们在开发环境还习惯打开控制台，这里也可以在创建窗口后自动打开它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    process.env.ELECTRON_START_URL || path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>  );<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>    mainWindow.webContents.openDevTools();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可能的错误参考: <a href="/p/76072311817b4c1985ab5746e8f91d87">常见问题</a> <strong>安装浏览器扩展报错</strong></p></blockquote><p>5、启动 electron 开发环境</p><p>启动后可以看到自动打开了控制台，然后可以看到 react devtool</p><p><img src="/resource/46612cfedc3643d98e11b1b6a4e99e1a.png" alt="实际效果"></p><h2 id="让主进程的代码也能热更新"><a href="#让主进程的代码也能热更新" class="headerlink" title="让主进程的代码也能热更新"></a>让主进程的代码也能热更新</h2><p>前言</p><p>可能你也发现了，渲染层使用 cra 创建的项目默认包含了热更新，这都要得益于 webpack HMR 技术，但主进程并非如此，即便使用 <code>tsc -w</code> 监听并编译 ts 代码，但想要生效仍然需要重启 electron，不厌其烦。幸运的是，有人已经实现了这个需求。</p><blockquote><p>核心依赖: <a href="https://www.npmjs.com/package/electron-reloader">electron-reloader</a></p></blockquote><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D electron-reloader<br></code></pre></td></tr></table></figure><p>2、在主进程入口文件载入 electron-reloader</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//添加热更新功能</span><br><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&quot;development&quot;</span>) &#123;<br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;electron-reloader&quot;</span>)(<span class="hljs-built_in">module</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、启动 electron 开发环境</p><p><img src="/resource/2cdd0ecc96ec46e095bd132c32675521.gif" alt="效果"></p><blockquote><p>注 2: 当修改代码时，重启 electron 应用是由 electron-reloader 负责，即它不在 WebStorm 的控制之下了。<br>注 2: 目前另一个 <a href="https://www.npmjs.com/package/electron-reload">electron-reload</a> 还存在一些小问题。</p></blockquote><h2 id="使用-esbuild-优化渲染层打包性能"><a href="#使用-esbuild-优化渲染层打包性能" class="headerlink" title="使用 esbuild 优化渲染层打包性能"></a>使用 esbuild 优化渲染层打包性能</h2><blockquote><p>如果你还没有感觉到 cra 打包很慢，可以跳过这一节。</p></blockquote><h3 id="禁止-ts-babel-将代码编译为-ES5"><a href="#禁止-ts-babel-将代码编译为-ES5" class="headerlink" title="禁止 ts/babel 将代码编译为 ES5"></a>禁止 ts/babel 将代码编译为 ES5</h3><p>由于 electron 捆绑的浏览器和 nodejs 版本都比较新，所以实际上渲染层我们基本不需要 babel 转义，可以优化一些配置项。</p><ul><li><p>将 <code>browserslist</code> 设置为仅支持最后一个 chrome 版本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;browserslist&quot;</span>: [<span class="hljs-string">&quot;last 1 chrome version&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <em>tsconfig.json</em> 中的配置，将编译目标修改为 <code>ESNext</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ESNext&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-esbuild-编译-typescript-代码"><a href="#使用-esbuild-编译-typescript-代码" class="headerlink" title="使用 esbuild 编译 typescript 代码"></a>使用 esbuild 编译 typescript 代码</h3></li></ul><blockquote><p>核心依赖: <a href="https://github.com/evanw/esbuild">esbuild</a>, <a href="https://github.com/gsoft-inc/craco">craco</a></p></blockquote><p>esbuild 是一个使用 golang 编写前端打包工具，官方在性能测试中提出比现有工具快 10-100 倍。</p><p>在 cra 创建的项目中，我们可以通过 craco 将 esbuild 仅用作 ts 编译之用（不会检查类型）。</p><p>1、安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D @craco/craco craco-esbuild<br></code></pre></td></tr></table></figure><p>2、修改 npm script，使用 <code>craco</code> 替换 <code>react-scripts</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;craco start&quot;</span>,<br>    <span class="hljs-attr">&quot;build:cra&quot;</span>: <span class="hljs-string">&quot;react-scripts build&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;craco build&quot;</span>,<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;craco test&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产项目中的对比测试结果（6000+ 行 ts 代码）</p><table><thead><tr><th>分类</th><th>ESBuild</th><th>tsc</th></tr></thead><tbody><tr><td>无缓存</td><td>17.61</td><td>36.57</td></tr><tr><td>有缓存（运行 5 次）</td><td>15252.8</td><td>17095.2</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-使用 electron-builder 打包</title>
    <link href="/p/63f0a26fdd3743668b11410a10625c1b/"/>
    <url>/p/63f0a26fdd3743668b11410a10625c1b/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="/p/475d21afd2404d5ba1f71f600c44da09">基本项目搭建</a> 中，我们已经能够启动一个 electron 应用程序了（开发环境），现在来看如何将之打包为二进制程序便于分发给最终用户。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><a href="https://www.electron.build/">electron-builder</a>: 打包的主要工具库，负责这个 electron 的跨平台打包工作<blockquote><p>事实上，还有一些其它的打包工具，但目前还没有比它更好的，参考: <a href="https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager">https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager</a></p></blockquote></li></ul><h2 id="渲染层打包"><a href="#渲染层打包" class="headerlink" title="渲染层打包"></a>渲染层打包</h2><p>直接使用 cra 的打包工具即可，没什么大不了的，但确实存在一些注意事项</p><ul><li>因为 electron 在生产环境会从文件系统中加载静态资源，所以打包出来的静态资源必须支持相对路径，下面是常见的两个设置。<ul><li>必须在 <em>apps/renderer/package.json</em> 中声明 <code>&quot;homepage&quot;: &quot;.&quot;</code>，参考: <a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Building for Relative Paths</a></li><li>路由必须是 <code>hash</code> 模式</li></ul></li></ul><h2 id="主进程打包"><a href="#主进程打包" class="headerlink" title="主进程打包"></a>主进程打包</h2><p>electron-builder 打包需要以下几个步骤</p><h3 id="更新-package-json-的一些配置"><a href="#更新-package-json-的一些配置" class="headerlink" title="更新 package.json 的一些配置"></a>更新 package.json 的一些配置</h3><ol><li> 使用 package.json 中的 <code>build</code> 字段作为配置项，参考: <a href="https://www.electron.build/">https://www.electron.build/</a></li><li> electron-builder 使用 <code>main</code> 字段作为启动脚本文件</li><li> electron-builder 要求必须使用固定的版本号，意味着 electron 依赖需要指定为 <code>&quot;electron&quot;: &quot;10.2.0&quot;</code></li></ol><p>下面是一个基本的配置示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 一个非常基本的打包脚本</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;electron-builder&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;electron&quot;</span>: <span class="hljs-string">&quot;10.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.9.1&quot;</span>,<br>    <span class="hljs-comment">// electron 主进程实际上是 nodejs 环境，所以为了更好的开发体验，安装 nodejs 的类型定义</span><br>    <span class="hljs-attr">&quot;@types/node&quot;</span>: <span class="hljs-string">&quot;^12.19.12&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-comment">// 程序的唯一标识符</span><br>    <span class="hljs-attr">&quot;appId&quot;</span>: <span class="hljs-string">&quot;com.rxliuli.electron_example&quot;</span>,<br>    <span class="hljs-comment">// 打包出来的 exe 名字</span><br>    <span class="hljs-attr">&quot;productName&quot;</span>: <span class="hljs-string">&quot;electron 示例应用&quot;</span>,<br>    <span class="hljs-comment">// 打包的目录</span><br>    <span class="hljs-attr">&quot;directories&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;output&quot;</span>: <span class="hljs-string">&quot;release&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;win&quot;</span>: &#123;<br>      <span class="hljs-comment">// 打包目标，参考: https://www.electron.build/</span><br>      <span class="hljs-attr">&quot;target&quot;</span>: [<span class="hljs-string">&quot;nsis&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制静态资源"><a href="#复制静态资源" class="headerlink" title="复制静态资源"></a>复制静态资源</h3><p>现在，我们需要打包静态资源并复制到主进程模块里面</p><ol><li> <code>cd apps/renderer</code> 目录</li><li> <code>yarn build</code> 打包静态资源</li><li> 将静态资源复制到 <code>build/dist</code> 目录下</li></ol><h3 id="修改主进程入口文件-main-ts"><a href="#修改主进程入口文件-main-ts" class="headerlink" title="修改主进程入口文件 main.ts"></a>修改主进程入口文件 main.ts</h3><p>还需要修改 <em>src/main.ts</em> 代码，主要修改 BrowserWindow 对象载入的 <code>url</code> 地址</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">import</span> &#123; URL &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入生产环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<br>    <span class="hljs-keyword">new</span> URL(path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)).href<br>  );<br>&#125;<br><br><span class="hljs-comment">// 其他代码...</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，这个 url 路径是相对于打包后的 <code>dist/main.js</code> 而言的，因为最终打包的程序运行时的相对路径也是这样。</p></blockquote><h3 id="打包主进程的-exe-程序"><a href="#打包主进程的-exe-程序" class="headerlink" title="打包主进程的 exe 程序"></a>打包主进程的 exe 程序</h3><blockquote><p>因为 electron-builder 需要下载基本的 electron 程序，所以请提前设置好透明代理，如果不知道它是什么，参考: <a href="https://github.com/rxliuli/haoel.github.io#7-%E9%80%8F%E6%98%8E%E7%BD%91%E5%85%B3">透明网关</a>，<a href="http://www.proxifier.com/">Proxifier</a></p></blockquote><ol><li> 使用 <code>yarn compile</code> 编译 ts 代码</li><li> 使用 <code>yarn pkg</code> 打包 electron 应用</li></ol><p>现在，我们应该可以在 <em>apps/main/release/win-unpacked</em> 下看到 exe 程序，双击它即可看到之前在开发环境的首页了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main">https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main</a></p></blockquote><h2 id="优化打包"><a href="#优化打包" class="headerlink" title="优化打包"></a>优化打包</h2><p>虽然打包已经实现，但确实还存在一些问题</p><ul><li>打包脚本仍然不是一键的</li><li>不能兼容开发、生产环境</li></ul><p>下面我们来解决这两个问题</p><h3 id="实现一键打包二进制程序"><a href="#实现一键打包二进制程序" class="headerlink" title="实现一键打包二进制程序"></a>实现一键打包二进制程序</h3><p>使用 gulp 复制渲染层的静态资源</p><p>1、添加 gulp 相关依赖 <code>yarn add -D gulp ts-node @types/gulp fs-extra @types/fs-extra</code></p><ul><li><code>gulp @types/gulp</code>: gulp 核心依赖</li><li><code>ts-node</code>: 使用 ts 编写 gulp 脚本必须的依赖</li><li><code>fs-extra @types/fs-extra</code>: fs 的扩展增强，使用 Promise 包装异步 api</li></ul><p>2、添加 gulp 脚本文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; copy, remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs-extra&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyByMap</span>(<span class="hljs-params">copyMap: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>][]</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>    copyMap.map(<span class="hljs-keyword">async</span> ([src, destDir]) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> srcPath = path.resolve(__dirname, src);<br>      <span class="hljs-keyword">const</span> destPath = path.resolve(__dirname, destDir, path.basename(srcPath));<br>      <span class="hljs-keyword">await</span> copy(srcPath, destPath);<br>    &#125;)<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 清理最终生成目录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clean</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>));<br>  <span class="hljs-keyword">await</span> remove(path.resolve(__dirname, <span class="hljs-string">&quot;release&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 复制一些资源到 dist 目录中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyStatic</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> copyByMap([[<span class="hljs-string">&quot;../renderer/build&quot;</span>, <span class="hljs-string">&quot;dist/&quot;</span>]]);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、添加 npm script</p><blockquote><p>注: lerna 的好处之一就是可以运行其它模块的 npm script。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 打包渲染层的静态资源</span><br>    <span class="hljs-attr">&quot;build:web&quot;</span>: <span class="hljs-string">&quot;lerna run --scope renderer build&quot;</span>,<br>    <span class="hljs-comment">// 打包渲染层的静态资源之后复制然后使用 electron-builder 打包 exe 程序</span><br>    <span class="hljs-attr">&quot;pkg&quot;</span>: <span class="hljs-string">&quot;gulp clean &amp;&amp; yarn compile &amp;&amp; yarn build:web &amp;&amp; gulp copyStatic &amp;&amp; electron-builder&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、修改 tsconfig.json</p><p>此时在 <em>apps/main</em> 模块根目录下也有 ts 文件了，所以 tsc 翻译代码会将它们也包含进去，但实际上不需要。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以使用一个命令打包 exe 程序了。</p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json">https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json</a></p></blockquote><h3 id="使用环境变量来兼容开发、生产环境"><a href="#使用环境变量来兼容开发、生产环境" class="headerlink" title="使用环境变量来兼容开发、生产环境"></a>使用环境变量来兼容开发、生产环境</h3><p>解决方案简单来说就一句话：使用环境变量指定开发环境的 URL。<br>这里使用 <a href="https://github.com/toddbluhm/env-cmd">env-cmd</a> 来跨平台写入环境变量（不使用 <a href="https://github.com/motdotla/dotenv">dotenv</a> 的原因在于自定义环境使用起来有点麻烦，不像 env-cmd 那么直观），而另一个 <a href="https://github.com/kentcdodds/cross-env">cross-env</a> 并未提供管理环境变量的解决方案。下面说一下使用 env-cmd 的步骤</p><ol><li><p> 安装依赖 <code>yarn add -D env-cmd</code></p></li><li><p>添加配置文件 <em>.env-cmdrc.json</em><br> 基本上是一个键值映射文件，键是环境，值对象是环境变量</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;ELECTRON_START_URL&quot;</span>: <span class="hljs-string">&quot;http://localhost:3000/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 在 <code>dev:electron</code> 命令之前设定环境变量 <code>env-cmd -e dev electron ./dist/main.js</code></p></li><li><p>修改 <em>src/main.ts</em> 读取环境变量</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> mainWindow.loadURL(<br>  process.env.ELECTRON_START_URL ||<br>    path.join(__dirname, <span class="hljs-string">&quot;./build/index.html&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>现在，像 <a href="/p/475d21afd2404d5ba1f71f600c44da09">基本项目搭建</a> 中 <strong>更新 <em>package.json</em> 添加几个 npm script</strong> 说的那样启动开发环境就会显示开发环境的页面，打包后显示的则是打包后的静态资源。</p></li></ol><p><img src="/resource/addf49c903f840bfa59ebaa1513ec689.png" alt="效果"></p><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json">https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 electron-builder 已经足够好用了，但它仍然不能解决 electron 项目工程上的问题，所以这里结合了 <code>lerna/gulp/env-cmd</code> 打包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-自动更新</title>
    <link href="/p/0f342a17caae4f1e845a543770008e35/"/>
    <url>/p/0f342a17caae4f1e845a543770008e35/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于生产应用希望在有新版本时，自动为用户推送更新，所以此处便写一下如何让 electron 程序自动更新。</p><h2 id="安装-npm-包"><a href="#安装-npm-包" class="headerlink" title="安装 npm 包"></a>安装 npm 包</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> apps/main/ &amp;&amp; yarn add electron-updater<br></code></pre></td></tr></table></figure><h2 id="配置-electron-builder"><a href="#配置-electron-builder" class="headerlink" title="配置 electron-builder"></a>配置 electron-builder</h2><blockquote><p>参考: <a href="https://www.electron.build/auto-update">https://www.electron.build/auto-update</a></p></blockquote><p>其实本质上就是配置一个网络可以访问到的静态资源目录，这里使用了一个本地的静态资源服务器，指向目录是 _apps/main/release_（即打包而进程程序的目录）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;build&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;publish&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;provider&quot;</span>: <span class="hljs-string">&quot;generic&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/&quot;</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动时检查更新"><a href="#启动时检查更新" class="headerlink" title="启动时检查更新"></a>启动时检查更新</h2><p>在主进程添加检查更新的代码，并自定义提示文案。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> autoUpdater.checkForUpdates();<br>autoUpdater.addListener(<span class="hljs-string">&quot;update-downloaded&quot;</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">new</span> Notification(&#123;<br>    title: <span class="hljs-string">&quot;更新提醒&quot;</span>,<br>    body: <span class="hljs-string">`新版本 <span class="hljs-subst">$&#123;info.version&#125;</span> 已经准备好，点击立刻更新！`</span>,<br>  &#125;)<br>    .addListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      autoUpdater.quitAndInstall();<br>    &#125;)<br>    .show();<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>现在，你可以启动一个本地静态服务器指向 _apps/main/release_，例如 <a href="https://www.npmjs.com/package/live-server">live-server</a>，然后打包一个新版本，再启动旧的程序就可以了。</p><p><img src="/resource/2c95743b50f445758d6cb8ef5db5a838.gif" alt="效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-渲染、主进程通信</title>
    <link href="/p/6e778ce220e042a0902e7a85976e7e47/"/>
    <url>/p/6e778ce220e042a0902e7a85976e7e47/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于 electron 应用分为主进程、渲染进程，所以它们之间需要通信。而 electron 本身实现了一个简单的 event emitter 通信模型，虽然能用，但并不足够好。</p><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/ipc-renderer">https://www.electronjs.org/docs/api/ipc-renderer</a></p></blockquote><p>问题</p><ul><li>基于字符串和约定进行通信本质上和当下前后端通信差不多，没有利用同构优势</li><li>使用起来没有任何限制，意味着很难维护（非强制性的约定基本上都很难生效）</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么一共 electron 进程通信有哪些情况呢？</p><ul><li>渲染进程 =&gt; 主进程</li><li>主进程 =&gt; 渲染进程</li><li>渲染进程 =&gt; 渲染进程</li></ul><p>而其中最常用的便是 <code>渲染进程 =&gt; 主进程</code></p><blockquote><p>其实吾辈也看过许多 electron 进程通信的 <a href="https://www.npmjs.com/package/electron-rpc-api">封装库</a> 或者类似场景的 rpc 实现 <a href="https://www.npmjs.com/package/comlink">comlink</a>，但最终还是决定使用接口 + 主进程实现 + 渲染层根据接口生成 Client 的方式实现。</p></blockquote><p>最终，吾辈选择了接口 + 实现类的基本模式</p><p><a href="/resource/5639a097671248d2a674f8524b050b81.drawio">设计图.drawio</a></p><h2 id="实现渲染进程-gt-主进程"><a href="#实现渲染进程-gt-主进程" class="headerlink" title="实现渲染进程 =&gt; 主进程"></a>实现渲染进程 =&gt; 主进程</h2><p>首先在创建 <em>libs</em> 目录用以存放通用模块（非业务），然后创建三个模块</p><ul><li><code>electron_ipc_type</code>: 一些需要引入的类型</li><li><code>electron_ipc_main</code>: 主进程封装</li><li><code>electron_ipc_renderer</code>: 渲染层封装</li></ul><blockquote><p>此处使用 rollup 进行打包</p></blockquote><p>大致实现</p><p>electron_ipc_type: 通用的基本接口定义，必须包含一个 <code>namespace</code> 属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BaseDefine&lt;T <span class="hljs-keyword">extends</span> string&gt; &#123;<br>  <span class="hljs-keyword">namespace</span>: T;<br>&#125;<br></code></pre></td></tr></table></figure><p>electron_ipc_main: 封装主进程实现相关代码，主要保证类型安全</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> FilteredKeys&lt;T, U&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]: T[P] <span class="hljs-keyword">extends</span> U ? P : <span class="hljs-built_in">never</span>;<br>&#125;[keyof T];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个主进程可以实现的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcMainDefine&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FilteredKeys&lt;T, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;]: (<br>    e: IpcMainInvokeEvent,<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcMainProvider</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> clazzMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">object</span>&gt;();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 计算主进程监听的 key</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">method</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> getKey&lt;T&gt;(<span class="hljs-keyword">namespace</span>: string, method: PropertyKey) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">namespace</span> + &quot;.&quot; + method.toString();<br>  &#125;<br><br>  register&lt;T extends BaseDefine&lt;string&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    api: IpcMainDefine&lt;T&gt;<br>  ): IpcMainDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">const</span> instance = ClassUtil.bindMethodThis(api);<br>    <span class="hljs-keyword">const</span> methods = ClassUtil.scan(instance);<br>    methods.forEach(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> key = IpcMainProvider.getKey(<span class="hljs-keyword">namespace</span>, method);<br>      ipcMain.handle(key, instance[method] as any);<br>      console.log(&quot;Register ipcMain.handle: &quot;, key);<br>    &#125;);<br>    this.clazzMap.set(<span class="hljs-keyword">namespace</span>, instance);<br>    return instance;<br>  &#125;<br><br>  unregister&lt;T extends BaseDefine&lt;string&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    api: IpcMainDefine&lt;T&gt;<br>  ): void &#123;<br>    <span class="hljs-keyword">const</span> methods = ClassUtil.scan(api);<br>    methods.forEach(<span class="hljs-function">(<span class="hljs-params">method</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> key = IpcMainProvider.getKey(<span class="hljs-keyword">namespace</span>, method);<br>      ipcMain.removeHandler(key);<br>    &#125;);<br>    this.clazzMap.delete(<span class="hljs-keyword">namespace</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>electron_ipc_renderer: 渲染进程</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> FilteredKeys&lt;T, U&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]: T[P] <span class="hljs-keyword">extends</span> U ? P : <span class="hljs-built_in">never</span>;<br>&#125;[keyof T];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个渲染进程可以调用的 Proxy 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcRendererDefine&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FilteredKeys&lt;T, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;]: (<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotElectronEnvError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcRendererClient</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成一个客户端实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> gen&lt;T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;]<br>  ): IpcRendererDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), &#123;<br>      get(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">api</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">namespace</span> + &quot;.&quot; + api;<br>        return function (...args: any[]) &#123;<br>          <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>          <span class="hljs-keyword">if</span> (!ipcRenderer) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotElectronEnvError(<span class="hljs-string">&quot;当前你不在 electron 进程中&quot;</span>);<br>          &#125;<br>          <span class="hljs-keyword">return</span> ipcRenderer.invoke(key, ...args);<br>        &#125;;<br>      &#125;,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取 electron ipc renderer 实例</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> getRenderer(): IpcRenderer | <span class="hljs-literal">null</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isElectron()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.require(<span class="hljs-string">&quot;electron&quot;</span>).ipcRenderer <span class="hljs-keyword">as</span> IpcRenderer;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>使用</p><p>在 apps 下创建一个模块 <code>shared_type</code>，里面包含一些渲染进程与主进程之间共享的类型，下面是一个简单的示例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// HelloDefine.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> HelloDefine <span class="hljs-keyword">extends</span> BaseDefine&lt;&quot;HelloApi&quot;&gt; &#123;<br>  hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主进程中使用 class 实现它并注册</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApi</span> </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params">e: IpcMainInvokeEvent, name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> ipcMainProvider = <span class="hljs-keyword">new</span> IpcMainProvider();<br><br>ipcMainProvider.register&lt;HelloDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>, <span class="hljs-keyword">new</span> HelloApi());<br></code></pre></td></tr></table></figure><p>在渲染进程中创建客户端对象并使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> helloApi = IpcRendererClient.gen&lt;HelloDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>);<br><br><span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> helloApi.hello(<span class="hljs-string">&quot;liuli&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="实现主进程-gt-渲染进程"><a href="#实现主进程-gt-渲染进程" class="headerlink" title="实现主进程 =&gt; 渲染进程"></a>实现主进程 =&gt; 渲染进程</h2><p>由于吾辈的 ui 层框架使用了 react，所以基于 class 的模式在此并不适用，需要使用某种变通的方式（吾辈仍然不愿意放弃将 class 作为命名空间的想法）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IpcRendererProviderDefine&lt;<br>  T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;,<br>  P <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt; = FunctionKeys&lt;T&gt;<br>&gt; = [<br>  <span class="hljs-keyword">type</span>: P,<br>  callback: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span>, ...args: Parameters&lt;T[P]&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;<br>];<br><br><span class="hljs-keyword">type</span> IpcRendererProviderHooksDefine&lt;<br>  T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;,<br>  P <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt; = FunctionKeys&lt;T&gt;<br>&gt; = [<br>  <span class="hljs-keyword">type</span>: P,<br>  callback: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span>, ...args: Parameters&lt;T[P]&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;,<br>  deps?: DependencyList<br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在渲染层管理提供者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcRendererProvider</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDefine</span>&lt;<span class="hljs-title">any</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> apiMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">any</span>&gt;();<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">namespace</span>: T[<span class="hljs-string">&quot;namespace&quot;</span>]</span>)</span> &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">...[<span class="hljs-keyword">type</span>, callback]: IpcRendererProviderDefine&lt;T&gt;</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>    <span class="hljs-keyword">if</span> (ipcRenderer === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&quot;不在 electron 环境，取消注册: &quot;</span>, <span class="hljs-keyword">type</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">this</span>.namespace + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">type</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;IpcRendererProvider.register: &quot;</span>, key);<br>    <span class="hljs-keyword">const</span> listener = <span class="hljs-keyword">async</span> (event: <span class="hljs-built_in">any</span>, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>, ...args: <span class="hljs-built_in">any</span>[]) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;IpcRendererProvider.listener: &quot;</span>, event, id, args);<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> callback(event, ...(args <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>));<br>        <span class="hljs-keyword">await</span> ipcRenderer.send(id, <span class="hljs-literal">null</span>, res);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">await</span> ipcRenderer.send(id, e);<br>      &#125;<br>    &#125;;<br>    ipcRenderer.on(key, listener);<br>    <span class="hljs-built_in">this</span>.apiMap.set(key, listener);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: IpcRendererProviderDefine&lt;T&gt;[<span class="hljs-number">0</span>]</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> ipcRenderer = IpcRendererClient.getRenderer();<br>    <span class="hljs-keyword">if</span> (ipcRenderer === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">this</span>.namespace + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">type</span>;<br>    ipcRenderer.off(key, <span class="hljs-built_in">this</span>.apiMap.get(key)!);<br>    <span class="hljs-built_in">this</span>.apiMap.delete(key);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * react 中的注册钩子，自动管理清理的操作</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">type</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">callback</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">deps</span></span></span><br><span class="hljs-comment">   */</span><br>  useIpcProvider(<br>    ...[<span class="hljs-keyword">type</span>, callback, deps = []]: IpcRendererProviderHooksDefine&lt;T&gt;<br>  ) &#123;<br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.register(<span class="hljs-keyword">type</span>, callback);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.unregister(<span class="hljs-keyword">type</span>);<br>    &#125;, deps);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换为一个渲染进程可以调用的 Proxy 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IpcClientDefine&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> FunctionKeys&lt;T&gt;]: (<br>    ...args: Parameters&lt;T[P]&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[P]&gt;&gt;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpcMainClient</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成一个客户端实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">namespace</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">win</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> gen&lt;T <span class="hljs-keyword">extends</span> BaseDefine&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>    <span class="hljs-keyword">namespace</span>: T[&quot;<span class="hljs-keyword">namespace</span>&quot;],<br>    win: BrowserWindow<br>  ): IpcClientDefine&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), &#123;<br>      get&lt;K <span class="hljs-keyword">extends</span> FunctionKeys&lt;T&gt;&gt;(target: <span class="hljs-built_in">any</span>, <span class="hljs-attr">api</span>: K): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">namespace</span> + &quot;.&quot; + api;<br>        return function (...args: any[]) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;ReturnType&lt;T[K]&gt;&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">Date</span>.now() + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-built_in">Math</span>.random();<br>            ipcMain.once(id, <span class="hljs-function">(<span class="hljs-params">event, err, res</span>) =&gt;</span> &#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;callback: &quot;</span>, err, res);<br>              <span class="hljs-keyword">if</span> (err) &#123;<br>                reject(err);<br>                <span class="hljs-keyword">return</span>;<br>              &#125;<br>              resolve(res);<br>            &#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;send: &quot;</span>, key, id, args);<br>            win.webContents.send(key, id, ...(args <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>));<br>          &#125;);<br>        &#125;;<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>使用</p><p>在渲染进程使用 hooks 注册它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> ipcRendererProvider = <span class="hljs-keyword">new</span> IpcRendererProvider&lt;HelloApiDefine&gt;(<span class="hljs-string">&quot;HelloApi&quot;</span>);<br><br>ipcRendererProvider.useIpcProvider(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">async</span> (e, name) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在主进程生成客户端实例调用它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> helloApi = IpcMainClient.gen&lt;HelloApiDefine&gt;(<br>  <span class="hljs-string">&quot;HelloApi&quot;</span>,<br>  <span class="hljs-keyword">new</span> BrowserWindow()<br>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-keyword">await</span> helloApi.hello(<span class="hljs-string">&quot;liuli&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="约定俗成"><a href="#约定俗成" class="headerlink" title="约定俗成"></a>约定俗成</h2><ul><li>在 <code>shared_type</code> 模块中的接口定义总是 <code>*Define</code> 形式，且实现的 <code>BaseDefine&lt;T&gt;</code> 泛型参数是 <code>*Api</code> 形式</li><li>在 <code>main</code> 模块中实现的 class 总是 <code>*Api</code> 形式</li><li>在 <code>renderer</code> 模块中获取的 client 实例总是 <code>*Api</code> 小写驼峰形式</li><li>实现 <code>BaseDefine&lt;T&gt;</code> 传入的命名空间参数不应该重复</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>electron 本身的进程通信 api 在逐渐发展，但目前仍然没有足够好用，所以吾辈不得不进行了封装。</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-基本项目搭建</title>
    <link href="/p/475d21afd2404d5ba1f71f600c44da09/"/>
    <url>/p/475d21afd2404d5ba1f71f600c44da09/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Windows 10</li><li>NodeJS 12</li><li>WebStorm</li><li>VSCode（编写 markdown 文档）</li></ul><h2 id="创建-lerna-项目"><a href="#创建-lerna-项目" class="headerlink" title="创建 lerna 项目"></a>创建 lerna 项目</h2><p>创建目录 _electron_example_，然后使用 yarn 初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir electron_example &amp;&amp; <span class="hljs-built_in">cd</span> electron_example<br>yarn init -y<br></code></pre></td></tr></table></figure><p>修改 <em>package.json</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;electron_example&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>,<br>  <span class="hljs-attr">&quot;workspaces&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;packages&quot;</span>: [<span class="hljs-string">&quot;apps/*&quot;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后创建 <em>lerna.json</em> 配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;packages&quot;</span>: [<span class="hljs-string">&quot;apps/*&quot;</span>],<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;independent&quot;</span>,<br>  <span class="hljs-attr">&quot;npmClient&quot;</span>: <span class="hljs-string">&quot;yarn&quot;</span>,<br>  <span class="hljs-attr">&quot;useWorkspaces&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>初始化目录如下</p><ul><li><em>apps</em><ul><li><em>main</em>: 主进程</li><li><em>renderer</em>: 渲染进程</li></ul></li><li>_node_modules_</li><li><em>lerna.json</em></li><li><em>package.json</em></li><li><em>yarn.lock</em></li></ul><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/b9628e1fd16bb5b6807e55e9ca72fdf2daf5bfde">https://github.com/rxliuli/electron_example/tree/b9628e1fd16bb5b6807e55e9ca72fdf2daf5bfde</a></p></blockquote><h2 id="初始化渲染层模块"><a href="#初始化渲染层模块" class="headerlink" title="初始化渲染层模块"></a>初始化渲染层模块</h2><p>在 renderer 目录中使用 create-react-app 创建一个 react 项目，并添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npx create-react-app apps/renderer/ --template typescript<br></code></pre></td></tr></table></figure><p>不过还需要修改其中部分配置，主要包含</p><ul><li>删除 <em>yarn.lock</em> 或 <em>package-lock.json</em> 文件</li></ul><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/8e0920af985e1201fc05ca36302e094532843c2d">https://github.com/rxliuli/electron_example/tree/8e0920af985e1201fc05ca36302e094532843c2d</a></p></blockquote><p>尝试再 yarn 安装依赖，接着再使用 <code>yarn start</code> 启动开发环境，应该可以在浏览器中看到默认的页面。</p><p><img src="/resource/08869afb99594ede8c00d65ad4b65c19.png" alt="20210106194304.png"></p><h2 id="初始化主进程模块"><a href="#初始化主进程模块" class="headerlink" title="初始化主进程模块"></a>初始化主进程模块</h2><blockquote><p>参考: <a href="https://github.com/rxliuli/electron_example/tree/a78885b76de9322dfdac82e2c220b7c6e0a9617f">https://github.com/rxliuli/electron_example/tree/a78885b76de9322dfdac82e2c220b7c6e0a9617f</a><br>注：electron 版本选择双数，生命周期更长。</p></blockquote><p>初始化主进程模块，主要包括</p><h3 id="为主进程创建-package-json"><a href="#为主进程创建-package-json" class="headerlink" title="为主进程创建 package.json"></a>为主进程创建 package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;main&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加依赖-yarn-add-electron-electron-builder-typescript"><a href="#添加依赖-yarn-add-electron-electron-builder-typescript" class="headerlink" title="添加依赖 yarn add electron electron-builder typescript"></a>添加依赖 <code>yarn add electron electron-builder typescript</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;electron&quot;</span>: <span class="hljs-string">&quot;^10.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;electron-builder&quot;</span>: <span class="hljs-string">&quot;^22.9.1&quot;</span>,<br>    <span class="hljs-attr">&quot;typescript&quot;</span>: <span class="hljs-string">&quot;^4.1.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加-tsconfig-json-配置文件"><a href="#添加-tsconfig-json-配置文件" class="headerlink" title="添加 tsconfig.json 配置文件"></a>添加 <em>tsconfig.json</em> 配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// tsconfig.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-comment">// nodejs 生态大多数都支持这种模块</span><br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>    <span class="hljs-comment">// 优先考虑输出 es5</span><br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,<br>    <span class="hljs-comment">// 但不要自缚手脚，仍然使用最新的 es 特性</span><br>    <span class="hljs-attr">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;ESNext&quot;</span>],<br>    <span class="hljs-comment">// 定义源目录与输出目录</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>,<br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;dist&quot;</span>,<br>    <span class="hljs-comment">// 生成 sourceMap 方便 IDE 本地调试</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 禁止 ts 检查 npm 依赖的类型定义（例如 electron 的类型定义就很容易被 ts 检查出错误，毕竟这个项目实在太大了）</span><br>    <span class="hljs-attr">&quot;skipLibCheck&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;skipDefaultLibCheck&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// 排除依赖目录与输出目录</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;node_modules&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加-src-main-ts-基本的启动文件"><a href="#添加-src-main-ts-基本的启动文件" class="headerlink" title="添加 src/main.ts 基本的启动文件"></a>添加 <em>src/main.ts</em> 基本的启动文件</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> &#123; app, BrowserWindow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMainWindow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 创建新的 electron 窗口</span><br>  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow();<br>  <span class="hljs-comment">// 载入开发环境的 url</span><br>  <span class="hljs-keyword">await</span> mainWindow.loadURL(<span class="hljs-string">&quot;http://localhost:3000/&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * main 函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>  app.on(<span class="hljs-string">&quot;ready&quot;</span>, createMainWindow);<br>&#125;<br><br>main();<br></code></pre></td></tr></table></figure><h3 id="更新-package-json-添加几个-npm-script"><a href="#更新-package-json-添加几个-npm-script" class="headerlink" title="更新 package.json 添加几个 npm script"></a>更新 <em>package.json</em> 添加几个 npm script</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// 编译 ts 代码</span><br>    <span class="hljs-attr">&quot;compile&quot;</span>: <span class="hljs-string">&quot;tsc&quot;</span>,<br>    <span class="hljs-comment">// 编译 tsc 代码且启动监听模式</span><br>    <span class="hljs-attr">&quot;watch&quot;</span>: <span class="hljs-string">&quot;yarn compile -w&quot;</span>,<br>    <span class="hljs-comment">// 在主进程通过 lerna 启动渲染进程模块的开发环境</span><br>    <span class="hljs-attr">&quot;dev:web&quot;</span>: <span class="hljs-string">&quot;lerna run --scope renderer start&quot;</span>,<br>    <span class="hljs-comment">// 启动主进程的开发环境</span><br>    <span class="hljs-attr">&quot;dev:electron&quot;</span>: <span class="hljs-string">&quot;electron ./dist/main.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们通过这些 npm script 启动 electron 开发环境</p><ol><li> 运行 <code>yarn watch</code></li><li> 运行 <code>dev:web</code></li><li> 等待以上两条命令都运行完成，再继续运行 <code>dev:electron</code></li></ol><p>现在，你应该可以看到一个 electron 窗口，其中显示着。</p><p><img src="/resource/8f2afb0c085a4d3c8c678c71bc128412.png" alt="20210106194102.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前，使用 lerna monorepo 似乎还看不出来明显的优点，不过实际上在后面逐步完善 Electron 程序的过程中我们会发现它的强大之处。</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-技术栈简介及选择</title>
    <link href="/p/74b1ec3c598940c2afbd17cdd50e31cb/"/>
    <url>/p/74b1ec3c598940c2afbd17cdd50e31cb/</url>
    
    <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><a href="https://electronjs.org/">electron</a>: 跨平台桌面开发</li><li><a href="https://reactjs.org/">react</a>: 视图层框架</li><li><a href="https://www.typescriptlang.org/">typescript</a>: 强类型的 js</li><li><a href="https://lerna.js.org/">lerna</a>: 前端 monorepo 管理工具</li><li><a href="https://classic.yarnpkg.com/">yarn</a>: 包管理器，workspace 与 lerna 搭配非常好</li><li><a href="https://create-react-app.dev/">create-react-app</a>: react 官方出品的 react 脚手架生成器，社区和活跃度都不是其它工具可比的</li></ul><h2 id="其他依赖库"><a href="#其他依赖库" class="headerlink" title="其他依赖库"></a>其他依赖库</h2><blockquote><p>参考: <a href="/p/4b666902cd1e45779448a76a71d0e2e5">前端资源管理</a></p></blockquote><ul><li><a href="https://rollupjs.org/">rollup</a>: 前端库打包工具</li><li>electron-builder: electron 打包工具</li><li>is-electron: 在渲染层判断是否为 electron 环境的微型库</li><li>fs-extra: nodejs api 的 Promise 化封装</li><li>react-use: react 中的通用 hooks 库</li><li><a href="https://www.npmjs.com/org/liuli-util">@liuli-util/*</a>: 吾辈个人的一系列通用工具库</li><li>jest: 单元测试工具</li><li>wallaby.js: 单元测试 IDE 集成</li><li>gulp: 流式任务管理工具</li><li>electron-store: 主进程和渲染层通用的 k-v 存储</li><li>electron-reloader: electron 热更新工具</li><li>electron-devtools-installer: electron 插件安装工具</li><li>utility-types: typescript 通用类型库</li></ul><h2 id="选择动机"><a href="#选择动机" class="headerlink" title="选择动机"></a>选择动机</h2><ul><li>electron: 想必来看到这篇文章的人都无需解释，基于 web 技术的跨平台足以解释一切。</li><li>react: 吾辈无意争论框架优劣，但 react 确实是目前最流行的解决方案，所以吾辈选择了它。</li><li>typescript: 由于吾辈有着 Java 后端的经验，所以对强类型情有独钟。</li><li>lerna: 这个确实需要解释一下，electron 应用分为主进程和渲染层，一般示例中是将它们在一个项目中通过目录区分，但这种隔离性并不好，还会污染 <code>package.json</code>。这时候就到了 lerna 出场了，它是由 babel 的作者开发，专门用以解决前端没有多模块工程的问题。<blockquote><p>PS1: 老实说，吾辈很想念 Java <a href="https://maven.apache.org/">maven</a> 多模块的支持，可以非常简单的抽取模块出来。<br>PS2: 前端有名的 electron-react 示例项目 <a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate/">electron-react-boilerplate</a> 就是单模块的。</p></blockquote></li><li>electron-builder: electron 官方其实更推荐 <a href="https://www.electronforge.io/">Electron Forge</a>，但目前而言，electron-builder 更好。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 复盘及 2021 计划</title>
    <link href="/p/01f6410c002840e9ba7bfca65c9611ee/"/>
    <url>/p/01f6410c002840e9ba7bfca65c9611ee/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-复盘"><a href="#2020-复盘" class="headerlink" title="2020 复盘"></a>2020 复盘</h2><blockquote><p><a href="/p/17b171a3184c479e97ba7df9bc118023">年初计划</a></p><p>明年，吾辈最想要接触的是 Web 桌面开发，以及机器学习。</p><ul><li>[x] NodeJS 后端开发</li><li>[x] Web 桌面开发 Electron</li><li>[ ] 机器学习 TensorFlow</li><li>[x] 继续维护 Blog</li><li>[ ] 继续坚持读书</li><li>[ ] 尝试网络小说写作</li><li>[ ] 尝试 Youtube 视频创作</li></ul></blockquote><p>实际上 Web 桌面开发由于工作的原因算是接触的非常多，但机器学习几乎没什么了解。</p><p>那么今年到底做了什么呢？</p><table><thead><tr><th>时间</th><th>公司</th><th>个人</th></tr></thead><tbody><tr><td>1 月</td><td>疫情发生</td><td>过了最惨的年</td></tr><tr><td>2 月</td><td>远程办公</td><td></td></tr><tr><td>3 月</td><td>业务开发</td><td></td></tr><tr><td>4 月</td><td>开始招人</td><td>替换技术栈 vue =&gt; ts+react</td></tr><tr><td>5 月</td><td>995 福报中</td><td>接触 Electron</td></tr><tr><td>6 月</td><td>995 福报中</td><td>开始使用 joplin 管理笔记</td></tr><tr><td>7 月</td><td>程序定制化修改</td><td>开发 joplin-vscode-plugin</td></tr><tr><td>8 月</td><td>程序定制化修改</td><td>开始了解 Monorepo 工程化</td></tr><tr><td>9 月</td><td>程序定制化修改</td><td></td></tr><tr><td>10 月</td><td>程序定制化修改</td><td>开发 joplin-charts</td></tr><tr><td>11 月</td><td>开始新的项目</td><td>完善 joplin 周边工具链</td></tr><tr><td>12 月</td><td>开始另一个新的项目</td><td>开发 joplin-blog</td></tr></tbody></table><p>今年主要入的一个大坑是 joplin，虽说一开始仅仅是作为笔记工具使用，但中途因为遇到了一些问题所以参与了部分周边工具的开发，占用了不少的业余时间。然而，开源程序的魅力就在于此：当不能满足需求时，吾辈可以通过开发来改变这一切。</p><p>开源项目</p><ul><li><a href="https://github.com/rxliuli/rx-util">rx-util</a>: 前端通用工具库，虽然今年没怎么更新，但也是因为逐渐变得完善的愿意</li><li><a href="https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin&ssr=false#overview">joplin-vscode-plugin</a>: joplin 的 vscode 插件，使用 vscode 接管自己的笔记管理，支持大多数 joplin 的功能（通过 web clipper service）</li><li><a href="https://github.com/rxliuli/joplin-blog">joplin-blog</a>: 将 joplin 作为数据源导出 blog</li><li><a href="https://rxliuli.com/joplin-charts/#/">joplin-charts</a>: 展示 joplin 的一些统计图表数据</li><li><a href="https://www.npmjs.com/package/joplin-api">joplin-api</a>: joplin 的 api 封装，适用于 web/nodejs，也是以上成果的基础</li><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>: 参与了一个类型定义包的错误修复，熟悉了基本的贡献流程（其实也挺繁琐的）</li><li><a href="https://github.com/rxliuli/userjs">user.js</a>: 一些自用的油猴脚本 – 仅维护常用的几个了</li><li><a href="https://github.com/rxliuli/liuli-cli">liuli-cli</a>: 前端 npm 包的脚手架生成 cli 工具 – 不怎么维护了</li><li><a href="https://github.com/rxliuli/vue-url-persist">vue-url-persist</a>: vue url 序列化参数的包 – 自从主要技术栈更换为 react 之后就不怎么维护了</li></ul><p>但显而易见，去年是吾辈工作的第三年，但成长速度确实不尽人意。至于原因，吾辈内里倒也十分清楚。</p><ul><li>客观原因：<ul><li>当公司的 team 不能为自己的成长提供帮助时，也只能一个人走着自己的探索之路，但这时常会感到灰心丧气，甚至破罐破摔式的放弃挣扎。– 然后在一段时间时间后回想起来感到后悔，仿若贤者时间一般。</li><li>疫情（是一个非常不好的开始）</li></ul></li><li>主观原因<ul><li>没找到一条明确的变得更好的途径，内心迷茫。上一次这样的时候吾辈从后端转职为了前端，但这一次，吾辈不清楚应该怎么做。</li><li>懒散、无法坚持，这些缺点今年切实的体现在了吾辈身上，而这却又无法轻易摆脱。</li><li>生活没有规律，睡得很晚，周末没有合理的安排时间出去活动。</li></ul></li></ul><h2 id="新的计划"><a href="#新的计划" class="headerlink" title="新的计划"></a>新的计划</h2><p>总体而言，核心目标仍然没有变化：<strong>活下去，活得更好</strong>。但执行层面确实需要发生一些变化。</p><p>目标</p><ul><li>[ ] 制定并坚持合理的时间计划</li><li>[ ] 切实地找到新的学习方法</li><li>[ ] 看完之前购买的书籍</li><li>[ ] 学习英语</li></ul><p>开源项目</p><ul><li>[ ] 编写 Electron 经验之谈系列博客 – 1 月</li><li>[ ] 完善 joplin-blog cli，提高效率，优化 UX – 2 月上旬</li><li>[ ] 重构 web logger 日志工具 – 2 月上旬</li><li>[ ] 重构 rx-util 工具包，将之分解为独立的一系列模块，避免耦合 nodejs/dom 和庞大难以引入的问题 – 春节</li></ul><p>希望今年自己能变得更好，在一切糟糕到无法挽回之前，离开这里 – 世界那么大，吾辈也想出去看看。</p><blockquote><p>2020 是过去十年最坏的一年，但或许，是今后十年最好的一年。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>个人</tag>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫谈 反乌托邦</title>
    <link href="/p/a8e38f7f626943ab85ac911bf79ace1e/"/>
    <url>/p/a8e38f7f626943ab85ac911bf79ace1e/</url>
    
    <content type="html"><![CDATA[<h2 id="1984"><a href="#1984" class="headerlink" title="1984"></a>1984</h2><p>最近看完了 <strong>1984</strong> 这本小说，在之后也补了一下电影</p><p>Youtube 正版电影</p><iframe width="560" height="315" src="https://www.youtube.com/embed/S0WSCZx6R6M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>一些设定令人惊奇</p><ul><li>真理部：负责新闻、娱乐、教育、艺术</li><li>和平部：负责战争</li><li>有爱不：负责维持法律和秩序</li><li>富裕部：负责经济事务</li></ul><p>一些名言令人印象深刻</p><ul><li>过去被禁止，控制过去的人控制未来，控制现在的人控制过去。</li><li>除了对集体的爱，没有其他的爱，与之竞争的都要被摧毁。</li><li>无产阶级就像牲口一样，什么办法都没有。</li><li>现代战争的本质，就是毁灭产品和人类的劳动，保持社会处于饥饿的边缘，一个分等级的社会只可能建立在贫穷和无知的基础上。</li><li>栗树荫下，我出卖你，你出卖我。</li></ul><p>里面小孩举报父母，被洗脑而不自知，或许，亦是因为一张白纸更容易染上颜色吧。</p><ul><li>低效的前进，高效的内斗</li></ul><p>现实场景</p><ul><li>这本书可以很容易买到</li><li>中文网络上没有国人影评/同人小说</li><li>1984 在微博已经成为非法内容了</li><li>举报父母已有现实案例（所谓的大义灭亲）</li></ul><h2 id="美丽新世界"><a href="#美丽新世界" class="headerlink" title="美丽新世界"></a>美丽新世界</h2><ul><li>人工胚胎，设置命运：感觉是个恐怖的极权世界</li><li>从小开始的 SEX 游戏与索麻，消费/享乐主义至上：或许是个天堂？</li><li>野人区：旧时代的信仰、肮脏的生活与 <strong>美丽新世界</strong> 对比，让人真不知道哪个是天堂？</li><li>野人疯了：发现自己苦苦追寻的事物、坚信的认知却一文不值时，疯掉了，<strong>天堂</strong> 对他而言也是地狱了</li><li><code>9/10</code> 的人口供养着 <code>1/10</code> 的人口是 <strong>阿尔法</strong>，无论是水上还是水下都会感到快乐，不提高产量的最大原因是为了避免闲暇时间造成资源的浪费</li></ul><p>那种 <strong>美丽新世界</strong> 和 <strong>野人区</strong> 真的很难说哪个更好，活到 60 岁，但一生都能保持年轻，并且 <strong>每个人属于每个人</strong> 的理念确实很厉害。</p><ul><li>要求 <strong>不快乐</strong> 的权力</li></ul><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>花了几年营造出来的中国梦，在一个春节就破碎的不成样子了。</p><ul><li>双重思想在现实中确实存在，而且很常见。<ul><li><a href="https://twitter.com/LiYing_2015/status/1227363930504196096">所以为歌颂伟大牺牲的时候，就防护服不足，以至于医护人员都不够用，为辟反动谣言的时候，就殡葬人员都必须有防护服。动动脑子想一想的结果就是如此的辩证</a></li><li>“我们要自由。我们反对香港游行、台湾独立。”，说这两句话的是同一批人。<ul><li>或许未曾意识到，香港、台湾他们也是为了自由，甚至于，或许只是跟风发泄一下情绪，并不明白自由是什么。。。</li></ul></li></ul></li><li>没有说 <code>1 + 1 = 2</code> 的权利<ul><li><a href="https://zh.wikipedia.org/wiki/%E6%9D%8E%E6%96%87%E4%BA%AE">李文亮</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A6%E6%BC%A2%E9%80%A0%E8%AC%A0%E5%85%AB%E5%90%9B%E5%AD%90">武汉「造谣」八君子</a></li></ul></li><li>未曾想过现实中真的有 <strong>新语</strong> 一说<ul><li><a href="https://mp.weixin.qq.com/s/bS_8xCR2bxpwWKcoAeo4pw">为什么日本人显得比中国人更懂中国文化</a><ul><li>“山川异域，风月同天。” 居然比不上 <strong>新语</strong> 的 “武汉加油”。</li><li>新世纪笑话：<blockquote><p>我举一个例子，比如你是给武汉捐助救灾物资的一位执行者，你在包装箱上写了八个字：山川异域，风月同天。领导看见了，会直接骂你：“你特么神经病吗？写这个干嘛？应该写武汉加油，还要加一个大感叹号。”<br>为什么不能用这八个字？因为这八个字不在那一套新话系统里面。这就超出了一位领导干部的思维边界。超出思维边界的事物，都是危险的、不可控的，是不可以使用的。<br>领导还要问你：你听明白了吗？能不能做到？<br>所以，你只能写个 “武汉加油”。</p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的 ES6 Proxy</title>
    <link href="/p/701ee4d58e954c848e20e898ed0d428b/"/>
    <url>/p/701ee4d58e954c848e20e898ed0d428b/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>就算只是扮演，也会成为真实的自我的一部分。对人类的精神来说，真实和虚假其实并没有明显的界限。入戏太深不是一件好事，但对于你来说并不成立，因为戏中的你才是真正符合你的身份的你。如今的你是真实的，就算一开始你只是在模仿着这种形象，现在的你也已经成为了这种形象。无论如何，你也不可能再回到过去了。</p></blockquote><p><code>Proxy</code> 代理，在 JavaScript 似乎很陌生，却又在生活中无处不在。或许有人在学习 ES6 的时候有所涉猎，但却并未真正了解它的使用场景，平时在写业务代码时也不会用到这个特性。</p><p>相比于文绉绉的定义内容，想必我们更希望了解它的使用场景，使其在真正的生产环境发挥强大的作用，而不仅仅是作为一个新的特性 – <strong>然后，实际中完全没有用到！</strong></p><ul><li>为函数添加特定的功能</li><li>代理对象的访问</li><li>作为胶水桥接不同结构的对象</li><li>监视对象的变化</li><li>还有更多。。。</li></ul><p>如果你还没有了解过 <code>Proxy</code> 特性，可以先去 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN Proxy</a> 上查看基本概念及使用。</p><h2 id="为函数添加特定的功能"><a href="#为函数添加特定的功能" class="headerlink" title="为函数添加特定的功能"></a>为函数添加特定的功能</h2><p>下面是一个为异步函数自动添加超时功能的高阶函数，我们来看一下它有什么问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为异步函数添加自动超时功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>action 异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的异步函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTimeout</span>(<span class="hljs-params">timeout, action</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.race([<br>      <span class="hljs-built_in">Reflect</span>.apply(action, <span class="hljs-built_in">this</span>, args),<br>      wait(timeout).then(<span class="hljs-built_in">Promise</span>.reject),<br>    ]);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一般而言</strong>，上面的代码足以胜任，但问题就在这里，不一般的情况 – 函数上面包含<strong>自定义属性</strong>呢？<br>众所周知，JavaScript 中的函数是一等公民，即函数可以被传递，被返回，以及，被添加属性！</p><p>例如下面这个简单的函数 <code>get</code>，其上有着 <code>_name</code> 这个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br>get._name = <span class="hljs-string">&quot;get&quot;</span>;<br></code></pre></td></tr></table></figure><p>一旦使用上面的 <code>asyncTimeout</code> 函数包裹之后，问题便会出现，返回的函数中 <code>_name</code> 属性不见了。这是当然的，毕竟实际上返回的是一个匿名函数。那么，如何才能让返回的函数能够拥有传入函数参数上的所有自定义属性呢？<br>一种方式是复制参数函数上的所有属性，但这点实现起来其实并不容易，真的不容易，不信你可以看看 Lodash 的 clone 函数。那么，有没有一种更简单的方式呢？答案就是 <code>Proxy</code>，它可以代理对象的指定操作，除此之外，其他的一切都指向原对象。<br>下面是 <code>Proxy</code> 实现的 <code>asyncTimeout</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为异步函数添加自动超时功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>action 异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的异步函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTimeout</span>(<span class="hljs-params">timeout, action</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(action, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">_, _this, args</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.race([<br>        <span class="hljs-built_in">Reflect</span>.apply(_, _this, args),<br>        wait(timeout).then(<span class="hljs-built_in">Promise</span>.reject),<br>      ]);<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下，是可以正常调用与访问其上的属性的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">console</span>.log(get._name);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>好了，这便是吾辈最常用的一种方式了 – <strong>封装高阶函数，为函数添加某些功能</strong>。</p><h2 id="代理对象的访问"><a href="#代理对象的访问" class="headerlink" title="代理对象的访问"></a>代理对象的访问</h2><p>下面是一段代码，用以在页面上展示从后台获取的数据，如果字段没有值则默认展示 <code>&#39;&#39;</code></p><p>模拟一个获取列表的异步请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">list</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 此处仅为构造列表</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; id, name, age, sex, address &#125; = &#123;&#125;</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.id = id;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.age = age;<br>      <span class="hljs-built_in">this</span>.sex = sex;<br>      <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [<br>    <span class="hljs-keyword">new</span> Person(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;琉璃&quot;</span> &#125;),<br>    <span class="hljs-keyword">new</span> Person(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">17</span> &#125;),<br>    <span class="hljs-keyword">new</span> Person(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">sex</span>: <span class="hljs-literal">false</span> &#125;),<br>    <span class="hljs-keyword">new</span> Person(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;幻想乡&quot;</span> &#125;),<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试直接通过解构为属性赋予默认值，并在默认值实现这个功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 为所有为赋值属性都赋予默认值 &#x27;&#x27;</span><br>  <span class="hljs-keyword">const</span> persons = (<span class="hljs-keyword">await</span> list()).map(<br>    (&#123; id = <span class="hljs-string">&quot;&quot;</span>, name = <span class="hljs-string">&quot;&quot;</span>, age = <span class="hljs-string">&quot;&quot;</span>, sex = <span class="hljs-string">&quot;&quot;</span>, address = <span class="hljs-string">&quot;&quot;</span> &#125;) =&gt; (&#123;<br>      id,<br>      name,<br>      age,<br>      sex,<br>      address,<br>    &#125;)<br>  );<br>  <span class="hljs-built_in">console</span>.log(persons);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>下面让我们写得更通用一些</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warp</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = obj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(obj)) &#123;<br>    <span class="hljs-keyword">const</span> v = <span class="hljs-built_in">Reflect</span>.get(obj, k);<br>    result[k] = v === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&quot;&quot;</span> : v;<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 为所有为赋值属性都赋予默认值 &#x27;&#x27;</span><br>  <span class="hljs-keyword">const</span> persons = (<span class="hljs-keyword">await</span> list()).map(warp);<br>  <span class="hljs-built_in">console</span>.log(persons);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>暂且先看一下这里的 <code>warp</code> 函数有什么问题？</p><hr><p>这里是答案的分割线</p><hr><ul><li>所有属性需要预定义，不能运行时决定</li><li>没有指向原对象，后续的修改会造成麻烦</li></ul><p>吾辈先解释一下这两个问题</p><ol><li>所有属性需要预定义，不能运行时决定<br> 如果调用了 <code>list[0].a</code> 会发生什么呢？是的，依旧会是 <code>undefined</code>，因为 <code>Reflect.ownKeys</code> 也不能找到没有定义的属性（<code>真*undefined</code>），因此导致访问未定义的属性仍然会是 <code>undefined</code> 而非期望的默认值。</li><li>没有指向原对象，后续的修改会造成麻烦<br> 如果我们此时修改对象的一个属性，那么会影响到原本的属性么？不会，因为 <code>warp</code> 返回的对象已经是全新的了，和原对象没有什么联系。所以，当你修改时当然不会影响到原对象。<br> Pass: 我们当然可以直接修改原对象，但这很明显不太符合我们的期望：显示时展示默认值 <code>&#39;&#39;</code> – 这并不意味着我们愿意在其他操作时需要 <code>&#39;&#39;</code>，否则我们还要再转换一遍。（例如发送编辑后的数据到后台）</li></ol><p>这个时候 <code>Proxy</code> 也可以派上用场，使用 <code>Proxy</code> 实现 <code>warp</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warp</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">_, k</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> v = <span class="hljs-built_in">Reflect</span>.get(_, k);<br>      <span class="hljs-keyword">if</span> (v !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">return</span> v;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，上面的那两个问题都解决了！</p><blockquote><p>注: 知名的 GitHub 库 <a href="https://github.com/immerjs/immer">immer</a> 就使用了该特性实现了不可变状态树。</p></blockquote><h2 id="作为胶水桥接不同结构的对象"><a href="#作为胶水桥接不同结构的对象" class="headerlink" title="作为胶水桥接不同结构的对象"></a>作为胶水桥接不同结构的对象</h2><p>通过上面的例子我们可以知道，即便是未定义的属性，<code>Proxy</code> 也能进行代理。这意味着，我们可以通过 <code>Proxy</code> 抹平相似对象之间结构的差异，以相同的方式处理类似的对象。</p><blockquote><p>Pass: 不同公司的项目中的同一个实体的结构不一定完全相同，但基本上类似，只是字段名不同罢了。所以使用 <code>Proxy</code> 实现胶水桥接不同结构的对象方便我们在不同公司使用我们的工具库！<br>嘛，开个玩笑，其实在同一个公司中不同的实体也会有类似的结构，也会需要相同的操作，最常见的应该是树结构数据。例如下面的菜单实体和系统权限实体就很相似，也需要相同的操作 – <strong>树 &lt;=&gt; 列表 相互转换</strong>。</p></blockquote><p>思考一下如何在同一个函数中处理这两种树节点结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 系统菜单</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysMenu</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>id 菜单 id</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>name 显示的名称</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>parent 父级菜单 id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">id, name, parent</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 系统权限</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysPermission</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>uid 系统唯一 uuid</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>label 显示的菜单名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>parentId 父级权限 uid</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uid, label, parentId</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.uid = uid;<br>    <span class="hljs-built_in">this</span>.label = label;<br>    <span class="hljs-built_in">this</span>.parentId = parentId;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面让我们使用 <code>Proxy</code> 来抹平访问它们之间的差异</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sysMenuProxy = &#123; <span class="hljs-attr">parentId</span>: <span class="hljs-string">&quot;parent&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> sysMenu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-keyword">new</span> SysMenu(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-number">0</span>), &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">_, k</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(sysMenuProxy, k)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(_, <span class="hljs-built_in">Reflect</span>.get(sysMenuProxy, k));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(_, k);<br>  &#125;,<br>&#125;);<br><span class="hljs-built_in">console</span>.log(sysMenu.id, sysMenu.name, sysMenu.parentId); <span class="hljs-comment">// 1 &#x27;rx&#x27; 0</span><br><br><span class="hljs-keyword">const</span> sysPermissionProxy = &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;uid&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;label&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> sysPermission = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-keyword">new</span> SysPermission(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-number">0</span>), &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">_, k</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(sysPermissionProxy, k)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(_, <span class="hljs-built_in">Reflect</span>.get(sysPermissionProxy, k));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(_, k);<br>  &#125;,<br>&#125;);<br><span class="hljs-built_in">console</span>.log(sysPermission.id, sysPermission.name, sysPermission.parentId); <span class="hljs-comment">// 1 &#x27;rx&#x27; 0</span><br></code></pre></td></tr></table></figure><p>看起来似乎有点繁琐，让我们封装一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 桥接对象不存在的字段</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>map 代理的字段映射 Map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Function&#125;</span> </span>转换一个对象为代理对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bridge</span>(<span class="hljs-params">map</span>) </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 为对象添加代理的函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>obj 任何对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Proxy&#125;</span> </span>代理后的对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, k</span>)</span> &#123;<br>        <span class="hljs-comment">// 如果遇到被代理的属性则返回真实的属性</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(map, k)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, <span class="hljs-built_in">Reflect</span>.get(map, k));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, k);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, k, v</span>)</span> &#123;<br>        <span class="hljs-comment">// 如果遇到被代理的属性则设置真实的属性</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(map, k)) &#123;<br>          <span class="hljs-built_in">Reflect</span>.set(target, <span class="hljs-built_in">Reflect</span>.get(map, k), v);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-built_in">Reflect</span>.set(target, k, v);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;,<br>    &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以用更简单的方式来做代理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sysMenu = bridge(&#123;<br>  parentId: <span class="hljs-string">&quot;parent&quot;</span>,<br>&#125;)(<span class="hljs-keyword">new</span> SysMenu(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">console</span>.log(sysMenu.id, sysMenu.name, sysMenu.parentId); <span class="hljs-comment">// 1 &#x27;rx&#x27; 0</span><br><br><span class="hljs-keyword">const</span> sysPermission = bridge(&#123;<br>  id: <span class="hljs-string">&quot;uid&quot;</span>,<br>  name: <span class="hljs-string">&quot;label&quot;</span>,<br>&#125;)(<span class="hljs-keyword">new</span> SysPermission(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">console</span>.log(sysPermission.id, sysPermission.name, sysPermission.parentId); <span class="hljs-comment">// 1 &#x27;rx&#x27; 0</span><br></code></pre></td></tr></table></figure><p>如果想看 JavaScirpt 如何处理树结构数据话，可以参考吾辈的 <a href="https://blog.rxliuli.com/p/bb943156/">JavaScript 处理树数据结构</a></p><h2 id="监视对象的变化"><a href="#监视对象的变化" class="headerlink" title="监视对象的变化"></a>监视对象的变化</h2><p>接下来，我们想想，平时是否有需要监视对象的变化，然后进行某些处理呢？</p><p>例如监视用户复选框选中项列表的变化并更新对应的需要发送到后台的 <code>id</code> 拼接字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟页面的复选框列表</span><br><span class="hljs-keyword">const</span> hobbyMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  .set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小说&quot;</span>)<br>  .set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;动画&quot;</span>)<br>  .set(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;电影&quot;</span>)<br>  .set(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;游戏&quot;</span>);<br><span class="hljs-keyword">const</span> user = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// 保存兴趣 id 的列表</span><br>  hobbySet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),<br>  <span class="hljs-comment">// 发送到后台的兴趣 id 拼接后的字符串，以都好进行分割</span><br>  hobby: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">id</span>) </span>&#123;<br>  user.hobbySet.has(id) ? user.hobbySet.delete(id) : user.hobbySet.add(id);<br>&#125;<br><br><span class="hljs-comment">// 模拟两次点击</span><br>onClick(<span class="hljs-number">1</span>);<br>onClick(<span class="hljs-number">2</span>);<br><br><span class="hljs-built_in">console</span>.log(user.hobby); <span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>下面使用 <code>Proxy</code> 来完成 <code>hobbySet</code> 属性改变后 <code>hobby</code> 自动更新的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 深度监听指定对象属性的变化</span><br><span class="hljs-comment"> * 注：指定对象不能是原始类型，即不可变类型，而且对象本身的引用不能改变，最好使用 const 进行声明</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>object 需要监视的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>callback 当代理对象发生改变时的回调函数，回调函数有三个参数，分别是对象，修改的 key，修改的 v</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>返回源对象的一个代理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchObject</span>(<span class="hljs-params">object, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">_, k</span>)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注意: 这里很关键，它为对象的字段也添加了代理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(v, <span class="hljs-built_in">Reflect</span>.get(_, k));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(_, k);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">_, k, v</span>)</span> &#123;<br>      callback(_, k, v);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(_, k, v);<br>    &#125;,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(object, handler);<br>&#125;<br><br><span class="hljs-comment">// 模拟页面的复选框列表</span><br><span class="hljs-keyword">const</span> hobbyMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  .set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小说&quot;</span>)<br>  .set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;动画&quot;</span>)<br>  .set(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;电影&quot;</span>)<br>  .set(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;游戏&quot;</span>);<br><span class="hljs-keyword">const</span> user = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  <span class="hljs-comment">// 保存兴趣 id 的列表</span><br>  hobbySet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),<br>  <span class="hljs-comment">// 发送到后台的兴趣 id 拼接后的字符串，以都好进行分割</span><br>  hobby: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = watchObject(user, <span class="hljs-function">(<span class="hljs-params">_, k, v</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (k === <span class="hljs-string">&quot;hobbySet&quot;</span>) &#123;<br>    _.hobby = [..._.hobbySet].join(<span class="hljs-string">&quot;,&quot;</span>);<br>  &#125;<br>&#125;);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">id</span>) </span>&#123;<br>  proxy.hobbySet = proxy.hobbySet.has(id)<br>    ? proxy.hobbySet.delete(id)<br>    : proxy.hobbySet.add(id);<br>&#125;<br><span class="hljs-comment">// 模拟两次点击</span><br>onClick(<span class="hljs-number">1</span>);<br>onClick(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 现在，user.hobby 的值将会自动更新</span><br><span class="hljs-built_in">console</span>.log(user.hobby); <span class="hljs-comment">// 1,2</span><br></code></pre></td></tr></table></figure><p>当然，这里实现的 <code>watchObject</code> 函数还非常非常非常简陋，如果有需要可以进行更深度/强大的监听，可以尝试自行实现一下啦！</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>说完了这些 <code>Proxy</code> 的使用场景，下面稍微来说一下它的缺点</p><ul><li><p>运行环境必须要 ES6 支持<br>这是一个不大不小的问题，现代的浏览器基本上都支持 ES6，但如果泥萌公司技术栈非常老旧的话（例如支持 IE6），还是安心吃土吧 #笑 #这种公司不离职等着老死</p></li><li><p>不能直接代理一些需要 this 的对象<br>这个问题就比较麻烦了，任何需要 this 的对象，代理之后的行为可能会发生变化。例如 <code>Set</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([]), &#123;&#125;);<br>proxy.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// Method Set.prototype.add called on incompatible receiver [object Object]</span><br></code></pre></td></tr></table></figure><p>是不是很奇怪，解决方案是把所有的 <code>get</code> 操作属性值为 <code>function</code> 的函数都手动绑定 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([]), &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">_, k</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> v = <span class="hljs-built_in">Reflect</span>.get(_, k);<br>    <span class="hljs-comment">// 遇到 Function 都手动绑定一下 this</span><br>    <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>      <span class="hljs-keyword">return</span> v.bind(_);<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>  &#125;,<br>&#125;);<br>proxy.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><p><code>Proxy</code> 是个很强大的特性，能够让我们实现一些曾经难以实现的功能（所以这就是你不支持 ES5 的理由？#打），就连 Vue3+ 都开始使用 <code>Proxy</code> 实现了，你还有什么理由在乎上古时期的 IE 而不用呢？（ｖ＾＿＾）ｖ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派入坑体会</title>
    <link href="/p/859bf7609f884a4a891123feac4db809/"/>
    <url>/p/859bf7609f884a4a891123feac4db809/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想在家里搭个本地服务器玩，于是便买了个树莓派 4。现在，吾辈已经让它在纸盒里默默吃灰了。</p><ul><li>为什么吾辈搭建服务器？</li><li>为什么吾辈要选择树莓派？</li><li>以及为何最终它还是吃灰了？</li></ul><p>上面这些问题吾辈会在下面一一解答。</p><h2 id="为什么吾辈搭建服务器"><a href="#为什么吾辈搭建服务器" class="headerlink" title="为什么吾辈搭建服务器"></a>为什么吾辈搭建服务器</h2><p>搭建本地服务器的原因当然是想让一些服务持续 24 小时运行了，而吾辈最初的需求便是 <strong>PT/BT 做种</strong>。BT 或许很多人听说过，PT 又是什么呢？</p><p><img src="https://img.rxliuli.com/20190903081607.png" alt="PT 下载"></p><p>PT，全程 Private Tracker，是一种私有的 BT 服务。整个 BT 网络将不再是完全公开并且可供任何人下载的了，每个用户都会被计算上传量/下载量，如果这个比率过低就会被 ban。这种下载方式本意是为了解决 BT 中很多用户喜欢只下载而不进行上传的行为，强制所有人必须<strong>殚精竭虑</strong>地计算分享率，注意自己的下载量，考虑下载热门资源而赚取积分（事实证明这条路注定也不会走的太顺利，分享是一个长期收益的行为，最终下载的人短期内实际上并不多，而计算分享率却是实时的）。<br>吾辈需要的便是 24h 不间断的挂着 PT/BT 服务，以在闲暇时刻消耗家里的网络带宽，顺便做一波公益行为。</p><blockquote><p><a href="https://zh.wikipedia.org/zh/PT%E4%B8%8B%E8%BC%89">PT 下载 Wiki</a></p></blockquote><h2 id="为什么吾辈要选择树莓派"><a href="#为什么吾辈要选择树莓派" class="headerlink" title="为什么吾辈要选择树莓派"></a>为什么吾辈要选择树莓派</h2><p>一言以蔽之：树莓派宣传的很厉害。</p><p><img src="https://img.rxliuli.com/20190903143806.png" alt="树莓派官方图"></p><p>让我们看看网络上对树莓派的相关内容</p><ul><li><a href="https://www.iplaysoft.com/raspberrypi.html">异次元软件: 树莓派 4 代 - 全球最流行的 Linux 小型迷你电脑，性能大幅飙升！(支持 4K / USB3.0)</a></li><li><a href="https://www.zhihu.com/question/20859055">知乎: 「树莓派」是什么以及普通人怎么玩？</a></li></ul><p>树莓派<a href="https://www.raspberrypi.org/">官网</a>也自称是小型、双显示器的台式电脑，而且提供了一个树莓派专用的 Linux Debian 的定制发行版。</p><p>下面放一张吾辈买的树莓派 4 的照片，体积之小可见一斑。<br><img src="https://img.rxliuli.com/20190903081924.png" alt="树莓派"></p><p>讲真第一次看到这么小的时候吾辈真的被惊艳到了，从来没想过一个电脑能这么小，而且居然还能安装可视化的操作系统。</p><h2 id="以及为何最终它还是吃灰了"><a href="#以及为何最终它还是吃灰了" class="headerlink" title="以及为何最终它还是吃灰了"></a>以及为何最终它还是吃灰了</h2><p>之后吾辈便开始安装了官方的操作系统，首先，官方提供了两个选项</p><ul><li><a href="https://www.raspberrypi.org/downloads/noobs/">NOOBS</a>: 全新开箱即用的软件 - 适合初学者的操作系统安装引导程序。</li><li><a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian</a>: 官方支持的树莓派操作系统 - 基于 Debian Buster。</li></ul><p>然而事实上，两者皆有不足之处。首先，前者需要屏幕、键盘和鼠标进行安装，对于吾辈这种只是想把它作为本地服务器的用户而言，这是不可接受的。而使用官方的烧录工具将 Raspbian 刻录到 SD 卡之后，启动命令行倒是没有什么问题，但在启动桌面时却遇到的 bug – <a href="https://segmentfault.com/q/1010000020144913">树莓派 4 VNC 远程连接桌面错误</a>。当时似乎互联网上并没有多少人遇到这个问题，而吾辈恰好遇到了，所以费了一番功夫之后才成功开启了桌面。<br>进入桌面之后，又是换源又是更新，之后才在命令行安装了 qBittorrent（是的，即使已经有了桌面仍然需要从命令行安装程序）。嘛，不谈遇到了多少麻烦，qBittorrent 终于启动了 BT 服务，吾辈把 RSS 挂上了之后使其自动更新和下载最新种子，也便是大功告成了。</p><p><img src="https://img.rxliuli.com/20190903150304.png" alt="qBittorrent"></p><p>然后发现种子的 RSS 服务器有时会更新失败，吾辈猜想是没有代理的问题，于是便去网络上找到了一个 Linux 下的 SSR 可视化客户端 – <a href="https://github.com/shadowsocksrr/electron-ssr">electron-ssr</a>，然而下载完之后安装直接提示安装错误。</p><blockquote><p>注: electron-ssr 项目作者已经被请喝茶了，真真是风声鹤唳。</p></blockquote><p>然后向他人询问的时候甚至说出了 <strong>“咱也回答你了 ，需要找 arm 的 debian 包”</strong>，我的天，难道 Linux 下安装程序这么麻烦的么？不仅发行版要区分，现在连 CPU 架构也要区分了？用户体验老实说糟糕透顶，吾辈最终直接使用了本地的 SSR 局域网代理，笔记本开着的时候有代理，关了就没了，也便只能是暂且用着。</p><p>后来吾辈在几次偶尔使用 VNC 连接时发现 qBittorrent 关了，吾辈以为是 Linux 会默认杀掉不活跃的程序，没有在意，就手动重启了。直到昨天，吾辈在启动 qBittorrent 后直接闪退了。。。在观察了任务管理器之后，吾辈发现是启动时 CPU 的使用率暴增，然后就 GG 了。</p><p><img src="https://img.rxliuli.com/20190903150520.gif" alt="GIF 动图"></p><p>好了，还是放它在角落里吃灰吧。既然吾辈这个唯一的需求都无法实现，那留它何用，拉出去斩了吧！这或许是 qBittorrent 的问题，或许是 Raspbian 的问题，但吾辈已然不想关心，深究之下终究就得不偿失。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前就吾辈使用的体验而言，树莓派不可能真正的普及开来，只能作为一个极客的玩具罢了 – 没错，就是玩具，而非工具。<br>这时候一定会有人反对吾辈说 <strong>“永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能”</strong>，这点 Linux 桌面的社区也有很多开发者喜欢这样说，然而现在的结果是 Linux 无法在桌面领域立足，究其原因还是对用户不友好，难道开发者就不算是用户了？记得有人说过 <strong>“我是开发者，但同时也是用户。你的产品因为各种原因让我不爽，我就不会选你，我才不会管究竟是谁的锅”</strong>，用户中心论在这里可以说是体现的淋漓尽致。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在现代前端项目中使用 Worker</title>
    <link href="/p/1912191534384d65bc1976a9c143b725/"/>
    <url>/p/1912191534384d65bc1976a9c143b725/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于需要在 Browser 进行大量的（音频转解码）计算，所以吾辈开始尝试使用 webworker 分离 CPU 密集型的计算操作，最终找到了 comlink 这个库，但之前在 vue 中使用时发生了错误，目前看起来已经得到了解决，所以在此记录一下。</p><h2 id="调研方案"><a href="#调研方案" class="headerlink" title="调研方案"></a>调研方案</h2><ul><li><a href="https://github.com/satya164/web-worker-proxy">web-worker-proxy</a>：结合了 proxy/promise/webworker 的强大工具库，但如何在 ts 中使用却是个问题</li><li><a href="https://github.com/miozzz/sandbox/tree/master/orc">Orc.js</a>：一个简单的 worker 封装</li><li><a href="https://github.com/israelss/vue-worker">VueWorker</a>：结合 vue 的 worker 封装，无法理解，难道真的会有人在 vue 组件中进行大量计算么？</li><li>comlink：Chrome 的一个基于 proxy/promise/webworker 的封装库</li><li><a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a>：和上面的同属 chrome 实验室的一个 webpack 插件</li></ul><p>最后决定使用 comlink 结合 worker-plugin 实现简单的 worker 使用。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><blockquote><p>在 GitHub 上有 <a href="https://github.com/rxliuli/example/tree/master/react_worker_example">可运行示例 demo</a><br>相关问题：<a href="https://segmentfault.com/q/1010000022359546">comlink-loader 工作不正常</a></p></blockquote><h3 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add comlink<br>yarn add -D worker-plugin<br></code></pre></td></tr></table></figure><h3 id="在-webpack-配置中添加插件"><a href="#在-webpack-配置中添加插件" class="headerlink" title="在 webpack 配置中添加插件"></a>在 webpack 配置中添加插件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  plugins: [<span class="hljs-keyword">new</span> WorkerPlugin()];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里一般不需要特殊参数配置，如果需要，可以参考：<a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a></p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><p>添加一个简单的 <em>hello.worker.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; expose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;comlink&quot;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  counter: <span class="hljs-number">0</span>,<br>  <span class="hljs-function"><span class="hljs-title">inc</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.counter++;<br>  &#125;,<br>&#125;;<br><br>expose(obj);<br></code></pre></td></tr></table></figure><p>在 <code>main.ts</code> 中使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = wrap(<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./hello.worker.ts&quot;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;module&quot;</span> &#125;)) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br><span class="hljs-keyword">await</span> obj.inc();<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>但这里并不是类型安全的，所以我们可以实现正确的类型。</p><p>添加一个 <em>hello.worker.ts</em> 暴露出来的类型 <code>HelloWorkerType</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> HelloWorkerType &#123;<br>  counter: <span class="hljs-built_in">number</span>;<br>  inc(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时为了支持在 <em>main.ts</em> 中使用正确的类型，需要使用泛型</p><p><em>main.ts</em> 修改如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = wrap&lt;HelloWorkerType&gt;(<br>  <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./hello.worker.ts&quot;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;module&quot;</span> &#125;)<br>);<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br><span class="hljs-keyword">await</span> obj.inc();<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>声明函数的类型 <em>HelloCallback.worker.type.d.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ListItem&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt; = T <span class="hljs-keyword">extends</span> (infer U)[] ? U : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> MapWorkerType = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">any</span>[], <span class="hljs-attr">U</span>&gt;</span>(</span><br><span class="xml">  arr: List,</span><br>  cb: (val: ListItem&lt;List&gt;) =&gt; U | Promise&lt;U&gt;<br>) =&gt; Promise&lt;U[]&gt;;<br></code></pre></td></tr></table></figure><p>声明一个纯函数 <em>HelloCallback.worker.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; MapWorkerType &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./HelloCallback.worker.type&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; expose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;comlink&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> map: MapWorkerType = <span class="hljs-function">(<span class="hljs-params">arr, cb</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>.all(arr.map(cb));<br><br>expose(map);<br></code></pre></td></tr></table></figure><p>注：此处最好使用变量的形式，主要是为了方便将函数类型剥离出去。</p><p>在 <em>main.ts</em> 中使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> map = wrap&lt;MapWorkerType&gt;(<br>  <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./HelloCallback.worker.ts&quot;</span>, &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  &#125;)<br>);<br><span class="hljs-keyword">const</span> list = <span class="hljs-keyword">await</span> map(<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  proxy(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>)<br>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;list: &quot;</span>, list);<br></code></pre></td></tr></table></figure><h3 id="使用-class-的形式"><a href="#使用-class-的形式" class="headerlink" title="使用 class 的形式"></a>使用 class 的形式</h3><p>声明接口 <em>HelloClass.worker.type.d.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClassWorker</span> </span>&#123;<br>  sum(...args: <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>worker 文件 <em>HelloClass.worker.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; HelloClassWorker &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./HelloClass.worker.type&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; expose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;comlink&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClassWorkerImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">HelloClassWorker</span> </span>&#123;<br>  sum(...args: <span class="hljs-built_in">number</span>[]): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">res, i</span>) =&gt;</span> res + i, <span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><br>expose(HelloClassWorkerImpl);<br></code></pre></td></tr></table></figure><blockquote><p>关于此处 <code>implements class</code> 的问题，吾辈偶然一试之下没报错也很奇怪，所以找到了相关问题 <a href="https://stackoverflow.com/a/26961710">Typescript: How to extend two classes?</a>，官方文档也同样说明了这个特性 <a href="https://www.typescriptlang.org/docs/handbook/mixins.html">Mixins</a>。</p></blockquote><p>在 <em>main.ts</em> 中使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> HelloClassWorkerClazz = wrap&lt;<span class="hljs-keyword">typeof</span> HelloClassWorker&gt;(<br>  <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./HelloClass.worker.ts&quot;</span>, &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  &#125;)<br>);<br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> HelloClassWorkerClazz();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> instance.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，使用 worker 的基本分三步</p><ol><li> 编写需要放在 worker 里内容的类型定义</li><li> 根据类型定义实现它</li><li> 在主进程的代码中使用它</li></ol><blockquote><p>注：当然，如果是复杂的东西，可以直接在单独的文件中实现，然后声明一个 <em>.worker.ts</em> 暴露出去，不在 <em>.worker.ts</em> 中包含任何</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/">Integrating web workers in a React app with Comlink</a></li><li><a href="https://lorefnon.tech/2019/03/24/using-comlink-with-typescript-and-worker-loader/">Using comlink with typescript and worker-loader</a></li><li><a href="https://medium.com/lacolaco-blog/an-issue-around-angular-cli-comlink-workerplugin-585be1c8d087">An issue around Angular CLI + Comlink + WorkerPlugin</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>偶遇 HTML 中的奇妙字符</title>
    <link href="/p/b1b219edef7648938999d7944ff6157d/"/>
    <url>/p/b1b219edef7648938999d7944ff6157d/</url>
    
    <content type="html"><![CDATA[<p>虽然名字听起来就像是<strong>一本正经的胡说八道</strong>，但吾辈确实遇到了一个奇怪的问题，于此分享给大家。</p><p>事情的起始如下</p><p><em>下班回家 =&gt; 想要看动画 =&gt; 去动漫花园下载 BT 种子 =&gt; 动漫花园一片空白 =&gt; Why？</em></p><p><img src="https://raw.githubusercontent.com/rxliuli/img-bed/master/20200429010151.png" alt="默认 uBlock 屏蔽页面"></p><p>于是吾辈<strong>偷偷的</strong>的打开了控制台看了一下，发现是页面中的内容元素不见了。经过深思熟虑（好吧其实也就是稍微想了一下）首先把 uBlock 禁用，毕竟这个最容易被网站检测出来并且<strong>对抗</strong>嘛！果不其然，页面恢复了正常，但。。。同时广告也出现在了页面上。</p><p><img src="https://img.rxliuli.com/20200429010420.png" alt="默认 uBlock 不屏蔽页面"></p><p>这可不行，重新启用了 uBlock 看了一下分析，很显然，内容不存在大概率是被 uBlock 的<strong>元素过滤</strong>功能隐藏掉了，查看被隐藏的内容元素，发现 id 为 <code>1280_adv</code>，但同时又包含了广告与主体内容，所以只要关掉 uBlock 的<strong>元素过滤</strong>就可以避免正常内容被误杀了。</p><blockquote><p>之所以不在该网站整个禁用掉 uBlock 的原因在于 uBlock 并不只有<strong>元素过滤</strong>，它还阻止了一些广告资源的加载，仅在动漫花园就包括但不限于 _baidu.com, bebi.com, histats.com_。显而易见，禁用它们还能提高加载速度。</p></blockquote><p><img src="https://img.rxliuli.com/20200429010547.png" alt="uBlock 屏蔽的脚本"></p><p>既然无法使用 uBlock 的元素屏蔽了，那么吾辈便需要使用一个新的方式去阻止广告了，幸运的是吾辈安装了 Stylus 和 Tampermonkey 插件。</p><blockquote><p>Stylus 能够使用被称为 <code>user.css</code> 的技术，能够在本地修改任意网站的样式 – 即自定义 UI 显示。<br>而 Tampermonkey 则更强大，支持 <code>user.js</code> – 可以在本地打开任意网站时载入自定义的 JavaScript 脚本，不再局限于修改 UI，几乎与插件无异（事实上它也确实被认为是更轻量的插件）。</p></blockquote><p>原以为就几句 css 的事情，找到了广告的 id，于是吾辈写下了下面这些 css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*屏蔽动漫花园的广告*/</span><br><span class="hljs-selector-class">.ad</span>,<br><span class="hljs-selector-id">#1280_adv</span>,<br><span class="hljs-selector-id">#1280_ad</span> &gt; <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-id">#bebiv3_ad</span> &#123;<br>  <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>但结果却是。。。只生效了一半！</p><p><img src="https://img.rxliuli.com/20200429010717.png" alt="屏蔽一半"></p><p>可以看到，上面两个广告确实被隐藏了，但下面一个却并没有，而且吾辈在控制台直接使用 <code>document.querySelector(&#39;#1280_adv&#39;)</code> 也获取 dom 会抛出错误 <code>SyntaxError: Document.querySelector: &#39;#1280_adv&#39; is not a valid selector</code>。吾辈是直接复制的 id，<strong>理论上</strong>来说不会有错才是。</p><p>仔细想想，吾辈或许是漏掉了什么。。。于是，吾辈使用 <strong>Copy =&gt; Copy Selector</strong> 功能，有趣的东西出现了，复制出来的内容竟然是 <code>&#39;\31 280_adv&#39;</code>，wtf？</p><p>嗯，或许吾辈需要冷静一下，尝试使用 <code>document.querySelector(&quot;#\\31 280_adv&quot;)</code> 获取一下</p><blockquote><p>注意：这里 JS 里面去查询 DOM Selector 的字符串又进行了转义。</p></blockquote><p><img src="https://img.rxliuli.com/20200429010811.png" alt="Console 获取"></p><p>OK，确实能够正常拿到。由于这些奇怪的字符在 css 中存在语法错误，那么接下来便用 <code>user.js</code> 去屏蔽掉它们吧！</p><p>基本实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#\\31 280_adv&quot;</span>),<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.ad&quot;</span>),<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#\\31 280_ad &gt; a&quot;</span>),<br>].forEach(<span class="hljs-function">(<span class="hljs-params">ad</span>) =&gt;</span> ad.remove());<br></code></pre></td></tr></table></figure><p>甚至吾辈都发到了 <a href="https://github.com/rxliuli/userjs/tree/master/src/dmhy">GitHub</a> 与 <a href="https://greasyfork.org/zh-CN/scripts/402206">GreasyFork</a> 上了。</p><p>然后，有个（万能的）网友就提出，可以转换思路，既然 <code>#\\31 280_adv</code> 在 css 中存在语法错误，那么使用属性选择器过滤 id 将值包裹在 <code>&#39;&#39;</code> 之中不就好了么？此话真是九言劝醒迷途仕，一语惊醒梦中人，吾辈瞬间 GET 到了这个点。</p><p>于是吾辈编写出了下面这段 <code>user.css</code> 样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*屏蔽动漫花园的广告*/</span><br><span class="hljs-selector-class">.ad</span>,<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&quot;\31 280_adv&quot;</span>]</span>,<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&quot;\31 280_ad&quot;</span>]</span> &gt; <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&quot;bebiv3_ad&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用后效果如下</p><p><img src="https://img.rxliuli.com/20200429010852.png" alt="屏蔽后干净的网页"></p><p>现在，初始目的达成了，吾辈开始有点好奇它是怎么实现这个功能，于是下载了它的源码，id 那里并未发现什么奇怪的东西，但吾辈却也无法复现一个 demo！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#test&quot;</span>).setAttribute(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;\\31 280_adv&quot;</span>);</span><br>      &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>demo 效果</p><p><img src="https://img.rxliuli.com/20200429011004.png" alt="demo 效果"></p><p>如果有人知道原因的话，请务必不吝赐教！</p><blockquote><p>参考：<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII Wiki</a></p></blockquote><hr><blockquote><p>后续，万能的网友 <a href="https://disqus.com/by/niamori/">NiaMori</a> 又来说明啦，实际上是 id 以数字开头的原因，具体问题参考：<br>是 id 以数字开头的原因，简单的 <code>&lt;div id=&quot;1&quot;&gt;test&lt;div&gt;</code> 就能复现这个效果。<br><code>document.getElementById(&#39;1&#39;)</code> 能够选中，但 <code>document.querySelector(&#39;#1&#39;)</code> 不能，因为 HTML5 允许 id 以数字开头而 CSS 不允许<br>0x31 是 ‘1’ 的 Unicode 编码值，Copy selector 的时候 Chrome 做了一个智能的 escape<br>参考：</p><ul><li><a href="https://disq.us/url?url=https://stackoverflow.com/questions/20306204/using-queryselector-with-ids-that-are-numbers:ywx_Ldt8DYLp36vWCEZDC-CT6pM&cuid=5534903">Using querySelector with IDs that are numbers</a></li><li><a href="https://disq.us/url?url=https://www.w3.org/TR/CSS21/syndata.html%23characters:YR69gjoR28vxgXneZXGYH3k8gFM&cuid=5534903">Css Spec</a></li><li><a href="https://disq.us/url?url=https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape:5uLuEmiEmKi4BAwjvTU8OFFY6OQ&cuid=5534903">CSS.escape</a></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FireFox [附加组件管理器] 标签页使用 Chrome 的 favIconUrl</title>
    <link href="/p/b7e38466a8df4e0aa80641480baa98b3/"/>
    <url>/p/b7e38466a8df4e0aa80641480baa98b3/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈最近开发了一个 <a href="https://github.com/rxliuli/tabs_panel">标签页快速切换插件</a>，原本准备在 Chrome Store 先行上架的，不过由于 Chrome 的 <a href="https://chrome.google.com/webstore/devconsole/register?hl=zh-CN">开发者注册</a> 需要 Visa 信用卡付费，所以不得已暂缓了下来。<br>于是，去看了一下 Firefox 的插件开发者中心，发现其并不需要收费，所以便想要兼容一下 Firefox，但吾辈却由此发现了奇怪的事情。</p><p>首先是 firefox 报的一个错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">安全错误：位于 moz-extension:<span class="hljs-comment">//b0d38f9f-eca1-4163-870e-64aedabf5f20/popup.html 的内容不可以载入或者链接至 chrome://mozapps/skin/extensions/extension.svg。</span><br></code></pre></td></tr></table></figure><p>当然，吾辈看到这个错误的第一时间是很懵逼的，因为吾辈未曾引用过 <em>chrome://mozapps/skin/extensions/extension.svg</em> 这个 svg 图片啊，为什么会提示不可以载入呢？</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>于是吾辈去看了 <code>browser.tabs.query</code> 所查询到的数据，结果。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">arr = <span class="hljs-keyword">await</span> browser.tabs.query(&#123;&#125;);<br>arr.find(<br>  (tab) =&gt; (tab.favIconUrl = <span class="hljs-string">&quot;chrome://mozapps/skin/extensions/extension.svg&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p><img src="https://img.rxliuli.com/20200508234243.png" alt="查询到的 tab"></p><p>为什么 Firefox 的<strong>附加组件管理器</strong>标签页会使用 Chrome 的图标啊？难道是 Firefox 的开发团队复制 Chrome 源码的时候忘记替换了么？<br>抱着好玩的想法，吾辈将这个错误分享到了某个 Telegram 前端群中，有人提出了完全不同的解释：这是 Firefox 历史的遗产 – 遠古的 XUL 留下來的 scheme，甚至在 Chrome 浏览器出现之前就已经存在了。</p><blockquote><p>参考:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/XUL/Tutorial/The_Chrome_URL">遠古的 XUL 留下來的 scheme</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Mozilla/Chrome_Registration">2004 年 Firefox 1.0 的介面層就叫做 chrome 惹</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/XUL_%E6%95%99%E5%AD%B8">XUL 教学</a></li></ul></blockquote><h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><p>如果有人想要复现这个问题玩一下的话，具体流程如下：</p><pre><code class=" mermaid">graph TB;打开附加组件管理器 --&gt; 调试附加组件 --&gt; 选择一个扩展点击检查按钮 --&gt; 输入上面的代码</code></pre><p><img src="https://img.rxliuli.com/20200509001909.gif" alt="流程示意图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真相只有一个：Firefox 58 之后虽然号称重构了这个浏览器，但 UI 层并未抛弃掉老旧的 XUL，同时 Firefox 主要推动的 web extension api 则并未注意到这个问题（这里或许能从侧面说明 Firefox 的插件生态并不繁荣，这种问题都没有人遇到过。。。），导致了这种 <strong>自相冲突</strong> 的奇葩问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客已添加离线支持</title>
    <link href="/p/04d4a0f974b4406fb34531036632ff5f/"/>
    <url>/p/04d4a0f974b4406fb34531036632ff5f/</url>
    
    <content type="html"><![CDATA[<p>博客已使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">service-worker</a> 技术对网站添加离线支持功能，具体实现不过是使用了 <a href="https://github.com/JLHwung/hexo-offline">hexo-offline</a> 插件，之后所有第一次访问过的页面之后便离线可用了，同时即便在线浏览仍然能更快的展示页面。<br>想要使用它的主要原因是吾辈的博客是静态的，意味着几乎所有的资源都可以通过 service-worker 缓存，以此提高网站的可用性。</p><blockquote><p>注: <a href="https://vuejs.org/">Vue 官网</a> 使用 hexo 构建，同时使用了该插件实现离线支持。</p></blockquote><p><img src="https://img.rxliuli.com/20200517111759.png" alt="ServiceWorker"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用插件还是油猴脚本</title>
    <link href="/p/b95ad81959a440fa9c3f2df0cafd3773/"/>
    <url>/p/b95ad81959a440fa9c3f2df0cafd3773/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近吾辈写了一个 chrome 插件，之前也有写过许多 user.js 脚本，所以便想在此谈一下它们的区别，以及如何选择。</p><ul><li><a href="https://greasyfork.org/zh-CN/users/84714">吾辈写过的 user.js 脚本</a></li><li><a href="https://chrome.google.com/webstore/search/rxliuli">吾辈写过的 chrome 插件</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://zh.wikipedia.org/zh-hk/Greasemonkey">user.js wiki</a>, <a href="https://developer.chrome.com/extensions/devguide">chrome plugin dev doc</a></p></blockquote><p>user.js 是一个开放的的标准，最早由 Firefox 的一个插件提出，后来在 chrome 得到原生支持。实际上，user.js 只是在用户的浏览器上访问一些网站时，向网站注入一些 JavaScript 脚本，除了顶部的声明信息以及一些 <code>GM_*</code> 的特殊 api 之外，它与普通的 JavaScript 没有什么不同。同时，目前支持 user.js 的浏览器插件很多，最流行的大概就是 <a href="https://www.tampermonkey.net/">TamperMonkey</a>，同时支持非常多的浏览器，在不同浏览器之间实现了 <strong>跨平台</strong>。当然，为网页注入一段 JavaScript 脚本可以改变网页本身，但普通 JavaScript 做不到的事情，user.js 也基本没法实现。例如 <strong>获取所有的浏览器标签页</strong> 这种涉及到浏览器本身的操作。</p><p>而插件则不同，它是浏览器提供的一种附加功能，借用官方介绍：<strong>扩展程序是可定制浏览体验的小型软件程序。它们使用户可以根据个人需要或偏好来定制 Chrome 功能和行为。它们基于 Web 技术（例如 HTML，JavaScript 和 CSS）构建。</strong>，它们能访问浏览器众多的扩展 API，实现对浏览器级别的功能定制 – 而非仅限于网站。例如上面 user.js 做不到的事情 <strong>获取所有的浏览器标签页</strong> 浏览器插件可以轻易实现。</p><h2 id="能力-API"><a href="#能力-API" class="headerlink" title="能力/API"></a>能力/API</h2><p>相关 API 链接如下，此处就不贴了（太多了）</p><ul><li><a href="https://www.tampermonkey.net/documentation.php">user.js api</a></li><li><a href="https://developer.chrome.com/extensions/devguide">chrome plugin api</a></li></ul><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><p>在工程化上，user.js 几乎没有工程化的最佳实践，直到目前为止，仍然没有简单可用的打包工具对 user.js 进行专门支持，例如通过 react 编写一些 UI 相关的内容并最终打包成一个 <code>*.user.js</code> 脚本文件是比较困难的。<br>看看目前的主流打包工具吧</p><ul><li>rollup: JavaScript SDK 打包工具</li><li>Webpack: 最强大的打包工具</li><li>parcel: 开箱可用的打包工具</li></ul><p>是的，打包工具有不少，但这三者都对 user.js 没有太好的支持，主要有两点</p><ol><li> 保证打包后顶部信息说明注释仍然在最顶部</li><li> 支持多入口打包</li><li> 支持 TypeScript</li><li> 支持 vue/react 现代前端框架</li></ol><p>目前最合适的是 parcel，但仍然没有默认解决第一个问题。</p><p>与之相比，chrome 插件的工程化就要好上不少，parcel 甚至官方支持了 <code>WebManifest</code> 类型的资源，这对浏览器插件的开发有着极大的方便 – 可以使用现代前端的一切！</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>user.js 可以发布在任何静态托管服务里，一般可以放在 <a href="https://greasyfork.org/">GreasyFork</a> 上，供需要的用户通过脚本管理其安装。GreasyFork 甚至可以直接导入 GitHub 上的源码和 README 发布一个脚本，同时在后续过程中自动更新。<br>而 chrome 插件则只能通过 <a href="https://chrome.google.com/webstore">chrome web store</a> 进行分发，而且每次更新或上架都需要被审核，这其实是比较花时间的，并非是即时性的。同时 web store 也有注册费用，必须使用 Visa 等国外信用卡支付 $5，而这对于国内开发者而言是一件比较麻烦的事情。</p><blockquote><p>吾辈知道可以使用开发者模式打开解压缩的插件，但这终究不是一个好的分发策略，不能要求每个用户都执行这种麻烦的操作，同时，每次重新打开浏览器都会进行提示也不厌其烦。</p></blockquote><h2 id="对于使用者"><a href="#对于使用者" class="headerlink" title="对于使用者"></a>对于使用者</h2><ul><li>安装难度：chrome 插件安装事实上只能从 chrome store 就意味着国内用户几乎用不了，嗯，这点是一个相当的减分项。而油猴脚本则不太相同，只要支持 user.js 的插件即可添加任意多的 user.js 脚本，事实上，插件只是一个管理工具，chrome 原生支持它！</li><li>需求： 如果只是为网站诸如一段脚本修改一些网站的内容，则优先考虑使用 user.js，如果涉及到操作浏览器相关功能，则只能选择插件，本质上 user.js 在插件中就是 <a href="https://developer.chrome.com/extensions/content_scripts">content script</a> 功能。</li><li>性能：对于一般用户而言，安装一个 chrome 插件会一直在后台开启一个线程，而脚本不会 – 只会在需要生效的网站上应用。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react 通用列表组件封装</title>
    <link href="/p/9b07ff8ce6dd4eb08896f6b8191d7181/"/>
    <url>/p/9b07ff8ce6dd4eb08896f6b8191d7181/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://github.com/rxliuli/example/tree/master/basic_list">GitHub 源码</a></p></blockquote><p>在后台项目中，即便使用了 antd，仍然存在太多太多的列表页面。这些列表页面大多数又是非常相似的，所以吾辈需要解决重复的简单列表的编写，避免每次都手动控制过滤器/分页之类的东西，将之抽象成配置项，然后通过配置生成列表页面。或许已经有很多人做过了这件事情，但于吾辈而言，这仍然是全新的体验，所以也便于此记录，并供之以他人参考。</p><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>使用逐级递进的方式进行封装，使用者可以根据需求停留在一个合适的封装层次，使用不同封装层次的组件。</p><ul><li><code>BasicList</code>：高层列表封装组件<ul><li><code>ListHeader</code>：列表页顶部工具栏组件<ul><li><code>CommonHeader</code>: 通用的顶部工具栏组件</li></ul></li><li><code>ListFilter</code>：过滤器组件<ul><li><code>FilterSelect</code>：单选过滤器</li><li><code>FilterTimeRange</code>：时间区间过滤器</li><li><code>FilterSlot</code>：自定义过滤器</li></ul></li><li><code>ListTable</code>：列表封装组件</li></ul></li></ul><p>BasicList 使用步骤</p><pre><code class=" mermaid">graph TD;A[添加 api class 实现 BasicListApi] --&gt; B[添加配置项]B --&gt; C&#123;是否需要动态修改&#125;;C --&gt; |是| C1[使用 useMemo 声明]C --&gt; |否| C2[将之抽离到组件外部声明为常量]C1 --&gt; DC2 --&gt; DD&#123;是否有非通用 Filter&#125;D --&gt; |是| D1[自定义 slot filter]D --&gt; |否| D2[使用 select&#x2F;time filter]D1 --&gt; ED2 --&gt; EE&#123;是否需要自定义表格相关功能&#125;E --&gt; |是| E1[使用 filterOperate 配置]E --&gt; |否| E2[不声明 filter 配置]E1 --&gt; FE2 --&gt; FF[列表渲染]</code></pre><p>BasicList 渲染流程</p><pre><code class=" mermaid">graph TBA[从 props 拿到配置项列表] --&gt; B&#123;header 是否为 ReactElement&#125;B --&gt; |是| B1[直接渲染]B --&gt; |否| B2[使用 ListHeader 渲染 header 配置项]B1 --&gt; CB2 --&gt; CC&#123;filters 是否存在&#125;C --&gt; |是| C1&#123;filters 是否为 ReactElement&#125;  C1 --&gt; |是| C1A[直接渲染]  C1 --&gt; |否| C1B[使用 ListFilter 渲染 filters 配置项] --&gt; C1C[监听 initialParams 变化, 以随时修改 form]C --&gt; |否| C2[不渲染]C1A --&gt; DC1B --&gt; DC2 --&gt; DD[渲染列表]</code></pre><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="使用基本-API"><a href="#使用基本-API" class="headerlink" title="使用基本 API"></a>使用基本 API</h3><blockquote><p><a href="https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/BasicListExample.tsx">GitHub 代码示例</a></p></blockquote><p>如下所示，我们想要构造下面这样一个简单的列表页面，包含一个面包屑导航列表、搜索框、过滤条件选择器和一个表格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import * as React from &quot;react&quot;;<br>import &#123; Button &#125; from &quot;antd&quot;;<br>import &#123; Link &#125; from &quot;react-router-dom&quot;;<br>import &#123; Moment &#125; from &quot;moment&quot;;<br>import &#123; LabeledValue &#125; from &quot;antd&#x2F;es&#x2F;select&quot;;<br>import &#123; userApi &#125; from &quot;.&#x2F;api&#x2F;UserApi&quot;;<br>import &#123;<br>  BasicList,<br>  BasicListPropsType,<br>  FilterFieldTypeEnum,<br>&#125; from &quot;..&#x2F;..&#x2F;components&#x2F;list&quot;;<br><br>type PropsType &#x3D; &#123;&#125;;<br><br>type Config &#x3D; Omit&lt;BasicListPropsType, &quot;params&quot;&gt; &amp; &#123;<br>  params?: &#123;<br>    keyword?: string;<br>    test?: number;<br>    birthdayTimeRange?: [Moment, Moment];<br>  &#125;;<br>&#125;;<br>const testOptionList: LabeledValue[] &#x3D; [<br>  &#123; value: 0, label: &quot;测试 0&quot; &#125;,<br>  &#123; value: 1, label: &quot;测试 1&quot; &#125;,<br>  &#123; value: 2, label: &quot;测试 2&quot; &#125;,<br>];<br><br>&#x2F;&#x2F;列表配置项<br>const config: Config &#x3D; &#123;<br>  header: &#123;<br>    placeholder: &quot;用户名&#x2F;住址&quot;,<br>    list: [&quot;用户&quot;, &quot;列表&quot;],<br>  &#125;,<br>  filters: [<br>    &#123;<br>      type: FilterFieldTypeEnum.Select,<br>      label: &quot;测试字段&quot;,<br>      field: &quot;test&quot;,<br>      options: testOptionList,<br>    &#125;,<br>    &#123;<br>      type: FilterFieldTypeEnum.TimeRange,<br>      label: &quot;生日&quot;,<br>      field: &quot;birthdayTimeRange&quot;,<br>    &#125;,<br>  ],<br>  columns: [<br>    &#123; field: &quot;id&quot;, title: &quot;ID&quot; &#125;,<br>    &#123; field: &quot;name&quot;, title: &quot;姓名&quot; &#125;,<br>    &#123; field: &quot;birthday&quot;, title: &quot;生日&quot; &#125;,<br>    &#123;<br>      field: &quot;operate&quot;,<br>      title: &quot;操作&quot;,<br>      slot: (param) &#x3D;&gt; &lt;Link to&#x3D;&#123;&#96;&#x2F;system&#x2F;user&#x2F;$&#123;param.record.id&#125;&#96;&#125;&gt;详情&lt;&#x2F;Link&gt;,<br>    &#125;,<br>  ],<br>  api: userApi,<br>&#125;;<br><br>&#x2F;**<br> * 一个基本的列表页面<br> * @constructor<br> *&#x2F;<br>const BasicListExample: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;<br>  return &lt;BasicList &#123;...config&#125; &#x2F;&gt;;<br>&#125;;<br><br>export default BasicListExample;<br></code></pre></td></tr></table></figure><h3 id="使用自定义过滤器组件"><a href="#使用自定义过滤器组件" class="headerlink" title="使用自定义过滤器组件"></a>使用自定义过滤器组件</h3><blockquote><p><a href="https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/CustomFilterListExample.tsx">GitHub 代码示例</a></p></blockquote><p>事实上，总有各种奇怪的过滤器无法满足，这时候就需要添加一个自定义的过滤器了。<br>例如下面这个过滤器，包含了年龄的值和单位，是不是感觉很奇怪</p><p>关键代码配置如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> config: Config = &#123;<br>  filters: [<br>    &#123;<br>      type: FilterFieldTypeEnum.Slot,<br>      label: <span class="hljs-string">&quot;年龄&quot;</span>,<br>      field: <span class="hljs-string">&quot;age&quot;</span>,<br>      children: (<br>        &lt;Input.Group compact&gt;<br>          &lt;Form.Item name=&#123;[<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>]&#125; noStyle&gt;<br>            &lt;InputNumber style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;calc(100% - 64px)&quot;</span> &#125;&#125; /&gt;<br>          &lt;/Form.Item&gt;<br>          &lt;Form.Item name=&#123;[<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;unit&quot;</span>]&#125; noStyle&gt;<br>            &lt;Select style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">64</span> &#125;&#125; options=&#123;ageUnitOptionList&#125; /&gt;<br>          &lt;/Form.Item&gt;<br>        &lt;/Input.Group&gt;<br>      ),<br>    &#125;,<br>  ],<br>  <span class="hljs-comment">// 此处是为了添加过滤器的默认值</span><br>  params: &#123;<br>    age: &#123;<br>      unit: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="添加表格的额外操作"><a href="#添加表格的额外操作" class="headerlink" title="添加表格的额外操作"></a>添加表格的额外操作</h3><blockquote><p><a href="https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/TableOperationListExample.tsx">GitHub 代码示例</a></p></blockquote><p>有时候，我们需要添加一个额外的表格操作，例如导出/导入数据/删除选中数据。</p><p>关键代码如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleBatchDelete</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-function"><span class="hljs-params">  selectedRowKeys,</span></span><br><span class="hljs-function"><span class="hljs-params">  setSelectedRowKeys,</span></span><br><span class="hljs-function"><span class="hljs-params">  searchPage,</span></span><br><span class="hljs-function"><span class="hljs-params">&#125;: ListTableOperateParam</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (selectedRowKeys.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">await</span> userApi.batchDelete(selectedRowKeys)<br>  setSelectedRowKeys([])<br>  <span class="hljs-keyword">await</span> searchPage()<br>&#125;<br><br><span class="hljs-keyword">const</span> config = useMemo&lt;Config&gt;(<br>  () =&gt; (&#123;<br>    tableOperate: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> (<br>      &lt;Button onClick=&#123;<span class="hljs-function">() =&gt;</span> handleBatchDelete(params)&#125;&gt;删除选中&lt;/Button&gt;<br>    ),<br>  &#125;),<br>  [],<br>)<br></code></pre></td></tr></table></figure><h3 id="过滤器的下拉框数据来源是异步的"><a href="#过滤器的下拉框数据来源是异步的" class="headerlink" title="过滤器的下拉框数据来源是异步的"></a>过滤器的下拉框数据来源是异步的</h3><blockquote><p><a href="https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/AsyncSelectOptionsListExample.tsx">GitHub 代码示例</a></p></blockquote><p>很多时候，我们的数据来源并不是由前端写死，而是从后台获取的，这就要求我们传入的值是 react 的一个 State 而非一个固定值。</p><p>关键代码如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> testOptionList = useAsyncMemo([], dictApi.list)<br><span class="hljs-keyword">const</span> config = useMemo&lt;Config&gt;(<br>  () =&gt; (&#123;<br>    filters: [<br>      &#123;<br>        type: FilterFieldTypeEnum.Select,<br>        label: <span class="hljs-string">&#x27;测试字段&#x27;</span>,<br>        field: <span class="hljs-string">&#x27;test&#x27;</span>,<br>        options: testOptionList,<br>      &#125;,<br>    ],<br>  &#125;),<br>  [testOptionList],<br>)<br></code></pre></td></tr></table></figure><h2 id="组件-API"><a href="#组件-API" class="headerlink" title="组件 API"></a>组件 API</h2><h3 id="BasicList"><a href="#BasicList" class="headerlink" title="BasicList"></a>BasicList</h3><p>参考 <em>src/components/common/table/js/BasicListOptions.d.ts</em></p><table><thead><tr><th><code>prop</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>header</code></td><td><code>BasicList.Header</code></td><td>标题栏相关配置</td></tr><tr><td><code>[filters]</code></td><td><code>BaseFilterField[]</code></td><td>过滤器列表</td></tr><tr><td></td><td><code>((params: any, onChange: (params: any) =&gt; void) =&gt; ReactElement)</code></td><td></td></tr><tr><td><code>[params]</code></td><td><code>Params</code></td><td>查询参数</td></tr><tr><td><code>columns</code></td><td><code>TableColumn[]</code></td><td>列字段列表</td></tr><tr><td><code>api</code></td><td><code>BaseListApi</code></td><td>api 对象</td></tr><tr><td><code>[tableOptions]</code></td><td><code>TableOptions</code></td><td>一些其他选项</td></tr><tr><td><code>[tableOperate]</code></td><td><code>ListTableOperate</code></td><td>一些其他操作</td></tr></tbody></table><h3 id="ListFilter"><a href="#ListFilter" class="headerlink" title="ListFilter"></a>ListFilter</h3><p>| <code>prop</code>           | 类型                 | 说明                     |<br>| —————- | ——————– | ———————— | —————— | ———- |<br>| <code>[initialValue]</code> | <code>any</code>                | 查询参数                 |<br>| <code>filters</code>        | <code>(FilterSelectType   | FilterTimeRangeType      | FilterSlotType)[]</code> | 过滤器列表 |<br>| <code>onChange</code>       | <code>(value: T) =&gt; void</code> | 当过滤器的参数发生改变时 |</p><h3 id="ListTable"><a href="#ListTable" class="headerlink" title="ListTable"></a>ListTable</h3><table><thead><tr><th><code>prop</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>columns</code></td><td><code>TableColumn[]</code></td><td>列字段列表</td></tr><tr><td><code>api</code></td><td><code>BaseListApi</code></td><td>api 对象</td></tr><tr><td><code>params</code></td><td><code>Params</code></td><td>查询参数</td></tr><tr><td><code>[tableOptions]</code></td><td><code>TableOptions</code></td><td>一些其他选项</td></tr><tr><td><code>[tableOperate]</code></td><td><code>ListTableOperate</code></td><td>一些其他选项</td></tr></tbody></table><h2 id="其他类型定义"><a href="#其他类型定义" class="headerlink" title="其他类型定义"></a>其他类型定义</h2><p>下面是类型定义，所有的类型定义都有对应的 <code>.d.ts</code> 文件，请使用 <code>C-N</code> 搜索 <code>class</code>。</p><table><thead><tr><th><code>HeaderNavItem</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>string</code></td><td></td><td>导航的名字</td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>导航的名字</td></tr><tr><td><code>[link]</code></td><td><code>string</code></td><td>如果是 route 的话必须有值</td></tr></tbody></table><table><thead><tr><th><code>Header</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>list</code></td><td><code>HeaderNavItem[]</code></td><td>导航元素列表</td></tr><tr><td><code>placeholder</code></td><td><code>string</code></td><td>搜索框的提示文本</td></tr></tbody></table><h3 id="过滤器相关"><a href="#过滤器相关" class="headerlink" title="过滤器相关"></a>过滤器相关</h3><table><thead><tr><th><code>FilterFieldTypeEnum</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Slot</code></td><td><code>1</code></td><td>自定义 slot</td></tr><tr><td><code>Select</code></td><td><code>2</code></td><td>普通选择框</td></tr><tr><td><code>TimeRange</code></td><td><code>3</code></td><td>日期区间选择器</td></tr></tbody></table><table><thead><tr><th><code>FilterFieldBase</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>FilterFieldTypeEnum</code></td><td>过滤器元素类型</td></tr><tr><td><code>label</code></td><td><code>string</code></td><td>显示的标题</td></tr></tbody></table><table><thead><tr><th><code>FilterSelectType</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>extends</code></td><td><code>FilterFieldBase</code></td><td>继承基本过滤器配置</td></tr><tr><td><code>field</code></td><td><code>string</code></td><td>字段名</td></tr><tr><td><code>options</code></td><td><code>LabeledValue[]</code></td><td>值列表</td></tr></tbody></table><table><thead><tr><th><code>FilterTimeRangeType</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>extends</code></td><td><code>FilterFieldBase</code></td><td>继承基本过滤器配置</td></tr><tr><td><code>field</code></td><td><code>string</code></td><td>字段名</td></tr></tbody></table><table><thead><tr><th><code>FilterSlotType</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>extends</code></td><td><code>FilterFieldBase</code></td><td>继承基本过滤器配置</td></tr><tr><td><code>field</code></td><td><code>string</code></td><td>字段名</td></tr><tr><td><code>children</code></td><td><code>ReactElement</code></td><td><code>Form.Item</code> 的子元素</td></tr><tr><td><code>[computed]</code></td><td><code>(res: Record&lt;string, any&gt;, value: any) =&gt; Record&lt;string, any&gt;</code></td><td>自定义计算方法</td></tr></tbody></table><table><thead><tr><th><code>Params</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>keyword</code></td><td><code>string</code></td><td>查询关键字</td></tr><tr><td><code>...args</code></td><td><code>any[]</code></td><td>其他查询参数</td></tr></tbody></table><h3 id="表格相关"><a href="#表格相关" class="headerlink" title="表格相关"></a>表格相关</h3><table><thead><tr><th><code>TableColumn</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>field</code></td><td><code>string</code></td><td>在数据项中对应的字段名</td></tr><tr><td><code>title</code></td><td><code>string</code></td><td>列标题</td></tr><tr><td><code>[formatter]</code></td><td><code>(v: any, record: any) =&gt; any</code></td><td>自定义字段格式化函数</td></tr><tr><td><code>[slot]</code></td><td><code>(param: &#123; text: string; record: any; i: number &#125;) =&gt; ReactNode</code></td><td>自定义 <code>slot</code></td></tr></tbody></table><table><thead><tr><th><code>BaseListApi</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>pageList</code></td><td><code>(params: any) =&gt; Promise&lt;PageRes&lt;any&gt;&gt;</code></td><td>所有 ListTable 中的 api 对象必须实现该类型</td></tr></tbody></table><table><thead><tr><th><code>ListTableOperateParam</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>searchPage</code></td><td><code>(page?: PageParam) =&gt; Promise&lt;void&gt;</code></td><td>导航元素列表</td></tr><tr><td><code>selectedRowKeys</code></td><td><code>string[]</code></td><td>当前选中行的主键</td></tr><tr><td><code>setSelectedRowKeys</code></td><td><code>(selectedRowKeys: string[]) =&gt; void</code></td><td>设置当前选中行的主键</td></tr><tr><td><code>page</code></td><td><code>PageData&lt;any&gt;</code></td><td>分页数据信息</td></tr><tr><td><code>params</code></td><td><code>Params</code></td><td>过滤器及搜索参数</td></tr></tbody></table><table><thead><tr><th><code>TableOptions</code></th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>[isSelect]</code></td><td><code>boolean</code></td><td>是否可选，默认为 false</td></tr><tr><td><code>[rowKey]</code></td><td><code>string</code></td><td>行的唯一键，默认为 id</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比于之前吾辈 <a href="https://blog.rxliuli.com/p/aa3fd9e1/">vue 的初版 List 封装</a>，嗯，差距非常明显！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>近期博客变化</title>
    <link href="/p/386f3414997f4517a4c071a1ec230182/"/>
    <url>/p/386f3414997f4517a4c071a1ec230182/</url>
    
    <content type="html"><![CDATA[<p>近期吾辈的博客会发生一些变化，可能会出现一些奇怪的问题</p><p>重要的变更只有以下两点</p><ul><li>hexo 主题由 <a href="https://github.com/blinkfox/hexo-theme-matery/">matery</a> 迁移至 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></li><li>评论系统由 <a href="https://blog.disqus.com/">disqus</a> 迁移至 <a href="https://utteranc.es/">utterances</a></li></ul><p>以下是细节变动</p><ul><li>更简洁的 material design 风格</li><li>评论系统以更新为以 github 为基础 utterances</li><li>代码高亮插件 <code>highlight.js</code> 更新以支持 <code>jsx/tsx</code></li><li>更新 hexo 至最新版 <code>4.2.1</code></li><li>更新封面由东方 Project 系列图片为穹妹</li><li>清理了一些无用的 hexo 插件</li><li>使用 git submodule 的形式管理主题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-简介</title>
    <link href="/p/da25fbc33fa248b196ea573b661dbe14/"/>
    <url>/p/da25fbc33fa248b196ea573b661dbe14/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注: 该系列博客存在前后顺序依赖，请尽量从前往后通读一遍。<br><a href="https://github.com/rxliuli/electron_example">GitHub 项目</a></p></blockquote><p>这是一个关于如何使用 React + Electron 开发桌面应用的一些经验之谈，可能包含一些主观意见，但或许仍然能对你有所帮助。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>那么，吾辈到底是想写一些什么呢？前端工程化？electron 项目的怪癖？还是其他什么？<br>吾辈想完成一个使用 electron 开发的的系列文章，说明开发 electron 的基本流程、各种选择、以及涉及到的工程化的内容，并在说明这些的过程中完成一个桌面应用程序。</p><p><a href="/resource/f7ddb35dc9a349a78f598309e04e3328.km">Electron 开发</a></p><blockquote><p>在这个系列中，会使用到一些额外的技术，如果你不了解可能也没太大问题，但了解之后才能更顺畅的阅读，参考: <a href="/p/74b1ec3c598940c2afbd17cdd50e31cb">技术栈简介及选择</a></p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="/p/da25fbc33fa248b196ea573b661dbe14">简介</a></li><li><a href="/p/74b1ec3c598940c2afbd17cdd50e31cb">技术栈简介及选择</a></li><li><a href="/p/475d21afd2404d5ba1f71f600c44da09">基本项目搭建</a></li><li><a href="/p/63f0a26fdd3743668b11410a10625c1b">使用 electron-builder 打包</a></li><li><a href="/p/6e778ce220e042a0902e7a85976e7e47">渲染、主进程通信</a></li><li><a href="/p/db74e6e5d2444bc3b6e185a7b338bbf6">在渲染、主进程间共享数据</a></li><li><a href="/p/9d55c013167a4e6d802fde969291c34b">自定义窗口顶栏</a></li><li><a href="/p/0f342a17caae4f1e845a543770008e35">自动更新</a></li><li><a href="/p/76072311817b4c1985ab5746e8f91d87">常见问题</a></li><li><a href="/p/ff86c5343d38460a8e78a62617f9eace">自定义协议</a></li><li><a href="/p/1527b67fbd78494cb716e2db4b8fb688">开发环境优化</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具类网站</title>
    <link href="/p/29570a546190499ebc65025840981f6b/"/>
    <url>/p/29570a546190499ebc65025840981f6b/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%BD%91%E7%AB%99">工具类网站</a><ul><li><a href="#%E7%BC%96%E7%A8%8B">编程</a><ul><li><a href="#netlify%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0">netlify：静态网站托管平台</a></li><li><a href="#cloudflare%E5%8A%A0%E9%80%9F%E5%B9%B6%E4%BF%9D%E6%8A%A4%E7%BD%91%E7%AB%99">cloudflare：加速并保护网站</a></li><li><a href="#heroku%E4%BA%91%E7%AB%AF%E7%A8%8B%E5%BA%8F%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0">heroku：云端程序托管平台</a></li><li><a href="#draw%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7">draw：画图工具</a></li><li><a href="#serveo%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F">Serveo：内网穿透</a></li><li><a href="#namesilo%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1">namesilo：域名服务</a></li><li><a href="#coursera%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2">coursera：在线教育</a></li><li><a href="#flaticon%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87%E5%BA%93">flaticon：矢量图标库</a></li></ul></li><li><a href="#%E9%9D%9E%E7%BC%96%E7%A8%8B">非编程</a><ul><li><a href="#google-translate%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91">Google Translate：谷歌翻译</a></li><li><a href="#inoreaderrss-%E9%98%85%E8%AF%BB%E5%99%A8">inoreader：RSS 阅读器</a></li><li><a href="#itellyou%E5%BE%AE%E8%BD%AF%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD">itellyou：微软相关资源下载</a></li><li><a href="#gmailgoogle-%E5%AE%B6%E7%9A%84%E9%82%AE%E7%AE%B1%E6%9C%8D%E5%8A%A1">Gmail：Google 家的邮箱服务</a></li><li><a href="#smms%E5%85%8D%E8%B4%B9%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%9B%BE%E5%BA%8A">smms：免费稳定的图床</a></li><li><a href="#firefox-send%E5%85%8D%E8%B4%B9%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB">Firefox send：免费安全的文件共享</a></li></ul></li></ul></li></ul><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="netlify：静态网站托管平台"><a href="#netlify：静态网站托管平台" class="headerlink" title="netlify：静态网站托管平台"></a><a href="https://www.netlify.com/">netlify</a>：静态网站托管平台</h3><p>可以简单方便的托管自己的静态网站，能够连接到主流的代码托管平台（<a href="https://github.com/">GitHub</a>, <a href="https://gitlab.com/">GitLab</a>, <a href="https://bitbucket.org/">Bitbucket</a>），支持自动在线部署网站，可以免费同时部署多个网站（同一域名下）。相比于 GitHub Page 而言有着更加强大的功能</p><p>下面是 GitHub 和 Netlify 的对比</p><table><thead><tr><th>对比</th><th>GitHub</th><th>Netlify</th></tr></thead><tbody><tr><td>价格</td><td>免费</td><td>免费</td></tr><tr><td>构建限制</td><td>每小时 10 次</td><td>每分钟 3 次</td></tr><tr><td>使用 HTTPS 的自定义域</td><td>是</td><td>是</td></tr><tr><td>单击 回滚</td><td>没有</td><td>是</td></tr><tr><td>资产优化</td><td>没有</td><td>是</td></tr><tr><td>表格处理</td><td>没有</td><td>是</td></tr><tr><td>部署预览</td><td>没有</td><td>是</td></tr><tr><td>持续部署</td><td>没有</td><td>是</td></tr><tr><td>自定义重写和重定向</td><td>没有</td><td>是</td></tr><tr><td>兼容所有静态站点生成器</td><td>没有</td><td>是</td></tr><tr><td>预呈现</td><td>没有</td><td>是</td></tr><tr><td>拆分测试</td><td>没有</td><td>是</td></tr><tr><td>Lambda 函数集成</td><td>没有</td><td>是</td></tr></tbody></table><h3 id="cloudflare：加速并保护网站"><a href="#cloudflare：加速并保护网站" class="headerlink" title="cloudflare：加速并保护网站"></a><a href="https://www.cloudflare.com/">cloudflare</a>：加速并保护网站</h3><p>配合上面的 <a href="#netlifyhttpswwwnetlifycom%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0">netlify</a> 一起使用，对于吾辈而言主要用到了下面的功能：</p><ul><li>快速刷新域名 DNS 缓存（几分钟内在网络上完成更新）</li><li>为网站加上 HTTPS 前缀</li><li>自动将 HTTP 请求转发到 HTTPS</li><li>使用 CDN 加速网站</li></ul><h3 id="heroku：云端程序托管平台"><a href="#heroku：云端程序托管平台" class="headerlink" title="heroku：云端程序托管平台"></a><a href="https://www.heroku.com/">heroku</a>：云端程序托管平台</h3><p>上面说过的 <a href="#netlifyhttpswwwnetlifycom%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0">netlify</a> 可以托管静态网站，但 heroku 能托管一切！不仅仅是前端，<code>Node.js, Ruby, Python, Java, PHP, Go, Scala, Clojure</code> 都不在话下。那么，为什么吾辈没有第一个就推荐它呢？因为 heroku 免费帐户的限制比较大。。。</p><ul><li>未认证信用卡的账户每个月只有 500 个小时可用时间</li><li>未认证信用卡的账户无法自定义域名</li><li>虽然能够托管多语言的程序，然而并非指程序依赖的服务也存在，例如 <code>MySQL，Redis</code> 等等</li></ul><p>但即便有上面的这些缺点，对于开源的后端程序用于展示的话还是相当不错的。而且，我们可以利用它免费搭建 <code>Shadowsocks</code> 服务，而且速度也不算慢！</p><h3 id="draw：画图工具"><a href="#draw：画图工具" class="headerlink" title="draw：画图工具"></a><a href="https://www.draw.io/">draw</a>：画图工具</h3><p>开源免费的 Web 版的在线画图工具，方便而快捷，支持多种格式导出/保存/导入。即时保存，即使浏览器崩溃也没有问题。</p><p>功能列表</p><ul><li>基础功能：支持任意拖动图形，自带对其/微调，可以进行样式编辑，在任意处插入文本</li><li>便签：将一个或多个可复用的内容保存为便签，下次直接拖动出来就好了</li><li>第三方保存：Google Drive, OneDrive, Dropbox, GitHub, Trello, 电脑或手机设备, 浏览器</li><li>多格式导出：PNG, JPEG, SVG, PDF, VSDX, HTML, XML, URL 地址</li></ul><h3 id="Serveo：内网穿透"><a href="#Serveo：内网穿透" class="headerlink" title="Serveo：内网穿透"></a><a href="https://serveo.net/">Serveo</a>：内网穿透</h3><p>用于在微信开发时，微信公众号需要公网 <strong>ip + 80</strong> 端口的问题，可以实现远程访问到本地部署的项目。</p><h3 id="namesilo：域名服务"><a href="#namesilo：域名服务" class="headerlink" title="namesilo：域名服务"></a><a href="https://www.namesilo.com/?rid=ea90147sn">namesilo</a>：域名服务</h3><p>如果你需要建立个人网站，或者搭建个人博客的话。那域名几乎是必不可少的。毕竟，谁也不想记住一个 IP 地址，而有一个更有标识性的域名岂非更好呢？</p><blockquote><p>注：之所以不使用国内的 <a href="https://wanwang.aliyun.com/">万网</a> 之类的是因为国内的域名有可能被封/被屏蔽，原因很多请参考 <a href="https://www.williamlong.info/archives/1654.html">警告——不要在国内注册和使用 CN 域名</a>，本质上在国内注册的域名所有权不属于你！</p></blockquote><h3 id="coursera：在线教育"><a href="#coursera：在线教育" class="headerlink" title="coursera：在线教育"></a><a href="https://www.coursera.org/">coursera</a>：在线教育</h3><p>国外非常流行的在线教育网站，有着非常多的在线课程可以学习，而且学完之后还有证书可拿（免费结业证书/付费认证证书）。</p><blockquote><p>附：大部分课程都是英语，当初没学好英语真是一生的痛呀！</p></blockquote><h3 id="flaticon：矢量图标库"><a href="#flaticon：矢量图标库" class="headerlink" title="flaticon：矢量图标库"></a><a href="https://www.flaticon.com/">flaticon</a>：矢量图标库</h3><p>免费的在线图标库，目前大约有 1494000 个图标了。只所以不推荐阿里的矢量图标库 <a href="https://www.iconfont.cn/">iconfont</a> 是因为。。。嗯，你懂的，国人总喜欢 <strong>抄袭</strong> 而非 <strong>原创</strong>（某企鹅以此成家），所以设计/创新相关的还是使用国外的更好一点呢！</p><h2 id="非编程"><a href="#非编程" class="headerlink" title="非编程"></a>非编程</h2><h3 id="Google-Translate：谷歌翻译"><a href="#Google-Translate：谷歌翻译" class="headerlink" title="Google Translate：谷歌翻译"></a><a href="https://translate.google.com/">Google Translate</a>：谷歌翻译</h3><p>Google 出品的翻译网站，支持的语言非常多，对于中文/英文的支持也很不错呢（信仰）</p><h3 id="inoreader：RSS-阅读器"><a href="#inoreader：RSS-阅读器" class="headerlink" title="inoreader：RSS 阅读器"></a><a href="https://www.inoreader.com/">inoreader</a>：RSS 阅读器</h3><p>全平台的 RSS 阅读器，与之相似的只有 feedly 了吧。用来订阅/管理 RSS 源，阅读起来也很方便，基本上免费的套餐便是足够个人使用了。</p><h3 id="itellyou：微软相关资源下载"><a href="#itellyou：微软相关资源下载" class="headerlink" title="itellyou：微软相关资源下载"></a><a href="https://msdn.itellyou.cn/">itellyou</a>：微软相关资源下载</h3><p>方便下载各种微软的相关资源，提供了直接的下载链接（_ed2k_），例如 _Windows 系统<em>，_VS IDE_，</em>.NET Framework_。</p><h3 id="Gmail：Google-家的邮箱服务"><a href="#Gmail：Google-家的邮箱服务" class="headerlink" title="Gmail：Google 家的邮箱服务"></a><a href="https://mail.google.com/">Gmail</a>：Google 家的邮箱服务</h3><p>Google 出品，必属精品（#大雾）目前而言最好的邮箱。Web 版本提供的功能与体验是其他国内邮箱根本无法相提并论的（QQ/163 之流），配合 <a href="https://jasonsavard.com/zh-CN/Checker-Plus-for-Gmail">Chrome 插件</a> 与 <a href="https://play.google.com/store/apps/details?id=com.google.android.gm&hl=zh_CN">Gmail For Android</a> 风味更佳。</p><blockquote><p>附：Gmail Web 版必须使用梯子，但服务本身并未受到影响，与其他邮箱互通邮件一切正常。</p></blockquote><h3 id="smms：免费稳定的图床"><a href="#smms：免费稳定的图床" class="headerlink" title="smms：免费稳定的图床"></a><a href="https://sm.ms/">smms</a>：免费稳定的图床</h3><p>一个简单好用的图床，不需要注册/登录，直接就可以上传图片获取外链了，提供 API 可供开发/嵌入到第三方客户端。</p><h3 id="Firefox-send：免费安全的文件共享"><a href="#Firefox-send：免费安全的文件共享" class="headerlink" title="Firefox send：免费安全的文件共享"></a><a href="https://send.firefox.com/">Firefox send</a>：免费安全的文件共享</h3><blockquote><p>说到 Mozilla 泥萌可能很多人不太清楚，但 Firefox 却是大名鼎鼎，而 Mozilla 正是 Firefox 的母公司！</p></blockquote><p>Mozilla 家推出的所有现代浏览器都可以使用的文件共享服务。<br>主要特性</p><ul><li>最大支持 1G</li><li>24 小时后自动删除</li><li>加密的共享链接</li><li>支持限制下载次数</li><li>支持手动失效</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客迁移</title>
    <link href="/p/744e094835954a57accd6edce4feeb93/"/>
    <url>/p/744e094835954a57accd6edce4feeb93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：可能出现博客文章的顺序完全混乱，但随着笔记的修正将逐渐恢复正确的顺序。</p></blockquote><p>这个博客正在从 github + hexo 迁移至 joplin + hexo，将 joplin 笔记作为唯一数据源，结合 hexo 生成一个网站。</p><hr><p>下面是关于 <a href="http://github.com/rxliuli/joplin-blog">joplin-blog 项目</a> 的介绍</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>你是否和吾辈一样烦恼同时维护笔记和博客的同步麻烦，如果你使用 joplin 作为笔记工具，而使用 hexo 作为博客生成器的话，你可以选择这个工具来连接它们。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>方式 1</p><ol><li> 添加配置文件 <code>.joplin-blog.json</code>（具体配置参考 <a href="#%E9%85%8D%E7%BD%AE">配置</a>）</li><li> 使用命令导出笔记为博客 <code>npx joplin-blog</code></li></ol><p>方式 2</p><ol><li> 在命令行导航到 hexo 博客目录</li><li> 添加依赖 <code>yarn add -D joplin-blog</code></li><li> 添加配置文件 <code>.joplin-blog.json</code>（具体配置参考 <a href="#%E9%85%8D%E7%BD%AE">配置</a>）</li><li> 添加一个 npm script 脚本文件 <code>&quot;imp&quot;: &quot;joplin-hexo&quot;</code></li><li> 运行命令 <code>yarn imp</code></li><li> 可以看到 <code>source/_posts</code> 目录下已经包含了所有导出的笔记</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li><a href="https://github.com/rxliuli/joplin-blog/tree/master/tutorials/hexo-example">hexo</a></li><li><a href="https://github.com/rxliuli/joplin-blog/tree/master/tutorials/vuepress-example">vuepress</a></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>公共</p><table><thead><tr><th>配置</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>hexo/vuepress</code></td><td>集成博客的类型</td></tr><tr><td><code>rootPath</code></td><td><code>string</code></td><td>hexo/vuepress 目录，一般应该为 <code>.</code></td></tr><tr><td><code>joplinProfilePath</code></td><td><code>string</code></td><td>joplin 个人文件夹</td></tr><tr><td><code>token</code></td><td><code>string</code></td><td>joplin web service 的 token</td></tr><tr><td><code>port</code></td><td><code>number</code></td><td>joplin web service 的端口</td></tr><tr><td><code>tag</code></td><td><code>string</code></td><td>joplin 的博客标签</td></tr></tbody></table><p>hexo</p><table><thead><tr><th>配置</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>stickyTopIdList</code></td><td><code>string[]</code></td><td>置顶的笔记 id（仅在 fluid 主题下生效）</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 类型编程</title>
    <link href="/p/59cc4e212f694ea78a27cda6e6770974/"/>
    <url>/p/59cc4e212f694ea78a27cda6e6770974/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>TypeScript 改变了吾辈对于类型系统的认知，它强大的类型系统使得类型本身也是可编程的。</p></blockquote><p>最近 TypeScript 更新了一个大版本 v4，新增了一些非常强大的特性，让之前难以做到的事情也能够实现了。</p><ul><li>模板字符串类型</li><li>递归类型</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>参考：<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html">TypeScript 4.1</a></p></blockquote><h3 id="模板字符串类型"><a href="#模板字符串类型" class="headerlink" title="模板字符串类型"></a>模板字符串类型</h3><p>尤其适合在 CSS Properties 相关的类型定义中使用，例如 css 的 <code>width</code>，就可以使用模板字符串进行检查避免低级错误。</p><p>之前</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Width = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">const</span> i: Width = <span class="hljs-string">&quot;1px&quot;</span>;<br><span class="hljs-keyword">const</span> i2: Width = <span class="hljs-string">&quot;1px2&quot;</span>; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><p>现在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Unit = <span class="hljs-string">&quot;px&quot;</span> | <span class="hljs-string">&quot;%&quot;</span> | <span class="hljs-string">&quot;em&quot;</span> | <span class="hljs-string">&quot;rem&quot;</span>;<br><span class="hljs-keyword">type</span> Width = <span class="hljs-built_in">number</span> | <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">number</span>&#125;</span><span class="hljs-subst">$&#123;Unit&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> i: Width = <span class="hljs-string">&quot;1px&quot;</span>;<br><span class="hljs-keyword">const</span> i2: Width = <span class="hljs-string">&quot;1px2&quot;</span>; <span class="hljs-comment">// TS2322: Type &#x27;&quot;1px2&quot;&#x27; is not assignable to type &#x27;Width&#x27;.</span><br></code></pre></td></tr></table></figure><blockquote><p>该特性在 Grid 组件进行了实用，能够避免一些低级错误。</p></blockquote><h3 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h3><p>事实上，递归类型的需求由来已久。例如典型的 <code>Array.prototype.flat</code> 函数的类型定义，或是函数式中部分应用函数的类型定义。</p><p>下面是一个将嵌套数组亚平的函数的类型定义示例（来自 TypeScript 官网）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ElementType&lt;T&gt; = T <span class="hljs-keyword">extends</span> ReadonlyArray&lt;infer U&gt; ? ElementType&lt;U&gt; : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepFlatten</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">unknown</span>[]&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">ElementType</span>&lt;<span class="hljs-title">T</span>&gt;[] </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;not implemented&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// All of these return the type &#x27;number[]&#x27;:</span><br>deepFlatten([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>deepFlatten([[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]);<br>deepFlatten([[<span class="hljs-number">1</span>], [[<span class="hljs-number">2</span>]], [[[<span class="hljs-number">3</span>]]]]);<br></code></pre></td></tr></table></figure><h2 id="实际的使用场景"><a href="#实际的使用场景" class="headerlink" title="实际的使用场景"></a>实际的使用场景</h2><h3 id="在-i18next-中根据-key-获取翻译字符串"><a href="#在-i18next-中根据-key-获取翻译字符串" class="headerlink" title="在 i18next 中根据 key 获取翻译字符串"></a>在 i18next 中根据 key 获取翻译字符串</h3><blockquote><p><a href="https://stackoverflow.com/a/58308279/8409380">i18next 的类型定义</a></p></blockquote><p>最近遇到了通过 i18n 框架获取翻译文本的需求，其中翻译文本通过一个对象的形式定义，所以吾辈就需要一种能够根据 key 获取到类型的方法。</p><p>需要支持以下情况</p><ul><li>根据 key 获取对应的文本</li><li>根据 key 深层获取文本</li><li>根据 key 获取文本并进行参数注入</li></ul><p>下面是吾辈对 i18next 的封装</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> zhCN <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../i18n/zhCN&quot;</span>;<br><span class="hljs-keyword">import</span> en <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../i18n/en&quot;</span>;<br><span class="hljs-keyword">import</span> i18next, &#123; TOptions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;i18next&quot;</span>;<br><br><span class="hljs-comment">//region 类型定义</span><br><br><span class="hljs-comment">// returns the same string literal T, if props match, else never</span><br><span class="hljs-keyword">type</span> CheckDictString&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, O&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer A&#125;</span>.<span class="hljs-subst">$&#123;infer B&#125;</span>`</span><br>  ? A <span class="hljs-keyword">extends</span> keyof O<br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span>.<span class="hljs-subst">$&#123;Extract&lt;CheckDictString&lt;B, O[A]&gt;, <span class="hljs-built_in">string</span>&gt;&#125;</span>`</span><br>    : <span class="hljs-built_in">never</span><br>  : T <span class="hljs-keyword">extends</span> keyof O<br>  ? T<br>  : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-comment">// returns the property value from object O given property path T</span><br><span class="hljs-keyword">type</span> GetDictValue&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, O&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer A&#125;</span>.<span class="hljs-subst">$&#123;infer B&#125;</span>`</span><br>  ? A <span class="hljs-keyword">extends</span> keyof O<br>    ? GetDictValue&lt;B, O[A]&gt;<br>    : <span class="hljs-built_in">never</span><br>  : T <span class="hljs-keyword">extends</span> keyof O<br>  ? O[T]<br>  : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-comment">// retrieves all variable placeholder names as tuple</span><br><span class="hljs-keyword">type</span> Keys&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = S <span class="hljs-keyword">extends</span> <span class="hljs-string">&quot;&quot;</span><br>  ? []<br>  : S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer _&#125;</span>&#123;&#123;<span class="hljs-subst">$&#123;infer B&#125;</span>&#125;&#125;<span class="hljs-subst">$&#123;infer C&#125;</span>`</span><br>  ? [B, ...Keys&lt;C&gt;]<br>  : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-comment">// substitutes placeholder variables with input values</span><br><span class="hljs-keyword">type</span> Interpolate&lt;<br>  S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>  I <span class="hljs-keyword">extends</span> Record&lt;Keys&lt;S&gt;[<span class="hljs-built_in">number</span>], <span class="hljs-built_in">string</span>&gt;<br>&gt; = S <span class="hljs-keyword">extends</span> <span class="hljs-string">&quot;&quot;</span><br>  ? <span class="hljs-string">&quot;&quot;</span><br>  : S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer A&#125;</span>&#123;&#123;<span class="hljs-subst">$&#123;infer B&#125;</span>&#125;&#125;<span class="hljs-subst">$&#123;infer C&#125;</span>`</span><br>  ? <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span><span class="hljs-subst">$&#123;I[Extract&lt;B, keyof I&gt;]&#125;</span><span class="hljs-subst">$&#123;Interpolate&lt;C, I&gt;&#125;</span>`</span><br>  : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-comment">//endregion</span><br><br><span class="hljs-keyword">type</span> Dict = <span class="hljs-keyword">typeof</span> zhCN | <span class="hljs-keyword">typeof</span> en;<br><br><span class="hljs-keyword">export</span> <span class="hljs-built_in">enum</span> LanguageEnum &#123;<br>  ZhCN = <span class="hljs-string">&quot;zhCN&quot;</span>,<br>  En = <span class="hljs-string">&quot;en&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I18nLoader</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 加载国际化</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params">language: LanguageEnum</span>)</span> &#123;<br>    <span class="hljs-keyword">await</span> i18next.init(&#123;<br>      lng: language,<br>      resources: &#123;<br>        en: &#123;<br>          translation: en,<br>        &#125;,<br>        zhCN: &#123;<br>          translation: zhCN,<br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 根据 key 获取翻译的文本</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">key</span></span></span><br><span class="hljs-comment">   */</span><br>  getText&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>    key: keyof Dict | (K &amp; CheckDictString&lt;K, Dict&gt;)<br>  ): GetDictValue&lt;K, Dict&gt;;<br>  getText&lt;<br>    D <span class="hljs-keyword">extends</span> Dict &amp; Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;,<br>    K <span class="hljs-keyword">extends</span> keyof D,<br>    I <span class="hljs-keyword">extends</span> Record&lt;Keys&lt;D[K]&gt;[<span class="hljs-built_in">number</span>], <span class="hljs-built_in">string</span>&gt;<br>  &gt;(k: K, <span class="hljs-attr">args</span>: I): Interpolate&lt;D[K], I&gt;;<br>  getText&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>    key: keyof Dict | (K &amp; CheckDictString&lt;K, Dict&gt;),<br>    args?: TOptions<br>  ): GetDictValue&lt;K, Dict&gt; &#123;<br>    <span class="hljs-keyword">return</span> i18next.t(key, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来很简单</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> i18nLoader = <span class="hljs-keyword">new</span> I18nLoader();<br><span class="hljs-keyword">await</span> i18nLoader.load(LanguageEnum.ZhCN);<br><span class="hljs-built_in">console</span>.log(i18nLoader.getText(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// 你好</span><br></code></pre></td></tr></table></figure><p>接下来，我们分析以下 <code>CheckDictString</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> CheckDictString&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, O&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer A&#125;</span>.<span class="hljs-subst">$&#123;infer B&#125;</span>`</span><br>  ? A <span class="hljs-keyword">extends</span> keyof O<br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span>.<span class="hljs-subst">$&#123;Extract&lt;CheckDictString&lt;B, O[A]&gt;, <span class="hljs-built_in">string</span>&gt;&#125;</span>`</span><br>    : <span class="hljs-built_in">never</span><br>  : T <span class="hljs-keyword">extends</span> keyof O<br>  ? T<br>  : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><ol><li> 传入泛型参数 <code>T</code> 和 <code>O</code>，<code>T</code> 必须继承自 <code>string</code></li><li>判断 <code>T</code> 是否继承自 <code>$&#123;infer A&#125;.$&#123;infer B&#125;</code>，即判断 <code>T</code> 是否包含 <code>.</code>，并解构得到 <code>A</code>（第一个 <code>.</code> 之前）,<code>B</code>（第一个 <code>.</code> 之后，可能还包含 <code>.</code>）<ol><li>如果是，则继续判断 <code>A</code> 是否为传入对象的字段<ol><li> 如果是，则继续递归检查 <code>B</code> 是否为 <code>O[A]</code> 的一个字段</li><li> 否则，返回 <code>never</code></li></ol></li><li>否则，则判断 <code>T</code> 是否是 <code>O</code> 的字段<ol><li> 如果是，则返回 <code>T</code></li><li> 否则，返回 <code>never</code></li></ol></li></ol></li></ol><p>可以看到，如果检查出现错误，则返回 <code>never</code>，但我们传入的 <code>string</code> 是不能合并为 <code>never</code> 的，这将会导致 ts 类型检查出错（其它的类型基本上也是一样的推导方式）。</p><hr><p>附录</p><p>虽然看起来不错，那么这个类型是否满足我们简化 i18next 使用的需求呢？<br>实际上没有。即便有如此强大的类型系统，但它仍然不足以满足特别灵活的需求。实际使用时仍发现以下问题：</p><ul><li>嵌套对象的参数注入没有进行检查</li><li>参数注入的翻译文本没有提示注入参数</li></ul><p>解决方案有两个方向</p><ul><li>linter rule</li><li>code generate</li></ul><p>下面是一个简单的对比</p><table><thead><tr><th>分类</th><th>typescript</th><th>linter rule</th><th>code generate</th></tr></thead><tbody><tr><td>使用</td><td>直接使用</td><td>通过 eslint 插件</td><td>通过 cli 命令行</td></tr><tr><td>复杂度</td><td>一般（不用了解 <code>ast</code>）</td><td>高</td><td>较高</td></tr><tr><td>适用场景</td><td>绝大多数场景</td><td>容易编写的少量代码的检查</td><td>大量重复可自动化生成的代码</td></tr></tbody></table><h3 id="使用类型系统解析-json-字符串（好玩性质）"><a href="#使用类型系统解析-json-字符串（好玩性质）" class="headerlink" title="使用类型系统解析 json 字符串（好玩性质）"></a>使用类型系统解析 json 字符串（好玩性质）</h3><p><a href="https://twitter.com/buildsghost/status/1301976526603206657">twitter 上</a> 甚至有人使用 TypeScript 的模板字符串和递归类型解析了 json 字符串。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ParserError&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = &#123; <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span> &#125; &amp; T;<br><span class="hljs-keyword">type</span> EatWhitespace&lt;State <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> State<br>  ? ParserError&lt;<span class="hljs-string">&quot;EatWhitespace got generic string type&quot;</span>&gt;<br>  : State <span class="hljs-keyword">extends</span> <span class="hljs-string">` <span class="hljs-subst">$&#123;infer State&#125;</span>`</span> | <span class="hljs-string">`\n<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? EatWhitespace&lt;State&gt;<br>  : State;<br><span class="hljs-keyword">type</span> AddKeyValue&lt;<br>  Memo <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;,<br>  Key <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>  Value <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span><br>&gt; = Memo &amp; &#123; [K <span class="hljs-keyword">in</span> Key]: Value &#125;;<br><span class="hljs-keyword">type</span> ParseJsonObject&lt;<br>  State <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>  Memo <span class="hljs-keyword">extends</span> Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; = &#123;&#125;<br>&gt; = <span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> State<br>  ? ParserError&lt;<span class="hljs-string">&quot;ParseJsonObject got generic string type&quot;</span>&gt;<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`&#125;<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? [Memo, State]<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;infer Key&#125;</span>&quot;<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`:<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>    ? ParseJsonValue&lt;State&gt; <span class="hljs-keyword">extends</span> [infer Value, <span class="hljs-string">`<span class="hljs-subst">$&#123;infer State&#125;</span>`</span>]<br>      ? EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`,<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>        ? ParseJsonObject&lt;State, AddKeyValue&lt;Memo, Key, Value&gt;&gt;<br>        : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`&#125;<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>        ? [AddKeyValue&lt;Memo, Key, Value&gt;, State]<br>        : ParserError&lt;<span class="hljs-string">`ParseJsonObject received unexpected token: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;<br>      : ParserError&lt;<span class="hljs-string">`ParseJsonValue returned unexpected value for: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;<br>    : ParserError&lt;<span class="hljs-string">`ParseJsonObject received unexpected token: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;<br>  : ParserError&lt;<span class="hljs-string">`ParseJsonObject received unexpected token: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;;<br><span class="hljs-keyword">type</span> ParseJsonArray&lt;<br>  State <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,<br>  Memo <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[] = []<br>&gt; = <span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> State<br>  ? ParserError&lt;<span class="hljs-string">&quot;ParseJsonArray got generic string type&quot;</span>&gt;<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`]<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? [Memo, State]<br>  : ParseJsonValue&lt;State&gt; <span class="hljs-keyword">extends</span> [infer Value, <span class="hljs-string">`<span class="hljs-subst">$&#123;infer State&#125;</span>`</span>]<br>  ? EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`,<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>    ? ParseJsonArray&lt;EatWhitespace&lt;State&gt;, [...Memo, Value]&gt;<br>    : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`]<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>    ? [[...Memo, Value], State]<br>    : ParserError&lt;<span class="hljs-string">`ParseJsonArray received unexpected token: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;<br>  : ParserError&lt;<span class="hljs-string">`ParseJsonValue returned unexpected value for: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;;<br><span class="hljs-keyword">type</span> ParseJsonValue&lt;State <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> State<br>  ? ParserError&lt;<span class="hljs-string">&quot;ParseJsonValue got generic string type&quot;</span>&gt;<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`null<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? [<span class="hljs-literal">null</span>, State]<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;infer Value&#125;</span>&quot;<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? [Value, State]<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? ParseJsonArray&lt;State&gt;<br>  : EatWhitespace&lt;State&gt; <span class="hljs-keyword">extends</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;infer State&#125;</span>`</span><br>  ? ParseJsonObject&lt;State&gt;<br>  : ParserError&lt;<span class="hljs-string">`ParseJsonValue received unexpected token: <span class="hljs-subst">$&#123;State&#125;</span>`</span>&gt;;<br><span class="hljs-keyword">type</span> ParseJson&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ParseJsonValue&lt;T&gt; <span class="hljs-keyword">extends</span> infer Result<br>  ? Result <span class="hljs-keyword">extends</span> [infer Value, <span class="hljs-built_in">string</span>]<br>    ? Value<br>    : Result <span class="hljs-keyword">extends</span> ParserError&lt;<span class="hljs-built_in">any</span>&gt;<br>    ? Result<br>    : ParserError&lt;<span class="hljs-string">&quot;ParseJsonValue returned unexpected Result&quot;</span>&gt;<br>  : ParserError&lt;<span class="hljs-string">&quot;ParseJsonValue returned uninferrable Result&quot;</span>&gt;;<br><br><span class="hljs-keyword">type</span> Json = ParseJson&lt;<span class="hljs-string">&#x27;&#123; &quot;key1&quot;: [&quot;value1&quot;, null], &quot;key2&quot;: &quot;value2&quot; &#125;&#x27;</span>&gt;; <span class="hljs-comment">// type Json = &#123; key1: [&quot;value1&quot;, null]; &#125; &amp; &#123; key2: &quot;value2&quot;; &#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>我想后端语言（Java/GoLang）至今也没有出现如此复杂的类型定义。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然 TypeScript 的类型系统已经如此强大，但它并非没有局限性，像在上面的 <a href="#%E5%9C%A8-i18next-%E4%B8%AD%E6%A0%B9%E6%8D%AE-key-%E8%8E%B7%E5%8F%96%E7%BF%BB%E8%AF%91%E5%AD%97%E7%AC%A6%E4%B8%B2">在 i18next 中根据 key 获取翻译字符串</a> 便是一例。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 开发经验之谈系列-常见问题</title>
    <link href="/p/76072311817b4c1985ab5746e8f91d87/"/>
    <url>/p/76072311817b4c1985ab5746e8f91d87/</url>
    
    <content type="html"><![CDATA[<h2 id="突然之间-electron-就不能启动了"><a href="#突然之间-electron-就不能启动了" class="headerlink" title="突然之间 electron 就不能启动了"></a>突然之间 electron 就不能启动了</h2><p>删除 node_modules 重新 yarn 看看？</p><h2 id="打包之后的程序页面空白"><a href="#打包之后的程序页面空白" class="headerlink" title="打包之后的程序页面空白"></a>打包之后的程序页面空白</h2><p>实际上是 electron 无法正常加载页面，原因很多</p><ol><li> 路径问题，解压 asar 查看实际路径（<code>main.js</code> 中 <code>loadUrl</code> 的路径是否正确）</li><li> react router 仅支持 hash 模式</li><li> 在从文件系统中读取 html 文件时不能使用 <code>#</code> 指定路由，参考: <a href="https://stackoverflow.com/questions/55715384s">https://stackoverflow.com/questions/55715384s</a></li></ol><blockquote><p>asar 文件一般在 _win-unpacked/:/app_，参考: <a href="https://github.com/electron/asar">https://github.com/electron/asar</a></p></blockquote><h2 id="electron-程序命令行输出中文乱码"><a href="#electron-程序命令行输出中文乱码" class="headerlink" title="electron 程序命令行输出中文乱码"></a>electron 程序命令行输出中文乱码</h2><p>在运行命令前首先运行 <code>chcp 65001</code> 修改活动代码页编号，参考：<a href="https://stackoverflow.com/questions/57131654">Using UTF-8 Encoding (CHCP 65001) in Command Prompt / Windows Powershell (Windows 10)</a></p><h2 id="如何不打包成压缩格式-asar"><a href="#如何不打包成压缩格式-asar" class="headerlink" title="如何不打包成压缩格式 asar"></a>如何不打包成压缩格式 asar</h2><p>配置 electron-builder <code>&quot;asar&quot;: false</code>。</p><h2 id="second-instance-事件监听无效"><a href="#second-instance-事件监听无效" class="headerlink" title="second-instance 事件监听无效"></a><code>second-instance</code> 事件监听无效</h2><p>必须使用 <code>app.requestSingleInstanceLock()</code> 保持应用程序单例，才能正常监听到该事件。</p><p>示例代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> gotTheLock = app.requestSingleInstanceLock();<br><span class="hljs-keyword">if</span> (!gotTheLock) &#123;<br>  app.quit();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  app.on(<span class="hljs-string">&quot;second-instance&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event, commandLine, workingDirectory</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;second-instance&quot;</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock">https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock</a></p></blockquote><h2 id="安装浏览器扩展报错"><a href="#安装浏览器扩展报错" class="headerlink" title="安装浏览器扩展报错"></a>安装浏览器扩展报错</h2><p>提示安装失败</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">(node:23488) ExtensionLoadWarning: Warnings loading extension at C:\Users\rxliuli\AppData\Roaming\Electron\extensions\fmkadmapgofadopljbjfkapdkoienihi: Unrecognized manifest key <span class="hljs-string">&#x27;browser_action&#x27;</span>. Unre<br>cognized manifest key <span class="hljs-string">&#x27;minimum_chrome_version&#x27;</span>. Unrecognized manifest key <span class="hljs-string">&#x27;update_url&#x27;</span>. Cannot load extension with file or directory name _metadata. Filenames starting with <span class="hljs-string">&quot;_&quot;</span> are reserved <span class="hljs-keyword">for</span> use by<br> the system.<br></code></pre></td></tr></table></figure><p>其实答案是：扩展必须在 <code>app.ready</code> 之后，创建 BrowserWindow 窗口之前安装。</p>]]></content>
    
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 页面布局</title>
    <link href="/p/b54161d3177f463d9b91f9fa17e0fd8e/"/>
    <url>/p/b54161d3177f463d9b91f9fa17e0fd8e/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p><a href="https://grid.layoutit.com/">grid 可视化布局</a>, <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">css grid 完整指南</a></p></blockquote><p>早就知道 css grid 布局非常强大，但之前由于兼容性问题一直没有机会尝试，近来在生产环境中大规模尝试使用它，并尝试在 react 中进行封装：<a href="/p/a4b40427c59d4c8eb258375771b7c5d8">在 react 中优雅的使用 grid 实现页面布局</a>，于此记录一下各种常见布局的 grid 实现。</p><blockquote><p>附：grid 真的是一个非常强大自适应布局系统。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>注：以下示例均默认引用了 <a href="https://necolas.github.io/normalize.css/">Normalize.css</a></p></blockquote><h3 id="中后台基本布局"><a href="#中后台基本布局" class="headerlink" title="中后台基本布局"></a>中后台基本布局</h3><p><img src="/resource/36ac0cf810e3433eb62f24cf94250346.png" alt="中后台基本布局"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    html,<br>    body,<br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      height: 100%;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      display: grid;<br><span class="css">      <span class="hljs-comment">/* 定义行和列 */</span></span><br>      grid-template-columns: 300px 1fr;<br>      grid-template-rows: auto 1fr;<br><span class="css">      <span class="hljs-comment">/* 定义布局的地图，未设定 area 则默认堆叠 */</span></span><br>      grid-template-areas: &quot;header header&quot;;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.header</span> &#123;</span><br>      grid-area: header;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.container</span> &gt; * &#123;</span><br>      border: solid 1px red;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>sidebar<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/resource/082f3b56a78f4be6932803df73970a85.html">中后台基本布局.html</a></p><h3 id="纵向布局"><a href="#纵向布局" class="headerlink" title="纵向布局"></a>纵向布局</h3><p><img src="/resource/63d35c58ce5c4f38acd4fe6e9bf6ee37.png" alt="纵向布局"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    html,<br>    body,<br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      height: 100%;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      display: grid;<br>      /* 下面这行指定了<br>        第一行按照内容自适应高度<br>        第二行占有剩余高度<br>         */<br>      grid-template-rows: auto 1fr;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.container</span> &gt; * &#123;</span><br>      border: solid 1px red;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/resource/72183c54283b42ada8489badd3a991af.html">纵向布局.html</a></p><h3 id="模拟-flex-margin-left-或-margin-right"><a href="#模拟-flex-margin-left-或-margin-right" class="headerlink" title="模拟 flex margin-left 或 margin-right"></a>模拟 flex margin-left 或 margin-right</h3><p><img src="/resource/9953b8f2368a4924a03a5cc84ccee09e.png" alt="模拟 flex margin-left 或 margin-right"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      display: grid;<br><span class="css">      <span class="hljs-comment">/* 下面两行是关键 */</span></span><br>      grid-template-columns: auto 1fr auto;<br>      justify-items: end;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.container</span> &gt; * &#123;</span><br>      border: solid 1px red;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/20&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>消息<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/resource/18b7bcdf9edb475d9fadfb31f507f2bc.html">模拟 flex margin-left 或 margin-right.html</a></p><h3 id="根据内容自适应贴靠在一边"><a href="#根据内容自适应贴靠在一边" class="headerlink" title="根据内容自适应贴靠在一边"></a>根据内容自适应贴靠在一边</h3><p>如下图展示一个图片列表</p><p><img src="/resource/140f7e0e0dbd4ca6a47ddbe546cc67b6.png" alt="根据内容自适应贴靠在一边"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      display: grid;<br>      grid-template-columns: auto auto;<br><span class="css">      <span class="hljs-comment">/* 下面一行是关键，效果类似于 flex-start */</span></span><br>      justify-content: start;<br>      grid-gap: 8px;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/1/100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/2/100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/3/100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/4/100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/5/100&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://picsum.photos/seed/6/100&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/resource/dcdbdf2653eb4ee68837c3b75da00fa0.html">根据内容自适应贴靠在一边.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在 react 中优雅的使用 grid 实现页面布局</title>
    <link href="/p/a4b40427c59d4c8eb258375771b7c5d8/"/>
    <url>/p/a4b40427c59d4c8eb258375771b7c5d8/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在做 electron 应用的时候遇到了这种布局，顶部是 header，然后是页面中的 toolbar，紧接着右边有一个侧边栏列表，左侧的内容又分为了两块区域。这种布局在中后台系统中应该很常见，但之前并未特别留意过布局通用化。</p><p><img src="/resource/2b76f0b1d64d437684ab41f5dde82e43.svg" alt="布局.drawio.svg"></p><ul><li>使用 <code>css calc()</code> 计算高度</li><li>基于 <code>css calc()</code> 封装 <code>Col/Row</code> 组件，然后使用组件进行布局（主要模仿 antd grid）</li><li>使用 <code>css grid</code> 自适应布局</li><li>使用 <code>css grid</code> 封装组件</li></ul><h2 id="使用-css-calc-计算高度"><a href="#使用-css-calc-计算高度" class="headerlink" title="使用 css calc() 计算高度"></a>使用 <code>css calc()</code> 计算高度</h2><p>最初，吾辈使用 <code>css calc()</code> 计算剩余高度，以占满全部高度。但这样实现存在的一个明显问题是，每当吾辈需要在纵向添加一行时，都要修改 <code>calc()</code> 重新计算高度。如果存在嵌套内容时，甚至会导致层层声明 <code>height: calc(100% - *px)</code>，而且难以复用，这是很难接受的。</p><p>下面是一个实现上面那种布局的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>grid test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      * &#123;<br>        margin: 0;<br>        padding: 0;<br>        box-sizing: border-box;<br>      &#125;<br>      html,<br>      body,<br><span class="css">      <span class="hljs-selector-class">.container</span> &#123;</span><br>        height: 100%;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.header</span> &#123;</span><br>        height: 64px;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.main</span> &#123;</span><br>        height: calc(100% - 64px);<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.toolbar</span> &#123;</span><br>        height: 64px;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.content</span> &#123;</span><br>        height: calc(100% - 64px);<br>        display: flex;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.main-content</span> &#123;</span><br>        display: inline-block;<br>        width: calc(100% - 300px);<br>        height: 100%;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.sider</span> &#123;</span><br>        display: inline-block;<br>        width: 300px;<br>        height: 100%;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.form</span> &#123;</span><br>        height: 300px;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.list</span> &#123;</span><br>        height: calc(100% - 300px);<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.header</span>,</span><br><span class="css">      <span class="hljs-selector-class">.main</span>,</span><br><span class="css">      <span class="hljs-selector-class">.toolbar</span>,</span><br><span class="css">      <span class="hljs-selector-class">.content</span>,</span><br><span class="css">      <span class="hljs-selector-class">.sider</span>,</span><br><span class="css">      <span class="hljs-selector-class">.form</span>,</span><br><span class="css">      <span class="hljs-selector-class">.list</span> &#123;</span><br>        border: solid 1px red;<br>        overflow-y: auto;<br>        text-align: center;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;toolbar&quot;</span>&gt;</span>toolbar<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-content&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span>form<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>list<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sider&quot;</span>&gt;</span>sider<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，不仅 html 部分嵌套众多，css 部分也需要反复计算宽高，这实在不是一件令人愉快的代码。</p><h2 id="基于-css-calc-封装-Col-Row-组件布局"><a href="#基于-css-calc-封装-Col-Row-组件布局" class="headerlink" title="基于 css calc() 封装 Col/Row 组件布局"></a>基于 <code>css calc()</code> 封装 <code>Col/Row</code> 组件布局</h2><p>由于不希望每次都去写类似下面的代码，因而吾辈产生了封装组件的想法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow-y</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>初次尝试</p><blockquote><p>基本思路来源于 antd 的 <a href="https://ant.design/components/grid-cn">Grid 布局</a>，之所以没有使用 antd grid 的原因是它并不支持纵向的布局，即便是 Layout 布局组件也不是那么好用。</p></blockquote><ul><li><code>FullHeight</code>: 让子组件占满父组件的全部高度</li><li><code>VerticalCol</code>: 占全高的一列</li><li><code>VerticalRow</code>: 可控制占比列中的一行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs tsx">type FullHeightProps &#x3D; &#123;<br>  children: ReactElement;<br>&#125;;<br><br>&#x2F;**<br> * 让子组件占满父组件的全部高度<br> *&#x2F;<br>const FullHeight: React.FC&lt;FullHeightProps&gt; &#x3D; (props) &#x3D;&gt; &#123;<br>  return cloneElement(props.children, &#123;<br>    ...props.children.props,<br>    style: &#123;<br>      height: &quot;100%&quot;,<br>      overflowY: &quot;auto&quot;,<br>      ...props.children.props.style,<br>    &#125;,<br>  &#125;);<br>&#125;;<br><br>&#x2F;&#x2F; 垂直布局的上下文<br><br>export type VerticalColContextType &#x3D; &#123;<br>  &#x2F;&#x2F;分割的份数<br>  gutter: number;<br>&#125;;<br><br>&#x2F;**<br> * 垂直布局的上下文环境<br> *&#x2F;<br>export const VerticalColContext &#x3D; createContext&lt;VerticalColContextType&gt;(&#123;<br>  gutter: 24,<br>&#125;);<br><br>type VerticalColProps &#x3D; &#123;<br>  children: ReactElement&lt;VerticalRowProps&gt; | ReactElement&lt;VerticalRowProps&gt;[];<br>  style?: CSSProperties;<br>&#125;;<br><br>&#x2F;**<br> * 垂直布局的一列<br> * 默认占父容器的全部高度<br> *&#x2F;<br>const VerticalCol &#x3D; React.forwardRef&lt;HTMLDivElement, VerticalColProps&gt;(<br>  (props, ref) &#x3D;&gt; (<br>    &lt;VerticalColContext.Provider<br>      value&#x3D;&#123;&#123;<br>        gutter: 24,<br>      &#125;&#125;<br>    &gt;<br>      &lt;FullHeight&gt;<br>        &lt;div style&#x3D;&#123;props.style&#125; ref&#x3D;&#123;ref&#125;&gt;<br>          &#123;props.children&#125;<br>        &lt;&#x2F;div&gt;<br>      &lt;&#x2F;FullHeight&gt;<br>    &lt;&#x2F;VerticalColContext.Provider&gt;<br>  )<br>);<br><br>export type VerticalRowProps &#x3D; &#123;<br>  span?: number;<br>  style?: CSSProperties;<br>&#125;;<br><br>&#x2F;**<br> * 用来控制每一行占比的元素<br> *&#x2F;<br>const VerticalRow: React.FC&lt;VerticalRowProps&gt; &#x3D; (props) &#x3D;&gt; &#123;<br>  const &#123; gutter &#125; &#x3D; useContext(VerticalColContext);<br>  return (<br>    &lt;div<br>      style&#x3D;&#123;&#123;<br>        height: &#96;calc(100% &#x2F; $&#123;gutter&#125; * $&#123;props.span&#125;)&#96;,<br>        overflowY: &quot;auto&quot;,<br>        ...props.style,<br>      &#125;&#125;<br>    &gt;<br>      &#123;props.children&#125;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br><br>VerticalRow.defaultProps &#x3D; &#123;<br>  span: 0,<br>&#125;;<br></code></pre></td></tr></table></figure><p>基本使用大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;VerticalCol<br>  style&#x3D;&#123;&#123;<br>    height: &quot;100%&quot;,<br>  &#125;&#125;<br>&gt;<br>  &lt;VerticalRow span&#x3D;&#123;2&#125; style&#x3D;&#123;&#123; backgroundColor: &quot;red&quot; &#125;&#125;&gt;<br>    内容块 1<br>  &lt;&#x2F;VerticalRow&gt;<br>  &lt;VerticalRow span&#x3D;&#123;22&#125; style&#x3D;&#123;&#123; backgroundColor: &quot;green&quot; &#125;&#125;&gt;<br>    内容块 2<br>  &lt;&#x2F;VerticalRow&gt;<br>&lt;&#x2F;VerticalCol&gt;<br></code></pre></td></tr></table></figure><p>看起来还不错，简单的使用组件就可以按比例分割页面了。但一旦在复杂的实际页面使用时，麻烦就接踵而来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;VerticalCol<br>  style&#x3D;&#123;&#123;<br>    height: 800,<br>  &#125;&#125;<br>&gt;<br>  &lt;VerticalRow span&#x3D;&#123;2&#125; style&#x3D;&#123;&#123; backgroundColor: &quot;red&quot; &#125;&#125;&gt;<br>    &lt;header&gt;<br>      &lt;h1&gt;标题&lt;&#x2F;h1&gt;<br>    &lt;&#x2F;header&gt;<br>  &lt;&#x2F;VerticalRow&gt;<br>  &lt;VerticalRow span&#x3D;&#123;22&#125; style&#x3D;&#123;&#123; backgroundColor: &quot;green&quot; &#125;&#125;&gt;<br>    &lt;FullHeight&gt;<br>      &lt;Row&gt;<br>        &lt;FullHeight&gt;<br>          &lt;Col<br>            span&#x3D;&#123;18&#125;<br>            style&#x3D;&#123;&#123;<br>              backgroundColor: &quot;aqua&quot;,<br>            &#125;&#125;<br>          &gt;<br>            内容区域<br>          &lt;&#x2F;Col&gt;<br>        &lt;&#x2F;FullHeight&gt;<br>        &lt;FullHeight&gt;<br>          &lt;Col<br>            span&#x3D;&#123;6&#125;<br>            style&#x3D;&#123;&#123;<br>              backgroundColor: &quot;blue&quot;,<br>            &#125;&#125;<br>          &gt;<br>            &#123;Array(100)<br>              .fill(0)<br>              .map((_, i) &#x3D;&gt; (<br>                &lt;h2<br>                  style&#x3D;&#123;&#123;<br>                    color: &quot;white&quot;,<br>                  &#125;&#125;<br>                &gt;<br>                  &#123;i&#125;<br>                &lt;&#x2F;h2&gt;<br>              ))&#125;<br>          &lt;&#x2F;Col&gt;<br>        &lt;&#x2F;FullHeight&gt;<br>      &lt;&#x2F;Row&gt;<br>    &lt;&#x2F;FullHeight&gt;<br>  &lt;&#x2F;VerticalRow&gt;<br>&lt;&#x2F;VerticalCol&gt;<br></code></pre></td></tr></table></figure><p>可以看到，这里仅仅是使用 Component 代替了 css class 而已，并未减少页面布局的复杂性，而且由于使用组件进行布局，导致组件的结构变得更深了。</p><h2 id="使用-css-grid-自适应布局"><a href="#使用-css-grid-自适应布局" class="headerlink" title="使用 css grid 自适应布局"></a>使用 <code>css grid</code> 自适应布局</h2><p>css grid 确实强大无比，尤其是 <code>grid-template-areas</code> 功能，直接改变了传统网页的布局方式。现在，自适应布局变得异常简单。</p><p>下面是使用 grid 的方式实现布局的代码，可以看到最复杂的部分其实是在 <code>grid-template-areas</code>，它确定了不同元素占有的区块。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>grid test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      html,<br>      body,<br><span class="css">      <span class="hljs-selector-class">.grid-container</span> &#123;</span><br>        margin: 0;<br>        padding: 0;<br>        box-sizing: border-box;<br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.grid-container</span> &#123;</span><br>        height: 100%;<br>        display: grid;<br>        grid-template-columns: 1fr 300px;<br>        grid-template-rows: 64px 64px 430px 1fr;<br>        grid-template-areas:<br>          &quot;header header&quot;<br>          &quot;toolbar toolbar&quot;<br>          &quot;form sider&quot;<br>          &quot;list sider&quot;;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.header</span> &#123;</span><br>        grid-area: header;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.toolbar</span> &#123;</span><br>        grid-area: toolbar;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.sider</span> &#123;</span><br>        grid-area: sider;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.form</span> &#123;</span><br>        grid-area: form;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.list</span> &#123;</span><br>        grid-area: list;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.header</span>,</span><br><span class="css">      <span class="hljs-selector-class">.toolbar</span>,</span><br><span class="css">      <span class="hljs-selector-class">.sider</span>,</span><br><span class="css">      <span class="hljs-selector-class">.form</span>,</span><br><span class="css">      <span class="hljs-selector-class">.list</span> &#123;</span><br>        border: 1px solid red;<br>        overflow-y: auto;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;toolbar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sider&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但 grid 也并非尽善尽美，它仅对直接子组件生效，而孙子及其子节点则不在 <code>grid</code> 的布局范围，这导致为子组件编写 grid 布局样式时，仍然存在一些样板代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 下面是典型的样板代码 */</span><br><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: header;<br>&#125;<br><span class="hljs-selector-class">.toolbar</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: toolbar;<br>&#125;<br><span class="hljs-selector-class">.sider</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: sider;<br>&#125;<br><span class="hljs-selector-class">.form</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: form;<br>&#125;<br><span class="hljs-selector-class">.list</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: list;<br>&#125;<br><span class="hljs-selector-class">.header</span>,<br><span class="hljs-selector-class">.toolbar</span>,<br><span class="hljs-selector-class">.sider</span>,<br><span class="hljs-selector-class">.form</span>,<br><span class="hljs-selector-class">.list</span> &#123;<br>  <span class="hljs-attribute">overflow-y</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-css-grid-封装组件"><a href="#使用-css-grid-封装组件" class="headerlink" title="使用 css grid 封装组件"></a>使用 <code>css grid</code> 封装组件</h2><p>事实上，吾辈确实找到了一个现有的基于 grid 的 react 布局组件库 <a href="https://github.com/STRML/react-grid-layout">react-grid-layout</a>，而且非常强大，但很遗憾的是它并 <a href="https://github.com/STRML/react-grid-layout/issues/1329">不支持 react 17</a>。但其 api 及封装方式确实有参考意义，所以吾辈也尝试封装一个 <code>Grid</code> 组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tsx">type Unit &#x3D; &#96;$&#123;number&#125;$&#123;&quot;px&quot; | &quot;fr&quot;&#125;&#96;;<br><br>type GridProps&lt;<br>  T extends string,<br>  R extends Unit[] &#x3D; Unit[],<br>  C extends Unit[] &#x3D; Unit[],<br>  A extends &#123; [P in keyof R]: &#123; [P in keyof C]: T &#125; &#125; &#x3D; &#123;<br>    [P in keyof R]: &#123; [P in keyof C]: T &#125;;<br>  &#125;<br>&gt; &#x3D; &#123;<br>  rows: R;<br>  cols: C;<br>  areas: A;<br>  children: ReactElement[];<br>&#125; &amp; CommonStyleProps;<br><br>&#x2F;**<br> * 使用 grid 进行布局的容器组件<br> *&#x2F;<br>function Grid&lt;T extends string&gt;(props: GridProps&lt;T&gt;) &#123;<br>  return (<br>    &lt;div<br>      className&#x3D;&#123;props.className&#125;<br>      style&#x3D;&#123;<br>        &#123;<br>          height: &quot;100%&quot;,<br>          display: &quot;grid&quot;,<br>          gridTemplateColumns: props.cols.join(&quot; &quot;),<br>          gridTemplateRows: props.rows.join(&quot; &quot;),<br>          gridTemplateAreas: props.areas<br>            .map((row) &#x3D;&gt; &#39;&quot;&#39; + row.join(&quot; &quot;) + &#39;&quot;&#39;)<br>            .join(&quot; &quot;),<br>          ...props.style,<br>        &#125; as CSSProperties<br>      &#125;<br>    &gt;<br>      &#123;props.children.map((child) &#x3D;&gt; &#123;<br>        console.log(&quot;child key: &quot;, child.key);<br>        return cloneElement(child, &#123;<br>          ...child.props,<br>          style: &#123;<br>            gridArea: child.key,<br>            border: &quot;solid 1px red&quot;,<br>          &#125; as CSSProperties,<br>        &#125;);<br>      &#125;)&#125;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来比较简单，唯一残念的是子元素中的 key 无法使用 ts 自动推导或强制约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;Grid&lt;AreaItemName&gt;<br>  style&#x3D;&#123;&#123;<br>    height: &quot;calc(100vh - 48px)&quot;,<br>  &#125;&#125;<br>  rows&#x3D;&#123;[&quot;48px&quot;, &quot;48px&quot;, &quot;300px&quot;, &quot;1fr&quot;]&#125;<br>  cols&#x3D;&#123;[&quot;1fr&quot;, &quot;300px&quot;]&#125;<br>  areas&#x3D;&#123;[<br>    [&quot;header&quot;, &quot;header&quot;],<br>    [&quot;toolbar&quot;, &quot;toolbar&quot;],<br>    [&quot;form&quot;, &quot;sider&quot;],<br>    [&quot;list&quot;, &quot;sider&quot;],<br>  ]&#125;<br>&gt;<br>  &lt;header key&#x3D;&#123;&quot;header&quot; as AreaItemName&#125;&gt;header&lt;&#x2F;header&gt;<br>  &lt;section key&#x3D;&#123;&quot;toolbar&quot; as AreaItemName&#125;&gt;toolbar&lt;&#x2F;section&gt;<br>  &lt;section key&#x3D;&#123;&quot;sider&quot; as AreaItemName&#125;&gt;sider&lt;&#x2F;section&gt;<br>  &lt;section key&#x3D;&#123;&quot;form&quot; as AreaItemName&#125;&gt;form&lt;&#x2F;section&gt;<br>  &lt;section key&#x3D;&#123;&quot;list&quot; as AreaItemName&#125;&gt;list&lt;&#x2F;section&gt;<br>&lt;&#x2F;Grid&gt;<br></code></pre></td></tr></table></figure><p>看起来不错，然而实际上这还是有缺陷的。</p><ol><li>子组件必须处理了 <code>props.style</code>，因为 <code>cloneElement</code> 仅仅为原组件注入了属性（默认的 react html 元素均已处理）<ol><li> 当布局的子组件需要监听滚动时，由于外层使用 div 在自定义组件外部，实际上并不能取到 ref，需要在业务组件再设置一次滚动。</li></ol></li><li> 类型约束未能完全生效，例如子元素的 key，就没办法做到类型自动推导限定</li><li> 子组件内容过多时仍然会导致父元素出现滚动条</li></ol><p>接下来一个个解决</p><h3 id="1-子组件必须处理了-props-style，因为-cloneElement-仅仅为原组件注入了属性（默认的-react-html-元素均已处理）"><a href="#1-子组件必须处理了-props-style，因为-cloneElement-仅仅为原组件注入了属性（默认的-react-html-元素均已处理）" class="headerlink" title="1. 子组件必须处理了 props.style，因为 cloneElement 仅仅为原组件注入了属性（默认的 react html 元素均已处理）"></a>1. 子组件必须处理了 <code>props.style</code>，因为 <code>cloneElement</code> 仅仅为原组件注入了属性（默认的 react html 元素均已处理）</h3><p>当需要为自定义的业务组件布局时，有两种思路</p><ol><li> 在外层套 <code>div</code></li><li> 由组件处理 <code>props.style</code></li></ol><p>但这两种方式各有优劣</p><p>前者父组件的布局不会受到子组件影响，意味着子组件更容易被复用。后者在子组件内部需要使用 ref 时，不需要再额外声明 css 以使之成为可滚动元素。</p><p>下面是一个混合使用两者的的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const style: CSSProperties &#x3D; &#123; border: &quot;solid 1px red&quot; &#125;;<br>type AreaItemName &#x3D; &quot;header&quot; | &quot;content&quot; | &quot;sider&quot;;<br><br>function Header() &#123;<br>  return &lt;header style&#x3D;&#123;style&#125;&gt;header&lt;&#x2F;header&gt;;<br>&#125;<br><br>function Content() &#123;<br>  return &lt;main style&#x3D;&#123;style&#125;&gt;content&lt;&#x2F;main&gt;;<br>&#125;<br><br>function Sider(props: CommonStyleProps) &#123;<br>  const $ref &#x3D; useRef&lt;HTMLElement&gt;(null);<br>  return wrapper(<br>    &lt;section style&#x3D;&#123;style&#125; ref&#x3D;&#123;$ref&#125;&gt;<br>      &lt;ul&gt;<br>        &#123;Array(100)<br>          .fill(0)<br>          .map((_, i) &#x3D;&gt; (<br>            &lt;li key&#x3D;&#123;i&#125;&gt;&#123;i&#125;&lt;&#x2F;li&gt;<br>          ))&#125;<br>      &lt;&#x2F;ul&gt;<br>      &lt;BackTop target&#x3D;&#123;() &#x3D;&gt; $ref.current!&#125;&gt;<br>        &lt;ToTopOutlined<br>          style&#x3D;&#123;<br>            &#123;<br>              fontSize: 24,<br>              padding: 8,<br>              borderRadius: &quot;50%&quot;,<br>              color: &quot;#ffffff&quot;,<br>              backgroundColor: &quot;#8ECAFE&quot;,<br>            &#125; as CSSProperties<br>          &#125;<br>        &#x2F;&gt;<br>      &lt;&#x2F;BackTop&gt;<br>    &lt;&#x2F;section&gt;,<br>    props<br>  );<br>&#125;<br><br>return (<br>  &lt;Grid&lt;AreaItemName&gt;<br>    style&#x3D;&#123;&#123;<br>      height: &quot;calc(100vh - 48px)&quot;,<br>    &#125;&#125;<br>    rows&#x3D;&#123;[&quot;48px&quot;, &quot;1fr&quot;]&#125;<br>    cols&#x3D;&#123;[&quot;1fr&quot;, &quot;300px&quot;]&#125;<br>    areas&#x3D;&#123;[[&quot;header&quot;, &quot;header&quot;]]&#125;<br>  &gt;<br>    &lt;div key&#x3D;&#123;&quot;header&quot; as AreaItemName&#125;&gt;<br>      &lt;Header &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>    &lt;Content &#x2F;&gt;<br>    &lt;Sider &#x2F;&gt;<br>  &lt;&#x2F;Grid&gt;<br>);<br></code></pre></td></tr></table></figure><h3 id="2-类型约束未能完全生效，例如子元素的-key，就没办法做到类型自动推导限定"><a href="#2-类型约束未能完全生效，例如子元素的-key，就没办法做到类型自动推导限定" class="headerlink" title="2. 类型约束未能完全生效，例如子元素的 key，就没办法做到类型自动推导限定"></a>2. 类型约束未能完全生效，例如子元素的 key，就没办法做到类型自动推导限定</h3><p>目前很难处理 <code>ReactElement</code> 类型，导致相关的类型自动推导特别麻烦，so…暂时没有好的办法。</p><h3 id="3-子组件内容过多时仍然会导致父元素出现滚动条"><a href="#3-子组件内容过多时仍然会导致父元素出现滚动条" class="headerlink" title="3. 子组件内容过多时仍然会导致父元素出现滚动条"></a>3. 子组件内容过多时仍然会导致父元素出现滚动条</h3><p>为子组件设置默认 <code>height/overflowY</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tsx">function Grid&lt;T extends string&gt;(props: GridProps&lt;T&gt;) &#123;<br>  const &#123; cols &#x3D; [], rows &#x3D; [], areas &#x3D; [], children &#125; &#x3D; props;<br>  return (<br>    &lt;div<br>      className&#x3D;&#123;props.className&#125;<br>      style&#x3D;&#123;<br>        &#123;<br>          height: &quot;100%&quot;,<br>          overflowY: &quot;auto&quot;,<br>          display: &quot;grid&quot;,<br>          gridTemplateColumns: cols.join(&quot; &quot;),<br>          gridTemplateRows: rows.join(&quot; &quot;),<br>          gridTemplateAreas: areas<br>            .map((row) &#x3D;&gt; &#39;&quot;&#39; + row.join(&quot; &quot;) + &#39;&quot;&#39;)<br>            .join(&quot; &quot;),<br>          ...props.style,<br>        &#125; as CSSProperties<br>      &#125;<br>    &gt;<br>      &#123;children.map((child) &#x3D;&gt; &#123;<br>        return cloneElement(child, &#123;<br>          ...child.props,<br>          style: &#123;<br>            &#x2F;&#x2F; 这里是关键<br>            height: &quot;100%&quot;,<br>            overflowY: &quot;auto&quot;,<br>            gridArea: child.key,<br>            ...child.props.style,<br>          &#125; as CSSProperties,<br>        &#125;);<br>      &#125;)&#125;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>老实说吾辈对现代前端的生态乱象表示很讨厌，尤其是 react 生态的 css 处理方案，仅 css-in-js 就有几十种可选方案，而官方又没有作为，导致没有统一的方式（vue 在这点上好很多）处理它们，所以吾辈才选择了 ui 组件 + css module 的方式。乍一看似乎回到了 HTML 标签控制样式的情况，但相比之下<strong>组件</strong>比 HTML 标签灵活得多，而且更容易扩展和组合（如果使用了 css 预处理器就是另外一回事了）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端资源管理</title>
    <link href="/p/4b666902cd1e45779448a76a71d0e2e5/"/>
    <url>/p/4b666902cd1e45779448a76a71d0e2e5/</url>
    
    <content type="html"><![CDATA[<h2 id="框架及社区"><a href="#框架及社区" class="headerlink" title="框架及社区"></a>框架及社区</h2><ul><li><a href="https://reactjs.org/">react</a>: 前端流行的 mvc 框架<ul><li><a href="https://create-react-app.dev/">create-react-app</a>: react 官方的脚手架</li><li><a href="https://reactrouter.com/">react-router</a>: react 上的路由管理库<ul><li><a href="https://www.npmjs.com/package/react-router-config">react-router-config</a>: 集中式的 react-router 路由管理库</li></ul></li><li><a href="https://github.com/gsoft-inc/craco">craco</a>: react 的一个非官方的无需 eject 即可覆盖 cra 内部配置的打包库</li><li><a href="https://github.com/streamich/react-use">react-use</a>: react hooks 通用库</li><li><a href="https://ant.design/">antd</a>: 极其强大的中后台 ui 组件库<ul><li><a href="https://ant.design/components/icon/">@ant-design/icons</a>: antd 的图标库</li></ul></li><li><a href="https://immerjs.github.io/immer/">immer</a>: 简化 react 中不可变数据的修改</li><li><a href="https://peterbeshai.com/use-query-params/">use-query-params</a>: 处理 react router 中的 query params<ul><li><a href="https://github.com/sindresorhus/query-string#readme">query-string</a>: 所依赖的 url 查询字符串库，必须手动添加以使用最新版本</li></ul></li><li><a href="https://github.com/JedWatson/classnames">classnames</a>: react css module 简化工具</li><li><a href="https://www.npmjs.com/package/react-infinite-scroller">react-infinite-scroller</a>: react 无限滚动通用组件</li></ul></li><li><a href="https://vuejs.org/">vue</a>: 国人开发的 mvvm 框架，更小更加轻量<ul><li><a href="https://cli.vuejs.org/">vue-cli</a>: vue 官方的脚手架</li><li><a href="https://router.vuejs.org/">vue-router</a>: vue 官方的集中式路由管理库</li><li><a href="https://vuex.vuejs.org/">vuex</a>: vue 官方的 flux 状态管理库</li></ul></li><li><a href="https://www.typescriptlang.org/">typescript</a>: 为 js 添加了类型系统</li><li><a href="https://mobx.js.org/">mobx</a>: 跨框架可变式的全局状态管理库</li><li><a href="https://xstate.js.org/">xstate</a>: 跨框架的状态机</li><li><a href="https://esdoc.org/">esdoc</a>: js 中最好的 api 文档生成工具</li><li><a href="https://typedoc.org/">typedoc</a>: ts 中目前最好的 api 文档生成工具（但仍然没有上面的 esdoc 好）</li><li><a href="https://storybook.js.org/">storybook</a>: 跨框架的 ui 组件文档生成器</li><li><a href="https://github.com/piotrwitek/type-fest">type-fest</a>: typescript 类型工具库</li><li><a href="https://github.com/marak/Faker.js/">faker</a>: mock 数据生成</li><li><a href="https://github.com/axios/axios">axios</a>: 通用 ajax 请求库</li><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">@types/*</a>: 社区类型定义库</li><li><a href="https://prettier.io/">prettier</a>: 代码统一格式化工具</li><li><a href="https://eslint.org/">eslint</a>: 前端可配置的 linter 工具（实测还是没有 WebStorm 的内置 linter 好用）</li><li><a href="https://github.com/uuidjs/uuid">uuid</a>: 前端 uuid 生成工具</li><li><a href="https://stuk.github.io/jszip/">jszip</a>: js 上的 zip 处理库</li><li><a href="https://dexie.org/">dexie</a>: Web IndexedDB 封装</li><li><a href="https://github.com/stipsan/scroll-into-view-if-needed">scroll-into-view-if-needed</a>: 控制 dom 元素滚动到视图区域的工具库</li><li><a href="https://github.com/lindell/JsBarcode">jsbarcode</a>: 生成一维码</li><li><a href="https://github.com/iansinnott/react-string-replace">react-string-replace</a>: react 中将 <code>string</code> 替换为 jsx 的工具函数</li><li><a href="https://github.com/crabbly/Print.js">print-js</a>: 浏览器端打印 pdf 的工具库</li><li><a href="https://github.com/moment/luxon">luxon</a>: 日期时间库</li></ul><h2 id="nodejs-上的工具"><a href="#nodejs-上的工具" class="headerlink" title="nodejs 上的工具"></a>nodejs 上的工具</h2><ul><li><a href="https://github.com/rollup/rollup">rollup</a>: 前端 npm 库打包工具</li><li><a href="https://github.com/toddbluhm/env-cmd">env-cmd</a>: 跨平台设置环境变量</li><li><a href="https://github.com/gulpjs/gulp">gulp</a>: 流式 task 工具</li><li><a href="https://github.com/typicode/husky">husky</a>: 为项目配置 git 钩子</li><li><a href="https://github.com/okonet/lint-staged">lint-staged</a>: 针对暂存的 git 文件运行 linters</li><li><a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a>: webpack worker 插件<ul><li><a href="https://github.com/GoogleChromeLabs/comlink">comlink</a>: 基于 Proxy 的一个 web worker rpc 实现</li></ul></li><li><a href="https://jestjs.io/">jest</a>: 单元测试框架<ul><li><a href="https://github.com/kulshekhar/ts-jest">ts-jest</a>: 支持 ts 单元测试的预设配置</li></ul></li><li><a href="https://github.com/TypeStrong/ts-node">ts-node</a>: 直接运行 ts 文件</li><li><a href="https://github.com/jprichardson/node-fs-extra">fs-extra</a>: nodejs fs 模块的 Promise 包装超集</li><li><a href="https://github.com/shelljs/shx">shx</a>: npm 中的跨平台 *unix 命令</li><li><a href="https://github.com/kurttheviking/git-rev-sync-js">git-rev-sync</a>: 读取当前项目的 git 信息</li><li><a href="https://electronjs.org/">electron</a>: Web 跨平台客户端解决方案<ul><li><a href="https://www.electron.build/">electron-builder</a>: electron 打包/更新一站式解决方案</li><li><a href="https://github.com/MarshallOfSound/electron-devtools-installer">electron-devtools-installer</a>: electron 客户端安装开发插件</li></ul></li><li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>: web 打包分析</li><li><a href="https://www.lodashjs.com/">lodash</a>: 前端通用工具库</li><li><a href="https://github.com/theophilusx/ssh2-sftp-client">ssh2-sftp-client</a>: sftp 工具库</li><li><a href="https://github.com/Level/levelup">levelup</a>: 跨语言的高性能键值存储</li><li><a href="https://github.com/sindresorhus/open">open</a>: 在 nodejs 中打开链接、文件之类的东西</li><li><a href="https://github.com/artiebits/pdf-to-printer">pdf-to-printer</a>: 使用 nodejs 打印 pdf 的函数库</li><li><a href="https://github.com/sindresorhus/os-locale">os-locale</a>: 在 nodejs 获取系统语言</li><li><a href="https://github.com/ajv-validator/ajv">ajv</a>: 前端 json 校验</li><li><a href="https://github.com/steveukx/git-js">simple-git</a>: 操作 git 的 npm 库</li><li><a href="https://github.com/google/diff-match-patch">diff-match-patch</a>: Google 的文本差异对比</li><li><a href="https://github.com/typeorm/typeorm">typeorm</a>: nodejs orm 库，和 nest.js 有着良好的集成</li><li><a href="https://remark.js.org/">remark</a>: markdown 社区及工具集</li><li><a href="https://github.com/puppeteer/puppeteer">puppeteer</a>: 无头浏览器</li></ul><h2 id="有用的资源和社区"><a href="#有用的资源和社区" class="headerlink" title="有用的资源和社区"></a>有用的资源和社区</h2><ul><li><a href="https://react-typescript-cheatsheet.netlify.app/">react+ts 使用指南</a></li><li><a href="https://grid.layoutit.com/">grid 可视化布局生成器</a></li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文档排版指北</a></li><li><a href="https://css-tricks.com/">css 全面指南</a></li><li><a href="https://reactjsexample.com/">react 示例网站</a></li></ul><h2 id="待定"><a href="#待定" class="headerlink" title="待定"></a>待定</h2><ul><li><a href="https://tailwindcss.com/">tailwind.css</a>: 实用且全面的工具库</li><li><a href="https://www.npmjs.com/package/img-clipboard">img-clipboard</a>: 在 nodejs 中复制剪切板中的图像</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么有那么多笔记工具</title>
    <link href="/p/c5bef8ccf92349939dc07daad2acd61c/"/>
    <url>/p/c5bef8ccf92349939dc07daad2acd61c/</url>
    
    <content type="html"><![CDATA[<p>真是疯了，吾辈发现网络上有太多的笔记工具了。</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>吾辈在大约半年前选择开始使用笔记工具，记录自己的日常知识碎片，并最终选择了 <a href="https://joplinapp.org/">Joplin</a>，也花费了许多时间为其编写 <a href="https://github.com/rxliuli/joplin-vscode-plugin">VSCode 插件</a>。就在今天，吾辈在编写插件的一个功能时，需要查看类似插件是如何实现的时候，发现了许多类似的插件存在，甚至包括吾辈想在 VSCode 中管理和编辑笔记的想法也已然有人实现。</p><p>让我们看一下玩家有哪些</p><p>老牌产品</p><ul><li>Evernote</li><li>OneNote</li><li>Apple Notes</li></ul><p>基于 Web/Electron/较新型工具</p><ul><li>Notion</li><li>Joplin</li><li>Roam</li><li>Bear</li><li>Obsidian</li><li>RemNote</li><li>Zettelkasten</li><li>Typora</li><li>marktext</li><li>Standard Notes</li><li>Google Keep</li></ul><p>基于 VSCode</p><ul><li>Foam</li><li>dendron</li></ul><p>国产</p><ul><li>有道云笔记</li><li>语雀</li><li>思源笔记</li></ul><p>还有更多。。。</p><p>吾辈列一下其中几个吾辈已经用过的，横向对比</p><table><thead><tr><th>产品</th><th>Web</th><th>PC 跨平台</th><th>移动端</th><th>数据库/文件</th><th>搜索速度</th><th>VSCode 集成</th><th>Markdown 支持</th><th>支持全量导出</th><th>UI</th></tr></thead><tbody><tr><td>Evernote</td><td>-</td><td>-</td><td>-</td><td>数据库</td><td>快</td><td>否</td><td>不完全</td><td>否</td><td>一般</td></tr><tr><td>OneNote</td><td>是</td><td>是</td><td>是</td><td>数据库</td><td>快</td><td>否</td><td>否</td><td>否</td><td>清新</td></tr><tr><td>Notion</td><td>是</td><td>是</td><td>是</td><td>数据库</td><td>慢</td><td>否</td><td>否</td><td>否</td><td>漂亮</td></tr><tr><td>Joplin</td><td>是</td><td>是</td><td>是</td><td>数据库</td><td>快</td><td>是</td><td>是</td><td>是</td><td>一般</td></tr><tr><td>Typora</td><td>否</td><td>是</td><td>否</td><td>文件</td><td>快</td><td>否</td><td>是</td><td>是</td><td>简洁</td></tr><tr><td>marktext</td><td>否</td><td>是</td><td>否</td><td>文件</td><td>快</td><td>否</td><td>是</td><td>是</td><td>漂亮</td></tr><tr><td>Google Keep</td><td>是</td><td>否</td><td>是</td><td>数据库</td><td>慢</td><td>否</td><td>否</td><td>是</td><td>简洁</td></tr></tbody></table><p>这真的有那么重要么？为什么有这么多的工具，或者说，为什么有这么多的人、这么多的公司愿意花费那么多的时间去编写各种各样的工具，难道最终不是只会出现一个或几个优胜者么？<br>这太糟糕了，吾辈感觉自己在为一件注定失败的事情浪费时间，相比之下更应该等到出现胜者之后再进行选择。</p><p>有人说</p><ul><li>因为需求不一致</li><li>说明这个市场很大</li><li>说明知识焦虑在扩散 终生学习的需求越来越大，不迭代就会被淘汰</li><li>因为笔记软件好多年都没什么大发展了吧，最近一段时间开始风起云涌</li><li>都好多年了吧……如果从 org 开始算，就更久了</li></ul><blockquote><p>在做一件事上，应该只有一个工具是最好的。</p></blockquote><p>吾辈对于笔记的主要关注点</p><ul><li>[x] 基于 Markdown: 不基于任何特定格式的富文本是最容易长期保存的</li><li>[x] 支持全量导出: 任何公司都有可能倒闭，所以全量导出可以容易的迁出</li><li>[x] 编辑器足够好用，最好支持 VSCode 直接编辑: 作为一个程序员实在难以离开强大的编辑器</li><li>[x] 搜索速度要快: 笔记如果无法快速找到，就失去了知识管理的意义</li><li>[ ] 移动端基本查看支持: 有时候可能要在移动端分享一下</li><li>[ ] WebClipper 浏览器插件支持</li><li>[ ] 图片等二进制资源支持</li><li>[ ] 多平台同步支持</li><li>[ ] 基本的 wiki 功能（笔记之间互相引用）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://collegeinfogeek.com/best-note-taking-apps/">The 11 Best Note-Taking Apps in 2020 – Evernote, Notion, and More</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>个人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 gh-pages 发布前端项目</title>
    <link href="/p/32a5980cdf284cf2b107a3ee04ff71f4/"/>
    <url>/p/32a5980cdf284cf2b107a3ee04ff71f4/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://www.npmjs.com/package/gh-pages">gh-pages</a></p></blockquote><p>之前就有在使用 gh-pages 这个库，但由于名字并未想到它如此强大，甚至支持发布代码到任意 git 仓库。换言之，它可以将任意本地文件发布到远端 git 仓库，而不需要自己处理各种乱七八糟的问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先说一下我们之前前后端分离项目的发布流程</p><ol><li> 修改打包的 webpack 脚本以支持引用 cdn 上的资源（本质上是修改路径）</li><li> 打包静态资源文件</li><li> 找到前端静态资源发布项目，切换到指定分支</li><li> 复制静态资源到特定目录</li><li> <code>git commit &amp;&amp; git push</code></li><li> 如果要发布 cdn 则再次对 cdn 仓库同样如此操作</li><li> 通知后端发布生产环境，进行验证</li></ol><p>这其中涉及到几个重要痛点</p><ol><li> 修改 webpack 配置，它极高的复杂度甚至产生了 <a href="https://www.zhihu.com/question/267908710">webpack 配置工程师</a> 这一职业岗位。</li><li> 处理文件复制提交 git 信息，有可能操作错误，每次发布生产都是一次心理上的考验</li><li> 发布失败难以快速解决，重新发布又需要手动再走一遍流程，所以有了我之前说过的发布一次要半个钟的事实</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>不难看出，这本质上还是因为发布没有自动化带来的问题。但是，在 DevOps 还不存在的情况下，gh-pages 能够自动化下面的两步，同时，像 <code>create-react-app/vue-cli</code> 这种基于 webpack 进行高层次封装的工具提供了 <code>PUBLIC_PATH</code> 的概念，能够通过环境变量指定 <code>index.html</code> 入口引用的其他静态资源的基本路径，即便不去碰 webpack 也可以处理第一个问题了。</p><blockquote><p><a href="https://create-react-app.dev/docs/using-the-public-folder/">react</a>, <a href="https://cli.vuejs.org/zh/config/#publicpath">vue</a></p></blockquote><p>大致过程如下</p><ol><li><p> 在项目中添加依赖 <code>yarn add -D env-cmd gh-pages</code></p></li><li><p> 在打包生产环境的资源时指定环境变量 <code>PUBLIC_URL=[cdn 发布后的远端基本路径]</code></p></li><li><p>添加发布 script 命令</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;yarn build:prod &amp;&amp; yarn deploy:cdn &amp;&amp; yarn deploy:publish&quot;</span>,<br>  <span class="hljs-attr">&quot;deploy:publish&quot;</span>: <span class="hljs-string">&quot;gh-pages -d [本地目录] -e [远端 git 目录] -r [远端 git 地址] -b [远端 git 分支]&quot;</span>,<br>  <span class="hljs-attr">&quot;deploy:cdn&quot;</span>: <span class="hljs-string">&quot;gh-pages -d [本地目录] -e [远端 git 目录] -r [远端 git 地址] -b [远端 git 分支]&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，发布生产环境只需要两个步骤</p></li><li><p> 运行 <code>deploy</code> 命令</p></li><li><p> 通知后端发布 cdn/静态资源目录</p></li></ol><p>虽然仍未能解决前后端不分离的项目，但，至少解决了所有新项目的发布问题了，不是么？</p><blockquote><p>这里有一个项目已经如此实现，可以进行参考：<a href="https://git.code.tencent.com/bingli_front/website-static">website-static</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是需要擅用工具，如果能够掌握更好的工具，效率的提高和自己的痛苦程度都能有极大的改善！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 vscode + draw.io 轻松绘制流程图</title>
    <link href="/p/96499825cae64978a6546b036c00a29e/"/>
    <url>/p/96499825cae64978a6546b036c00a29e/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio-insiders-build">vscode 扩展</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h2 id="考察"><a href="#考察" class="headerlink" title="考察"></a>考察</h2><p>事实上吾辈也有做过相当的考察，用过几个知名的流程图工具，但最终选择 vscode-drawio 插件。</p><ul><li><code>plantuml</code>: 复杂</li><li><code>mermaid</code>: 复杂，但通过 js 编写，web 友好</li><li><code>processOn</code>: 付费，不开放</li><li><code>drawio</code>: 开源、免费，可独立部署或集成</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 rollup 打包 react 库</title>
    <link href="/p/fc36d5e7eddc44b3a35c68f52e2b7033/"/>
    <url>/p/fc36d5e7eddc44b3a35c68f52e2b7033/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>其实一般用 tsc 编译一下就行了，但如果想要更加强大的功能，例如打包成一个单文件、多种格式、或者包含 css 时，就需要使用 rollup 来处理了。</p><ul><li>打包</li><li>处理 ts</li><li>处理 css</li><li>压缩</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;pub&quot;</span>: <span class="hljs-string">&quot;yarn build &amp;&amp; lerna bootstrap&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;rollup -c rollup.config.js&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@types/react&quot;</span>: <span class="hljs-string">&quot;^16.9.48&quot;</span>,<br>    <span class="hljs-attr">&quot;moment&quot;</span>: <span class="hljs-string">&quot;^2.27.0&quot;</span>,<br>    <span class="hljs-attr">&quot;rollup&quot;</span>: <span class="hljs-string">&quot;^2.26.9&quot;</span>,<br>    <span class="hljs-attr">&quot;rollup-plugin-babel&quot;</span>: <span class="hljs-string">&quot;^4.4.0&quot;</span>,<br>    <span class="hljs-attr">&quot;rollup-plugin-postcss&quot;</span>: <span class="hljs-string">&quot;^3.1.8&quot;</span>,<br>    <span class="hljs-attr">&quot;rollup-plugin-terser&quot;</span>: <span class="hljs-string">&quot;^7.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;rollup-plugin-typescript2&quot;</span>: <span class="hljs-string">&quot;^0.27.2&quot;</span>,<br>    <span class="hljs-attr">&quot;typescript&quot;</span>: <span class="hljs-string">&quot;3.8.2&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>rollup.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> babel <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-babel&quot;</span>;<br><span class="hljs-keyword">import</span> typescript <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-typescript2&quot;</span>;<br><span class="hljs-keyword">import</span> pkg <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./package.json&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; terser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-terser&quot;</span>;<br><span class="hljs-keyword">import</span> postcss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-postcss&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; resolve &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 入口文件</span><br>  input: resolve(__dirname, <span class="hljs-string">&quot;./src/index.ts&quot;</span>),<br>  output: &#123;<br>    <span class="hljs-comment">// 打包名称</span><br>    name: pkg.name,<br>    <span class="hljs-built_in">exports</span>: <span class="hljs-string">&quot;named&quot;</span>,<br>    file: resolve(__dirname, <span class="hljs-string">&quot;./dist/index.js&quot;</span>),<br>    format: <span class="hljs-string">&quot;es&quot;</span>,<br>  &#125;,<br>  external: [<br>    ...Object.keys(pkg.dependencies || &#123;&#125;),<br>    ...Object.keys(pkg.peerDependencies || &#123;&#125;),<br>  ],<br>  plugins: [<br>    babel(&#123;<br>      exclude: <span class="hljs-string">&quot;node_modules/**&quot;</span>,<br>    &#125;),<br>    typescript(&#123;<br>      typescript: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;typescript&quot;</span>),<br>    &#125;),<br>    postcss(&#123;<br>      sourceMap: <span class="hljs-literal">true</span>,<br>      extract: <span class="hljs-literal">true</span>,<br>      minimize: <span class="hljs-literal">true</span>,<br>    &#125;),<br>    terser(), <span class="hljs-comment">// minifies generated bundles</span><br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 React Context 结合 EventEmitter</title>
    <link href="/p/46a28ca74c22482d832b7d15ea2e1ec3/"/>
    <url>/p/46a28ca74c22482d832b7d15ea2e1ec3/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>EventEmitter 很适合在不修改组件状态结构的情况下进行组件通信，然而它的生命周期不受 react 管理，需要手动添加/清理监听事件很麻烦。而且，如果一个 EventEmitter 没有使用就被初始化也会有点麻烦。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>所以使用 react context 结合 event emitter 的目的便是</p><ul><li>添加高阶组件，通过 react context 为所有子组件注入 em 对象</li><li>添加自定义 hooks，从 react context 获取 emitter 对象，并暴露出合适的函数。</li><li>自动清理 emitter 对象和 emitter listener。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现基本的-EventEmitter"><a href="#实现基本的-EventEmitter" class="headerlink" title="实现基本的 EventEmitter"></a>实现基本的 EventEmitter</h3><p>首先，实现一个基本的 EventEmitter，这里之前吾辈曾经就有 <a href="https://github.com/rxliuli/rx-util/blob/master/src/module/event/EventEmitter.ts">实现过</a>，所以直接拿过来了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> EventType = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> BaseEvents = Record&lt;EventType, <span class="hljs-built_in">any</span>[]&gt;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事件总线</span><br><span class="hljs-comment"> * 实际上就是发布订阅模式的一种简单实现</span><br><span class="hljs-comment"> * 类型定义受到 &#123;<span class="hljs-doctag">@link </span>https://github.com/andywer/typed-emitter/blob/master/index.d.ts&#125; 的启发，不过只需要声明参数就好了，而不需要返回值（应该是 &#123;<span class="hljs-doctag">@code </span>void&#125;）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span>&lt;<span class="hljs-title">Events</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEvents</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> events = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;keyof Events, <span class="hljs-built_in">Function</span>[]&gt;();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加一个事件监听程序</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>type 监听类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>callback 处理回调</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;@code this&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  add&lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;(<span class="hljs-keyword">type</span>: E, <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">...args: Events[E]</span>) =&gt;</span> <span class="hljs-built_in">void</span>) &#123;<br>    <span class="hljs-keyword">const</span> callbacks = <span class="hljs-built_in">this</span>.events.get(<span class="hljs-keyword">type</span>) || [];<br>    callbacks.push(callback);<br>    <span class="hljs-built_in">this</span>.events.set(<span class="hljs-keyword">type</span>, callbacks);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除一个事件监听程序</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>type 监听类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>callback 处理回调</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;@code this&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  remove&lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;(<br>    <span class="hljs-keyword">type</span>: E,<br>    callback: <span class="hljs-function">(<span class="hljs-params">...args: Events[E]</span>) =&gt;</span> <span class="hljs-built_in">void</span><br>  ) &#123;<br>    <span class="hljs-keyword">const</span> callbacks = <span class="hljs-built_in">this</span>.events.get(<span class="hljs-keyword">type</span>) || [];<br>    <span class="hljs-built_in">this</span>.events.set(<br>      <span class="hljs-keyword">type</span>,<br>      callbacks.filter(<span class="hljs-function">(<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>) =&gt;</span> fn !== callback)<br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 移除一类事件监听程序</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>type 监听类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;@code this&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  removeByType&lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;(<span class="hljs-keyword">type</span>: E) &#123;<br>    <span class="hljs-built_in">this</span>.events.delete(<span class="hljs-keyword">type</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 触发一类事件监听程序</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>type 监听类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>args 处理回调需要的参数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;@code this&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  emit&lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;(<span class="hljs-keyword">type</span>: E, ...args: Events[E]) &#123;<br>    <span class="hljs-keyword">const</span> callbacks = <span class="hljs-built_in">this</span>.events.get(<span class="hljs-keyword">type</span>) || [];<br>    callbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>      fn(...args);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取一类事件监听程序</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>type 监听类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns </span>一个只读的数组，如果找不到，则返回空数组 &#123;<span class="hljs-doctag">@code </span>[]&#125;</span><br><span class="hljs-comment">   */</span><br>  listeners&lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;(<span class="hljs-keyword">type</span>: E) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.freeze(<span class="hljs-built_in">this</span>.events.get(<span class="hljs-keyword">type</span>) || []);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合-context-实现一个包裹组件"><a href="#结合-context-实现一个包裹组件" class="headerlink" title="结合 context 实现一个包裹组件"></a>结合 context 实现一个包裹组件</h3><p>包裹组件的目的是为了能直接提供一个包裹组件，以及提供 provider 的默认值，不需要使用者直接接触 emitter 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import * as React from &quot;react&quot;;<br>import &#123; createContext, PropsWithChildren &#125; from &quot;react&quot;;<br>import &#123; BaseEvents, EventEmitter &#125; from &quot;.&#x2F;util&#x2F;EventEmitter&quot;;<br><br>export const EventEmitterContext &#x3D; createContext&lt;EventEmitter&lt;any&gt;&gt;(<br>  null as any<br>);<br><br>export function EventEmitterRC&lt;T extends BaseEvents&gt;(<br>  props: PropsWithChildren&lt;&#123; value: EventEmitter&lt;T&gt; &#125;&gt;<br>) &#123;<br>  return (<br>    &lt;EventEmitterContext.Provider value&#x3D;&#123;props.value&#125;&gt;<br>      &#123;props.children&#125;<br>    &lt;&#x2F;EventEmitterContext.Provider&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-hooks-暴露-emitter-api"><a href="#使用-hooks-暴露-emitter-api" class="headerlink" title="使用 hooks 暴露 emitter api"></a>使用 hooks 暴露 emitter api</h3><p>我们主要需要暴露的 API 只有三个</p><ul><li><code>useListener</code>: 添加监听器，使用 hooks 是为了能在组件卸载时自动清理监听函数</li><li><code>emit</code>: 触发监听器，直接调用即可</li><li><code>emitter</code>: 在当前组件树生效的 emitter 对象</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;<br>  DependencyList,<br>  useCallback,<br>  useContext,<br>  useEffect,<br>  useMemo,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; EventEmitterContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../EventEmitterRC&quot;</span>;<br><span class="hljs-comment">// noinspection ES6PreferShortImport</span><br><span class="hljs-keyword">import</span> &#123; BaseEvents, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/EventEmitter&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEmit</span>&lt;<span class="hljs-title">Events</span> <span class="hljs-title">extends</span> <span class="hljs-title">BaseEvents</span>&gt;(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> em = useContext(EventEmitterContext);<br>  <span class="hljs-keyword">return</span> useCallback(<br>    &lt;E <span class="hljs-keyword">extends</span> keyof Events&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">type</span>: E, ...args: Events[E]</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;emitter emit: &quot;</span>, <span class="hljs-keyword">type</span>, args);<br>      em.emit(<span class="hljs-keyword">type</span>, ...args);<br>    &#125;,<br>    [em]<br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEventEmitter</span>&lt;<span class="hljs-title">Events</span> <span class="hljs-title">extends</span> <span class="hljs-title">BaseEvents</span>&gt;(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> emit = useEmit&lt;Events&gt;();<br>  <span class="hljs-comment">// 这里使用 useMemo 产生的 emitter 对象的原因是在当前组件树 emitter 仅初始化一次</span><br>  <span class="hljs-keyword">const</span> emitter = useMemo(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> EventEmitter&lt;Events&gt;(), []);<br>  <span class="hljs-keyword">return</span> &#123;<br>    useListener: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">E</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">keyof</span> <span class="hljs-attr">Events</span>&gt;</span>(</span><br><span class="xml">      type: E,</span><br><span class="xml">      listener: (...args: Events[E]) =&gt; void,</span><br><span class="xml">      deps: DependencyList = []</span><br><span class="xml">    ) =&gt; &#123;</span><br><span class="xml">      const em = useContext(EventEmitterContext);</span><br><span class="xml">      useEffect(() =&gt; &#123;</span><br><span class="xml">        console.log(&quot;emitter add: &quot;, type, listener.name);</span><br><span class="xml">        em.add(type, listener);</span><br><span class="xml">        return () =&gt; &#123;</span><br><span class="xml">          console.log(&quot;emitter remove: &quot;, type, listener.name);</span><br><span class="xml">          em.remove(type, listener);</span><br><span class="xml">        &#125;;</span><br><span class="xml">        // eslint-disable-next-line react-hooks/exhaustive-deps</span><br><span class="xml">      &#125;, [listener, type, ...deps]);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    emit,</span><br><span class="xml">    emitter,</span><br><span class="xml">  &#125;;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来非常简单，在需要使用的 emitter hooks 的组件外部包裹一个 <code>EventEmitterRC</code> 组件，然后就可以使用 <code>useEventEmitter</code> 了。</p><p>下面是一个简单的 Todo 示例，使用 emitter 实现了 todo 表单 与 todo 列表之间的通信。</p><p>目录结构如下</p><ul><li><code>todo</code><ul><li><code>component</code><ul><li><code>TodoForm.tsx</code></li><li><code>TodoList.tsx</code></li></ul></li><li><code>modal</code><ul><li><code>TodoEntity.ts</code></li><li><code>TodoEvents.ts</code></li></ul></li><li><code>Todo.tsx</code></li></ul></li></ul><p>Todo 父组件，使用 <code>EventEmitterRC</code> 包裹子组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const Todo: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;<br>  const &#123; emitter &#125; &#x3D; useEventEmitter();<br>  return (<br>    &lt;EventEmitterRC value&#x3D;&#123;emitter&#125;&gt;<br>      &lt;TodoForm &#x2F;&gt;<br>      &lt;TodoList &#x2F;&gt;<br>    &lt;&#x2F;EventEmitterRC&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>在表单组件中使用 <code>useEventEmitter</code> hooks 获得 <code>emit</code> 方法，然后在添加 todo 时触发它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const TodoForm: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;<br>  const &#123; emit &#125; &#x3D; useEventEmitter&lt;TodoEvents&gt;();<br><br>  const [title, setTitle] &#x3D; useState(&quot;&quot;);<br><br>  function handleAddTodo(e: FormEvent&lt;HTMLFormElement&gt;) &#123;<br>    e.preventDefault();<br>    emit(&quot;addTodo&quot;, &#123;<br>      title,<br>    &#125;);<br>    setTitle(&quot;&quot;);<br>  &#125;<br><br>  return (<br>    &lt;form onSubmit&#x3D;&#123;handleAddTodo&#125;&gt;<br>      &lt;div&gt;<br>        &lt;label htmlFor&#x3D;&#123;&quot;title&quot;&#125;&gt;标题：&lt;&#x2F;label&gt;<br>        &lt;input<br>          value&#x3D;&#123;title&#125;<br>          onChange&#x3D;&#123;(e) &#x3D;&gt; setTitle(e.target.value)&#125;<br>          id&#x3D;&#123;&quot;title&quot;&#125;<br>        &#x2F;&gt;<br>        &lt;button type&#x3D;&#123;&quot;submit&quot;&#125;&gt;添加&lt;&#x2F;button&gt;<br>      &lt;&#x2F;div&gt;<br>    &lt;&#x2F;form&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>在列表组件中使用 <code>useEventEmitter</code> hooks 获得 <code>useListener</code> hooks，然后监听添加 todo 的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const TodoList: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;<br>  const [list, setList] &#x3D; useState&lt;TodoEntity[]&gt;([]);<br>  const &#123; useListener &#125; &#x3D; useEventEmitter&lt;TodoEvents&gt;();<br>  useListener(<br>    &quot;addTodo&quot;,<br>    (todo) &#x3D;&gt; &#123;<br>      setList([...list, todo]);<br>    &#125;,<br>    [list]<br>  );<br>  const em &#x3D; &#123; useListener &#125;;<br>  useEffect(() &#x3D;&gt; &#123;<br>    console.log(&quot;em: &quot;, em);<br>  &#125;, [em]);<br>  return (<br>    &lt;ul&gt;<br>      &#123;list.map((todo, i) &#x3D;&gt; (<br>        &lt;li key&#x3D;&#123;i&#125;&gt;&#123;todo.title&#125;&lt;&#x2F;li&gt;<br>      ))&#125;<br>    &lt;&#x2F;ul&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一些 TypeScript 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TodoEntity &#123;<br>  title: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; BaseEvents &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../components/emitter&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; TodoEntity &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TodoEntity&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TodoEvents <span class="hljs-keyword">extends</span> BaseEvents &#123;<br>  addTodo: [entity: TodoEntity];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://medium.com/@dominikdosoudil/building-event-emitter-using-react-hooks-650f94a057ea">Building event emitter using react hooks</a></li><li><a href="https://nodejs.org/api/events.html">NodeJS EventEmitter API</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于前端组件通信的一些理解</title>
    <link href="/p/a4ea45dd6ba445e1b307ef4e1fd3233e/"/>
    <url>/p/a4ea45dd6ba445e1b307ef4e1fd3233e/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>吾辈同时是 vue/react 的使用者。</p></blockquote><p>在使用现代前端框架时，我们经常要要面对的问题之一就是组件之间的通信，目前我们有着很多选择，包括但不限于以下这些。</p><ul><li><code>Super Component Props</code>: 将状态或操作放在父组件，然后传递到子组件。该特性在 vue/react 都存在</li><li><code>Context/Provider Pattern</code>: 将状态放在父组件，然后所有的子组件都可以获取到。例如 react 中的 context 或 vue 中的 <code>provide/inject</code></li><li><code>Global State</code>: 全局状态管理器。包含 redux/vuex/mobx/xstate 等一系列状态管理器。</li><li><code>EventEmitter</code>: 全局事件触发器。包含 nodejs 和一些第三方实现。</li></ul><p>然而，有了如此多的解决方案，到底该在那些场景下使用那些解决方案呢？</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首先，我们将以上组件通信的解决方案分为两类</p><table><thead><tr><th>解决方案</th><th>是否在 react 生命周期中</th></tr></thead><tbody><tr><td><code>Super Component Props</code></td><td>√</td></tr><tr><td><code>Context/Provider Pattern</code></td><td>√</td></tr><tr><td><code>Global Store</code></td><td>×</td></tr><tr><td><code>EventEmitter</code></td><td>×</td></tr></tbody></table><p>选择树</p><pre><code class=" mermaid">graph LR;start[开始选择]isSimpleProps&#123;是否为简单的父子组件&#125;isComponentInnerUse&#123;是否仅在组件内部使用&#125;isUseNotice&#123;是否只需要通知而非状态共享&#125;favoriteStyle&#123;喜欢的风格&#125;start --&gt; isSimplePropsisSimpleProps --&gt; |是| propsisSimpleProps --&gt; |否| isComponentInnerUseisComponentInnerUse --&gt; |是| context&#x2F;providerisComponentInnerUse --&gt; |否| isUseNoticeisUseNotice --&gt; |是| emitterisUseNotice --&gt; |否| favoriteStylefavoriteStyle --&gt; |可变| mobx_跨框架favoriteStyle --&gt; |flux不可变| redux&#x2F;vuexfavoriteStyle --&gt; |状态机| xstate_跨框架</code></pre><h3 id="Super-Component-Props"><a href="#Super-Component-Props" class="headerlink" title="Super Component Props"></a><code>Super Component Props</code></h3><blockquote><p>适合简单的父子组件通信。参考: <a href="https://zh-hans.reactjs.org/docs/components-and-props.html">组件 &amp; Props</a></p></blockquote><p>为什么 <code>props</code> 适合简单的父子通信呢？因为 <code>props</code> 是框架中基础的父子组件通信方式，模板代码也是最少的。</p><p>下面是一个简单的示例：将一个组件内输入框的值渲染到另一个组件中。</p><p><img src="https://img.rxliuli.com/20200818203510.png" alt="最终效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const Hello: React.FC&lt;&#123; name: string &#125;&gt; &#x3D; (props) &#x3D;&gt; &#123;<br>  return (<br>    &lt;section&gt;<br>      &lt;h3&gt;hello &#123;props.name&#125;&lt;&#x2F;h3&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;;<br><br>const InputName: React.FC&lt;<br>  Pick&lt;InputHTMLAttributes&lt;HTMLInputElement&gt;, &quot;value&quot; | &quot;onChange&quot;&gt;<br>&gt; &#x3D; (props) &#x3D;&gt; &#123;<br>  return &lt;input &#123;...props&#125; &#x2F;&gt;;<br>&#125;;<br><br>const App &#x3D; () &#x3D;&gt; &#123;<br>  const [name, setName] &#x3D; useState(&quot;&quot;);<br>  return (<br>    &lt;div&gt;<br>      &lt;InputName value&#x3D;&#123;name&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; setName(e.target.value)&#125; &#x2F;&gt;<br>      &lt;Hello name&#x3D;&#123;name&#125; &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>如题，对于这种简单的父子组件传值，使用 props 是最简单合适的。</p><p>下面演示使用其他几种方式的实现</p><hr><p>使用 context</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const HelloContext &#x3D; React.createContext&lt;&#123;<br>  name: string;<br>  setName: (name: string) &#x3D;&gt; void;<br>&#125;&gt;(&#123;<br>  name: &quot;&quot;,<br>  setName: () &#x3D;&gt; &#123;&#125;,<br>&#125;);<br><br>const Hello: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; 模板代码<br>  const context &#x3D; useContext(HelloContext);<br>  return (<br>    &lt;section&gt;<br>      &lt;h3&gt;hello &#123;context.name&#125;&lt;&#x2F;h3&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;;<br><br>const InputName: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; 模板代码<br>  const context &#x3D; useContext(HelloContext);<br>  return (<br>    &lt;input<br>      name&#x3D;&#123;context.name&#125;<br>      onChange&#x3D;&#123;(e) &#x3D;&gt; context.setName(e.target.value)&#125;<br>    &#x2F;&gt;<br>  );<br>&#125;;<br><br>const App &#x3D; () &#x3D;&gt; &#123;<br>  const [name, setName] &#x3D; useState(&quot;&quot;);<br>  return (<br>    &lt;HelloContext.Provider value&#x3D;&#123;&#123; name, setName &#125;&#125;&gt;<br>      &lt;InputName &#x2F;&gt;<br>      &lt;Hello &#x2F;&gt;<br>    &lt;&#x2F;HelloContext.Provider&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，加的 context 能被深层子组件读取的优势并未体现出来，反而多了一些模板代码。</p><hr><p>使用 global state，此处使用 mobx 进行演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#x2F;&#x2F; 模板代码<br>class HelloStore &#123;<br>  @observable<br>  name &#x3D; &quot;&quot;;<br>  @action<br>  setName(name: string) &#123;<br>    this.name &#x3D; name;<br>  &#125;<br>&#125;<br><br>const helloStore &#x3D; new HelloStore();<br><br>const Hello: React.FC &#x3D; observer(() &#x3D;&gt; &#123;<br>  return (<br>    &lt;section&gt;<br>      &lt;h3&gt;hello &#123;helloStore.name&#125;&lt;&#x2F;h3&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;);<br><br>const InputName: React.FC &#x3D; observer(() &#x3D;&gt; &#123;<br>  return (<br>    &lt;input<br>      name&#x3D;&#123;helloStore.name&#125;<br>      onChange&#x3D;&#123;(e) &#x3D;&gt; helloStore.setName(e.target.value)&#125;<br>    &#x2F;&gt;<br>  );<br>&#125;);<br><br>const App &#x3D; () &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; 模板代码<br>  useMount(() &#x3D;&gt; &#123;<br>    helloStore.setName(&quot;&quot;);<br>  &#125;);<br>  return (<br>    &lt;div&gt;<br>      &lt;InputName &#x2F;&gt;<br>      &lt;Hello &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，store 是全局可用的，但也需要在相应组件内做初始化动作，而非像 props/context 那样受组件生命周期控制，自动的初始化和销毁状态。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const em &#x3D; new EventEmitter&lt;&#123;<br>  update: [string];<br>&#125;&gt;();<br><br>const Hello: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; 模板代码<br>  const [name, setName] &#x3D; useState(&quot;&quot;);<br>  &#x2F;&#x2F; 模板代码<br>  useEffectOnce(() &#x3D;&gt; &#123;<br>    em.add(&quot;update&quot;, setName);<br>    return () &#x3D;&gt; &#123;<br>      em.remove(&quot;update&quot;, setName);<br>    &#125;;<br>  &#125;);<br>  return (<br>    &lt;section&gt;<br>      &lt;h3&gt;hello &#123;name&#125;&lt;&#x2F;h3&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;;<br><br>const InputName: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; 模板代码<br>  const [name, setName] &#x3D; useState(&quot;&quot;);<br>  function handleChange(e: ChangeEvent&lt;HTMLInputElement&gt;) &#123;<br>    const value &#x3D; e.target.value;<br>    setName(value);<br>    &#x2F;&#x2F; 模板代码<br>    em.emit(&quot;update&quot;, value);<br>  &#125;<br>  return &lt;input name&#x3D;&#123;name&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;;<br>&#125;;<br><br>const App &#x3D; () &#x3D;&gt; &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;InputName &#x2F;&gt;<br>      &lt;Hello &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，emitter 可以在不改变原有组件(<code>InputName</code>)的情况下在新的组件添加相关的逻辑，但确实会多一些模板代码，且需要维护两次状态。</p><h3 id="Context-Provider-Pattern"><a href="#Context-Provider-Pattern" class="headerlink" title="Context/Provider Pattern"></a><code>Context/Provider Pattern</code></h3><blockquote><p>适合深层的父组件共享状态给多个子组件，有时候会结合 <code>EventEmitter</code> 一起使用。</p></blockquote><p>为什么我们有了 props，甚至有了更强大的 <code>render props</code>（vue 中被称为 <code>slot</code>），却还是需要 context 呢？</p><p>考虑以下场景，我们想要为一颗组件树的所有组件添加一些全局特性，例如 <code>theme</code>、<code>local</code>、<code>全局配色</code>，而你使用这些状态的组件又分散在各个地方时，便可以考虑使用 context。相比于全局状态，context 仅与框架而非状态管理库绑定，这对于第三方库（尤其是 UI 组件库）是大有益处的，例如 <a href="https://github.com/react-component/field-form">rc-field-form</a> 和 <a href="https://github.com/ReactTraining/react-router">react-router</a> 均有如此实现。理论上，当我们需要状态共享但 props 又不需要在组件外操作状态时，就应该首先选择 context。</p><p>下面是一个简单的示例来说明使用 context 实现全局的 theme 控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tsx">type ThemeContextType &#x3D; &#123;<br>  color: &quot;light&quot; | &quot;black&quot;;<br>&#125;;<br>const ThemeContext &#x3D; React.createContext&lt;ThemeContextType&gt;(&#123;<br>  color: &quot;light&quot;,<br>&#125;);<br>const Theme &#x3D; ThemeContext.Provider;<br><br>const Button: React.FC &#x3D; (props) &#x3D;&gt; &#123;<br>  const context &#x3D; useContext(ThemeContext);<br>  return (<br>    &lt;button className&#x3D;&#123;context.color !&#x3D;&#x3D; &quot;black&quot; ? &quot;light&quot; : &quot;black&quot;&#125;&gt;<br>      &#123;props.children&#125;<br>    &lt;&#x2F;button&gt;<br>  );<br>&#125;;<br>const Tag: React.FC &#x3D; (props) &#x3D;&gt; &#123;<br>  const context &#x3D; useContext(ThemeContext);<br>  return (<br>    &lt;span className&#x3D;&#123;context.color !&#x3D;&#x3D; &quot;black&quot; ? &quot;light&quot; : &quot;black&quot;&#125;&gt;<br>      &#123;props.children&#125;<br>    &lt;&#x2F;span&gt;<br>  );<br>&#125;;<br>const App &#x3D; () &#x3D;&gt; &#123;<br>  return (<br>    &lt;Theme value&#x3D;&#123;&#123; color: &quot;black&quot; &#125;&#125;&gt;<br>      &lt;Button&gt;按钮&lt;&#x2F;Button&gt;<br>      &lt;Tag&gt;标签&lt;&#x2F;Tag&gt;<br>    &lt;&#x2F;Theme&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题</p><ul><li>仅限于同一个父组件树下的两个子组件共享状态，当然你也可以说所有的组件都只有<strong>单根</strong>。</li><li>无法在组件外部使用，这点是致命的，例如路由 <code>history</code> 对象弹窗无法在逻辑层使用是不可接受的（需要在请求接口报 404 时跳转登录页面）。</li><li>使用时的模板代码要稍微更多一点，相比与 mobx 的话。</li></ul><h3 id="Global-Store"><a href="#Global-Store" class="headerlink" title="Global Store"></a><code>Global Store</code></h3><blockquote><p>适合在组件树上相隔较远的组件/组件外共享状态和逻辑使用。</p></blockquote><p>那么，继续来看以下场景，当我们需要在多个组件/组件外共享状态时，例如当前登录的用户信息，便应该优先考虑使用状态管理器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs tsx">interface UserInfo &#123;<br>  id: string;<br>  username: string;<br>  nickname: string;<br>&#125;<br>class UserStore &#123;<br>  @observable<br>  userInfo?: UserInfo;<br>  refresh(userInfo: UserInfo) &#123;<br>    this.userInfo &#x3D; userInfo;<br>  &#125;<br>&#125;<br><br>const userStore &#x3D; new UserStore();<br><br>async function post&lt;T&gt;(url: string, data: object) &#123;<br>  const response &#x3D; await fetch(url, &#123;<br>    method: &quot;post&quot;,<br>    headers: &#123;<br>      &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,<br>    &#125;,<br>    body: JSON.stringify(&#123;<br>      client: &#123;<br>        &#x2F;&#x2F;在组件外使用用户信息<br>        uid: userStore.userInfo?.id,<br>      &#125;,<br>      data: data,<br>    &#125;),<br>  &#125;);<br>  return (await response.json()) as T;<br>&#125;<br><br>type UserInfoForm &#x3D; &#123; username: string; password: string &#125;;<br>const Login: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  const [form, dispatchForm] &#x3D; useReducer&lt;<br>    Reducer&lt;UserInfoForm, &#123; name: keyof UserInfoForm; value: string &#125;&gt;<br>  &gt;(<br>    (state, action) &#x3D;&gt; &#123;<br>      return &#123;<br>        ...state,<br>        [action.name]: action.value,<br>      &#125;;<br>    &#125;,<br>    &#123; username: &quot;&quot;, password: &quot;&quot; &#125;<br>  );<br>  async function handleSubmit(e: FormEvent&lt;HTMLFormElement&gt;) &#123;<br>    e.preventDefault();<br>    console.log(&quot;handleSubmit: &quot;, form);<br>    &#x2F;&#x2F;登录时刷新用户信息<br>    const userInfo &#x3D; await post&lt;UserInfo&gt;(&quot;&#x2F;login&quot;, form);<br>    userStore.refresh(userInfo);<br>  &#125;<br>  return (<br>    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;<br>      &lt;div&gt;<br>        &lt;label htmlFor&#x3D;&#123;&quot;username&quot;&#125;&gt;用户名：&lt;&#x2F;label&gt;<br>        &lt;input<br>          name&#x3D;&#123;&quot;username&quot;&#125;<br>          value&#x3D;&#123;form.username&#125;<br>          onChange&#x3D;&#123;(e) &#x3D;&gt;<br>            dispatchForm(&#123;<br>              name: &quot;username&quot;,<br>              value: e.target.value,<br>            &#125;)<br>          &#125;<br>        &#x2F;&gt;<br>      &lt;&#x2F;div&gt;<br>      &lt;div&gt;<br>        &lt;label htmlFor&#x3D;&#123;&quot;password&quot;&#125;&gt;密码：&lt;&#x2F;label&gt;<br>        &lt;input<br>          name&#x3D;&#123;&quot;password&quot;&#125;<br>          type&#x3D;&#123;&quot;password&quot;&#125;<br>          value&#x3D;&#123;form.password&#125;<br>          onChange&#x3D;&#123;(e) &#x3D;&gt;<br>            dispatchForm(&#123;<br>              name: &quot;password&quot;,<br>              value: e.target.value,<br>            &#125;)<br>          &#125;<br>        &#x2F;&gt;<br>      &lt;&#x2F;div&gt;<br>      &lt;div&gt;<br>        &lt;button type&#x3D;&#123;&quot;submit&quot;&#125;&gt;提交&lt;&#x2F;button&gt;<br>      &lt;&#x2F;div&gt;<br>    &lt;&#x2F;form&gt;<br>  );<br>&#125;;<br>const App &#x3D; observer(() &#x3D;&gt; &#123;<br>  return (<br>    &lt;div&gt;<br>      &#123;&#x2F;*在组件中使用 store 的值*&#x2F;&#125;<br>      &lt;header&gt;&#123;userStore.userInfo?.nickname&#125;&lt;&#x2F;header&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>问题</p><ul><li>需要自己管理状态的初始化与清理，不跟随组件的生命周期进行变化。</li><li>全局状态是混乱的根源，过度使用害人害己</li><li>无论何时都存在，占用额外的内存资源</li></ul><h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a><code>EventEmitter</code></h3><blockquote><p>适合用于逻辑层的状态通信或是组件之间的监听/通知操作，不修改组件状态存储的结构，无法复用状态。</p></blockquote><p>在不想改变组件状态/操作的代码结构而仅仅只是想要简单的通信时，EventEmitter 是一种合适的方式。设想以下场景，当你已经写完了一个复杂的组件，而突然 UI/UX 又在另一个相隔很远的地方添加了另一个相关的组件并且需要通信时，在你不想对原组件大刀阔斧的改动时，那么 EventEmitter 是一个合适的选择。</p><p>例如下面这段代码，假设你已经写完了复杂的 MainContent 组件（当然下面代码中的 MainContent 并不算复杂），但后来需求变化，想在 Header 组件中添加一个刷新按钮，而不希望变更代码状态结构的时候，便可以尝试使用 EventEmitter 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#x2F;**<br> * 随机数生成器（从 0 开始，不包含最大值）<br> * 线性同余生成器<br> * @link 网上常能见到的一段 JS 随机数生成算法如下，为什么用 9301, 49297, 233280 这三个数字做基数？ - 猫杀的回答 - 知乎<br> https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;22818104&#x2F;answer&#x2F;22744803<br> *&#x2F;<br>export const rand &#x3D; (function () &#123;<br>  let seed &#x3D; Date.now();<br>  function rnd() &#123;<br>    seed &#x3D; (seed * 9301 + 49297) % 233280.0;<br>    return seed &#x2F; 233280.0;<br>  &#125;<br>  return function rand(num: number) &#123;<br>    return Math.floor(rnd() * num);<br>  &#125;;<br>&#125;)();<br><br>const Header: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  return (<br>    &lt;header&gt;<br>      &lt;h2&gt;标题&lt;&#x2F;h2&gt;<br>    &lt;&#x2F;header&gt;<br>  );<br>&#125;;<br>const MainContent: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  const [list, setList] &#x3D; useState&lt;number[]&gt;([]);<br>  function load() &#123;<br>    setList(<br>      Array(10)<br>        .fill(0)<br>        .map(() &#x3D;&gt; rand(100))<br>    );<br>  &#125;<br>  useMount(() &#x3D;&gt; &#123;<br>    load();<br>  &#125;);<br>  return (<br>    &lt;section&gt;<br>      &lt;ul&gt;<br>        &#123;list.map((i) &#x3D;&gt; (<br>          &lt;li key&#x3D;&#123;i&#125;&gt;&#123;i&#125;&lt;&#x2F;li&gt;<br>        ))&#125;<br>      &lt;&#x2F;ul&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;;<br>const App &#x3D; () &#x3D;&gt; &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;Header &#x2F;&gt;<br>      &lt;MainContent &#x2F;&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 EventEmitter 进行通知，其中的 useEventEmitter hooks 来源于 <a href="https://blog.rxliuli.com/p/4358e813/">使用 React Hooks 结合 EventEmitter</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs tsx">type RefreshEmitterType &#x3D; &#123; refresh: [] &#125;;<br>const Header: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  const &#123; emit &#125; &#x3D; useEventEmitter&lt;RefreshEmitterType&gt;();<br>  return (<br>    &lt;header&gt;<br>      &lt;h2&gt;标题&lt;&#x2F;h2&gt;<br>      &#123;&#x2F;*不同，添加触发操作*&#x2F;&#125;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; emit(&quot;refresh&quot;)&#125;&gt;刷新&lt;&#x2F;button&gt;<br>    &lt;&#x2F;header&gt;<br>  );<br>&#125;;<br>const MainContent: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  const [list, setList] &#x3D; useState&lt;number[]&gt;([]);<br>  const load &#x3D; useCallback(() &#x3D;&gt; &#123;<br>    setList(<br>      Array(10)<br>        .fill(0)<br>        .map(() &#x3D;&gt; rand(100))<br>    );<br>  &#125;, []);<br>  useMount(load);<br>  &#x2F;&#x2F;不同，添加监听<br>  const &#123; useListener &#125; &#x3D; useEventEmitter&lt;RefreshEmitterType&gt;();<br>  useListener(&quot;refresh&quot;, load);<br>  return (<br>    &lt;section&gt;<br>      &lt;ul&gt;<br>        &#123;list.map((v, i) &#x3D;&gt; (<br>          &lt;li key&#x3D;&#123;i&#125;&gt;&#123;v&#125;&lt;&#x2F;li&gt;<br>        ))&#125;<br>      &lt;&#x2F;ul&gt;<br>    &lt;&#x2F;section&gt;<br>  );<br>&#125;;<br>const App &#x3D; () &#x3D;&gt; &#123;<br>  return (<br>    &#x2F;&#x2F;不同<br>    &lt;EventEmitterRC&gt;<br>      &lt;Header &#x2F;&gt;<br>      &lt;MainContent &#x2F;&gt;<br>    &lt;&#x2F;EventEmitterRC&gt;<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题</p><ul><li>需要自己管理事件的注册和清理，不跟随特定组件的生命周期变化。</li><li>无论何时都存在，占用额外的内存资源（但相比于全局状态占用的仍然是非常低的）</li><li>使用不当可能导致多个组件由重复的状态</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一种解决方案的劣势可能是另一种方案的优势，总是要选择合适的方案才是最好的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React 根据状态动态化功能的一些思考</title>
    <link href="/p/d55f430907ed4972be823c4979b67fb7/"/>
    <url>/p/d55f430907ed4972be823c4979b67fb7/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>之前吾辈也在 SF 上询问过 <a href="https://segmentfault.com/q/1010000021851252">类似的问题</a>。</p></blockquote><p>目前在实际业务中遇到了两种情况</p><ol><li>程序的功能在分发给不同组织使用的时候有所差异，即不同的组织都会存在一些定制化的功能。<br> 最常见的差异例如<ul><li>表单的字段存在差异</li><li>列表展示的字段与相关操作有所不同</li></ul></li><li>组件内的代码在某个权限下才会执行，但是又依赖于组件内的一些状态，如何将这些代码分割到不同的地方（例如不同的文件）便于之后的维护。<ul><li>一些按钮在指定权限下存在</li><li>一些数据在指定权限下展示</li></ul></li></ol><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>使用动态配置渲染不同的页面(可序列化的配置)</li><li>根据状态匹配不同的动态组件</li><li>使用 hooks 封装不同的逻辑</li><li>使用状态图控制状态和逻辑</li></ul><h2 id="实际调研结果"><a href="#实际调研结果" class="headerlink" title="实际调研结果"></a>实际调研结果</h2><h3 id="使用动态配置渲染不同的页面"><a href="#使用动态配置渲染不同的页面" class="headerlink" title="使用动态配置渲染不同的页面"></a>使用动态配置渲染不同的页面</h3><p>实际上，之前有看过吾辈写的 <a href="/p/9b07ff8ce6dd4eb08896f6b8191d7181">react 通用列表组件封装</a> 就知道，实际上列表已经被配置化了，可以使用配置的形式去渲染一个完整的列表页面，因此可以根据不同的组织使用不同的配置就好了。但是，事实上并没有这么简单，因为就算是简单的列表，也仍然包含<strong>上下文</strong>，而这，正是配置不能拿到的内容。</p><p>上下文主要包括</p><ul><li>需要异步请求的数据，例如下拉框的选择项</li><li>需要从路由上获取的数据，例如搜索条件</li><li>需要对页面内的其它组件进行操作时，例如点击按钮有个新增列表项的弹窗</li></ul><p>可以有几种解决方案</p><ul><li>通过函数，而不是单纯的配置，这样，可以通过参数解决一些上下文的依赖情况</li><li>通过函数且异步，可以解决 api 请求时，此时的 api 必定是可以用的，但是会依赖于 api。</li></ul><p>但这仍然会带来问题</p><ul><li>数据不再纯粹，无法序列化。</li><li>不同配置依赖的数据可能不同，需要配置自己去解决，那么如果这样想的话，那么配置就需要自行获取数据，而不是外部传递数据了</li><li>仍然无法使用<strong>状态</strong></li><li>最重要的是，使用函数之后变得不再像是<strong>配置</strong>了</li></ul><h3 id="根据状态匹配不同的动态组件"><a href="#根据状态匹配不同的动态组件" class="headerlink" title="根据状态匹配不同的动态组件"></a>根据状态匹配不同的动态组件</h3><ul><li>配置更为灵活，能够获取到组件的上下文</li><li>接口请求也没有问题</li><li>对不同配置，可以自行对数据进行处理</li></ul><p>问题</p><ul><li>无法如同纯数据配置那样，复用逻辑这么彻底，但是也可以通过 hooks 解决。</li><li>UI 复用问题<br>先使用组件的方式编写一下，看具体结果如何</li><li>无法序列化也意味着无法放到后端，甚至意味着很难做动态加载</li></ul><p>使用</p><ul><li>使用一个 wrapper 组件来讲 UI 和通用逻辑给包裹进去</li><li>使用另外一套组件去区分不同租户的配置（因为是在组件内部写配置，所以该配置可以灵活的使用任意接口，组件上下文可能还不太行）也就是用多个组件来解决这个问题。</li></ul><p>可以再尝试一下有没有解决方案。</p><h3 id="使用-hooks-封装不同的代码"><a href="#使用-hooks-封装不同的代码" class="headerlink" title="使用 hooks 封装不同的代码"></a>使用 hooks 封装不同的代码</h3><ul><li>相比于处理 <strong>是哪一个</strong>，更适合处理 <strong>有或没有</strong> 的代码分割</li><li>能够使用 react 的状态</li></ul><p>问题</p><ul><li>使用 hooks 必须放在函数组件最顶层，导致本质上无法 <code>lazy</code> 加载。参考：<a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 规则</a></li><li>使用 hooks 同样难以序列化存储到后端</li></ul><h3 id="使用状态图控制状态和逻辑"><a href="#使用状态图控制状态和逻辑" class="headerlink" title="使用状态图控制状态和逻辑"></a>使用状态图控制状态和逻辑</h3><p>使用 hooks 封装代码最适合处理元素级的权限控制，但在面对需要根据多个维度的状态决定程序的状态或行为时，就有点力不从心了。而这，也是为什么有限状态机为什么有用的原因。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最终，我们选择了最灵活的 <strong>动态组件 + Hooks 共享逻辑</strong> 的形式，虽然使用动态组件会增加一些冗余度，但也可以通过子组件或 hooks 的形式复用逻辑，实际上在工程化减小的复杂度的收益是要高于代码冗余的。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><blockquote><p>登记相关内容已经使用该方式进行了重构</p></blockquote><ul><li><code>src/pages/register</code><ul><li><code>common</code>: 通用的一些组件和逻辑，例如请求后台接口应该是统一的，但返回的数据类型却应该是单独的<ul><li><code>form</code>: 表单相关组件，提供给列表/详情页面使用</li><li><code>detail</code>: 详情页面</li><li><code>list</code>: 列表页面</li></ul></li><li><code>organizations</code>: 不同组织的目录<ul><li><code>org1</code>: 组织 1</li><li><code>org2</code>: 组织 2</li></ul></li></ul></li></ul><p>吾辈编写了一个简单的示例，代码在 <a href="https://github.com/rxliuli/example/tree/master/dynamic_state">dynamic_state</a></p><p><img src="https://img.rxliuli.com/20200803203027.png" alt="简单示例"></p><h2 id="其他技术问题"><a href="#其他技术问题" class="headerlink" title="其他技术问题"></a>其他技术问题</h2><ul><li>[x] 如何在运行时根据组织切换功能<ul><li>可以再包一层组件而非简单的从 <code>lazy component map</code> 取出组件</li></ul></li><li>[x] 如何在运行时添加新组织的功能<ul><li>可能需要插件的实现方式，支持动态加载进来，例如 vscode 的插件体系。</li></ul></li><li>[x] 如何使用 hooks 更好的复用逻辑<ul><li>使用 hooks 封装逻辑，使用小型组件封装 UI/UX</li></ul></li><li>[x] 如何在打包阶段干掉不相关组织的代码<ul><li>需要修改 webpack 相关的内容，目前不予考虑</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异步并发调用</title>
    <link href="/p/c3b0b2b4e98e4e31959fdf1fef1af678/"/>
    <url>/p/c3b0b2b4e98e4e31959fdf1fef1af678/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你觉得下面这段代码会怎么打印？这里使用异步模拟了 10 个 thread，然后从 generator 里面迭代取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">sec</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(res, sec * <span class="hljs-number">1000</span>);<br>  &#125;);<br><span class="hljs-keyword">const</span> group = <span class="hljs-function">(<span class="hljs-params">arr, kFn</span>) =&gt;</span><br>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> i = kFn(item);<br>    res[i] = (res[i] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;, &#123;&#125;);<br><br><span class="hljs-keyword">const</span> fibGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">yield</span> a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> fibIterator = fibGenerator(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 开十个 thread</span><br><span class="hljs-keyword">const</span> idxArr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)<br>  .fill(<span class="hljs-number">0</span>)<br>  .map(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);<br><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-built_in">Promise</span>.all(<br>  idxArr.map(<span class="hljs-keyword">async</span> (i) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> fibIterator) &#123;<br>      arr.push([i, num]);<br>      <span class="hljs-comment">// 如果改成 await sleep(0) 呢？</span><br>      <span class="hljs-keyword">await</span> sleep(<span class="hljs-built_in">Math</span>.random());<br>    &#125;<br>  &#125;)<br>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<br>    arr.length,<br>    arr,<br>    group(arr, <span class="hljs-function">(<span class="hljs-params">[i]</span>) =&gt;</span> i)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>主要考察并发异步和迭代器的知识</p><p>修改前</p><ul><li>100 个，因为 generator 只能迭代 100 次</li><li>没什么规律的数组，因为队列在第一次之后追加的 idx 顺序是不确定的，会是 1,2,3…9 然后后面线程就不能确定了</li><li>每个线程运行次数至少为 1</li></ul><p>修改后</p><ul><li>同上</li><li>确定的数组，线程是 0,1,2…9 的循环，对应的值则是从 0-99 对应的斐波那契数列递增</li><li>确定的对象，每个线程运行次数均为 10</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有限状态机</title>
    <link href="/p/0eb593b87cbb401692e22e19cae0ea8e/"/>
    <url>/p/0eb593b87cbb401692e22e19cae0ea8e/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://xstate.js.org/">xstate.js 官网</a>, <a href="https://blog.jerry-hong.com/posts/xstate-tutorials-context-actions/">中文（繁体）教程参考</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>为什么要引入状态机？</li><li>吾辈希望使用有限状态机管理程序中的状态及状态的流转，以避免使用各种 <code>flag</code> + <code>if/else</code> 控制程序的运行。</li><li>为什么吾辈会突然觉得 <code>flag</code> + <code>if/else</code> 这种方式不好呢？</li><li>原因在于吾辈最近在看设计模式相关的书籍：<a href="https://book.douban.com/subject/26382780/">JavaScript 设计模式与开发实践</a>，其中涉及到了[状态模式]，里面就提到了[有限状态机]与[状态图]的概念，在经过 Google 一下了解之后，吾辈确实感觉到可以使用它来简化程序的状态流转控制。</li></ul><p>例如有一个开关，控制灯泡怎么变化，在指定状态下点击会触发不同的行为，然后改变状态。</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>想象以下场景，有一个开关控制着一个灯泡，灯泡有三种状态：关闭、打开弱光和打开强光，轮流变化。</p><h3 id="使用原生代码实现"><a href="#使用原生代码实现" class="headerlink" title="使用原生代码实现"></a>使用原生代码实现</h3><p>首先，我们尝试简单的使用 <code>if/else</code> 判断进行实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> state: <span class="hljs-string">&quot;off&quot;</span> | <span class="hljs-string">&quot;weak&quot;</span> | <span class="hljs-string">&quot;strong&quot;</span> = <span class="hljs-string">&quot;off&quot;</span>;<br>  <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.state) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;off&quot;</span>:<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开弱光&quot;</span>);<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;weak&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;weak&quot;</span>:<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开强光&quot;</span>);<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;strong&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;strong&quot;</span>:<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;关灯&quot;</span>);<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;off&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> Light();<br>light.click();<br>light.click();<br>light.click();<br></code></pre></td></tr></table></figure><p>然而，这种代码充斥着判断，同时代码本身也都耦合在了一起。目前只有一个 <code>flag</code> 的时候还没太大问题，如果有更多的 flag（例如典型的用户角色与状态同时控制指定操作的行为），代码将非常混乱。</p><blockquote><p>这也是吾辈之前为什么很想要一种支持多个 key 的 Map 的重要原因之一（其实有点类似数据库中索引的概念了）。</p></blockquote><h3 id="抽离方法，使用-Map-消除判断"><a href="#抽离方法，使用-Map-消除判断" class="headerlink" title="抽离方法，使用 Map 消除判断"></a>抽离方法，使用 Map 消除判断</h3><p>一般来说，我们都会使用下面的方式去简化代码。</p><ol><li> 将不同的逻辑抽离为单独的方法</li><li> 使用 Map 消除条件判断</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> state: <span class="hljs-string">&quot;off&quot;</span> | <span class="hljs-string">&quot;weak&quot;</span> | <span class="hljs-string">&quot;strong&quot;</span> = <span class="hljs-string">&quot;off&quot;</span>;<br>  <span class="hljs-keyword">private</span> map = &#123;<br>    off: <span class="hljs-built_in">this</span>.offClick.bind(<span class="hljs-built_in">this</span>),<br>    weak: <span class="hljs-built_in">this</span>.weakClick.bind(<span class="hljs-built_in">this</span>),<br>    strong: <span class="hljs-built_in">this</span>.strongClick.bind(<span class="hljs-built_in">this</span>),<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.map[<span class="hljs-built_in">this</span>.state]();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">offClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开弱光&quot;</span>);<br>    <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;weak&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">weakClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开强光&quot;</span>);<br>    <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;strong&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">strongClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;关灯&quot;</span>);<br>    <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;off&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> Light();<br>light.click();<br>light.click();<br>light.click();<br></code></pre></td></tr></table></figure><p>事实上，第一种方式是卓有成效且任何人都能够无师自通的（分离了实现和控制），但第二种，虽然这里可以简化逻辑的控制，但稍微复杂或是由多个 <code>flag</code> 控制的状态流转则无法使用这种方式抽离出来。</p><h3 id="使用简单的状态模式"><a href="#使用简单的状态模式" class="headerlink" title="使用简单的状态模式"></a>使用简单的状态模式</h3><p>下面是用简单的状态模式来简化代码的控制逻辑</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>  toggle: <span class="hljs-function">(<span class="hljs-params">light: Light</span>) =&gt;</span> <span class="hljs-built_in">void</span> = FSM.off;<br>  <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.toggle(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> FSM = &#123;<br>  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">light: Light</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开弱光&quot;</span>);<br>    light.toggle = FSM.weak;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">weak</span>(<span class="hljs-params">light: Light</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开强光&quot;</span>);<br>    light.toggle = FSM.strong;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">strong</span>(<span class="hljs-params">light: Light</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;关灯&quot;</span>);<br>    light.toggle = FSM.off;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> Light();<br>light.click();<br>light.click();<br>light.click();<br></code></pre></td></tr></table></figure><p>仔细观察变化</p><ol><li> 主流程只是做了转发，将操作转发给当前状态的子流程执行</li><li> 状态对应的操作都在子流程中修改</li></ol><p>其实本质上状态模式是将控制流程分散到了各个子流程中，不再集中在一个地方控制。</p><h3 id="结合-react-与状态模式"><a href="#结合-react-与状态模式" class="headerlink" title="结合 react 与状态模式"></a>结合 react 与状态模式</h3><p>然后，有趣的地方来了：如何结合状态模式与现有框架？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import React from &quot;react&quot;;<br>import ReactDOM from &quot;react-dom&quot;;<br>import &#123; useState &#125; from &quot;react&quot;;<br><br>class Light &#123;<br>  toggle: (light: Light) &#x3D;&gt; void &#x3D; FSM.off;<br>  click() &#123;<br>    this.toggle(this);<br>  &#125;<br>&#125;<br><br>const FSM &#x3D; &#123;<br>  off(light: Light) &#123;<br>    console.log(&quot;打开弱光&quot;);<br>    light.toggle &#x3D; FSM.weak;<br>  &#125;,<br>  weak(light: Light) &#123;<br>    console.log(&quot;打开强光&quot;);<br>    light.toggle &#x3D; FSM.strong;<br>  &#125;,<br>  strong(light: Light) &#123;<br>    console.log(&quot;关灯&quot;);<br>    light.toggle &#x3D; FSM.off;<br>  &#125;,<br>&#125;;<br><br>function App() &#123;<br>  const [light] &#x3D; useState(new Light());<br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;app&lt;&#x2F;h2&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; light.click()&#125;&gt;灯的开关&lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br><br>ReactDOM.render(&lt;App &#x2F;&gt;, document.querySelector(&quot;#app&quot;));<br></code></pre></td></tr></table></figure><p>然而，当我们想要即时显示当前状态时，却发现了问题，是的，状态模式中将状态放在 <code>Light</code> 类中，而它并不在 react 的控制范围之内！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#x2F;&#x2F; 其他代码<br><br>class Light &#123;<br>  state: &quot;off&quot; | &quot;weak&quot; | &quot;strong&quot; &#x3D; &quot;off&quot;;<br>  &#x2F;&#x2F; 其他代码<br>&#125;<br><br>const FSM &#x3D; &#123;<br>  off(light: Light) &#123;<br>    console.log(&quot;打开弱光&quot;);<br>    light.state &#x3D; &quot;weak&quot;;<br>    light.toggle &#x3D; FSM.weak;<br>  &#125;,<br>  &#x2F;&#x2F; 其他状态的代码<br>&#125;;<br><br>function App() &#123;<br>  const [light] &#x3D; useState(new Light());<br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;app&lt;&#x2F;h2&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; light.click()&#125;&gt;灯的开关&lt;&#x2F;button&gt;<br>      &lt;p&gt;&#123;light.state&#125;&lt;&#x2F;p&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br><br>&#x2F;&#x2F; 其他代码<br></code></pre></td></tr></table></figure><p>即便这样做，仍然不会发生变化，因为 Light 是个对象，而我们并未使用 <code>setLight</code> 修改它，所以自然不会发生变化</p><h3 id="尝试-react-useReducer"><a href="#尝试-react-useReducer" class="headerlink" title="尝试 react + useReducer"></a>尝试 react + useReducer</h3><p>当然，我们可以使用 <code>useReducer</code> 试试，毕竟它是专门应对复杂逻辑处理的 hooks。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LightState = <span class="hljs-string">&#x27;off&#x27;</span> | <span class="hljs-string">&#x27;weak&#x27;</span> | <span class="hljs-string">&#x27;strong&#x27;</span><br><span class="hljs-keyword">const</span> FSM: Record&lt;LightState, <span class="hljs-function">() =&gt;</span> LightState&gt; = &#123;<br>  off(): LightState &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;打开弱光&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;weak&#x27;</span><br>  &#125;,<br>  weak(): LightState &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;打开强光&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;strong&#x27;</span><br>  &#125;,<br>  strong(): LightState &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;关灯&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;off&#x27;</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> App: React.FC = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [num, setNum] = useState(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> [lightState, lightSend] = useReducer&lt;<span class="hljs-function">(<span class="hljs-params">state: LightState</span>) =&gt;</span> LightState&gt;(<br>    (state) =&gt; &#123;<br>      <span class="hljs-keyword">return</span> FSM[state]()<br>    &#125;,<br>    <span class="hljs-string">&#x27;off&#x27;</span>,<br>  )<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;header&gt;<br>        &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> lightSend()&#125;&gt;切换&lt;/button&gt;<br>        每次从 off =&gt; weak 就改变状态<br>      &lt;/header&gt;<br>      &lt;p&gt;&#123;lightState&#125;&lt;/p&gt;<br>      &lt;p&gt;当前 useState 的值: &#123;num&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，可以看到，FSM 逻辑代码在 react 组件外部时，想要修改 react 组件内部的状态仍然非常困难，只能维护状态机自身的状态，而这显然是没多大用处的。解决方案很简单，使用回调的形式将具体的实现函数放在 react 组件内部，而这，正是 xstate 集成 react 实现的功能之一。</p><h2 id="使用-xstate"><a href="#使用-xstate" class="headerlink" title="使用 xstate"></a>使用 xstate</h2><h3 id="react-状态机-xstate"><a href="#react-状态机-xstate" class="headerlink" title="react + 状态机 xstate"></a>react + 状态机 xstate</h3><p>下面是一个使用状态机控制点击开关控制灯泡的示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs tsx">enum LightStateEnum &#123;<br>  Off &#x3D; &#39;off&#39;,<br>  Weak &#x3D; &#39;weak&#39;,<br>  Strong &#x3D; &#39;strong&#39;,<br>&#125;<br><br>enum LightEventEnum &#123;<br>  Click &#x3D; &#39;click&#39;,<br>&#125;<br>interface LightEvent extends EventObject &#123;<br>  type: LightEventEnum.Click<br>  num: number<br>&#125;<br><br>enum LightActionEnum &#123;<br>  EntryWeak &#x3D; &#39;entryWeak&#39;,<br>&#125;<br><br>const lightStateMachine &#x3D; Machine&lt;&#123;&#125;, LightEvent&gt;(&#123;<br>  initial: LightStateEnum.Off,<br>  states: &#123;<br>    [LightStateEnum.Off]: &#123;<br>      on: &#123;<br>        [LightEventEnum.Click]: &#123;<br>          target: LightStateEnum.Weak,<br>          actions: LightActionEnum.EntryWeak,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>    [LightStateEnum.Weak]: &#123;<br>      on: &#123;<br>        [LightEventEnum.Click]: LightStateEnum.Strong,<br>      &#125;,<br>    &#125;,<br>    [LightStateEnum.Strong]: &#123;<br>      on: &#123;<br>        [LightEventEnum.Click]: LightStateEnum.Off,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br><br>const App: React.FC &#x3D; () &#x3D;&gt; &#123;<br>  const [num, setNum] &#x3D; useState(0)<br>  const [lightState, lightSend] &#x3D; useMachine(lightStateMachine, &#123;<br>    actions: &#123;<br>      [LightActionEnum.EntryWeak](_context, event) &#123;<br>        console.log(&#39;entryOff: &#39;, event.num)<br>        setNum(num + event.num)<br>      &#125;,<br>    &#125;,<br>  &#125;)<br>  return (<br>    &lt;div className&#x3D;&quot;App&quot;&gt;<br>      &lt;header&gt;<br>        &lt;button<br>          onClick&#x3D;&#123;() &#x3D;&gt;<br>            lightSend(&#123;<br>              type: LightEventEnum.Click,<br>              num: 1,<br>            &#125;)<br>          &#125;<br>        &gt;<br>          切换<br>        &lt;&#x2F;button&gt;<br>        每次从 off &#x3D;&gt; weak 就改变状态<br>      &lt;&#x2F;header&gt;<br>      &lt;p&gt;&#123;lightState.value&#125;&lt;&#x2F;p&gt;<br>      &lt;p&gt;当前 useState 的值: &#123;num&#125;&lt;&#x2F;p&gt;<br>    &lt;&#x2F;div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>看的出来，上面多了很多<strong>模板</strong>代码，但状态机的意图我们却能以声明式的形式构造出来，具体 <code>actions</code> 的实现细节则被分离在 hooks 中。</p><h2 id="xstate-概述"><a href="#xstate-概述" class="headerlink" title="xstate 概述"></a>xstate 概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p><a href="https://statecharts.github.io/concepts.html">常用术语</a>, <a href="https://statecharts.github.io/glossary/">术语参考</a></p></blockquote><ul><li>状态: 任何时候总是有且只有一种状态</li><li>事件: 对外暴露事件，通过事件（声明式）触发状态的变化</li><li>动作: 触发事件时对应的具体行为，可以以编程的形式影响状态的变化</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>主要问题还是太大了，xstate 想要把所有的状态都用这种方式管理起来，而非仅限于适合的情况。。。（大而全 ）<blockquote><p><a href="https://codesandbox.io/s/dry-worker-hb5ct">在线示例</a></p></blockquote></li><li>[x] 怎么让 TypeScript 提示正确的类型？<ul><li>显式声明类型</li></ul></li><li>[x] 怎么在 react 里使用它修改状态<ul><li>使用 <code>useMachine</code> 在 react hooks 组件里添加 <code>actions</code></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的批处理和缓存</title>
    <link href="/p/ce13ff46242348b094f95e46a915cef2/"/>
    <url>/p/ce13ff46242348b094f95e46a915cef2/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在生产环境遇到了下面这样一个场景：<br>后台在字典表中存储了一些之前需要前后端共同维护的枚举值，并提供根据 <code>type/id</code> 获取字典的 API。所以在渲染列表的时候，有很多列表的字段直接就是字典的 id，而没有经过后台的数据拼装。</p><blockquote><p>也是吾辈之前写的文章 <a href="/p/9b07ff8ce6dd4eb08896f6b8191d7181">react 通用列表组件封装</a> 中的那个通用列表在实际使用时遇到的问题之一。</p></blockquote><p>起初，吾辈解决问题的流程如下</p><ol><li> 确定字典字段，添加转换后的对象类型接口</li><li> 将对象列表进行转换得到其中字典字段的所有值</li><li> 对字典 id 列表进行去重</li><li> 根据 id 列表从后台获取到所有的字典数据</li><li> 将获得的字典数据转换为 <strong>id =&gt; 字典</strong> 的 Map</li><li> 遍历最初的列表，对里面指定的字典字段进行转换</li></ol><p>可以看到，上面的步骤虽然不麻烦，但却十分繁琐，需要定义额外的类型不说，还很容易发生错误。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li> 使用 <code>异步批处理 + LRU 缓存</code> 优化性能</li><li> 支持异步 <code>formatter</code> 获得更好的使用体验</li></ol><h2 id="实现异步批处理"><a href="#实现异步批处理" class="headerlink" title="实现异步批处理"></a>实现异步批处理</h2><blockquote><p>参考实现: <a href="https://github.com/rxliuli/rx-util/blob/dev/src/module/function/batch.ts">batch</a></p></blockquote><p>实现批处理的基本思路如下</p><ol><li> 使用 <code>Map</code> <code>paramCache</code> 缓存传入的 <code>参数 =&gt; 剩余调用次数</code>（该参数还需要查询几次结果）</li><li> 使用 <code>Map</code> <code>resultCache</code> 缓存 <strong>参数 =&gt; 结果</strong></li><li> 使用 <code>lock</code> 标识当前是否有函数正在执行</li><li>满足以下条件需要等待<ol><li> Map 中不包含结果</li><li> 目前有其它调用在执行</li><li> 还未满最小等待时长（收集调用的最小时间片段）</li></ol></li><li> 使用 <code>lock</code> 标识正在执行</li><li>判断是否已经存在结果<ol><li> 如果不存在则执行批处理处理当前所有的参数</li></ol></li><li> 从缓存 Map 中获取结果</li><li> 将 <code>paramCache</code> 中对应参数的 <code>剩余调用次数 -1</code></li><li>判断是否还需要保留该缓存（该参数对应的剩余调用次数为 0）<ol><li> 不需要则删除</li></ol></li><li>判断缓存的结果是否是 <code>Error</code><ol><li> 是的话则 <code>throw</code> 抛出错误</li></ol></li></ol><h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><blockquote><p>参考: <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Wiki 缓存算法</a>, 实现 <a href="https://github.com/rxliuli/rx-util/blob/dev/src/module/cache/MemoryCache.ts">MemoryCache</a></p></blockquote><ul><li>问：这里为什么使用缓存？</li><li>答：这里的字典接口在大概率上是<strong>幂等</strong>的，所以可以使用缓存提高性能</li><li>问：那么缓存策略为什么要选择 LRU 呢？</li><li>答：毫无疑问 <code>FIFO</code> 是不合理的</li><li>问：那为什么不选择 <code>LFU</code> 算法呢？它似乎能保留访问最频繁的资源</li><li>答：因为字典表并非完全幂等，吾辈希望避免一种可能–<strong>访问最多的字典一直没有删除，而它在数据库已经被更新了</strong>。</li></ul><p>大致实现思路如下</p><ol><li> 使用一个 <code>Map</code> 记录 <strong>缓存 key =&gt; 最后访问时间</strong></li><li> 每次获取缓存时更新最后访问时间</li><li>添加新的缓存时检查缓存数量<ol><li> 如果超过最大数量，则删除最后访问时间距离现在最长的一个缓存</li></ol></li><li> 添加新的缓存</li></ol><blockquote><p>Pass: 不要吐槽性能很差啦，这个场景下不会缓存特别多的元素啦，最多也就不到 1000 个吧</p></blockquote><h2 id="结合高阶函数"><a href="#结合高阶函数" class="headerlink" title="结合高阶函数"></a>结合高阶函数</h2><p>现在，我们可以结合这两种方式了，同时使用 <code>onceOfSameParam/batch</code> 两个高阶函数来优化 <strong>根据 id 获取字典信息</strong> 的 API 了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> getById = onceOfSameParam(<br>  batch&lt;[<span class="hljs-built_in">number</span>], Dict&gt;(<span class="hljs-keyword">async</span> (idList) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (idList.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>    &#125;<br>    <span class="hljs-comment">// 一次批量处理多个 id</span><br>    <span class="hljs-keyword">const</span> list = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getByIdList(uniqueBy(idList.flat()));<br>    <span class="hljs-keyword">return</span> arrayToMap(<br>      list,<br>      (dict) =&gt; [dict.id],<br>      (dict) =&gt; dict<br>    );<br>  &#125;, <span class="hljs-number">100</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="支持异步-formatter"><a href="#支持异步-formatter" class="headerlink" title="支持异步 formatter"></a>支持异步 formatter</h2><p>原本想要支持 ListTable 的异步 <code>formatter</code> 函数，但后来想想，如果 <code>slot</code> 里也包含字典 id 呢？那是否 <code>slot</code> 也要支持异步呢？这可是个比较棘手的问题，所以还是不支持好了。</p><blockquote><p>最终，吾辈在组件与 API 之间添加了 <code>*Service</code> 中间层负责处理数据转换。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 上最好的浏览器 Kiwi browser</title>
    <link href="/p/5ee4baf7db80466387689bbb291aa11a/"/>
    <url>/p/5ee4baf7db80466387689bbb291aa11a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://kiwibrowser.com/">官网</a></p></blockquote><p>或许对于现在很多人来说，浏览器是一个很少使用的 App，因为所有功能都可以在 App 做，不需要使用浏览器。一方面，是由于国内的大环境就是把用户当成傻瓜（事实上，即便是吾辈目前所在的公司，在 UI/UX 设计方面也倾向于将用户当成傻瓜），导致用户真的是越来越傻瓜，甚至遇到了除了微信其他的都不怎么会用的地步，更何况浏览器这种“<strong>高端</strong>”的 App 呢？<br>然而对于某些特定人群来说，尤其是不喜欢安装太多 App 的人来说，浏览器几乎是 App 上数一数二的应用了，甚至称之为互联网的入口都不为过（现在一般的傻瓜式用户大概认为微信才是吧，缅怀曾经互联网都是通过浏览器使用的时代）。<br>在使用过 <em>UC =&gt; Chrome =&gt; FireFox =&gt; Kiwi browser</em> 之后，吾辈可以确定的说，Kiwi browser 是目前 Android 上最好的浏览器，其中尤以支持 Chrome PC 版的 Plugin 最为有名。</p><h2 id="使用过的浏览器"><a href="#使用过的浏览器" class="headerlink" title="使用过的浏览器"></a>使用过的浏览器</h2><h3 id="UC-浏览器（国内版）"><a href="#UC-浏览器（国内版）" class="headerlink" title="UC 浏览器（国内版）"></a>UC 浏览器（国内版）</h3><p>在早期吾辈使用的浏览器中，UC 绝对是当年（2016 年之前）使用体验非常好的浏览器，直到后来被阿里系收购，导致它逐渐充斥着各种广告，甚至首先开辟出了<a href="http://kf.uc.cn/self_service/web/faqdetails-8311412_9210815_20559164_5.html">浏览器收费</a>这一跨世纪倒车壮举。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141319.jpg" alt="UC 国内版首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141320.png" alt="UC 国内版搜索"></p><blockquote><p>附：这里的跨世纪倒车壮举指的是自从浏览器始祖 Netscape 被 MS 的 IE 使用系统捆绑 + 免费的策略干掉以后，后来流行起来的浏览器还从未出现过收费的（或许是吾辈孤陋寡闻了？）<br>附：所有的国内浏览器都有内置的黑名单，例如 GitHub 上的 996 icu 就被国内浏览器屏蔽了，不仅仅是墙，就连浏览器都是墙的帮凶。参考：<a href="http://kf.uc.cn/self_service/web/faqdetails-9212655_9212659_20389994_6.html">国外网站无法访问？</a></p></blockquote><h3 id="UC-浏览器（国际版）"><a href="#UC-浏览器（国际版）" class="headerlink" title="UC 浏览器（国际版）"></a>UC 浏览器（国际版）</h3><p>UC 国际版，这是一个比较有趣的版本，没有国内版那么多花俏无用的功能，但同时不支持简体中文（当然支持繁体中文），同时保留了 UC 的核心功能——怪不得手机上 UC 的使用占有率很高呢！<br>它默认支持的主要功能如下</p><ul><li>广告过滤</li><li>黑暗模式</li><li>手势方面几近完美</li><li>下载功能</li><li>自带 QR</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141317.png" alt="UC 国际版首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141318.png" alt="UC 国际版搜索"></p><p>看起来没什么太大的问题，然而，它却在隐私方面做的一如既往的烂，参考：<a href="https://web.archive.org/web/20180228041423/http://news.163.com/16/0330/10/BJDBF3TT00014AEE.html">美媒:中国人上网须防泄露隐私 浏览器存安全隐患</a></p><h3 id="Chrome-for-Android"><a href="#Chrome-for-Android" class="headerlink" title="Chrome for Android"></a>Chrome for Android</h3><p>后来，吾辈在 PC 上先后遇到了 FireFox 和 Chrome，简直比国内的各种浏览器干净整洁了一百倍。在实际使用过相当长的一段时间后，吾辈最终在 PC 上选择了 Chrome，手机上也安装了 Chrome 进行网页浏览，它的速度非常理想，使用体验也还算不错，尤其是翻译功能更是被完整地保留了下来。唯有一点，插件功能被整个砍掉了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141709.png" alt="Chrome 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141404.png" alt="Chrome 搜索"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141403.png" alt="Google 翻译功能"></p><blockquote><p>为什么 Chrome For Android 不支持插件？虽然官方说是为了使之能够在较旧的浏览器上也能正常运行，但实际上应该有两个原因</p><ol><li> Android 是 Google 自己的，而 Google 对于 App 的控制力要超过网页，所以为了让用户使用 App，Google 不原因让用户更多的浏览网页。</li><li> 大约 70％的 chrome 用户在 android 和 ios 端，只有 30％的 chrome 用户在台式机和 mac 上。谷歌知道，如果他们在智能手机上引入扩展功能，那么由于广告拦截器的存在，他们将损失很多钱，而且大多数互联网用户由于舒适性，大部分时间都倾向于将智能手机用于互联网。Google 在这里玩一个聪明的游戏。参考：<a href="https://www.quora.com/Why-arent-there-any-extensions-for-Google-Chrome-on-Android">https://www.quora.com/Why-arent-there-any-extensions-for-Google-Chrome-on-Android</a></li></ol></blockquote><h3 id="FireFox-for-Android"><a href="#FireFox-for-Android" class="headerlink" title="FireFox for Android"></a>FireFox for Android</h3><p>所以，在知道 FireFox 在 Android 上亦支持插件后，吾辈感觉它就是吾辈理想中的手机浏览器，吾辈在手机上也开始尝试使用 FireFox 了。但事与愿违，它真的太慢了。。。在使用体验上和 Chrome 无法相提并论,而且翻译插件的支持不完善导致有时候想在移动端阅读大量英文网页时还需要切到 Chrome.</p><blockquote><p>注：FireFox 的桌面版插件支持存在一些问题，同时插件官方一直未曾修复，这也是吾辈放弃 FireFox 的重要原因之一。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141432.png" alt="FireFox 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141433.png" alt="FireFox 搜索"></p><h3 id="Kiwi-browser"><a href="#Kiwi-browser" class="headerlink" title="Kiwi browser"></a>Kiwi browser</h3><p>最终，吾辈遇到了 Kiwi browser，诚然，它也不是十全十美的，也有很多缺点。</p><ul><li>默认主页的新闻资讯很讨厌，而且还无法关闭。</li><li>翻译功能没有 Chrome 强大，没有<strong>就地</strong>全文翻译的功能</li><li>不是一个非常流行的浏览器，没有桌面版本，没有同步功能</li></ul><p>但有一个及其突出的优点，足以掩盖以上的所有缺点 – 支持 Chrome 桌面版插件。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141349.png" alt="Kiwi 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141348.png" alt="Kiwi 翻译"></p><h3 id="微型浏览器"><a href="#微型浏览器" class="headerlink" title="微型浏览器"></a>微型浏览器</h3><p>事实上，吾辈也曾断断续续地使用过一些微型浏览器，在功能上做的比较简洁（但并不意味着不够用），但内核却薄弱不堪（其实就是用系统默认浏览器的内核）。<br>包括但不限于以下列表</p><ul><li><a href="https://play.google.com/store/apps/details?id=mark.via.gp&hl=en_US">via 浏览器</a></li><li><a href="https://www.coolapk.com/apk/org.noear.h5">h5 浏览器</a></li><li><a href="https://www.xbext.com/">X 浏览器</a></li></ul><p>其他吾辈没有使用过的浏览器可以参考：<a href="https://m.xianjichina.com/news/details_145337.html">手机浏览器有哪些？安卓平台良心浏览器推荐</a></p><p>虽然这些微型浏览器理念很好：<strong>少即是多，简单就是美！</strong>，但实际上，这些没有内核的浏览器很多地方，尤其是性能方面，仍然受限于系统默认浏览器。大多数自带的插件系统，往往只是实现了一套加载 <code>*.user.js</code> 的机制罢了，而且生态之小与 Chrome/FireFox 这些主流其相比往往是天壤之别。</p><h2 id="Kiwi-browser-配置"><a href="#Kiwi-browser-配置" class="headerlink" title="Kiwi browser 配置"></a>Kiwi browser 配置</h2><h3 id="Kiwi-browser-推荐的插件"><a href="#Kiwi-browser-推荐的插件" class="headerlink" title="Kiwi browser 推荐的插件"></a>Kiwi browser 推荐的插件</h3><ul><li><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a>：广告过滤</li><li><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">Dark Reader</a>：为所有网站加上黑色主题，大部分情况下都还不错</li><li><a href="https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp">Tabliss</a>：美丽的新标签页</li><li><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd">LastPass</a>：全平台密码管理器</li><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">Tampermonkey</a>：油猴脚本管理器</li></ul><blockquote><p>桌面的 Chrome 使用建议可以参考：<a href="https://blog.rxliuli.com/p/54be2845/">优化 Google Chrome 的使用体验</a></p></blockquote><h3 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h3><p>有时候需要使用二维码扫描使用手机去打开某个网站，而 Kiwi 并没有自带这个功能，所以需要配合 App <a href="https://play.google.com/store/apps/details?id=mark.qrcode">二维码扫描</a> 食用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 禁止用户保存图片</title>
    <link href="/p/ddcef057b6fa4f4bb8707e0978665f7c/"/>
    <url>/p/ddcef057b6fa4f4bb8707e0978665f7c/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在业务需求中不希望用户保存图片，因为是一些供内部使用的图片。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>添加事件禁止选择、拖拽、右键（简单的禁止用户保存图片，但无法阻止用户打开控制台查看，或是直接抓包）</li><li>将之转换为 canvas（让浏览器认为不是图片以此禁止用户对之进行图片的操作，但无法阻止抓包）</li><li>禁止用户使用控制台查看源码（阻止浏览器打开控制台，但无法阻止抓包）</li><li>传输图片使用自定义格式（可以阻止抓包，但需要后台配合）</li></ul><blockquote><p>注：以下内容使用 react+ts 实现</p></blockquote><h2 id="添加事件禁止选择、拖拽、右键"><a href="#添加事件禁止选择、拖拽、右键" class="headerlink" title="添加事件禁止选择、拖拽、右键"></a>添加事件禁止选择、拖拽、右键</h2><p>简而言之，这是一种简单有效的方式，能够在用户不打开控制台的情况下阻止用户保存图片。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preventDefaultListener</span>(<span class="hljs-params">e: any</span>) </span>&#123;<br>  e.preventDefault();<br>&#125;<br><br>&lt;img<br>  src=&#123;props.url&#125;<br>  alt=<span class="hljs-string">&quot;&quot;</span><br>  style=&#123;&#123;<br>    <span class="hljs-comment">//禁止用户选择</span><br>    userSelect: <span class="hljs-string">&quot;none&quot;</span>,<br>    <span class="hljs-comment">//禁止所有鼠标事件，过于强大，图片仅用于展示可用</span><br>    <span class="hljs-comment">// pointerEvents: &#x27;none&#x27;,</span><br>  &#125;&#125;<br>  onTouchStart=&#123;preventDefaultListener&#125;<br>  onContextMenu=&#123;preventDefaultListener&#125;<br>  onDragStart=&#123;preventDefaultListener&#125;<br>/&gt;;<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://www.cnblogs.com/dxzg/p/9930559.html">https://www.cnblogs.com/dxzg/p/9930559.html</a></p></blockquote><h2 id="将之转换为-canvas"><a href="#将之转换为-canvas" class="headerlink" title="将之转换为 canvas"></a>将之转换为 canvas</h2><p>另一种思路是将图片转换为 canvas 避免用户使用 <code>img</code> 相关的操作。</p><ol><li><p>将图片转成 canvas</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageToCanvas</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  url: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  canvas: HTMLCanvasElement</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//新建Image对象，引入当前目录下的图片</span><br>    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image();<br>    img.src = url;<br>    <span class="hljs-keyword">const</span> c = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>)!;<br><br>    <span class="hljs-comment">//图片初始化完成后调用</span><br>    img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">//将canvas的宽高设置为图像的宽高</span><br>      canvas.width = img.width;<br>      canvas.height = img.height;<br><br>      <span class="hljs-comment">//canvas画图片</span><br>      c.drawImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, img.width, img.height);<br>      resolve();<br>    &#125;;<br>    img.addEventListener(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      reject(e);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>禁用 canvas 事件</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> throwFn = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>    <span class="hljs-string">&quot;Uncaught DOMException: Failed to execute &#x27;toDataURL&#x27; on &#x27;HTMLCanvasElement&#x27;: Tainted canvases may not be exported.&quot;</span>,<br>  )<br>&#125;<br><br><span class="hljs-keyword">const</span> $canvasRef = useRef&lt;HTMLCanvasElement&gt;(<span class="hljs-literal">null</span>)<br> useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>     ;(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>         <span class="hljs-keyword">await</span> imageToCanvas(props.url, $canvasRef.current!)<br>         $canvasRef.current!.toBlob = throwFn<br>         $canvasRef.current!.toDataURL = throwFn<br>     &#125;)()<br> &#125;, [])<br> <span class="hljs-keyword">return</span> (<br>     &lt;canvas<br>         ref=&#123;$canvasRef&#125;<br>         onTouchStart=&#123;preventDefaultListener&#125;<br>         onContextMenu=&#123;preventDefaultListener&#125;<br>     /&gt;<br> )<br></code></pre></td></tr></table></figure><h2 id="禁止用户使用控制台查看源码"><a href="#禁止用户使用控制台查看源码" class="headerlink" title="禁止用户使用控制台查看源码"></a>禁止用户使用控制台查看源码</h2></li></ol><p>如果能禁止用户操作控制台，那么自然能够避免用户查看源码了，下面是一个简单的实现。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 兼容异步函数的返回值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>res 返回值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>callback 同步/异步结果的回调函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typeparam </span>T 处理参数的类型，如果是 Promise 类型，则取出其泛型类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typeparam </span>Param 处理参数具体的类型，如果是 Promise 类型，则指定为原类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typeparam </span>R 返回值具体的类型，如果是 Promise 类型，则指定为 Promise 类型，否则为原类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>处理后的结果，如果是同步的，则返回结果是同步的，否则为异步的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compatibleAsync</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">any</span>, <span class="hljs-title">Param</span> = <span class="hljs-title">T</span> | <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">R</span> = <span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  res: Param,</span></span><br><span class="hljs-function"><span class="hljs-params">  callback: (r: T) =&gt; R</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Param</span> <span class="hljs-title">extends</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">T</span>&gt; ? <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">R</span>&gt; : <span class="hljs-title">R</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (res <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span><br>    ? res.then(callback)<br>    : callback(res <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试函数的执行时间</span><br><span class="hljs-comment"> * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 需要测试的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>执行的毫秒数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>&lt;<span class="hljs-title">R</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; R</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-comment">// 函数返回类型是 Promise 的话，则返回 Promise&lt;number&gt;，否则返回 number</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">R</span> <span class="hljs-title">extends</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">any</span>&gt; ? <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; : <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> res = fn();<br>  <span class="hljs-keyword">return</span> compatibleAsync(res, <span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁止他人调试网站相关方法的集合对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AntiDebug</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 不停循环 debugger 防止有人调试代码</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns </span>取消函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> cyclingDebugger(): <span class="hljs-built_in">Function</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">debugger</span>;<br>    &#125;, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(res);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 检查是否正在 debugger 并调用回调函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>fn 回调函数，默认为重载页面</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns </span>取消函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> checkDebug(<br>    fn: <span class="hljs-built_in">Function</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">window</span>.location.reload()<br>  ): <span class="hljs-built_in">Function</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> diff = timing(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">debugger</span>;<br>      &#125;);<br>      <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">500</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(diff);<br>        fn();<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(res);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> cancel1 = AntiDebug.cyclingDebugger() <span class="hljs-keyword">as</span> any<br>  <span class="hljs-keyword">const</span> cancel2 = AntiDebug.checkDebug(<span class="hljs-function">() =&gt;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请不要打开调试&#x27;</span>),<br>  ) <span class="hljs-keyword">as</span> any<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    cancel1()<br>    cancel2()<br>  &#125;<br>&#125;, [])<br><br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;url&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="传输图片使用自定义格式"><a href="#传输图片使用自定义格式" class="headerlink" title="传输图片使用自定义格式"></a>传输图片使用自定义格式</h2><p>该功能需要服务端配合，故而此处赞不实现，可以参考 <a href="https://weread.qq.com/">微信读书</a>，就是将文本转为 canvas，数据传输也进行了加密，可以在很大程度上防止普通用户想要复制/下载的行为了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如同所有的前端限制用户的技术一样，这是一个没有终点的斗争。。。</p><blockquote><p>参考广告屏蔽和屏蔽复制粘贴的发展。。。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 获取随机条数据</title>
    <link href="/p/0540dc0bb40e41c58e19c3b827aba1cd/"/>
    <url>/p/0540dc0bb40e41c58e19c3b827aba1cd/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有一个需要从数据库随机获取指定数量的数据的需求，然而这个问题却是意外的挺麻烦。</p><p>假设有一个数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> topic (<br>  id      <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>  content <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)     <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;内容&#x27;</span><br>)<br>  comment <span class="hljs-string">&#x27;主题表&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>这里的 <code>topic</code> 表有两个关键性的特点</p><ul><li>主键可以进行比较（<code>int</code>）</li><li>主键整体存在趋势（自增/自减）</li></ul></blockquote><h2 id="解决方案-1：直接使用-order-by-rand"><a href="#解决方案-1：直接使用-order-by-rand" class="headerlink" title="解决方案 1：直接使用 order by rand()"></a>解决方案 1：直接使用 <code>order by rand()</code></h2><p>直接使用 <code>order by rand()</code> 就可以获取到随机的数据了，而且能够获取到全部的数据（顺序仍然是随机的）。</p><ol><li>按照 <code>rand()</code> 产生的结果<blockquote><p>这一步相当于为每条数据加上一列由 <code>rand()</code> 函数产生的数据，然后对这一列进行排序</p></blockquote></li><li> 限制查询条数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> topic<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rand()<br>limit <span class="hljs-number">50000</span>;<br></code></pre></td></tr></table></figure><p>但缺点很明显，速度是个问题，因为 rand() 的数据没有索引，所以会造成排序速度极慢。</p><p>在 10w 条数据中随机获取 5w 条数据，花费时常 <strong>6 s 378 ms</strong>，这个时间真的太长了点。</p><p>其实 <code>order by rand()</code> 看起来很奇怪，实际上等效于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> (<br>       <span class="hljs-keyword">select</span><br>         topic.<span class="hljs-operator">*</span>,<br>         rand() <span class="hljs-keyword">as</span> order_column<br>       <span class="hljs-keyword">from</span> topic<br>     ) <span class="hljs-keyword">as</span> temp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_column<br>limit <span class="hljs-number">50000</span>;<br></code></pre></td></tr></table></figure><h2 id="解决方案-2：使用-where-subquery-取中间的随机值"><a href="#解决方案-2：使用-where-subquery-取中间的随机值" class="headerlink" title="解决方案 2：使用 where subquery 取中间的随机值"></a>解决方案 2：使用 <code>where subquery</code> 取中间的随机值</h2><p>因为 <code>order by rand()</code> 没有索引导致的排序太耗时，我们可以尝试绕过这个问题。</p><p>下面的这种解决方案便是如此</p><ol><li> 取最小值和最大值之间的随机值</li><li> 判断 id 是否大于（或者小于）这个随机值</li><li> 限制查询条数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> topic<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span> ((<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(id)<br>              <span class="hljs-keyword">from</span> topic)<br>             <span class="hljs-operator">-</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id)<br>                <span class="hljs-keyword">from</span> topic))<br>            <span class="hljs-operator">*</span> rand()<br>            <span class="hljs-operator">+</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id)<br>               <span class="hljs-keyword">from</span> topic)<br>limit <span class="hljs-number">50000</span>;<br></code></pre></td></tr></table></figure><p>这种方法查询速度虽然极快（150 ms），但却会受到数据分布密度的影响。如果数据不是平均的，那么查询到的总数据条数就会受限。</p><p>那么，下面来说该方法的缺陷</p><ul><li><p>获取到的数据受分布密度影响</p><p>例如数据分布呈以下情况</p><p><code>1,100002,100003,100004...199999,200000</code></p><p>那么使用上述代码就只能获取到很少一部分数据（大约在 2.5w 条左右）。然而如果将符号稍微下改一下，将 <code>&gt;=</code> 修改为 <code>&lt;=</code>，那么能够获取到的平均数量将大大增加（7.5w 条左右）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> topic<br># 注意：这里的符号修改了<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span> ((<span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(id)<br>              <span class="hljs-keyword">from</span> topic)<br>            <span class="hljs-operator">-</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id)<br>                <span class="hljs-keyword">from</span> topic))<br>            <span class="hljs-operator">*</span> rand()<br>            <span class="hljs-operator">+</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id)<br>              <span class="hljs-keyword">from</span> topic)<br>limit <span class="hljs-number">50000</span>;<br></code></pre></td></tr></table></figure></li><li><p>每一条数据获取到的概率不是完全相同的<br>虽然获取到的全部数据是随机的，但每一个的概率却并不相同。例如在 <code>&lt;=</code> 时会出现永远都为第一条的现象，究其原因就是因为 <strong>第一条</strong> 的概率实在是太大了，因为查询数据表时数据的检索规则是从第一条开始的呢！即便修改成 <code>&gt;=</code>，所得到的第一条数据也普遍偏小。<br>使用 <code>&gt;=</code> 的结果</p><ul><li>数据越是在前面，那么获取到的概率就越低</li><li>但即便是很低概率，在最前面总有机会，所以第一条一般偏小</li><li>数据密度前面偏大时，获取到的数量会非常小</li></ul></li></ul><p>密度越是趋于平均，获取到的最大随机数据条数的平均值愈接近 <code>1/2</code>，否则则会愈加偏离（不一定偏大还是偏小）。</p><h2 id="解决方案-3：使用临时表-temporary-table"><a href="#解决方案-3：使用临时表-temporary-table" class="headerlink" title="解决方案 3：使用临时表 temporary table"></a>解决方案 3：使用临时表 <code>temporary table</code></h2><p>解决方案 2 着眼于避免使用没有索引的 <code>rand()</code> 进行排序，但这里思考另一个解决方案，使用加了索引之后的 <code>rand()</code> 进行排序。创建临时表，仅包含主键 <code>id</code> 和需要进行排序的索引列 <code>randomId</code>，然后排序完成过后获取到乱序数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> temporary <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> temp_topic;<br><span class="hljs-keyword">create</span> temporary <span class="hljs-keyword">table</span> temp_topic (<br>  id       <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  randomId <span class="hljs-keyword">double</span>             <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  index (randomId)<br>)<br>  <span class="hljs-keyword">as</span><br>    <span class="hljs-keyword">select</span><br>      id,<br>      rand() <span class="hljs-keyword">as</span> randomId<br>    <span class="hljs-keyword">from</span> topic;<br><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> topic t<br>  <span class="hljs-keyword">join</span> (<br>         <span class="hljs-keyword">select</span> id<br>         <span class="hljs-keyword">from</span> (<br>                <span class="hljs-keyword">select</span> id<br>                <span class="hljs-keyword">from</span> temp_topic<br>                <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> randomId<br>              ) <span class="hljs-keyword">as</span> temp<br>         limit <span class="hljs-number">50000</span><br>       ) <span class="hljs-keyword">as</span> temp<br>    <span class="hljs-keyword">on</span> t.id <span class="hljs-operator">=</span> temp.id;<br></code></pre></td></tr></table></figure><p>这种方法的查询速度不算很快（878 ms，相比于第二种），而且仍然是与数据量呈正相关的（因为要复制数据）。但和第一种，也是真正的随机获取。</p><h2 id="解决方案-4：使用-join-order-by-rand"><a href="#解决方案-4：使用-join-order-by-rand" class="headerlink" title="解决方案 4：使用 join order by rand()"></a>解决方案 4：使用 <code>join order by rand()</code></h2><p>吾辈在 <a href="https://stackoverflow.com/">StackOverflow</a> 上面看到了一个 <a href="https://stackoverflow.com/a/36013954/8409380">最优解 by 2016</a>，一切表现的都很好，速度不算慢（261 ms），也可以获取到全部数据，也是真正的随机获取。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> g.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span><br>  topic g<br>  <span class="hljs-keyword">join</span><br>  (<span class="hljs-keyword">select</span> id<br>   <span class="hljs-keyword">from</span><br>     topic<br>   <span class="hljs-keyword">where</span><br>     rand() <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">select</span> ((<span class="hljs-number">50000</span> <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>)) <span class="hljs-operator">*</span> <span class="hljs-number">10</span>)<br>               <span class="hljs-keyword">from</span><br>                 topic)<br>   <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rand()<br>   limit <span class="hljs-number">50000</span>) <span class="hljs-keyword">as</span> z <span class="hljs-keyword">on</span> z.id <span class="hljs-operator">=</span> g.id;<br></code></pre></td></tr></table></figure><p>这里的 <code>where rand()</code> 是想要在获取的数据与总数据量差距过大（10 倍以上）时过滤数据，提高排序效率。</p><p>吾辈这里不清楚上面发生了什么，感觉 <code>rand()</code> 只要在 <code>join</code> 里面之后的排序就会变得很快！<br>事实上，只要使用 <code>join</code> 内连接之后，就算是 <code>order by rand()</code> 的效率也很高，甚至在获取少量数据时比上面使用 <code>where rand</code> 过滤数据后再排序的的速度还要快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> topic t<br>  <span class="hljs-keyword">JOIN</span><br>  (<span class="hljs-keyword">SELECT</span> id<br>   <span class="hljs-keyword">FROM</span> `topic`<br>   <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> RAND()<br>   LIMIT <span class="hljs-number">50000</span>) <span class="hljs-keyword">AS</span> z <span class="hljs-keyword">ON</span> z.id <span class="hljs-operator">=</span> t.id;<br></code></pre></td></tr></table></figure><blockquote><p>注：在获取的数据量很大时，使用上面那种 <code>where</code> 过滤一次的效率上会更有优势一点！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这里有一篇不错的英文文章对随机获取数据进行了分析：<a href="http://jan.kneschke.de/projects/mysql/order-by-rand/">http://jan.kneschke.de/projects/mysql/order-by-rand/</a>，也有人在 StackOverflow 上进行了讨论 <a href="https://stackoverflow.com/questions/1823306/">https://stackoverflow.com/questions/1823306/</a></p></blockquote><table><thead><tr><th>不同点</th><th><code>order by rand()</code></th><th><code>where subquery</code></th><th><code>temporary table</code></th><th><code>join order by rand()</code></th></tr></thead><tbody><tr><td>可以随机获取全部</td><td>可以</td><td>几乎不可能</td><td>可以</td><td>可以</td></tr><tr><td>速度</td><td>慢</td><td>极快</td><td>较快</td><td>极快</td></tr><tr><td>需要可比较的主键类型</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>受数据分布密度影响</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>速度受表数据复杂度影响</td><td>很大</td><td>极小</td><td>较小</td><td>极小</td></tr></tbody></table><p>那么，看完上面的不同点对比，我们也可以得出它们的使用场景了</p><ul><li>强烈推荐首选 <code>join order by rand()</code> 作为随机获取数据的解决方案</li><li>唯一不推荐的就是 <code>order by rand()</code>，这是新手才会写出来 sql。当然，如果你的数据量很小（1000 条以下）时，直接使用 <code>order by rand()</code> 以现代机器的性能 sql 也不会很慢呢</li></ul><blockquote><p>注：如果仅仅只是需要打乱数据顺序的话还是更推荐将数据读取到内存中在进行操作更好！</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 无法插入中文数据</title>
    <link href="/p/07b0f417d17c460383ae8a1a668b8e1a/"/>
    <url>/p/07b0f417d17c460383ae8a1a668b8e1a/</url>
    
    <content type="html"><![CDATA[<p>刚刚在 Linux Centos 装完 MySQL 后，想试一下是否能正常使用，但在插入中文数据时发生了下面的这个错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[HY000][<span class="hljs-number">1366</span>] Incorrect string <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;\xE7\x90\x89\xE7\x92\x83&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">column</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">at</span> <span class="hljs-type">row</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>感觉是 MySQL 编码问题，查看一下编码格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%char%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>结果</p><table><thead><tr><th>Variable_name</th><th>Value</th></tr></thead><tbody><tr><td>character_set_client</td><td>utf8</td></tr><tr><td>character_set_connection</td><td>utf8</td></tr><tr><td>character_set_database</td><td>latin1</td></tr><tr><td>character_set_filesystem</td><td>latin1</td></tr><tr><td>character_set_results</td><td>utf8</td></tr><tr><td>character_set_server</td><td>latin1</td></tr><tr><td>character_set_system</td><td>utf8</td></tr><tr><td>character_sets_dir</td><td>/usr/share/mysql/charsets/</td></tr><tr><td>validate_password_special_char_count</td><td>1</td></tr></tbody></table><p>果然有几个编码是不支持中文的，所以将 <code>latin1</code> 编码修改为 <code>utf8mb4</code>/<code>utf8</code> 就好啦</p><blockquote><p>有关编码格式请参考：<a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1">latin1</a>, <a href="https://zh.wikipedia.org/wiki/UTF-8">utf8</a>, <code>utf8mb4</code> 与 <code>utf8</code> 区别可以参考 <a href="https://my.oschina.net/xsh1208/blog/1052781">https://my.oschina.net/xsh1208/blog/1052781</a></p></blockquote><p>修改它们</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> character_set_client <span class="hljs-operator">=</span> utf8mb4;<br><span class="hljs-keyword">set</span> character_set_connection <span class="hljs-operator">=</span> utf8mb4;<br><span class="hljs-keyword">set</span> character_set_database <span class="hljs-operator">=</span> utf8mb4;<br><span class="hljs-keyword">set</span> character_set_filesystem <span class="hljs-operator">=</span> utf8mb4;<br><span class="hljs-keyword">set</span> character_set_results <span class="hljs-operator">=</span> utf8mb4;<br><span class="hljs-keyword">set</span> character_set_server <span class="hljs-operator">=</span> utf8mb4;<br></code></pre></td></tr></table></figure><p>然后再次尝试插入中文数据，好像还是不行呀，怎么办呢？实际上上面修改的是数据库默认的编码格式，对于已经存在的表和列并未生效</p><p>查看一下数据表编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Table</th><th>Crate Table</th></tr></thead><tbody><tr><td>user</td><td><code>CREATE TABLE user ( id bigint(20) NOT NULL COMMENT &#39;编号&#39;, name varchar(20) NOT NULL COMMENT &#39;名字&#39;, sex tinyint(1) DEFAULT NULL COMMENT &#39;性别&#39;, age int(11) DEFAULT NULL COMMENT &#39;年龄&#39; ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;用户&#39;</code></td></tr></tbody></table><p>查看全部列编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> columns <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Field</th><th>Type</th><th>Collation</th><th>Null</th><th>Key</th><th>Default</th><th>Extra Privileges</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>bigint(20)</td><td>null</td><td>NO</td><td>“”</td><td>“”</td><td>select,insert,update,references</td><td>编号</td></tr><tr><td>name</td><td>varchar(20)</td><td>utf8_general_ci</td><td>NO</td><td>“”</td><td>“”</td><td>select,insert,update,references</td><td>名字</td></tr><tr><td>sex</td><td>tinyint(1)</td><td>null</td><td>YES</td><td>“”</td><td>“”</td><td>select,insert,update,references</td><td>性别</td></tr><tr><td>age</td><td>int(11)</td><td>null</td><td>YES</td><td>“”</td><td>“”</td><td>select,insert,update,references</td><td>年龄</td></tr></tbody></table><p>现在有两个选择</p><ul><li>删除数据库重新建一个，数据库的编码格式就默认是 utf8mb4 了</li><li>手动修改数据库，数据表，字段的编码方式</li></ul><ol><li> 删除重建数据库的话只需要将数据库导出 sql 脚本，然后重新执行即可（如果存在很多数据/数据库正在使用则此方法不适用）</li><li>手动修改编码<ol><li>修改数据库编码 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> database <span class="hljs-operator">&lt;</span>db_name<span class="hljs-operator">&gt;</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8mb4;<br></code></pre></td></tr></table></figure></li><li>修改数据表编码 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">&lt;</span>table_name<span class="hljs-operator">&gt;</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8mb4;<br></code></pre></td></tr></table></figure></li><li>修改字段编码 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>table_name<span class="hljs-operator">&gt;</span> MODIFY <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>field_name<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>field_type<span class="hljs-operator">&gt;</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure>那么，关于 MySQL 不能插入中文数据的问题就到这里啦</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8 函数式功能速查</title>
    <link href="/p/09d35ae510984c72bdc5a745c2c3f473/"/>
    <url>/p/09d35ae510984c72bdc5a745c2c3f473/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时候使用 <code>lambda</code> 参数的时候忘记应该接口的名字，所以便在此写一下 Java8<br><code>function</code> 包下原生的相关接口，方便快速查找。</p><h2 id="lambda-接口"><a href="#lambda-接口" class="headerlink" title="lambda 接口"></a>lambda 接口</h2><table><thead><tr><th>class</th><th>参数</th><th>返回值</th><th><code>Stream</code> 示例</th><th>应用场景</th></tr></thead><tbody><tr><td><code>Function</code></td><td><code>&lt;T&gt;</code></td><td><code>&lt;R&gt;</code></td><td><code>map/flatMap</code></td><td>映射</td></tr><tr><td><code>Consumer</code></td><td><code>&lt;T&gt;</code></td><td><code>void</code></td><td><code>forEach/peek</code></td><td>迭代</td></tr><tr><td><code>Predicate</code></td><td><code>&lt;T&gt;</code></td><td><code>boolean</code></td><td><code>filter/anyMatch</code></td><td>过滤</td></tr><tr><td><code>Supplier</code></td><td></td><td><code>&lt;R&gt;</code></td><td><code>generate</code></td><td>生成</td></tr><tr><td><code>BiFunction</code></td><td><code>&lt;U,T&gt;</code></td><td><code>&lt;T&gt;</code></td><td><code>reduce</code></td><td>归纳</td></tr><tr><td><code>UnaryOperator</code></td><td><code>&lt;T&gt;</code></td><td><code>&lt;T&gt;</code></td><td><code>iterate</code></td><td>映射相同类型</td></tr><tr><td><code>BinaryOperator</code></td><td><code>&lt;T,T&gt;</code></td><td><code>&lt;T&gt;</code></td><td><code>reduce</code></td><td>归纳相同类型</td></tr><tr><td><code>Comparator</code></td><td><code>&lt;T,T&gt;</code></td><td><code>&lt;U&gt;</code></td><td><code>sort</code></td><td>比较</td></tr></tbody></table><h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><p>Stream 流为我们提供了一种简单的操作集合的方式，每个操作都具有原子性。</p><table><thead><tr><th>function</th><th>参数</th><th>返回值</th><th>功能</th></tr></thead><tbody><tr><td><code>filter</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>过滤</td></tr><tr><td><code>map</code></td><td><code>Function&lt;T,T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>映射</td></tr><tr><td><code>flatMap</code></td><td><code>Function&lt;T,Stream&lt;T&gt;&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>压平映射</td></tr><tr><td><code>distinct</code></td><td></td><td><code>Stream&lt;T&gt;</code></td><td>去重</td></tr><tr><td><code>sorted</code></td><td></td><td><code>Stream&lt;T&gt;</code></td><td>排序, 要求 <code>T</code> 实现 <code>Closeable</code></td></tr><tr><td><code>sorted</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>排序</td></tr><tr><td><code>peek</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>迭代，但有返回值</td></tr><tr><td><code>limit</code></td><td><code>long</code></td><td><code>Stream&lt;T&gt;</code></td><td>限制数量</td></tr><tr><td><code>skip</code></td><td><code>long</code></td><td><code>Stream&lt;T&gt;</code></td><td>从开头丢弃指定数量的元素</td></tr><tr><td><code>forEach</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>void</code></td><td>迭代</td></tr><tr><td><code>forEachOrdered</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>void</code></td><td>保证顺序的迭代</td></tr><tr><td><code>toArray</code></td><td></td><td><code>Object[]</code></td><td>转换为数组</td></tr><tr><td><code>toArray</code></td><td><code>IntFunction&lt;T[]&gt;</code></td><td><code>T[]</code></td><td>转换为指定类型的数组</td></tr><tr><td><code>reduce</code></td><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>Optional&lt;T&gt;</code></td><td>归纳为一个元素</td></tr><tr><td><code>collect</code></td><td><code>Collector&lt;T,A,R&gt;</code></td><td><code>R</code></td><td>将结果归集</td></tr><tr><td><code>min</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>Optional&lt;T&gt;</code></td><td>最小值</td></tr><tr><td><code>max</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>Optional&lt;T&gt;</code></td><td>最大值</td></tr><tr><td><code>count</code></td><td></td><td><code>long</code></td><td>长度</td></tr><tr><td><code>anyMatch</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>boolean</code></td><td>是否存在匹配的元素</td></tr><tr><td><code>allMatch</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>boolean</code></td><td>是否所有元素都匹配</td></tr><tr><td><code>noneMatch</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>boolean</code></td><td>是否所有元素都不匹配</td></tr><tr><td><code>findFirst</code></td><td></td><td><code>Optional&lt;T&gt;</code></td><td>查找第一个元素</td></tr><tr><td><code>findAny</code></td><td></td><td><code>Optional&lt;T&gt;</code></td><td>查找任意一个元素</td></tr><tr><td><code>empty</code></td><td></td><td><code>Stream&lt;T&gt;</code></td><td>获取一个空的流</td></tr><tr><td><code>of</code></td><td><code>T...</code></td><td><code>Stream&lt;T&gt;</code></td><td>将多个元素构造为流</td></tr><tr><td><code>iterate</code></td><td><code>T,UnaryOperator&lt;T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>构造无限有序流</td></tr><tr><td><code>generate</code></td><td><code>Supplier</code></td><td><code>Stream&lt;T&gt;</code></td><td>构造无限无序流</td></tr><tr><td><code>concat</code></td><td><code>Stream&lt;T&gt;,Stream&lt;T&gt;</code></td><td><code>Stream&lt;T&gt;</code></td><td>连接两个流</td></tr><tr><td><code>parallel</code></td><td></td><td><code>Stream&lt;T&gt;</code></td><td>将流转换为并行模式（多线程）</td></tr></tbody></table><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 是一个 Java8 增加的一个工具类，用于简单的构造 <code>Collector</code> 接口的实现，主要用于 <code>Stream.collect()</code> 中的参数。<code>Stream.collect()</code> 用于将流转换为其他的数据结构，包括但不限于 <code>Collection</code>, <code>Map</code>, <code>String</code>, <code>Long</code> 等等，并以此衍生出了许多有用的操作：分组，转换为 <code>Map</code>，归约（<code>reduce</code> 的另一种使用方式），连接（归约的特化形式）</p><table><thead><tr><th>function</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>toList</code></td><td>转换为 <code>List</code></td><td></td></tr><tr><td><code>toSet</code></td><td>转换为 <code>Set</code></td><td></td></tr><tr><td><code>toMap</code></td><td>转换为 <code>Map</code></td><td></td></tr><tr><td><code>toCollection</code></td><td>转换为 <code>Collection</code> 的子类</td><td></td></tr><tr><td><code>joining</code></td><td>所有元素连接为 <code>String</code>, 可以指定<strong>分隔符/开头/结尾</strong></td><td></td></tr><tr><td><code>mapping</code></td><td>在转换之前对每个元素进行映射，常用于分组</td><td></td></tr><tr><td><code>collectingAndThen</code></td><td>在转为之前对结果进行一些操作，例如构造不可变集合</td><td></td></tr><tr><td><code>counting</code></td><td>计算元素总数</td><td></td></tr><tr><td><code>minBy</code></td><td>最小值</td><td></td></tr><tr><td><code>maxBy</code></td><td>最大值</td><td></td></tr><tr><td><code>summingInt</code></td><td>计算总和（结果为 <code>Integer</code>）</td><td></td></tr><tr><td><code>summingLong</code></td><td>计算总和（结果为 <code>Long</code>）</td><td></td></tr><tr><td><code>summingDouble</code></td><td>计算总和（结果为 <code>Double</code>）</td><td></td></tr><tr><td><code>averagingInt</code></td><td>计算平均值（结果为 <code>Integer</code>）</td><td></td></tr><tr><td><code>averagingLong</code></td><td>计算平均值（结果为 <code>Long</code>）</td><td></td></tr><tr><td><code>averagingDouble</code></td><td>计算平均值（结果为 <code>Double</code>）</td><td></td></tr><tr><td><code>reducing</code></td><td>归纳, 与 <code>Stream.reduce()</code> 功能相同</td><td></td></tr><tr><td><code>groupingBy</code></td><td>分组, <code>Collectors</code> 独有</td><td></td></tr><tr><td><code>groupingByConcurrent</code></td><td>并发分组</td><td></td></tr><tr><td><code>partitioningBy</code></td><td>特化分组, 分成 <code>true</code> 和 <code>false</code></td><td></td></tr><tr><td><code>toMap</code></td><td>转换为 <code>Map</code></td><td></td></tr><tr><td><code>toConcurrentMap</code></td><td>转换为并发 <code>Map</code></td><td></td></tr><tr><td><code>summarizingInt</code></td><td>汇总信息并尽可能返回 <code>Integer</code>。注: <code>summarizing*</code> 的方法汇总的信息都是 <strong>数量/求和/平均值/最小值/最大值</strong></td><td></td></tr><tr><td><code>summarizingLong</code></td><td>汇总信息并尽可能返回 <code>Long</code></td><td></td></tr><tr><td><code>summarizingDouble</code></td><td>汇总信息并尽可能返回 <code>Double</code></td><td></td></tr></tbody></table><h2 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h2><h3 id="常见-Stream-操作"><a href="#常见-Stream-操作" class="headerlink" title="常见 Stream 操作"></a>常见 Stream 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> List&lt;String&gt; collect = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;321&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-comment">//过滤</span><br>                .filter(s -&gt; !s.isEmpty())<br>                <span class="hljs-comment">//提取出组成字符串的字符</span><br>                .flatMap(s -&gt; Arrays.stream(s.split(<span class="hljs-string">&quot;&quot;</span>)))<br>                <span class="hljs-comment">//去重</span><br>                .distinct()<br>                <span class="hljs-comment">//转换为集合</span><br>                .collect(Collectors.toList());<br>System.out.println(collect); <span class="hljs-comment">//结果是 [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="常见-Collectors-操作"><a href="#常见-Collectors-操作" class="headerlink" title="常见 Collectors 操作"></a>常见 Collectors 操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt; collect = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;13&quot;</span>, <span class="hljs-string">&quot;321&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        .collect(<br>                <span class="hljs-comment">//分组</span><br>                Collectors.groupingBy(<br>                        <span class="hljs-comment">//分组条件</span><br>                        String::length,<br>                        <span class="hljs-comment">//分组之前对每个元素进行映射</span><br>                        Collectors.mapping(<br>                                <span class="hljs-comment">//映射函数</span><br>                                s -&gt; Arrays.asList(s.split(<span class="hljs-string">&quot;&quot;</span>)),<br>                                <span class="hljs-comment">//最后将 Stream 转换为 List</span><br>                                Collectors.toList()<br>                        )<br>                )<br>        );<br>System.out.println(collect); <span class="hljs-comment">//结果是 &#123;0=[[], []], 1=[[1], [2]], 2=[[1, 2], [1, 3]], 3=[[1, 2, 3], [3, 2, 1]]&#125;</span><br></code></pre></td></tr></table></figure><hr><p>最后，Java8 有很多有趣的功能，或许我们所使用的不过是其中一个很小的子集，然而了解的越多越是觉得 Java8 的改进很多呢</p><blockquote><p>注：本文并非 <code>API</code> 列表，并未包含<strong>全部</strong>的功能，所以如果找不到所需要的函数可以查看 <a href="https://docs.oracle.com/javase/8/">JDK8 Oracle Documentation</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Java8 新的时间 API</title>
    <link href="/p/12d510588aee423d8bd1ac24ecc6925a/"/>
    <url>/p/12d510588aee423d8bd1ac24ecc6925a/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java8 面世以来已经 6 年了，许多人也开始使用起了 <code>lambda</code>,<code>Stream&lt;T&gt;</code>,<code>Optional&lt;T&gt;</code> 之类的新的语言特性，然而对于 Java8 提供的新的时间 <code>API</code> 虽然据说比旧版本的 <code>Date</code> 好很多，但并没有得到完全的使用。一方面是为了兼容旧的系统，另一方面 Java8 的时间 API 似乎太过于强大了，让人有些不知所措，不知道应该从何下手。再加上因为对 <code>Date</code>,<code>Calendar</code> 的熟悉，此消彼长之下自然是懒得去修改了。</p><p>其实对于时间 API，大致的需求是一样的</p><ul><li>创建/修改/比较/转换简单</li><li>对遗留系统的时间可以集成/转换</li><li>主流框架对其要有支持</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="常用的类"><a href="#常用的类" class="headerlink" title="常用的类"></a>常用的类</h3><ul><li><a href="#LocalDate">LocalDate</a>: 日期的不可变类</li><li><a href="#LocalTime">LocalTime</a>: 时间的不可变类</li><li><a href="#LocalDateTime">LocalDateTime</a>: 日期时间的不可变类</li><li><a href="#OffsetDateTime">OffsetDateTime</a>: 偏移标准 UTC 时间的日期时间不可变类</li><li><a href="#Temporal/TemporalAccessor">Temporal/TemporalAccessor</a>: 上面几个时间类的基类</li><li><a href="#Period">Period</a>: 计算日期差值</li><li><a href="#Duration">Duration</a>: 计算日期时间差值</li><li><a href="#TemporalField/ChronoField">ChronoField/TemporalField</a>: 时间的单位</li><li><a href="#TemporalUnit/ChronoUnit">ChronoUnit/TemporalUnit</a>: 根据指定的单位计算时间</li><li><a href="#DateTimeFormatter">DateTimeFormatter</a>: 时间格式化</li><li><a href="#%E5%85%BC%E5%AE%B9-Date">兼容 Date</a>: 兼容旧的 Date 类</li></ul><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>一个不可变（线程安全）的日期对象，用且表示 <em>年-月-日</em> 的时间，默认 <code>toString()</code> 格式是 <code>yyyy-MM-dd</code>。</p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取当前的日期</span><br><span class="hljs-keyword">final</span> LocalDate now = LocalDate.now();<br><span class="hljs-comment">//toString 一下日期</span><br><span class="hljs-comment">//会得到 yyyy-MM-dd 格式</span><br>System.out.println(<span class="hljs-string">&quot;现在：&quot;</span> + now);<br><span class="hljs-comment">//1 天后的日期</span><br><span class="hljs-keyword">final</span> LocalDate localDatePlusDayOne = now.plusDays(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;一天后：&quot;</span> + localDatePlusDayOne);<br><span class="hljs-comment">//一天前的日期</span><br><span class="hljs-keyword">final</span> LocalDate localDateMinusDayOne = now.minusDays(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;一天前：&quot;</span> + localDateMinusDayOne);<br><span class="hljs-comment">//比较两个日期/时间的大小</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nowEvenBigger = now.compareTo(localDatePlusDayOne);<br>System.out.println(<span class="hljs-string">&quot;当前时间更大么？&quot;</span> + nowEvenBigger);<br><span class="hljs-comment">//获取指定单位的日期（年/月/日/星期）</span><br><span class="hljs-comment">//获取当前月的时间</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dayOfMonth = now.getDayOfMonth();<br>System.out.println(<span class="hljs-string">&quot;当前月的天数：&quot;</span> + dayOfMonth);<br><span class="hljs-comment">//更加通用获取方式</span><br><span class="hljs-comment">//使用枚举类 ChronoField</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dayOfMonthForChronoField = now.get(ChronoField.DAY_OF_MONTH);<br>System.out.println(<span class="hljs-string">&quot;当前月的天数（通过 get() 获取）：&quot;</span> + dayOfMonthForChronoField);<br><span class="hljs-comment">//比较两个日期的差值</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> between = ChronoUnit.DAYS.between(now, localDatePlusDayOne);<br>System.out.println(between);<br></code></pre></td></tr></table></figure><p>上面有些地方看不太懂不碍事，先过一遍，下面对其中的部分代码会有解释</p><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>一个不可变的（线程安全）的时间对象，用于表示 <em>时：分：秒：毫秒</em> 的时间，默认 <code>toString()</code> 格式是 <code>hh:mm:ss.SSS</code>。</p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得当前时间</span><br><span class="hljs-keyword">final</span> LocalTime now = LocalTime.now();<br><span class="hljs-comment">//默认格式 hh:mm:ss.SSS</span><br>System.out.println(<span class="hljs-string">&quot;现在：&quot;</span> + now);<br><span class="hljs-comment">//一个小时后的时间</span><br><span class="hljs-keyword">final</span> LocalTime localTimePlusHourOne = now.plusHours(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;一小时后：&quot;</span> + localTimePlusHourOne);<br><span class="hljs-comment">//一分钟前的时间</span><br><span class="hljs-keyword">final</span> LocalTime localTimeMinusMinuteOne = now.minusMinutes(<span class="hljs-number">1</span>);<br>System.out.println(localTimeMinusMinuteOne);<br><span class="hljs-comment">//比较时间大小（实现了 Comparable 接口）</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nowEvenBigger = now.compareTo(localTimeMinusMinuteOne);<br>System.out.println(<span class="hljs-string">&quot;当前时间更大么？&quot;</span> + nowEvenBigger);<br><span class="hljs-comment">//获取指定单位的时间</span><br><span class="hljs-comment">//当前小时数</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hour = now.getHour();<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数：&quot;</span> + hour);<br><span class="hljs-comment">//使用枚举类 ChronoField 获取</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hourOfDay = now.get(ChronoField.HOUR_OF_DAY);<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数（通过 get() 获取）：&quot;</span> + hourOfDay);<br><span class="hljs-comment">//比较两个日期的差值</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> between = ChronoUnit.HOURS.between(now, localTimePlusHourOne);<br>System.out.println(between);<br></code></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>不可变的日期时间对象，用于表示 <em>日-月-年 时：分：秒：毫秒</em> 的日期时间，默认格式化格式是 <code>yyyy-MM-ddThh:mm:ss.SSS</code>。</p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前日期时间</span><br><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-comment">//默认格式 yyyy-MM-ddThh:mm:ss.SSS</span><br>System.out.println(<span class="hljs-string">&quot;现在：&quot;</span> + now);<br><span class="hljs-comment">//一个小时后的时间</span><br><span class="hljs-keyword">final</span> LocalDateTime localTimePlusHourOne = now.plusHours(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;一小时后：&quot;</span> + localTimePlusHourOne);<br><span class="hljs-comment">//一分钟前的时间</span><br><span class="hljs-keyword">final</span> LocalDateTime localTimeMinusMinuteOne = now.minusMinutes(<span class="hljs-number">1</span>);<br>System.out.println(localTimeMinusMinuteOne);<br><span class="hljs-comment">//比较时间大小（实现了 Comparable 接口）</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nowEvenBigger = now.compareTo(localTimeMinusMinuteOne);<br>System.out.println(<span class="hljs-string">&quot;当前时间更大么？&quot;</span> + nowEvenBigger);<br><span class="hljs-comment">//获取指定单位的时间</span><br><span class="hljs-comment">//当前小时数</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hour = now.getHour();<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数：&quot;</span> + hour);<br><span class="hljs-comment">//使用枚举类 ChronoField 获取</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hourOfDay = now.get(ChronoField.HOUR_OF_DAY);<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数（通过 get() 获取）：&quot;</span> + hourOfDay);<br><span class="hljs-comment">//比较两个日期的差值</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> between = ChronoUnit.HOURS.between(now, localTimePlusHourOne);<br>System.out.println(between);<br><span class="hljs-comment">//获取一天的开始和结束</span><br><span class="hljs-keyword">final</span> LocalDateTime start = LocalDateTime.of(yesterday, LocalTime.MIN);<br><span class="hljs-keyword">final</span> LocalDateTime end = LocalDateTime.of(yesterday, LocalTime.MAX);<br>System.out.println(start);<br>System.out.println(end);<br></code></pre></td></tr></table></figure><p>可以看到，和上面的 <a href="#LocalTime">LocalTime</a> 除了类型不同外，代码是完全相同的，因为 <a href="#LocalDateTime">LocalDateTime</a> 是包含 <a href="#LocalDate">LocalDate</a> 与 <a href="#LocalTime">LocalTime</a> 的。在源码中也可以看到其包含了两个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取日期/时间对象</span><br><span class="hljs-keyword">final</span> LocalDate localDate = now.toLocalDate();<br><span class="hljs-keyword">final</span> LocalTime localTime = now.toLocalTime();<br>System.out.println(<span class="hljs-string">&quot;当前日期：&quot;</span> + localDate);<br>System.out.println(<span class="hljs-string">&quot;当前时间：&quot;</span> + localTime);<br></code></pre></td></tr></table></figure><h3 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h3><p>代表偏移标准 UTC 时间的日期时间不可变对象，用于表示 _日-月-年 时：分：秒：毫秒时区_，默认格式是 <code>yyyy-MM-ddThh:mm:ss.SSSZoneId</code></p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前偏移的日期时间</span><br><span class="hljs-keyword">final</span> OffsetDateTime now = OffsetDateTime.now();<br>System.out.println(now);<br><span class="hljs-comment">//其实个人感觉就是多了一个时区</span><br><span class="hljs-comment">//获取到时区</span><br>ZoneId zone = now.toZonedDateTime().getZone();<br>System.out.println(zone);<br><span class="hljs-comment">//转换时区</span><br>ZonedDateTime zonedDateTime = now.atZoneSameInstant(ZoneId.of(<span class="hljs-string">&quot;+00:00&quot;</span>));<br>System.out.println(zonedDateTime);<br><span class="hljs-comment">//其他基本操作和上面的差不多，就不啰嗦啦</span><br></code></pre></td></tr></table></figure><h3 id="Temporal-TemporalAccessor"><a href="#Temporal-TemporalAccessor" class="headerlink" title="Temporal/TemporalAccessor"></a>Temporal/TemporalAccessor</h3><p>上面的 <a href="#LocalDate">LocalDate</a>, <a href="#LocalTime">LocalTime</a>, <a href="#LocalDateTime">LocalDateTime</a>, <a href="#OffsetDateTime">OffsetDateTime</a> 的基类，并定义了一系列非常通用的方法</p><ul><li>minus: 减少时间</li><li>plus: 增加时间</li><li>with: 获取时间指定单位的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-comment">//获取上个星期</span><br><span class="hljs-keyword">final</span> LocalDateTime lastWeek = now.minus(<span class="hljs-number">1</span>, ChronoUnit.WEEKS);<br><span class="hljs-comment">//获取下个月</span><br><span class="hljs-keyword">final</span> LocalDateTime nextMonth = now.plus(<span class="hljs-number">1</span>, ChronoUnit.MONTHS);<br><span class="hljs-comment">//获取当前是今年的第几个星期</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> weekValue = now.get(ChronoField.ALIGNED_WEEK_OF_YEAR);<br><span class="hljs-comment">//获取这周星期一的时间</span><br><span class="hljs-keyword">final</span> LocalDateTime nowOfMonday = now.with(DayOfWeek.MONDAY);<br><span class="hljs-keyword">final</span> LocalDateTime nowOfMonday2 = now.with(ChronoField.DAY_OF_WEEK, <span class="hljs-number">1</span>);<br>System.out.println(<br>    <span class="hljs-string">&quot;lastWeek: &quot;</span> + lastWeek<br>        + <span class="hljs-string">&quot;\nnextMonth: &quot;</span> + nextMonth<br>        + <span class="hljs-string">&quot;\nweekValue: &quot;</span> + weekValue<br>        + <span class="hljs-string">&quot;\nnowOfMonday: &quot;</span> + nowOfMonday<br>        + <span class="hljs-string">&quot;\nnowOfMonday2: &quot;</span> + nowOfMonday2<br>);<br></code></pre></td></tr></table></figure><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>代表两个日期的差值，默认 <code>toString()</code> 格式是 <code>P([时间][单位])*</code></p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDate now = LocalDate.now();<br><span class="hljs-keyword">final</span> LocalDate localTimePlusMonthOne = now.plusDays(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//计算相差的时间</span><br><span class="hljs-keyword">final</span> Period betweenForDay = Period.between(now, localTimePlusMonthOne);<br><span class="hljs-comment">//获取相差的天数</span><br>System.out.println(<span class="hljs-string">&quot;相差的天数：&quot;</span> + betweenForDay.getDays());<br><span class="hljs-comment">//使用 get() 方法获取通用的相差的天数</span><br>System.out.println(<span class="hljs-string">&quot;相差的天数(使用 get() 获取)：&quot;</span> + betweenForDay.get(ChronoUnit.DAYS));<br><span class="hljs-comment">//对相差的日期减去一天并判断是否为 0</span><br>System.out.println(<span class="hljs-string">&quot;相差的日期减去 1 天是不是就相同了呢？&quot;</span> + betweenForDay.minusDays(<span class="hljs-number">1</span>).isZero());<br></code></pre></td></tr></table></figure><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>代表两个日期时间的差值，默认 <code>toString()</code> 格式是 <code>PT([时间][单位])*</code></p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-keyword">final</span> LocalDateTime localDateTimeForPlusHourOne = now.plusHours(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//计算两个时间的差值</span><br><span class="hljs-keyword">final</span> Duration between = Duration.between(now, localDateTimeForPlusHourOne);<br><span class="hljs-comment">//默认格式是 PT 时间 单位</span><br>System.out.println(<span class="hljs-string">&quot;相差的时间：&quot;</span> + between);<br><span class="hljs-comment">//获取日期</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> betweenSeconds = between.getSeconds();<br>System.out.println(<span class="hljs-string">&quot;相差的时间（/秒）：&quot;</span> + betweenSeconds);<br><span class="hljs-comment">//根据指定单位获取相差时间的大小</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> betweenSecondsForGet = between.get(ChronoUnit.SECONDS);<br>System.out.println(<span class="hljs-string">&quot;相差的时间（/秒）：&quot;</span> + betweenSecondsForGet);<br><span class="hljs-comment">//转换成毫秒</span><br>System.out.println(<span class="hljs-string">&quot;相差的时间（/毫秒）：&quot;</span> + between.toMillis());<br><span class="hljs-comment">//获取相差时间支持的单位列表（其实感觉上没太大意义）</span><br><span class="hljs-keyword">final</span> List&lt;TemporalUnit&gt; temporalUnitList = between.getUnits();<br>System.out.println(<span class="hljs-string">&quot;相差的时间列表：&quot;</span> + temporalUnitList);<br><span class="hljs-comment">//在创建一个时间差</span><br><span class="hljs-keyword">final</span> Duration betweenForMinutes = Duration.between(now, now.minusMinutes(<span class="hljs-number">100</span>));<br><span class="hljs-comment">//判断两个时间差哪个更大</span><br>System.out.println(<span class="hljs-string">&quot;between 的时间差更大么？&quot;</span> + between.compareTo(betweenForMinutes));<br><span class="hljs-comment">//获取绝对值</span><br>System.out.println(<span class="hljs-string">&quot;相差的绝对时间：&quot;</span> + betweenForMinutes.abs());<br></code></pre></td></tr></table></figure><h3 id="TemporalField-ChronoField"><a href="#TemporalField-ChronoField" class="headerlink" title="TemporalField/ChronoField"></a>TemporalField/ChronoField</h3><p>日期/时间单位字段，TemporalField 是接口，ChronoField 则是实现类。</p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-keyword">final</span> ChronoField hourOfDay = ChronoField.HOUR_OF_DAY;<br>System.out.println(hourOfDay);<br><span class="hljs-comment">//获取当前小时数</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowForHours = hourOfDay.getFrom(now);<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数：&quot;</span> + nowForHours);<br><span class="hljs-comment">//获取到指定单位的时间大小</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hoursForGet = now.get(ChronoField.HOUR_OF_DAY);<br>System.out.println(<span class="hljs-string">&quot;当前时间的小时数（get()）：&quot;</span> + hoursForGet);<br><span class="hljs-comment">//获取到特定单位的时间对比对象 Duration</span><br><span class="hljs-keyword">final</span> TemporalUnit baseUnit = hourOfDay.getBaseUnit();<br>System.out.println(baseUnit);<br></code></pre></td></tr></table></figure><h3 id="TemporalUnit-ChronoUnit"><a href="#TemporalUnit-ChronoUnit" class="headerlink" title="TemporalUnit/ChronoUnit"></a>TemporalUnit/ChronoUnit</h3><p>也是时间单位，TemporalUnit 是接口，ChronoUnit 则是实现类。和上面的不同的地方在于上面的不能 ChronoField 不能对时间进行对比差值，只能根据指定单位获取时间的大小。</p><p>基本操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取一个小时数</span><br><span class="hljs-keyword">final</span> ChronoUnit chronoUnit = ChronoUnit.MILLIS;<br>System.out.println(chronoUnit);<br><span class="hljs-comment">//获取两个时间的差值毫秒数</span><br><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-keyword">final</span> LocalDateTime localDateTimePlusHourOne = now.plusHours(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> betweenForMillis = chronoUnit.between(now, localDateTimePlusHourOne);<br>System.out.println(<span class="hljs-string">&quot;相差的毫秒数：&quot;</span> + betweenForMillis);<br><span class="hljs-comment">//根据指定的单位修改时间也需要使用这个</span><br><span class="hljs-keyword">final</span> LocalDateTime localDateTimePlusMinuteOne = now.plus(<span class="hljs-number">1</span>, ChronoUnit.MINUTES);<br>System.out.println(<span class="hljs-string">&quot;一分钟后的时间：&quot;</span> + localDateTimePlusMinuteOne);<br></code></pre></td></tr></table></figure><h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><p>日期时间格式化类，基本上没什么好说的（标准的格式化一般就足够了，毕竟显示是前端的事情，而标准的格式化确实是国际标准呢）</p><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取一个标准 iso 日期时间格式化对象</span><br><span class="hljs-keyword">final</span> DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME;<br>System.out.println(dateTimeFormatter);<br><span class="hljs-comment">//格式化日期时间</span><br><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br>System.out.println(<span class="hljs-string">&quot;当前日期时间：&quot;</span> + dateTimeFormatter.format(now));<br><span class="hljs-comment">//根据自定义的格式格式化时间</span><br><span class="hljs-keyword">final</span> DateTimeFormatter customDateTimeFormatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 hh时mm分ss秒&quot;</span>);<br>System.out.println(customDateTimeFormatter.format(now));<br></code></pre></td></tr></table></figure><h3 id="兼容-Date"><a href="#兼容-Date" class="headerlink" title="兼容 Date"></a>兼容 Date</h3><p>使用新的时间 API 固然很令人舒服，但有时候不得不兼容旧的 Date 类型，这时候如何转换就很重要了呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime now = LocalDateTime.now();<br><span class="hljs-comment">//转换为 Instant（包括时区）</span><br><span class="hljs-keyword">final</span> Instant instant = now.toInstant(ZoneOffset.UTC);<br>System.out.println(instant);<br><span class="hljs-comment">//转换为 Date</span><br><span class="hljs-keyword">final</span> Date date = Date.from(instant);<br>System.out.println(<span class="hljs-string">&quot;当前时间：&quot;</span> + date);<br><span class="hljs-comment">//转换为 Instant</span><br><span class="hljs-keyword">final</span> Instant dateToInstant = date.toInstant();<br>System.out.println(<span class="hljs-string">&quot;两次转换后的时间还是相同的吧？&quot;</span> + dateToInstant.equals(instant));<br><span class="hljs-comment">//转换为 LocalDateTime</span><br><span class="hljs-keyword">final</span> ZoneId zoneId = ZoneId.systemDefault();<br><span class="hljs-keyword">final</span> LocalDateTime toLocalDateTime = LocalDateTime.ofInstant(dateToInstant, zoneId);<br>System.out.println(<span class="hljs-string">&quot;转换后的日期时间：&quot;</span> + toLocalDateTime);<br></code></pre></td></tr></table></figure><h2 id="主流框架支持"><a href="#主流框架支持" class="headerlink" title="主流框架支持"></a>主流框架支持</h2><p>现如今大部分的包应该都支持 Java8 时间 API 了吧</p><p>例如：</p><ul><li>Jackson：jackson-datatype-jsr310</li><li>Mybatis：mybatis-typehandlers-jsr310</li></ul><p>那么，关于 Java8 新的时间 API 的使用暂且到这里了，想到什么吾辈再补充啦（=´∇ ｀=）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB 用户认证及操作</title>
    <link href="/p/13b0e6026a7942c29c2784508bd77526/"/>
    <url>/p/13b0e6026a7942c29c2784508bd77526/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果还没有安装 MongoDB 可以参考：<a href="https://blog.rxliuli.com/p/424bf4e1/">Windows 下 MongoDB 便携版安装与初始化</a></p></blockquote><h2 id="启动-mongod-和-mongo-shell-服务"><a href="#启动-mongod-和-mongo-shell-服务" class="headerlink" title="启动 mongod 和 mongo shell 服务"></a>启动 <code>mongod</code> 和 <code>mongo shell</code> 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 mongodb 服务</span><br>mongod --port 27017 --dbpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\data&quot;</span> --logpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\log\mongodb.log&quot;</span><br><br><span class="hljs-comment"># 启动 mongo shell</span><br>mongo --port 27017<br></code></pre></td></tr></table></figure><blockquote><p>注：mongodb 的默认 port 就是 27017，所以也可以省略不写</p></blockquote><h2 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 admin 数据库</span><br>use admin;<br><span class="hljs-comment"># 创建用户 root, 密码是 root 的 admin 账号了</span><br>db.createUser(<br>  &#123;<br>    user: <span class="hljs-string">&quot;root&quot;</span>,<br>    <span class="hljs-built_in">pwd</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>    roles: [<br>      &#123;role: <span class="hljs-string">&quot;root&quot;</span>, db: <span class="hljs-string">&quot;admin&quot;</span>&#125;<br>    ]<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="验证用户登录"><a href="#验证用户登录" class="headerlink" title="验证用户登录"></a>验证用户登录</h2><ol><li> 重启一下 <code>mongod</code> 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里的 --auth 选项就代表着启用身份认证</span><br>mongod --auth --port 27017 --dbpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\data&quot;</span> --logpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\log\mongodb.log&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li> 测试 root 用户是否能正常登录</li></ol><ul><li>使用用户名/密码认证连接 mongodb<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里添加了 --authenticationDatabase 设置认证的数据库</span><br>mongo --port 27017 -u <span class="hljs-string">&quot;root&quot;</span> -p <span class="hljs-string">&quot;root&quot;</span> --authenticationDatabase <span class="hljs-string">&quot;admin&quot;</span><br></code></pre></td></tr></table></figure></li><li>连接到 mongo 客户端后验证<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongo --port 27017<br>use admin;<br>db.auth(<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 test 数据库</span><br>use <span class="hljs-built_in">test</span>;<br><span class="hljs-comment"># 创建用户 test, 密码是 test 的普通账号了</span><br><span class="hljs-comment"># 主要变化在于 role，修改为对数据库 [test] 拥有 [可读写] 权限</span><br>db.createUser(<br>  &#123;<br>    user: <span class="hljs-string">&quot;test&quot;</span>,<br>    <span class="hljs-built_in">pwd</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    roles: [<br>      &#123; role: <span class="hljs-string">&quot;readWrite&quot;</span>, db: <span class="hljs-string">&quot;yapi&quot;</span> &#125;<br>    ]<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>使用 test 这个普通用户在登陆后能看到的也只有自己的数据库呢（如果数据库存在的话）</p><h2 id="内建权限"><a href="#内建权限" class="headerlink" title="内建权限"></a>内建权限</h2><p>下面是一些常用的权限</p><ul><li>Read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li><li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profile</li><li>userAdmin：允许用户向 system.users 集合写入，可以找指定数据库里创建、删除和管理用户</li><li>clusterAdmin：只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</li><li>readAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限</li><li>dbAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限。</li><li>root：只在 admin 数据库中可用。超级账号，超级权限</li></ul><h2 id="使用-url-访问"><a href="#使用-url-访问" class="headerlink" title="使用 url 访问"></a>使用 url 访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 不使用用户认证<br>mongodb:&#x2F;&#x2F;ip:port&#x2F;db<br># 使用用户认证<br>mongodb:&#x2F;&#x2F;username:password@ip:port&#x2F;db<br></code></pre></td></tr></table></figure><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><ul><li><p>查看全局的所有账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use admin;<br>db.system.users.find().pretty()<br></code></pre></td></tr></table></figure></li><li><p>查看当前库下的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use admin;<br>show users;<br></code></pre></td></tr></table></figure><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2></li><li><p>追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给用户 test 追加新的权限</span><br>db.grantRolesToUser(<br>  <span class="hljs-string">&quot;test&quot;</span>,<br>  [&#123;role:<span class="hljs-string">&quot;readWrite&quot;</span>, db:<span class="hljs-string">&quot;test&quot;</span>&#125;]<br>)<br></code></pre></td></tr></table></figure></li><li><p>替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换用户 test 的权限</span><br>db.updateUser(<br>  <span class="hljs-string">&quot;test&quot;</span>,<br>  &#123;<br>    roles: [<br>      &#123;role:<span class="hljs-string">&quot;read&quot;</span>, db:<span class="hljs-string">&quot;test&quot;</span>&#125;<br>    ]<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2></li></ul><p>删除掉名为 test 的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">db.dropUser(<span class="hljs-string">&#x27;test&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 使用 Jackson 处理 Java8 时间 API</title>
    <link href="/p/1565309f51494388bba9991f593b3237/"/>
    <url>/p/1565309f51494388bba9991f593b3237/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在项目中的实体类里面使用了 <code>Java8</code> 新的时间 API，例如 <code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code> 等。然而在将这些时间类型的字段序列化返回到前端时，但格式却感觉有些异常。</p><p>嗯，大概就是下面这种样子的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dayOfMonth&quot;</span>: <span class="hljs-number">27</span>,<br>  <span class="hljs-attr">&quot;dayOfWeek&quot;</span>: <span class="hljs-string">&quot;MONDAY&quot;</span>,<br>  <span class="hljs-attr">&quot;dayOfYear&quot;</span>: <span class="hljs-number">239</span>,<br>  <span class="hljs-attr">&quot;month&quot;</span>: <span class="hljs-string">&quot;AUGUST&quot;</span>,<br>  <span class="hljs-attr">&quot;monthValue&quot;</span>: <span class="hljs-number">8</span>,<br>  <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">2018</span>,<br>  <span class="hljs-attr">&quot;hour&quot;</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">&quot;minute&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;nano&quot;</span>: <span class="hljs-number">370000000</span>,<br>  <span class="hljs-attr">&quot;second&quot;</span>: <span class="hljs-number">52</span>,<br>  <span class="hljs-attr">&quot;chronology&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;ISO&quot;</span>,<br>    <span class="hljs-attr">&quot;calendarType&quot;</span>: <span class="hljs-string">&quot;iso8601&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是什么鬼的格式。。。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改 <code>application.yml</code>，配置 <code>spring.jackson.serialization.write_dates_as_timestamps</code> 禁用 _打印日期为时间戳的功能_。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jackson:</span><br>    <span class="hljs-attr">serialization:</span><br>      <span class="hljs-attr">write_dates_as_timestamps:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>如此，在返回数据到前端的时候 SpringBoot 就会自动将日期格式化为 <code>yyyy-MM-ddThh:mm:ss</code></p><p>然而，如果我们想要在程序中手动的序列化日期怎么办呢？实际上也很简单，使用代码 <code>.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</code> 来禁止序列化时间为时间戳并注册 <code>jackson-datatype-jsr310</code> 中的 <code>JavaTimeModule</code> 模块。</p><p>下面是吾辈在项目里使用的一个全局 <code>ObjectMapper</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 提供一个全局可用的序列化 Bean</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectMapper OM = <span class="hljs-keyword">new</span> ObjectMapper()<br>        <span class="hljs-comment">//Date 对象的格式</span><br>        .setDateFormat(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>))<br>        <span class="hljs-comment">//禁止序列化值为 null 的属性</span><br>        .setSerializationInclusion(JsonInclude.Include.NON_NULL)<br>        <span class="hljs-comment">//禁止序列化时间为时间戳</span><br>        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>        .registerModules(<br>                <span class="hljs-comment">//注册 Jsr310（Java8 的时间兼容模块）</span><br>                <span class="hljs-keyword">new</span> JavaTimeModule(),<br>                <span class="hljs-comment">//序列化 Long 为 String</span><br>                <span class="hljs-keyword">new</span> SimpleModule()<br>                        <span class="hljs-comment">//大数字直接序列化为 String</span><br>                        .addSerializer(Long.class, ToStringSerializer.instance)<br>                        .addSerializer(Long.TYPE, ToStringSerializer.instance)<br>                        .addSerializer(<span class="hljs-keyword">long</span>.class, ToStringSerializer.instance)<br>                        .addSerializer(BigInteger.class, ToStringSerializer.instance)<br>                        <span class="hljs-comment">//大浮点数直接序列化为 String</span><br>                        .addSerializer(BigDecimal.class, <span class="hljs-keyword">new</span> JsonSerializer&lt;BigDecimal&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(BigDecimal value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                                gen.writeString(value.setScale(<span class="hljs-number">10</span>, BigDecimal.ROUND_HALF_UP).toPlainString());<br>                            &#125;<br>                        &#125;)<br>        )<br>        <span class="hljs-comment">//JSON 序列化移除 transient 修饰的 Page 无关紧要的返回属性(Mybatis Plus)</span><br>        .configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>那么，以上就是 SpringBoot 序列化 Java8 时间 API 的问题和解决方案啦 ヾ(@^▽^@)ノ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Mongo Data 使用</title>
    <link href="/p/18753b40bb754e94835d3c74acd4f997/"/>
    <url>/p/18753b40bb754e94835d3c74acd4f997/</url>
    
    <content type="html"><![CDATA[<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><p>本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。</p><ul><li>[x] Gradle</li><li>[x] SpringBoot</li><li>[x] MongoDB</li><li>[x] SpringBoot 集成 MongoDB</li></ul><blockquote><p>注：本文不谈 SpringBoot 如何整合 MongoDB，如果需要可以去吾辈的另一篇记录 <a href="https://blog.rxliuli.com/p/872037f5/">SpringBoot 整合 Mybatis Plus/MongoDB</a> 查看，并且本文以项目 <a href="https://github.com/rxliuli/spring-boot-mybatis-plus-mongo-example">spring-boot-mybatis-plus-mongo-example</a> 为基础作为说明。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>注：Spring Data MongoDB 是 Spring Data 的一部分，下面统一使用 MongoData 来称呼。</p></blockquote><h3 id="继承-MongoRepository-lt-T-ID-gt-使用命名方法"><a href="#继承-MongoRepository-lt-T-ID-gt-使用命名方法" class="headerlink" title="继承 MongoRepository&lt;T, ID&gt; 使用命名方法"></a>继承 MongoRepository&lt;T, ID&gt; 使用命名方法</h3><p>集成了 MongoData 之后，我们可以选择让 Dao 继承 <code>MongoRepository&lt;T, ID&gt;</code> 模板以获得通用方法，并且，可以通过特定方式的命名方法让 MongoData 来帮我们自动实现。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoLogRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">UserInfoLog</span>, <span class="hljs-title">Long</span>&gt;, <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 查询用户日志信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 查询的 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">UserInfoLog <span class="hljs-title">findUserInfoLogByIdEquals</span><span class="hljs-params">(Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法将会被 MongoData 自动实现，而我们做的只是让接口方法名符合 MongoData 的命名规范罢了。</p><p>这里来说明一下 <code>findUserInfoLogByIdEquals</code> 方法，将之拆分开来</p><ul><li><code>find</code>: 代表查询的意思，可以想象成 SQL 中的 <code>select</code></li><li><code>UserInfoLog</code>: 代表查询的类型，可以想象成 <code>select</code> 中的表名（非必须，默认为当前 <code>MongoRepository</code> 的实体泛型类）</li><li><code>By</code>: 代表着条件的开始，可以想象成 SQL 中的 <code>where</code></li><li><code>Id</code>: 代表着条件中的字段，可以想象成 <code>where</code> 下的条件字段名</li><li><code>Equals</code>: 代表条件的操作，可以想象成 <code>where</code> 下的条件操作，此处等价于 <code>=</code></li></ul><p>是的，MongoData 会自动根据方法名创建具体的实现，而我们要做的，仅仅是让方法名复合 MongoData 的规范而已。</p><p>甚至于，我们可以添加更多的条件，例如下面的 <code>findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据用户 id/记录时间/操作说明查询用户日志</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> userId  用户 id</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> logTime 记录时间</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> operate 操作说明</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 用户日志</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function">List&lt;UserInfoLog&gt; <span class="hljs-title">findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex</span><span class="hljs-params">(Long userId, LocalDateTime logTime, String operate)</span></span>;<br></code></pre></td></tr></table></figure><p>当吾辈第一次看到这么长的方法名时（是的，足足有 71 个字符组成），也只能惊呼：**Oh my Gad!**<br>这对业务层的调用实在是太过于痛苦了，尤其而且能逼死强迫症（例如吾辈），所以下面就说一种更加灵活的解决方案！</p><h3 id="使用-MongoOperations-创建更加灵活的查询"><a href="#使用-MongoOperations-创建更加灵活的查询" class="headerlink" title="使用 MongoOperations 创建更加灵活的查询"></a>使用 MongoOperations 创建更加灵活的查询</h3><p>修改 <code>UserInfoLogRepository</code> 并定义 <code>listByParam()</code> 以替代上面的 <code>findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据一些参数查询用户信息列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userInfoLog 参数对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建实现类 <code>UserInfoLogRepositoryImpl</code> 并实现 <code>listByParam()</code> 方法。这里注入 <code>MongoOperations</code> MongoDB 操作模板，它的实现类实际上是 <code>MongoTemplate</code>，然后使用 <code>Criteria</code> 定义复杂的查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoLogRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MongoOperations mongoOperations;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Criteria criteria = <span class="hljs-keyword">new</span> Criteria();<br>        <span class="hljs-keyword">if</span> (userInfoLog.getUserId() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;userId&quot;</span>)<br>                    .is(userInfoLog.getUserId());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getLogTime() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;logTime&quot;</span>)<br>                    .gte(userInfoLog.getLogTime());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getOperate() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;operate&quot;</span>)<br>                    .regex(userInfoLog.getOperate());<br>        &#125;<br>        <span class="hljs-keyword">return</span> mongoOperations.find(<span class="hljs-keyword">new</span> Query(criteria), UserInfoLog.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>listByParam()</code> 相对而言更加优雅，不过代码量上也有增加就是了。事实上，对于复杂的查询，最好使用这种方式进行查询。</p><h3 id="集合-MongoRepository-和-MongoOperations"><a href="#集合-MongoRepository-和-MongoOperations" class="headerlink" title="集合 MongoRepository 和 MongoOperations"></a>集合 MongoRepository 和 MongoOperations</h3><p>总之，上面两种方式各有优缺点。<code>MongoRepository</code> 对于大部分常见的操作基本都可以正常替代，而 <code>MongoOperations</code> 比之灵活得多，我们是否只能<strong>鱼与熊掌不可兼得</strong>呢？<br>当然不是，MongoData 在设计之初便充分权衡过方便与灵活性的平衡点，所以，我们可以同时使用它们！</p><p>具体使用步骤如下</p><h4 id="自定义更加复杂的-Dao-接口"><a href="#自定义更加复杂的-Dao-接口" class="headerlink" title="自定义更加复杂的 Dao 接口"></a>自定义更加复杂的 Dao 接口</h4><p>该接口定义需要自己实现的方法，需要同时被 <code>UserInfoLogRepository</code> 和 <code>UserInfoLogRepositoryImpl</code> 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据一些参数查询用户信息列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userInfoLog 参数对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定义一些简单操作的-Dao-接口"><a href="#定义一些简单操作的-Dao-接口" class="headerlink" title="定义一些简单操作的 Dao 接口"></a>定义一些简单操作的 Dao 接口</h4><p>注意，这里同时继承了 <code>CustomUserInfoLogRepository</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoLogRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">UserInfoLog</span>, <span class="hljs-title">Long</span>&gt;, <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 查询用户日志信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 查询的 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function">UserInfoLog <span class="hljs-title">findUserInfoLogByIdEquals</span><span class="hljs-params">(Long id)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户 id/记录时间/操作说明查询用户日志</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId  用户 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> logTime 记录时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operate 操作说明</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;UserInfoLog&gt; <span class="hljs-title">findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex</span><span class="hljs-params">(Long userId, LocalDateTime logTime, String operate)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定义实现-UserInfoLogRepositoryImpl-类"><a href="#定义实现-UserInfoLogRepositoryImpl-类" class="headerlink" title="定义实现 UserInfoLogRepositoryImpl 类"></a>定义实现 UserInfoLogRepositoryImpl 类</h4><p>数据仓库 <code>UserInfoLogRepository</code> 的实现类，但请务必注意，实现类继承的是 <code>CustomUserInfoLogRepository</code> 接口，而非本应该继承的接口。而且实现类的名字必须是基础接口名 + <code>Impl</code>，因为 MongoData 默认使用的实现类就是这个名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoLogRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MongoOperations mongoOperations;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Criteria criteria = <span class="hljs-keyword">new</span> Criteria();<br>        <span class="hljs-keyword">if</span> (userInfoLog.getUserId() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;userId&quot;</span>)<br>                    .is(userInfoLog.getUserId());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getLogTime() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;logTime&quot;</span>)<br>                    .gte(userInfoLog.getLogTime());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getOperate() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;operate&quot;</span>)<br>                    .regex(userInfoLog.getOperate());<br>        &#125;<br>        <span class="hljs-keyword">return</span> mongoOperations.find(<span class="hljs-keyword">new</span> Query(criteria), UserInfoLog.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><p>匹配标准：<code>Criteria</code></p><table><thead><tr><th>方法名</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>and</code></td><td><code>String</code></td><td>并且</td></tr><tr><td><code>not</code></td><td><code>/Object</code></td><td>非</td></tr><tr><td><code>orOperator</code></td><td><code>Criteria...</code></td><td>并且是其他标准</td></tr><tr><td><code>andOperator</code></td><td><code>Criteria...</code></td><td>并且是其他标准</td></tr><tr><td><code>is</code></td><td><code>Object</code></td><td>等于</td></tr><tr><td><code>ne</code></td><td><code>Object</code></td><td>不等于</td></tr><tr><td><code>le</code></td><td><code>Object</code></td><td>小于</td></tr><tr><td><code>let</code></td><td><code>Object</code></td><td>小于或等于</td></tr><tr><td><code>gt</code></td><td><code>Object</code></td><td>大于</td></tr><tr><td><code>gte</code></td><td><code>Object</code></td><td>大于或等于</td></tr><tr><td><code>in</code></td><td><code>Object.../Collection&lt;?&gt;</code></td><td>在其中</td></tr><tr><td><code>nin</code></td><td><code>Object.../Collection&lt;?&gt;</code></td><td>不在其中</td></tr><tr><td><code>mod</code></td><td><code>Number,Number</code></td><td>模运算</td></tr><tr><td><code>all</code></td><td><code>Object.../Collection&lt;?&gt;</code></td><td>包含全部</td></tr><tr><td><code>size</code></td><td><code>int</code></td><td>长度</td></tr><tr><td><code>exists</code></td><td><code>boolean</code></td><td>存在</td></tr><tr><td><code>type</code></td><td><code>int/Type...</code></td><td>结构化数据的类型</td></tr><tr><td><code>regex</code></td><td><code>String/String,String/Pattern</code></td><td>正则</td></tr><tr><td><code>alike</code></td><td><code>Example&lt;?&gt;</code></td><td>匹配到最像的</td></tr><tr><td><code>isEqual</code></td><td><code>Object,Object</code></td><td>是否相等</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8 时间格式化 DateTimeFormatter</title>
    <link href="/p/204076adb8604e1fa1c9745fb28afbf5/"/>
    <url>/p/204076adb8604e1fa1c9745fb28afbf5/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在使用 Java8 的 <code>LocalDateTime</code> 想要根据某种格式格式化字符串为日期时间，本以来会简单的事情，事实上却出乎预料！</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>想要格式化一个字符串为日期时间。例如常见的 <code>yyyy-MM-dd hh:mm:ss</code> 格式的 <code>2017-12-11 10:11:05</code>，吾辈习惯性的写出以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String text = <span class="hljs-string">&quot;2017-12-11 10:11:05&quot;</span>;<br><span class="hljs-keyword">final</span> String pattern = <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>;<br><span class="hljs-keyword">final</span> LocalDateTime dateTime = LocalDateTime.parse(text, DateTimeFormatter.ofPattern(pattern));<br>System.out.println(dateTime);<br></code></pre></td></tr></table></figure><p>谜之音：<strong>JVM</strong> 不想理你，并抛给了你一个 <strong>Error</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java.time.format.DateTimeParseException: Text <span class="hljs-string">&#x27;2017-12-11 10:11:05&#x27;</span> could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor: &#123;MinuteOfHour=11, MilliOfSecond=0, MicroOfSecond=0, SecondOfMinute=5, HourOfAmPm=10, NanoOfSecond=0&#125;,ISO resolved to 2017-12-11 of <span class="hljs-built_in">type</span> java.time.format.Parsed<br></code></pre></td></tr></table></figure><p>大意便是无法解析，去 Google 了一下，在 StackOverflow 上发现了这个问题：<a href="https://stackoverflow.com/questions/43732751/">DateTimeParseException: Text could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor</a></p><p>里面的答案说是使用 <code>HH</code>（每小时）而非 <code>hh</code>（每小时上午时钟），所以吾辈修改了代码，变成了下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String text = <span class="hljs-string">&quot;2017-12-11 10:11:05&quot;</span>;<br><span class="hljs-comment">// 只改了这里的格式</span><br><span class="hljs-keyword">final</span> String pattern = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;<br><span class="hljs-keyword">final</span> LocalDateTime dateTime = LocalDateTime.parse(text, DateTimeFormatter.ofPattern(pattern));<br>System.out.println(dateTime);<br></code></pre></td></tr></table></figure><p>然而确实能正常解析了！？？**#黑人问号**</p><h2 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h2><p>去看了一下 Java8 的 <code>DateTimeFormatter</code> 日期时间格式化类，发现了 class 上一段有趣的注释</p><p>All letters ‘A’ to ‘Z’ and ‘a’ to ‘z’ are reserved as pattern letters. The<br>following pattern letters are defined:</p><table><thead><tr><th>Symbol</th><th>Meaning</th><th>Presentation</th><th>Examples</th></tr></thead><tbody><tr><td><code>G</code></td><td>era</td><td>text</td><td>AD; Anno Domini; A</td></tr><tr><td><code>u</code></td><td>year</td><td>year</td><td>2004; 04</td></tr><tr><td><code>y</code></td><td>year-of-era</td><td>year</td><td>2004; 04</td></tr><tr><td><code>D</code></td><td>day-of-year</td><td>number</td><td>189</td></tr><tr><td><code>M/L</code></td><td>month-of-year</td><td>number/text</td><td>7; 07; Jul; July; J</td></tr><tr><td><code>d</code></td><td>day-of-month</td><td>number</td><td>10</td></tr><tr><td><code>Q/q</code></td><td>quarter-of-year</td><td>number/text</td><td>3; 03; Q3; 3rd quarter</td></tr><tr><td><code>Y</code></td><td>week-based-year</td><td>year</td><td>1996; 96</td></tr><tr><td><code>w</code></td><td>week-of-week-based-year</td><td>number</td><td>27</td></tr><tr><td><code>W</code></td><td>week-of-month</td><td>number</td><td>4</td></tr><tr><td><code>E</code></td><td>day-of-week</td><td>text</td><td>Tue; Tuesday; T</td></tr><tr><td><code>e/c</code></td><td>localized day-of-week</td><td>number/text</td><td>2; 02; Tue; Tuesday; T</td></tr><tr><td><code>F</code></td><td>week-of-month</td><td>number</td><td>3</td></tr><tr><td><code>a</code></td><td>am-pm-of-day</td><td>text</td><td>PM</td></tr><tr><td><code>h</code></td><td>clock-hour-of-am-pm (1-12)</td><td>number</td><td>12</td></tr><tr><td><code>K</code></td><td>hour-of-am-pm (0-11)</td><td>number</td><td>0</td></tr><tr><td><code>k</code></td><td>clock-hour-of-am-pm (1-24)</td><td>number</td><td>0</td></tr><tr><td><code>H</code></td><td>hour-of-day (0-23)</td><td>number</td><td>0</td></tr><tr><td><code>m</code></td><td>minute-of-hour</td><td>number</td><td>30</td></tr><tr><td><code>s</code></td><td>second-of-minute</td><td>number</td><td>55</td></tr><tr><td><code>S</code></td><td>fraction-of-second</td><td>fraction</td><td>978</td></tr><tr><td><code>A</code></td><td>milli-of-day</td><td>number</td><td>1234</td></tr><tr><td><code>n</code></td><td>nano-of-second</td><td>number</td><td>987654321</td></tr><tr><td><code>N</code></td><td>nano-of-day</td><td>number</td><td>1234000000</td></tr><tr><td><code>V</code></td><td>time-zone ID</td><td>zone-id</td><td>America/Los_Angeles; Z; -08:30</td></tr><tr><td><code>z</code></td><td>time-zone name</td><td>zone-name</td><td>Pacific Standard Time; PST</td></tr><tr><td><code>O</code></td><td>localized zone-offset</td><td>offset-O</td><td>GMT+8; GMT+08:00; UTC-08:00;</td></tr><tr><td><code>X</code></td><td>zone-offset ‘Z’ for zero</td><td>offset-X</td><td>Z; -08; -0830; -08:30; -083015; -08:30:15;</td></tr><tr><td><code>x</code></td><td>zone-offset</td><td>offset-x</td><td>+0000; -08; -0830; -08:30; -083015; -08:30:15;</td></tr><tr><td><code>Z</code></td><td>zone-offset</td><td>offset-Z</td><td>+0000; -0800; -08:00;</td></tr><tr><td><code>p</code></td><td>pad next</td><td>pad modifier</td><td>1</td></tr><tr><td><code>&#39;</code></td><td>escape for text</td><td>delimiter</td><td></td></tr><tr><td><code>&#39;&#39;</code></td><td>single quote</td><td>literal ‘</td><td></td></tr><tr><td><code>[</code></td><td>optional section start</td><td></td><td></td></tr><tr><td><code>]</code></td><td>optional section end</td><td></td><td></td></tr><tr><td><code>#</code></td><td>reserved for future use</td><td></td><td></td></tr><tr><td><code>&#123;</code></td><td>reserved for future use</td><td></td><td></td></tr><tr><td><code>&#125;</code></td><td>reserved for future use</td><td></td><td></td></tr></tbody></table><p>是的，这是一个日期格式的说明，在这里确实可以看到 <code>HH</code> 才代表的是 24 小时，而 <code>hh</code> 则是将小时分为 <code>am/pm</code>（上午/下午）。</p><blockquote><p>附：这里吐槽一下，Java 的格式化规则居然和标准的有偏差，<code>uuuu</code> 也能当作更好的 <code>yyyy</code> 使用（主要针对负的年份）</p></blockquote><p>所以现在也只能将格式化时间的 pattern 修改为 <code>uuuu-MM-dd HH:mm:ss</code> 便能正常匹配了！</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>那么，既然知道日期时间格式化模式的规则，那么接下来就可以直接写模式字符串了</p><ul><li>日期：<code>uuuu-MM-dd</code></li><li>时间：<code>HH:mm:ss</code></li><li>常见的日期时间：<code>uuuu-MM-dd HH:mm:ss</code></li><li>标准的日期时间：<code>DateTimeFormatter.ISO_DATE_TIME</code>（Java8 time 库中已存在）</li></ul><p>将字符串转换为日期时间大致有两种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String text = <span class="hljs-string">&quot;2019-02-12T01:24:07.425Z&quot;</span>;<br><span class="hljs-comment">// 先解析为时间在转换为具体的日期时间类</span><br><span class="hljs-keyword">final</span> LocalDateTime from = LocalDateTime.from(DateTimeFormatter.ISO_DATE_TIME.parse(text));<br><span class="hljs-comment">// 直接根据指定的格式解析字符串为具体的日期时间类</span><br><span class="hljs-keyword">final</span> LocalDateTime parse = LocalDateTime.parse(text, DateTimeFormatter.ISO_DATE_TIME);<br></code></pre></td></tr></table></figure><hr><p>那么，<code>Java8</code> 的踩坑之路还在继续，不知还有多少人在用 <code>Java7-</code> 呢？＼（＠￣ ∇ ￣＠）／</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 递归查询</title>
    <link href="/p/225a5ed11da14cf7a2a600ee987604be/"/>
    <url>/p/225a5ed11da14cf7a2a600ee987604be/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近需要将根据父级分类查询出所有的自己分类，所以却是需要使用 MySQL 实现递归查询的功能。</p><p>对于以下数据表（此处简化了）</p><table><thead><tr><th>id</th><th>parentId</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>数学</td></tr><tr><td>2</td><td>1</td><td>高等数学</td></tr><tr><td>3</td><td>1</td><td>线性代数</td></tr><tr><td>4</td><td>0</td><td>英语</td></tr><tr><td>5</td><td>4</td><td>即时翻译</td></tr><tr><td>6</td><td>4</td><td>口语阅读</td></tr><tr><td>7</td><td>0</td><td>物理</td></tr><tr><td>8</td><td>7</td><td>高能物理</td></tr><tr><td>9</td><td>8</td><td>无限能量</td></tr><tr><td>10</td><td>9</td><td>迪克拉之海</td></tr></tbody></table><p>SQL 结构/数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> question_type (<br>  id       <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;问题编号&#x27;</span>,<br>  parentId <span class="hljs-type">bigint</span>              <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;问题父分类编号，根节点为 0&#x27;</span>,<br>  name     <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;编号名称&#x27;</span><br>)<br>  comment <span class="hljs-string">&#x27;问题编号&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;数学&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;高等数学&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;线性代数&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;英语&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;即时翻译&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;口语阅读&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;物理&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;高能物理&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;无限能量&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;迪克拉之海&#x27;</span>);<br></code></pre></td></tr></table></figure><p>吾辈只有一个 id，想要查询出所有的子级</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这个问题在网络上流传着各种各样的解决方案</p><ul><li>使用额外的字段存储节点全路径</li><li>在应用层递归查询完成</li><li>使用 Mybatis collection 标签</li><li>使用存储过程</li><li>使用 SQL 视图</li><li>使用单条 SQL 实现</li></ul><p>吾辈目前只尝试了其中三种</p><h2 id="使用额外的字段存储节点全路径"><a href="#使用额外的字段存储节点全路径" class="headerlink" title="使用额外的字段存储节点全路径"></a>使用额外的字段存储节点全路径</h2><p>有人提出使用一个额外的字段记录当前节点的全路径，每一级使用 <code>,</code> 进行分割，所以吾辈的数据表变成了下面这样</p><table><thead><tr><th>id</th><th>parentId</th><th>name</th><th>path</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>数学</td><td>0,1</td></tr><tr><td>2</td><td>1</td><td>高等数学</td><td>0,1,2</td></tr><tr><td>3</td><td>1</td><td>线性代数</td><td>0,1,3</td></tr><tr><td>4</td><td>0</td><td>英语</td><td>0,4</td></tr><tr><td>5</td><td>4</td><td>即时翻译</td><td>0,4,5</td></tr><tr><td>6</td><td>4</td><td>口语阅读</td><td>0,4,6</td></tr><tr><td>7</td><td>0</td><td>物理</td><td>0,7</td></tr><tr><td>8</td><td>7</td><td>高能物理</td><td>0,7,8</td></tr><tr><td>9</td><td>8</td><td>无限能量</td><td>0,7,8,9</td></tr><tr><td>10</td><td>9</td><td>迪克拉之海</td><td>0,7,8,9,10</td></tr></tbody></table><p>SQL 结构/数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> question_type (<br>  id       <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;问题编号&#x27;</span>,<br>  parentId <span class="hljs-type">bigint</span>              <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;问题父分类编号，根节点为 0&#x27;</span>,<br>  name     <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;编号名称&#x27;</span>,<br>  path     <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;全路径，每级使用 , 分割&#x27;</span><br>)<br>  comment <span class="hljs-string">&#x27;问题编号&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;0,1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;高等数学&#x27;</span>, <span class="hljs-string">&#x27;0,1,2&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;线性代数&#x27;</span>, <span class="hljs-string">&#x27;0,1,3&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;英语&#x27;</span>, <span class="hljs-string">&#x27;0,4&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;即时翻译&#x27;</span>, <span class="hljs-string">&#x27;0,4,5&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;口语阅读&#x27;</span>, <span class="hljs-string">&#x27;0,4,6&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;物理&#x27;</span>, <span class="hljs-string">&#x27;0,7&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;高能物理&#x27;</span>, <span class="hljs-string">&#x27;0,7,8&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;无限能量&#x27;</span>, <span class="hljs-string">&#x27;0,7,8,9&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> question_type <span class="hljs-keyword">values</span> (<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;迪克拉之海&#x27;</span>, <span class="hljs-string">&#x27;0,7,8,9,10&#x27;</span>);<br></code></pre></td></tr></table></figure><p>现在，我们可以很简单的查询了子级信息了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询物理分类及其子级<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> question_type<br><span class="hljs-keyword">where</span> path regexp concat(<br>    <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;,|^&#x27;</span>, <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;,|,&#x27;</span>, <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;$|^&#x27;</span>, <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;$&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>这里使用正则是为了避免出现部分重复的情况，例如 <code>1</code> 和 <code>10</code>，直接使用 <code>like</code> 的话可能会出现错误查询额外的数据。</p></blockquote><h2 id="在应用层递归查询完成"><a href="#在应用层递归查询完成" class="headerlink" title="在应用层递归查询完成"></a>在应用层递归查询完成</h2><p>在不修改数据表结构的情况下有什么方法能递归查询么？答案是可以的！我们可以在程序中递归查询数据库，虽然效率上会低点，但对于不能修改的数据库而言还是相当有用的。</p><p>Domain 实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;question_type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 问题编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 问题父分类编号，根节点为 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long parentId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编号名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 全路径，每级使用 , 分割</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-comment">// getter / setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Service 及其实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QuestionTypeService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归查询节点及其子节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootId 查询的根节点 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 子节点列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;QuestionType&gt; <span class="hljs-title">selectRecursiveById</span><span class="hljs-params">(Long rootId)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuestionTypeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QuestionTypeService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> QuestionTypeDao baseMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;QuestionType&gt; <span class="hljs-title">selectRecursiveById</span><span class="hljs-params">(Long rootId)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> List&lt;QuestionType&gt; list = baseMapper.selectListByParentId(rootId).stream()<br>                .flatMap(qt -&gt; selectRecursiveById(qt.getId()).stream())<br>                .collect(Collectors.toList());<br>        Optional.ofNullable(baseMapper.selectById(rootId)).ifPresent(list::add);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Dao/Mapper.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QuestionTypeDao</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 查询分类</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 分类 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询到的分类数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">QuestionType <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据父节点 id 查询一级子节点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parentId 父节点 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一级子节点列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;QuestionType&gt; <span class="hljs-title">selectListByParentId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;parentId&quot;)</span> Long parentId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectListByParentId&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType&quot;</span>&gt;</span><br>        select *<br>        from question_type<br>        where parentId = #&#123;parentId&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType&quot;</span>&gt;</span><br>        select *<br>        from question_type<br>        where id = #&#123;id&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用的时候只要传入一个根节点 id 就可以查找到所有节点及其所有子节点了</p><h2 id="使用-Mybatis-collection-标签"><a href="#使用-Mybatis-collection-标签" class="headerlink" title="使用 Mybatis collection 标签"></a>使用 Mybatis collection 标签</h2><p>如果你使用的 ORM 是 Mybatis，那么也可以使用 Mybatis collection 标签实现递归查询的功能。</p><ol><li> Mybatis <code>collection</code> 标签可以查询一个集合为字段赋值</li><li> 那么我们可以使用 <code>select</code> 指向查询子分类本身</li><li> 查询的参数 <code>cloumn</code> 设置为查询出来每一个对象的 <code>id</code> 字段</li><li> 更改查询子分类的返回值为 <code>resultMap=&quot;RecursiveMap&quot;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QuestionTypeDao</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据父分类 id 递归查询子分类（不包含父分类本身）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parentId 分类 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询到的分类树</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;QuestionType&gt; <span class="hljs-title">selectRecursiveByParentId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;parentId&quot;)</span> Long parentId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义一个结果映射 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;RecursiveMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;parentId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;parentId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;path&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;path&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 这里是关键，定义集合字段，元素类型，查询函数以及对应的列 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;childrenList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao.selectRecursiveByParentId&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 正常查询子分类，唯一修改之处就是 resultMap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectRecursiveByParentId&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;RecursiveMap&quot;</span>&gt;</span><br>        select *<br>        from question_type<br>        where parentId = #&#123;parentId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>那么，关于 MySQL 递归查询暂且到此为止了。如果吾辈找到了更好的方法，也会继续更新这篇文章的！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus 自定义全局操作 exists 一直返回 null</title>
    <link href="/p/3312fc5f8fcd4b5ebb6fb8941f0ddd86/"/>
    <url>/p/3312fc5f8fcd4b5ebb6fb8941f0ddd86/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>为 <code>mybatis-plus</code> 自定义了一个全局操作，然后就一直返回 <code>null</code>。。。</p><p>在自定义 sql 注入器类的时候，突然发现 <code>existsById()</code> 一直都在抛空指针异常，就去看了一下结果发现一直返回 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.mybatisplussqlinjector.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.entity.TableInfo;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.mapper.AutoSqlInjector;<br><span class="hljs-keyword">import</span> org.apache.ibatis.builder.MapperBuilderAssistant;<br><span class="hljs-keyword">import</span> org.apache.ibatis.mapping.SqlSource;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义 sql 注入器</span><br><span class="hljs-comment"> * 注: 此处不能声明为 Bean, 因为回和 MybatisPlus 自己的 SqlInjector 冲突</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AutoSqlInjector</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 确定数据是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SQL_EXISTS_BY_ID = <span class="hljs-string">&quot;select exists(select 0 from %s where id = #&#123;id&#125;);&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table)</span> </span>&#123;<br>        existsById(mapperClass, modelClass, table);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">existsById</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String sql = String.format(SQL_EXISTS_BY_ID, table.getTableName());<br>        <span class="hljs-keyword">final</span> SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);<br>        <span class="hljs-keyword">this</span>.addSelectMappedStatement(mapperClass, <span class="hljs-string">&quot;existsById&quot;</span>, sqlSource, modelClass, table);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的 <code>BaseDao</code> 基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.mybatisplussqlinjector.common.dao;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseDao</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 查询数据是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 数据 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 数据是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Boolean <span class="hljs-title">existsById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.mybatisplussqlinjector.dao;<br><br><span class="hljs-keyword">import</span> com.rxliuli.example.mybatisplussqlinjector.entity.User;<br><span class="hljs-keyword">import</span> common.test.BaseDaoAndServiceTest;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.assertj.core.api.Assertions.assertThat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDaoAndServiceTest</span>&lt;<span class="hljs-title">UserDao</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">existsById</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Boolean res = base.existsById(<span class="hljs-number">1L</span>);<br>        log.debug(<span class="hljs-string">&quot;res: &#123;&#125;&quot;</span>, res);<br>        assertThat(res)<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectById</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> User user = base.selectById(<span class="hljs-number">1L</span>);<br>        log.debug(<span class="hljs-string">&quot;user: &#123;&#125;&quot;</span>, user);<br>        assertThat(user)<br>                .isNotNull();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><p><img src="https://img.rxliuli.com/20181211202332.png" alt="测试结果"></p><p>然而，当我把全局注入的 sql 操作放到 xml 文件时</p><p>Dao 和对应的 xml 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.mybatisplussqlinjector.dao;<br><br><span class="hljs-keyword">import</span> com.rxliuli.example.mybatisplussqlinjector.common.dao.BaseDao;<br><span class="hljs-keyword">import</span> com.rxliuli.example.mybatisplussqlinjector.entity.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDao</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Boolean <span class="hljs-title">existsById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rxliuli.example.mybatisplussqlinjector.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;existsById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Boolean&quot;</span>&gt;</span><br>        select exists(select 0<br>                      from user<br>                      where id = #&#123;id&#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，一切又能正常运行了，这其中到底发生了什么呢？</p><p><img src="https://img.rxliuli.com/20181211202834.png" alt="测试正常运行"></p><blockquote><p>目前该问题已经在 <a href="https://github.com/baomidou/mybatis-plus">官方 GitHub</a> 上提出了一个 <a href="https://github.com/baomidou/mybatis-plus/issues/694">issue</a></p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>好吧，开发人员说是要在使用 <code>addSelectMappedStatement()</code> 时对返回值进行界定，之前一直查的都是表数据确实没注意到还需要对返回值类型进行界定呢</p><p>修改的地方其实只有一处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.mybatisplussqlinjector.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.entity.TableInfo;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.mapper.AutoSqlInjector;<br><span class="hljs-keyword">import</span> org.apache.ibatis.builder.MapperBuilderAssistant;<br><span class="hljs-keyword">import</span> org.apache.ibatis.mapping.SqlSource;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义 sql 注入器</span><br><span class="hljs-comment"> * 注: 此处不能声明为 Bean, 因为回和 MybatisPlus 自己的 SqlInjector 冲突</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AutoSqlInjector</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 确定数据是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SQL_EXISTS_BY_ID = <span class="hljs-string">&quot;select exists(select 0 from %s where id = #&#123;id&#125;);&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table)</span> </span>&#123;<br>        existsById(mapperClass, modelClass, table);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">existsById</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo table)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String sql = String.format(SQL_EXISTS_BY_ID, table.getTableName());<br>        <span class="hljs-keyword">final</span> SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);<br>        <span class="hljs-comment">// 注：在此处界定返回值类型</span><br>        <span class="hljs-keyword">this</span>.addSelectMappedStatement(mapperClass, <span class="hljs-string">&quot;existsById&quot;</span>, sqlSource, Boolean.class, table);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码已经上传到 <a href="https://github.com/rxliuli/mybatis-plus-sql-injector-example">GitHub</a></p></blockquote><p>虽然只是个不起眼的小错误，不过这里还是记录一下吧，毕竟坑只要踩过一次就够了 ┐(￣ヮ￣)┌</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 进行测试</title>
    <link href="/p/34365365960f42eb9c45892c852cab29/"/>
    <url>/p/34365365960f42eb9c45892c852cab29/</url>
    
    <content type="html"><![CDATA[<h2 id="概略"><a href="#概略" class="headerlink" title="概略"></a>概略</h2><p>SpringBoot 中进行测试比 Spring 项目中更加简单，想了解 Spring 项目中测试的可以参考 <a href="https://blog.rxliuli.com/p/c2870a27/">使用 Spring 时进行测试</a>。</p><h2 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h2><p>假设要测试一个工具类 <code>StringUtil</code>（<code>com.rxliuli.example.springboottest.util.StringUtil</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于测试的字符串工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringUtil</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string 要进行判断的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(String string)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> string == <span class="hljs-keyword">null</span> || string.isEmpty();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string 要进行判断的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">(String string)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !isEmpty(string);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否有字符串为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> strings 要进行判断的一个或多个字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否有 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnyEmpty</span><span class="hljs-params">(String... strings)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(strings)<br>                .anyMatch(StringUtil::isEmpty);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断字符串是否全部为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> strings 要进行判断的一个或多个字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否全部为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAllEmpty</span><span class="hljs-params">(String... strings)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(strings)<br>                .allMatch(StringUtil::isEmpty);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要添加依赖 <code>spring-boot-starter-test</code> 以及指定 <code>assertj-core</code> 的最新版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.assertj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>assertj-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里指定 <code>assertj-core</code> 的版本是为了使用较新的一部分断言功能（例如属性 <code>lambda</code> 断言）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringUtilTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String strNull = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> String strEmpty = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">private</span> String strSome = <span class="hljs-string">&quot;str&quot;</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//测试 null</span><br>        assertThat(StringUtil.isEmpty(strNull))<br>                .isTrue();<br>        <span class="hljs-comment">//测试 empty</span><br>        assertThat(StringUtil.isEmpty(strEmpty))<br>                .isTrue();<br>        <span class="hljs-comment">//测试 some</span><br>        assertThat(StringUtil.isEmpty(strSome))<br>                .isFalse();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//测试 null</span><br>        assertThat(StringUtil.isNotEmpty(strNull))<br>                .isFalse();<br>        <span class="hljs-comment">//测试 empty</span><br>        assertThat(StringUtil.isNotEmpty(strEmpty))<br>                .isFalse();<br>        <span class="hljs-comment">//测试 some</span><br>        assertThat(StringUtil.isNotEmpty(strSome))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAnyEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty, strSome))<br>                .isTrue();<br>        assertThat(StringUtil.isAnyEmpty())<br>                .isFalse();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAllEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        assertThat(StringUtil.isAllEmpty(strNull, strEmpty, strSome))<br>                .isFalse();<br>        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty))<br>                .isTrue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里和非 SpringBoot 测试时没什么太大的区别，唯一的一点就是引入 Jar 不同，这里虽然我们只引入了 <code>spring-boot-starter-test</code>，但它本身已经帮我们引入了许多的测试相关类库了。</p><h2 id="Dao-Service-测试"><a href="#Dao-Service-测试" class="headerlink" title="Dao/Service 测试"></a>Dao/Service 测试</h2><p>从这里开始就和标准的 Spring 不太一样了</p><p>首先，我们需要 Dao 层，这里使用 H2DB 和 SpringJDBC 做数据访问层（比较简单）。</p><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.h2database<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>h2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加两个初始化脚本</p><p>数据库结构 <code>db_schema.sql</code>（<code>db/db_schema.sql</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> (<br>  id   <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;名字&#x27;</span>,<br>  sex  <span class="hljs-type">boolean</span>            <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>  age  <span class="hljs-type">int</span>                <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;年龄&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>数据库数据 <code>db_data.sql</code>（<code>db/db_data.sql</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (id, name, sex, age)<br><span class="hljs-keyword">values</span><br>  (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">17</span>),<br>  (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;月姬&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>为 SpringBoot 配置一下数据源及初始化脚本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">org.h2.Driver</span><br>    <span class="hljs-attr">platform:</span> <span class="hljs-string">h2</span><br>    <span class="hljs-attr">schema:</span> <span class="hljs-string">classpath:db/db_schema.sql</span><br>    <span class="hljs-attr">data:</span> <span class="hljs-string">classpath:db/db_data.sql</span><br></code></pre></td></tr></table></figure><p>然后是实体类与 Dao</p><p>用户实体类 <code>User</code>（<code>com.rxliuli.example.springboottest.entity.User</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Boolean sex;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, Boolean sex, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name, Boolean sex, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">//getter() and setter()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用户 Dao <code>UserDao</code>（<code>com.rxliuli.example.springboottest.dao.UserDao</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RowMapper&lt;User&gt; userRowMapper = (rs, rowNum) -&gt; <span class="hljs-keyword">new</span> User(<br>            rs.getInt(<span class="hljs-string">&quot;id&quot;</span>),<br>            rs.getString(<span class="hljs-string">&quot;name&quot;</span>),<br>            rs.getBoolean(<span class="hljs-string">&quot;sex&quot;</span>),<br>            rs.getInt(<span class="hljs-string">&quot;age&quot;</span>)<br>    );<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 获取一个对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 根据 id 查询到的对象，如果没有查到则为 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from user where id = ?&quot;</span>, userRowMapper, id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询全部用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 全部用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, userRowMapper);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 删除用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 用户 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 受影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;delete from user where id = ?&quot;</span>, id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来才是正事，测试 Dao 层需要加载 Spring 容器，自动回滚以避免污染数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@SpringBootTest</span>&#125; 和 &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@RunWith</span>(SpringRunner.class)&#125; 是必须的，这里貌似一直有人误会需要使用 &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@RunWith</span>(SpringJUnit4ClassRunner.class)&#125;，但其实并不需要了</span><br><span class="hljs-comment"> * 下面的 &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Transactional</span>&#125; 和 &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Rollback</span>&#125;则是开启事务控制以及自动回滚</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br>        User result = userDao.get(id);<br>        <span class="hljs-comment">//断言 id 和 get id 相同</span><br>        assertThat(result)<br>                .extracting(User::getId)<br>                .contains(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = userDao.listForAll();<br>        <span class="hljs-comment">//断言不为空</span><br>        assertThat(userList)<br>                .isNotEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = userDao.deleteById(<span class="hljs-number">1</span>);<br>        assertThat(result)<br>                .isGreaterThan(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Web-测试"><a href="#Web-测试" class="headerlink" title="Web 测试"></a>Web 测试</h2><p>与传统的 SpringTest 一样，SpringBoot 也分为两种。</p><ul><li>独立安装测试：<br>手动加载单个 Controller，所以测试其他 Controller 中的接口会发生异常。但测试速度上较快，所以应当优先选择。</li><li>集成 Web 环境测试：<br>将启动并且加载所有的 Controller, 所以效率上之于 BaseWebUnitTest 来说非常低下, 仅适用于集成测试多个 Controller 时使用。</li></ul><h3 id="独立安装测试"><a href="#独立安装测试" class="headerlink" title="独立安装测试"></a>独立安装测试</h3><p>主要是设置需要使用的 Controller 实例，然后用获得 MockMvc 对象进行测试即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerUnitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserController userController;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于测试 API 的模拟请求对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//模拟一个 Mvc 测试环境，获取一个 MockMvc 实例</span><br>        mockMvc = MockMvcBuilders.standaloneSetup(userController)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试能够正常获取</span><br>        Integer id = <span class="hljs-number">1</span>;<br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 get 请求</span><br>                get(<span class="hljs-string">&quot;/user/&quot;</span> + id)<br>        )<br>                <span class="hljs-comment">//断言请求的状态是成功的(200)</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回对象的 id 和请求的 id 相同</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$.id&quot;</span>).value(id));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试正常获取</span><br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 post 请求</span><br>                post(<span class="hljs-string">&quot;/user/listForAll&quot;</span>)<br>        )<br>                <span class="hljs-comment">//断言请求状态</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回结果是数组</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isArray())<br>                <span class="hljs-comment">//断言返回数组不是空的</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isNotEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="集成-Web-环境测试"><a href="#集成-Web-环境测试" class="headerlink" title="集成 Web 环境测试"></a>集成 Web 环境测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerIntegratedTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WebApplicationContext context;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于测试 API 的模拟请求对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//这里把整个 WebApplicationContext 上下文都丢进去了，所以可以测试所有的 Controller</span><br>        mockMvc = MockMvcBuilders.webAppContextSetup(context)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试能够正常获取</span><br>        Integer id = <span class="hljs-number">1</span>;<br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 get 请求</span><br>                get(<span class="hljs-string">&quot;/user/&quot;</span> + id)<br>        )<br>                <span class="hljs-comment">//断言请求的状态是成功的(200)</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回对象的 id 和请求的 id 相同</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$.id&quot;</span>).value(id));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试正常获取</span><br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 post 请求</span><br>                post(<span class="hljs-string">&quot;/user/listForAll&quot;</span>)<br>        )<br>                <span class="hljs-comment">//断言请求状态</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回结果是数组</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isArray())<br>                <span class="hljs-comment">//断言返回数组不是空的</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isNotEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实上面的测试类的注解感觉都差不多，我们可以将一些普遍的注解封装到基类，然后测试类只要继承基类就能得到所需要的环境，吾辈自己的测试基类在 <code>src/test/common</code> 下面，具体使用方法便留到下次再说吧</p><blockquote><p>以上代码已全部放到 <a href="https://github.com/rxliuli/springboot-test">GitHub</a> 上面，可以直接 <em>clone</em> 下来进行测试</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 使用 FTP/SFTP</title>
    <link href="/p/3c16942a2e994263847a2ae35f2473aa/"/>
    <url>/p/3c16942a2e994263847a2ae35f2473aa/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>项目中需要使用 FTP，所以做了简单的 <code>FTP/SFTP</code> 封装，此处仅做一下记录。</p><blockquote><p>注：这里并未实现连接池管理，生产环境强烈建议手动实现连接池以提高性能！</p></blockquote><h2 id="UML-图像说明"><a href="#UML-图像说明" class="headerlink" title="UML 图像说明"></a>UML 图像说明</h2><h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><blockquote><p>注：此处参考自 IDEA UML 图中的颜色</p></blockquote><ul><li>蓝色：类/步骤</li><li>黄色：字段</li><li>红色：函数</li><li>紫色：配置</li></ul><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul><li>长方形：类/配置文件/依赖项</li><li>圆角长方形：字段/函数/对象/变量</li><li>箭头：拥有/向下依赖的意思</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>封装简单的通用操作</p><ul><li>上传单个文件</li><li>上传使用 <code>InputStream</code>(内存操作)</li><li>下载单个文件</li><li>下载得到 <code>InputStream</code>(内存操作)</li><li>创建目录</li><li>递归创建目录</li><li>删除单个文件/空目录</li><li>获取指定目录下的文件信息列表</li><li>获取文件/目录信息</li><li>递归获取文件/目录信息</li><li>递归删除目录</li><li>监听目录变化（内部使用）</li><li>异步上传后等待结果</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li> 定义顶层接口 <code>FtpOperator</code>，具体实现由子类（<code>BasicFtpOperatorImpl</code>, <code>SftpOperatorImpl</code>）完成</li><li> 定义顶层配置文件基类 <code>FtpClientConfig</code>，包含着 ftp 连接必须的一些东西，具体细节在子类配置中 <code>BasicFtpClientConfig</code>, <code>SftpClientConfig</code></li><li> 添加工厂类 <code>FtpOperatorFactory</code>，根据不同子类的配置对象创建不同的 ftp 操作对象，并且一经创建就可以永久性使用</li><li> 添加 <code>FtpWatchConfig</code>, <code>FtpWatch</code>, <code>FtpWatchFactory</code> FTP 监听器</li><li> 添加集成 SpringBoot 中，读取 <code>application.yml</code> 中的配置，并创建不同的 <code>FtpOperator</code> 暴露给外部使用，动态初始化 FTP 监视器</li></ol><blockquote><p>注：这里使用 FTP 监视器的原因是为了避免每次上传数据后都要单独监听 FTP 目录的变化，造成 FTP 多线程连接数量过多<br>注：这里的并未实现 FTPClient 及 Jsch 的对象池管理，所以仅可参考实现，生产环境中仍需进行修改！</p></blockquote><p>图解如下</p><p><img src="https://img.rxliuli.com/20190226221826.png" alt="图解"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>具体的代码吾辈就不贴到这里了，全部的代码已经放到 <a href="https://github.com/rxliuli/java-ftp-example">GitHub 的公共仓库</a> 上了。</p><h2 id="FTP-使用"><a href="#FTP-使用" class="headerlink" title="FTP 使用"></a>FTP 使用</h2><p>FtpOperator API 图解<br><img src="https://img.rxliuli.com/20190302115433.png" alt="FtpOperator API 图解"></p><p>上传部分流程图解<br><img src="https://img.rxliuli.com/20190302120512.png" alt="上传部分流程图解"></p><h3 id="使用-FtpOperator-进行基本操作"><a href="#使用-FtpOperator-进行基本操作" class="headerlink" title="使用 FtpOperator 进行基本操作"></a>使用 FtpOperator 进行基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FtpSpringConfigTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> FtpOperator ftp;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br>        <span class="hljs-comment">// 上传数据</span><br>        <span class="hljs-keyword">final</span> ByteArrayInputStream is = <span class="hljs-keyword">new</span> ByteArrayInputStream(<span class="hljs-string">&quot;测试数据&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result = ftp.put(is, <span class="hljs-string">&quot;/test.txt&quot;</span>);<br>        assertThat(result)<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exist</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 判断数据是否存在于 ftp 服务器</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> exist = ftp.exist(<span class="hljs-string">&quot;/test.txt&quot;</span>);<br>        assertThat(exist)<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 从 ftp 服务器上下载数据</span><br>        ftp.get(<span class="hljs-string">&quot;/test.txt&quot;</span>, is -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> List&lt;String&gt; list = IOUtils.readLines(is);<br>                log.info(<span class="hljs-string">&quot;list: &#123;&#125;&quot;</span>, list);<br>                assertThat(list)<br>                        .isNotEmpty();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mkdir</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建文件夹</span><br>        assertThat(ftp.mkdir(<span class="hljs-string">&quot;/test&quot;</span>))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mkdirR</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 递归创建文件夹</span><br>        assertThat(ftp.mkdirR(<span class="hljs-string">&quot;/test/test2/test3&quot;</span>))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ls</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取目录下的文件信息列表</span><br>        <span class="hljs-keyword">final</span> List&lt;Stat&gt; list = ftp.ls(<span class="hljs-string">&quot;/&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;list: &#123;&#125;&quot;</span>, list.stream()<br>                .map(Stat::getPath)<br>                .collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>)));<br>        assertThat(list)<br>                .isNotEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lsr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取目录下的文件信息列表</span><br>        <span class="hljs-keyword">final</span> List&lt;Stat&gt; list = ftp.lsR(<span class="hljs-string">&quot;/&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;list: &#123;&#125;&quot;</span>, list.stream()<br>                .map(Stat::getPath)<br>                .collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>)));<br>        assertThat(list)<br>                .isNotEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rm</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 删除单个文件</span><br>        assertThat(ftp.rm(<span class="hljs-string">&quot;/test.txt&quot;</span>))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rmdir</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 删除指定空目录</span><br>        assertThat(ftp.rmdir(<span class="hljs-string">&quot;/test/test2/test3&quot;</span>))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rmdirR</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 递归删除指定目录</span><br>        assertThat(ftp.rmdirR(<span class="hljs-string">&quot;/test&quot;</span>))<br>                .isTrue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-FtpOperator-上传文件并监听结果"><a href="#使用-FtpOperator-上传文件并监听结果" class="headerlink" title="使用 FtpOperator 上传文件并监听结果"></a>使用 FtpOperator 上传文件并监听结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FtpSpringConfigTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> FtpOperator ftp;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, UnsupportedEncodingException </span>&#123;<br>        <span class="hljs-comment">// 监听新文件 /test.md 的出现</span><br>        <span class="hljs-keyword">final</span> String path = <span class="hljs-string">&quot;/test.md&quot;</span>;<br>        ftp.watch((Predicate&lt;String&gt;) str -&gt; str.equals(path))<br>                .thenAcceptAsync(stat -&gt; &#123;<br>                    log.warn(<span class="hljs-string">&quot;stat: &#123;&#125;&quot;</span>, stat);<br>                    assertThat(ftp.exist(stat.getPath()))<br>                            .isNotNull();<br>                &#125;);<br>        <span class="hljs-comment">// 创建测试文件</span><br>        <span class="hljs-keyword">final</span> ByteArrayInputStream is = <span class="hljs-keyword">new</span> ByteArrayInputStream(<span class="hljs-string">&quot;测试数据&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        log.warn(<span class="hljs-string">&quot;test file upload completed!&quot;</span>);<br>        assertThat(ftp.put(is, path))<br>                .isTrue();<br>        <span class="hljs-comment">// 注意，这里有一个问题就是如果程序结束的太快，那么更新将变得不可能的！</span><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-comment">// 删除测试文件</span><br>        ftp.rm(path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>那么，关于 Java 中使用 <code>FTP/SFTP</code> 便到此为止啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 使用 IF 判断是否执行 SQL</title>
    <link href="/p/3bb34d2fe4a64ca8b93520c8498b812a/"/>
    <url>/p/3bb34d2fe4a64ca8b93520c8498b812a/</url>
    
    <content type="html"><![CDATA[<p>语法<br><code>if(condition, value_if_true, value_if_false)</code></p><p>上面的三个参数的意思是，如果 <code>condition</code>（表达式）为 <code>true</code>，则执行表达式 <code>value_if_true</code>，否则执行表达式 <code>value_if_false</code>。</p><p>例如有下面这个 <code>User</code> 用户表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">User</span> (<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>  COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age  <span class="hljs-type">INT</span>         <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>  COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  sex  <span class="hljs-type">BOOLEAN</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>  COMMENT <span class="hljs-string">&#x27;性别&#x27;</span><br>)<br>  COMMENT <span class="hljs-string">&#x27;用户表&#x27;</span><br></code></pre></td></tr></table></figure><p>一个简单的根据属性查询列表的 SQL 语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">User</span><br><span class="hljs-keyword">WHERE</span><br>  name <span class="hljs-operator">=</span> ?<br>  <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> ?<br>  <span class="hljs-keyword">AND</span> sex <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>那么，现在问题来了。我们有一个需求就是如果性别为空，就查询全部的性别，否则就根据性别进行查询。这时就可以使用 if 来进行判断了（吾辈的某位同事就是碰到了这个坑。。。），如果 <code>condition</code>(<code>sex = null</code>) 为 <code>true</code>，就直接执行表达式 <code>value_if_true</code>(<code>true</code>)，否则执行 <code>value_if_false</code>(<code>sex = ?</code>)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">User</span><br><span class="hljs-keyword">WHERE</span><br>  name <span class="hljs-operator">=</span> ?<br>  <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> ?<br>  <span class="hljs-keyword">AND</span> if(sex <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-literal">TRUE</span>, sex <span class="hljs-operator">=</span> ?);<br></code></pre></td></tr></table></figure><blockquote><p>注：这里不要使用 <code>1 = 1</code> 而直接使用 <code>true</code> 就好了。<br>PS：这难道就是所谓的习惯成自然么。。。<br>附：诚然，在使用了 ORM 框架(例如 Mybatis 后)，基本上都可以对传入的参数进行判空处理，然而有时候会出现一种情况：<br>某个属性经由其他属性统合计算而得到，并非是实体（或是其他的什么）传入进来的参数，那便是只能使用 SQL 的原生语法了呢</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置文件 yml</title>
    <link href="/p/40a3c0c38dec4c618bc034441425e810/"/>
    <url>/p/40a3c0c38dec4c618bc034441425e810/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要引用自：<a href="https://www.cnblogs.com/itdragon/p/8686554.html">Spring Boot 配置文件详解</a>，这里主要是为了进行记录以便吾辈进行查找。</p></blockquote><p>yml 是 YAML（YAML Ain’t Markup Language）语言的文件，以数据为中心，比 json、xml 等更适合做配置文件。</p><blockquote><p>对比：<br>yml 和 xml 相比，少了一些结构化的代码，使数据更直接，一目了然。<br>yml 和 json 呢？没有谁好谁坏，合适才是最好的。yml 的语法比 json 优雅，注释更标准，适合做配置文件。json 作为一种机器交换格式比 yml 强，更适合做 api 调用的数据交换。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用 <code>tab</code> 代替 <code>空格</code>。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。</li><li>字面值：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持 <code>yyyy/MM/dd HH:mm:ss</code></li><li>对象：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：{k1: v1, ….kn: vn}</li><li>数组：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法： [1,2,…n]</li><li>复合结构：上面三种数据结构任意组合</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建一个 Spring Boot 的全局配置文件 application.yml，配置属性参数。主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">yaml:</span><br>  <span class="hljs-attr">str:</span> <span class="hljs-string">字符串可以不加引号</span><br>  <span class="hljs-attr">specialStr:</span> <span class="hljs-string">&quot;双引号直接输出\n特殊字符&quot;</span><br>  <span class="hljs-attr">specialStr2:</span> <span class="hljs-string">&#x27;单引号可以转义\n特殊字符&#x27;</span><br>  <span class="hljs-attr">flag:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">num:</span> <span class="hljs-number">666</span><br>  <span class="hljs-attr">Dnum:</span> <span class="hljs-number">88.88</span><br>  <span class="hljs-attr">list:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">one</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">two</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">two</span><br>  <span class="hljs-attr">set:</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>  <span class="hljs-attr">map:</span> &#123; <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>, <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span> &#125;<br>  <span class="hljs-attr">positions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ITDragon</span><br>      <span class="hljs-attr">salary:</span> <span class="hljs-number">15000.00</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ITDragonBlog</span><br>      <span class="hljs-attr">salary:</span> <span class="hljs-number">18888.88</span><br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字</li><li>数组类型，短横线后面要有空格；对象类型，冒号后面要有空格。</li><li>YAML 是以空格缩进的程度来控制层级关系，但不能用 tab 键代替空格，大小写敏</li><li>如何让一个程序员崩溃？在 yml 文件中加几个空格！(〃＞皿＜)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 中 String 转 LocalDateTime 出现错误</title>
    <link href="/p/75b7b44fa66d461ba8a7ae3c8dadc2a9/"/>
    <url>/p/75b7b44fa66d461ba8a7ae3c8dadc2a9/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在 Java 中使用 <code>LocalDateTime</code> 解析 <code>String</code> 失败</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime result = LocalDateTime.parse(<span class="hljs-string">&quot;2000-01-01&quot;</span>, DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>log.info(<span class="hljs-string">&quot;result: &#123;&#125;&quot;</span>, result);<br></code></pre></td></tr></table></figure><p>抛出异常</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java.time.format.DateTimeParseException: Text <span class="hljs-string">&#x27;2000-01-01&#x27;</span> could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor: &#123;&#125;,ISO resolved to 2000-01-01 of <span class="hljs-built_in">type</span> java.time.format.Parsed<br></code></pre></td></tr></table></figure><p>吾辈也在 <a href="https://segmentfault.com/q/1010000018526018">SegmentFault</a> 上提出了这个问题，然而直到写出这篇记录时然而没有人告诉吾辈答案。。。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="先转换为-LocalDate-再二次转换"><a href="#先转换为-LocalDate-再二次转换" class="headerlink" title="先转换为 LocalDate 再二次转换"></a>先转换为 LocalDate 再二次转换</h3><p>吾辈首先找到了一种笨方法</p><ol><li> 先解析为 <code>LocalDate</code></li><li> 将 <code>LocalDate</code> 转换为 <code>LocalDateTime</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> LocalDateTime localDateTime = LocalDate.parse(<span class="hljs-string">&quot;2018-12-11&quot;</span>, DateTimeFormatter.ISO_DATE).atStartOfDay();<br>assertThat(localDateTime)<br>    .isNotNull();<br></code></pre></td></tr></table></figure><h3 id="使用-DateTimeFormatter-先解析，然后转换为-LocalDateTime"><a href="#使用-DateTimeFormatter-先解析，然后转换为-LocalDateTime" class="headerlink" title="使用 DateTimeFormatter 先解析，然后转换为 LocalDateTime"></a>使用 DateTimeFormatter 先解析，然后转换为 LocalDateTime</h3><ol><li> 使用 <code>DateTimeFormatter.ISO_DATE</code> 解析文本并得到 <code>TemporalAccessor</code> 对象</li><li> 使用 <code>temporalAccessor.get</code> 方法获取指定属性</li><li> 使用 <code>LocalDateTime.of</code> 构造一个 <code>LocalDateTime</code> 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> TemporalAccessor temporalAccessor = DateTimeFormatter.ISO_DATE.parse(<span class="hljs-string">&quot;2018-12-11&quot;</span>);<br><span class="hljs-keyword">final</span> LocalDateTime localDateTime = LocalDateTime.of(<br>    secureGet(temporalAccessor, ChronoField.YEAR),<br>    secureGet(temporalAccessor, ChronoField.MONTH_OF_YEAR),<br>    secureGet(temporalAccessor, ChronoField.DAY_OF_MONTH),<br>    secureGet(temporalAccessor, ChronoField.HOUR_OF_DAY),<br>    secureGet(temporalAccessor, ChronoField.MINUTE_OF_HOUR),<br>    secureGet(temporalAccessor, ChronoField.SECOND_OF_MINUTE),<br>    secureGet(temporalAccessor, ChronoField.NANO_OF_SECOND)<br>);<br>log.info(<span class="hljs-string">&quot;localDateTime: &#123;&#125;&quot;</span>, localDateTime);<br></code></pre></td></tr></table></figure><p><code>secureGet</code> 是吾辈自定义的一个工具方法，具体看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 安全获取时间的某个属性</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> temporalAccessor 需要获取的时间对象</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> chronoField      需要获取的属性</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 时间的值，如果无法获取则默认为 0</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">secureGet</span><span class="hljs-params">(TemporalAccessor temporalAccessor, ChronoField chronoField)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (temporalAccessor.isSupported(chronoField)) &#123;<br>        <span class="hljs-keyword">return</span> temporalAccessor.get(chronoField);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-DateTimeFormatterBuilder-构建器"><a href="#使用-DateTimeFormatterBuilder-构建器" class="headerlink" title="使用 DateTimeFormatterBuilder 构建器"></a>使用 DateTimeFormatterBuilder 构建器</h3><p>吾辈在 <a href="https://stackoverflow.com/questions/27454025">StackOverflow</a> 找到了一个好的方法</p><ol><li> 使用 <code>DateTimeFormatterBuilder</code> 构建 <code>DateTimeFormatter</code> 对象</li><li> 赋予可选匹配项默认值（<strong>非常重要</strong>）</li><li> 使用 <code>LocalDateTime.parse</code> 进行解析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> DateTimeFormatter formatter = <span class="hljs-keyword">new</span> DateTimeFormatterBuilder()<br>    .appendPattern(<span class="hljs-string">&quot;yyyy-MM-dd[[&#x27;T&#x27;hh][:mm][:ss]]&quot;</span>)<br>    .parseDefaulting(ChronoField.HOUR_OF_DAY, <span class="hljs-number">0</span>)<br>    .parseDefaulting(ChronoField.MINUTE_OF_HOUR, <span class="hljs-number">0</span>)<br>    .parseDefaulting(ChronoField.SECOND_OF_MINUTE, <span class="hljs-number">0</span>)<br>    .parseDefaulting(ChronoField.MILLI_OF_SECOND, <span class="hljs-number">0</span>)<br>    .toFormatter();<br><span class="hljs-keyword">final</span> LocalDateTime localDateTime = LocalDateTime.parse(<span class="hljs-string">&quot;2018-12-11&quot;</span>, formatter);<br>assertThat(localDateTime)<br>    .isNotNull();<br></code></pre></td></tr></table></figure><hr><p>最后一种方法满足了吾辈的需求，所以，也便是在这里记录一下啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>将 Mybatis/MongoDB 集成到 SpringBoot 中的示例</title>
    <link href="/p/7afb8532f50945d49222448db4be21ff/"/>
    <url>/p/7afb8532f50945d49222448db4be21ff/</url>
    
    <content type="html"><![CDATA[<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><p>本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。</p><ul><li>[x] Gradle</li><li>[x] SpringBoot</li><li>[x] Mybatis Plus</li><li>[x] MongoDB</li><li>[ ] SpringBoot MongoDB Data</li><li>[ ] H2DB</li><li>[ ] SpringTest</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://github.com/rxliuli/spring-boot-mybatis-plus-mongo">GitHub 项目</a>, <a href="https://blog.rxliuli.com/p/872037f5/">Blog 教程</a></p></blockquote><p>需要同时使用 <code>Mybatis-Plus</code> 和 <code>MongoDB</code>，所以就去了解了一下如何集成它们。</p><h2 id="集成-Mybatis-Plus"><a href="#集成-Mybatis-Plus" class="headerlink" title="集成 Mybatis Plus"></a>集成 Mybatis Plus</h2><h3 id="创建-SpringBoot-项目"><a href="#创建-SpringBoot-项目" class="headerlink" title="创建 SpringBoot 项目"></a>创建 SpringBoot 项目</h3><p>使用 SpringIO 创建 SpringBoot 项目，初始依赖选择 <code>web</code>, <code>h2</code> 两个模块，gradle 配置如下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle">plugins &#123;<br>    id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.1.3.RELEASE&#x27;</span><br>    id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>apply plugin: <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span><br><br><span class="hljs-keyword">group</span> = <span class="hljs-string">&#x27;com.rxliuli.example&#x27;</span><br>version = <span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br><span class="hljs-keyword">sourceCompatibility</span> = <span class="hljs-string">&#x27;1.8&#x27;</span><br><br><span class="hljs-keyword">repositories</span> &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    runtimeOnly <span class="hljs-string">&#x27;com.h2database:h2&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：数据库吾辈这里为了简单起见直接使用了 <code>H2DB</code>，真实项目中可能需要配置 <code>MySQL</code> 之类。为了简化项目依赖配置文件，所以使用了 Gradle 而非 Maven。</p></blockquote><h3 id="引入-Mybatis-Plus-和-MongoDB-依赖"><a href="#引入-Mybatis-Plus-和-MongoDB-依赖" class="headerlink" title="引入 Mybatis-Plus 和 MongoDB 依赖"></a>引入 Mybatis-Plus 和 MongoDB 依赖</h3><p>在 <code>build.gradle</code> 中引入 <code>mybatis-plus-boot-starter</code> 依赖</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">group</span>: <span class="hljs-string">&#x27;com.baomidou&#x27;</span>, name: <span class="hljs-string">&#x27;mybatis-plus-boot-starter&#x27;</span>, version: <span class="hljs-string">&#x27;3.0.7.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加测试数据库"><a href="#添加测试数据库" class="headerlink" title="添加测试数据库"></a>添加测试数据库</h3><p>在 <em>src/resources</em> 下创建两个 sql 文件 <code>schema-h2.sql</code> 和 <code>data-h2.sql</code>，简单的使用 <code>H2DB</code> 创建数据库/表并添加数据以供测试使用。</p><p>数据库结构：<code>schema-h2.sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> schema spring_boot_mybatis_plus_mongo;<br>use spring_boot_mybatis_plus_mongo;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_info (<br>  id   <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  age  tinyint            <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  sex  bool               <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><p>数据库测试数据：<code>data-h2.sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">use spring_boot_mybatis_plus_mongo;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_info (id, name, age, sex) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rx&#x27;</span>, <span class="hljs-number">17</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> user_info (id, name, age, sex) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="配置-Mybatis-Plus"><a href="#配置-Mybatis-Plus" class="headerlink" title="配置 Mybatis Plus"></a>配置 Mybatis Plus</h3><p>在 <code>application.yml</code> 中添加数据源配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># DataSource Config</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">org.h2.Driver</span><br>    <span class="hljs-attr">schema:</span> <span class="hljs-string">classpath*:db/schema-h2.sql</span><br>    <span class="hljs-attr">data:</span> <span class="hljs-string">classpath*:db/data-h2.sql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:h2:mem:test</span><br></code></pre></td></tr></table></figure><h3 id="添加一些实体-Dao-Service"><a href="#添加一些实体-Dao-Service" class="headerlink" title="添加一些实体/Dao/Service"></a>添加一些实体/Dao/Service</h3><p>用户信息实体类：<code>com.rxliuli.example.springbootmybatisplusmongo.entity.UserInfo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;user_info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@TableField</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@TableField</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField</span><br>    <span class="hljs-keyword">private</span> Boolean sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserInfo</span><span class="hljs-params">(Long id, String name, Integer age, Boolean sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-comment">// getter()/setter()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用户信息 Dao：<code>com.rxliuli.example.springbootmybatisplusmongo.dao.UserInfoDao</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">UserInfo</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户信息业务接口：<code>com.rxliuli.example.springbootmybatisplusmongo.service.UserInfoService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IService</span>&lt;<span class="hljs-title">UserInfo</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户信息业务接口实现类：<code>com.rxliuli.example.springbootmybatisplusmongo.service.impl.UserInfoServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserInfoDao</span>, <span class="hljs-title">UserInfo</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInfoService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置-Mybatis-Plus-扫描的路径"><a href="#配置-Mybatis-Plus-扫描的路径" class="headerlink" title="配置 Mybatis Plus 扫描的路径"></a>配置 Mybatis Plus 扫描的路径</h3><p>在启动类配置 <code>Mybatis Plus</code>，这点非常重要，以致于吾辈要单独列出，可能会出现的问题参见 <a href="@#%E8%B8%A9%E5%9D%91">踩坑</a> 部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.rxliuli.example.springbootmybatisplusmongo.**.dao.**&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootMybatisPlusMongoApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringBootMybatisPlusMongoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试使用-Mybatis-Plus-的-UserInfoService"><a href="#测试使用-Mybatis-Plus-的-UserInfoService" class="headerlink" title="测试使用 Mybatis Plus 的 UserInfoService"></a>测试使用 Mybatis Plus 的 UserInfoService</h3><p>测试 Mybatis Plus 中 <code>IService</code> 接口的 <code>list()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoServiceTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserInfoService userInfoService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> List&lt;UserInfo&gt; list = userInfoService.list();<br>        assertThat(list)<br>                .isNotEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集成-MongoDB"><a href="#集成-MongoDB" class="headerlink" title="集成 MongoDB"></a>集成 MongoDB</h2><h3 id="引入-MongoDB-Boot-Starter"><a href="#引入-MongoDB-Boot-Starter" class="headerlink" title="引入 MongoDB Boot Starter"></a>引入 MongoDB Boot Starter</h3><p>在 <code>build.gradle</code> 中引入 <code>spring-boot-starter-data-mongodb</code> 依赖</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-data-mongodb&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置-MongoDB"><a href="#配置-MongoDB" class="headerlink" title="配置 MongoDB"></a>配置 MongoDB</h3><p>在 <code>application.yml</code> 中添加 MongoDB 的配置，现在 <code>application.yaml</code> 应该变成了下面这样</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># DataSource Config</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">org.h2.Driver</span><br>    <span class="hljs-attr">schema:</span> <span class="hljs-string">classpath*:db/schema-h2.sql</span><br>    <span class="hljs-attr">data:</span> <span class="hljs-string">classpath*:db/data-h2.sql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:h2:mem:test</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-comment"># Integration mongodb</span><br>    <span class="hljs-attr">mongodb:</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://XXX:XXX@XXX:XXX/XXX</span><br></code></pre></td></tr></table></figure><h3 id="添加-Repository"><a href="#添加-Repository" class="headerlink" title="添加 Repository"></a>添加 Repository</h3><p>定义一些简单操作的 Dao 接口：<code>com.rxliuli.example.springbootmybatisplusmongo.repository.UserInfoLogRepository</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoLogRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">UserInfoLog</span>, <span class="hljs-title">Long</span>&gt;, <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 查询用户日志信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 查询的 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">UserInfoLog <span class="hljs-title">findUserInfoLogByIdEquals</span><span class="hljs-params">(Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义更加复杂需求的 Dao 接口：<code>com.rxliuli.example.springbootmybatisplusmongo.repository.CustomUserInfoLogRepository</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据一些参数查询用户信息列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userInfoLog 参数对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的实现类：<code>com.rxliuli.example.springbootmybatisplusmongo.repository.UserInfoLogRepositoryImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据仓库 &#123;<span class="hljs-doctag">@link</span> UserInfoLogRepository&#125; 的实现类，但请务必注意，实现类继承的是 &#123;<span class="hljs-doctag">@link</span> CustomUserInfoLogRepository&#125; 接口，而非本应该继承的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoLogRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CustomUserInfoLogRepository</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MongoOperations mongoOperations;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfoLog&gt; <span class="hljs-title">listByParam</span><span class="hljs-params">(UserInfoLog userInfoLog)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Criteria criteria = <span class="hljs-keyword">new</span> Criteria();<br>        <span class="hljs-keyword">if</span> (userInfoLog.getUserId() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;userId&quot;</span>)<br>                    .is(userInfoLog.getUserId());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getLogTime() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;logTime&quot;</span>)<br>                    .gte(userInfoLog.getLogTime());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (userInfoLog.getOperate() != <span class="hljs-keyword">null</span>) &#123;<br>            criteria.and(<span class="hljs-string">&quot;operate&quot;</span>)<br>                    .regex(userInfoLog.getOperate());<br>        &#125;<br>        <span class="hljs-keyword">return</span> mongoOperations.find(<span class="hljs-keyword">new</span> Query(criteria), UserInfoLog.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置-MongoDB-扫描的路径"><a href="#配置-MongoDB-扫描的路径" class="headerlink" title="配置 MongoDB 扫描的路径"></a>配置 MongoDB 扫描的路径</h3><p>修改启动类，添加 <code>@EnableMongoRepositories</code> 注解用以配置 MongoDB 扫描的 <code>Repository</code> 路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.rxliuli.example.springbootmybatisplusmongo.**.dao.**&quot;)</span><br><span class="hljs-meta">@EnableMongoRepositories(&quot;com.rxliuli.example.springbootmybatisplusmongo.**.repository.**&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootMybatisPlusMongoApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringBootMybatisPlusMongoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试使用-MongoDB-的-UserInfoLogRepository"><a href="#测试使用-MongoDB-的-UserInfoLogRepository" class="headerlink" title="测试使用 MongoDB 的 UserInfoLogRepository"></a>测试使用 MongoDB 的 UserInfoLogRepository</h3><ol><li> 测试 <code>UserInfoLogRepository</code> 中由 MongoDB Data 自动实现的 <code>findUserInfoLogByIdEquals()</code> 方法</li><li> 测试 <code>CustomUserInfoLogRepository</code> 中自定义复杂的 <code>listByParam()</code> 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoLogRepositoryTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserInfoLogRepository userInfoLogRepository;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始数据，最开始要运行一次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br>        userInfoLogRepository.insert(Lists.newArrayList(<br>                <span class="hljs-keyword">new</span> UserInfoLog(<span class="hljs-number">1L</span>, <span class="hljs-number">1L</span>, <span class="hljs-string">&quot;登录&quot;</span>, LocalDateTime.now()),<br>                <span class="hljs-keyword">new</span> UserInfoLog(<span class="hljs-number">2L</span>, <span class="hljs-number">1L</span>, <span class="hljs-string">&quot;退出&quot;</span>, LocalDateTime.now()),<br>                <span class="hljs-keyword">new</span> UserInfoLog(<span class="hljs-number">3L</span>, <span class="hljs-number">2L</span>, <span class="hljs-string">&quot;登录&quot;</span>, LocalDateTime.now()),<br>                <span class="hljs-keyword">new</span> UserInfoLog(<span class="hljs-number">4L</span>, <span class="hljs-number">3L</span>, <span class="hljs-string">&quot;退出&quot;</span>, LocalDateTime.now())<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findUserInfoLogByIdEquals</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> UserInfoLog result = userInfoLogRepository.findUserInfoLogByIdEquals(<span class="hljs-number">1L</span>);<br>        assertThat(result)<br>                .isNotNull();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listByParam</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> UserInfoLog userInfoLog = <span class="hljs-keyword">new</span> UserInfoLog(<span class="hljs-keyword">null</span>, <span class="hljs-number">1L</span>, <span class="hljs-string">&quot;登&quot;</span>,<br>                LocalDateTime.parse(<span class="hljs-string">&quot;2019-02-22T08:22:16.000Z&quot;</span>, DateTimeFormatter.ISO_DATE_TIME));<br>        <span class="hljs-keyword">final</span> List&lt;UserInfoLog&gt; result = userInfoLogRepository.listByParam(userInfoLog);<br>        assertThat(result)<br>                .isNotEmpty()<br>                .allMatch(log -&gt;<br>                        Objects.equals(userInfoLog.getUserId(), log.getUserId())<br>                                &amp;&amp; log.getOperate().contains(userInfoLog.getOperate())<br>                                &amp;&amp; log.getLogTime().isAfter(userInfoLog.getLogTime())<br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="同时使用-Mybatis-Dao-和-MongoDB-Repository"><a href="#同时使用-Mybatis-Dao-和-MongoDB-Repository" class="headerlink" title="同时使用 Mybatis Dao 和 MongoDB Repository"></a>同时使用 Mybatis Dao 和 MongoDB Repository</h2><h3 id="在-Service-中添加方法"><a href="#在-Service-中添加方法" class="headerlink" title="在 Service 中添加方法"></a>在 Service 中添加方法</h3><p>用户信息业务接口：<code>com.rxliuli.example.springbootmybatisplusmongo.service.UserInfoService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IService</span>&lt;<span class="hljs-title">UserInfo</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户信息与用户日志的映射表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 以 &#123;<span class="hljs-doctag">@link</span> UserInfo&#125; -&gt; &#123;<span class="hljs-doctag">@link</span> List&lt;UserInfoLog&gt;&#125; 形式的 &#123;<span class="hljs-doctag">@link</span> Map&#125;</span><br><span class="hljs-comment">     */</span><br>    Map&lt;UserInfo, List&lt;UserInfoLog&gt;&gt; listUserInfoAndLogMap();<br>&#125;<br></code></pre></td></tr></table></figure><p>用户信息业务接口实现类：<code>com.rxliuli.example.springbootmybatisplusmongo.service.impl.UserInfoServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserInfoDao</span>, <span class="hljs-title">UserInfo</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInfoService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserInfoLogRepository userInfoLogRepository;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Map&lt;UserInfo, List&lt;UserInfoLog&gt;&gt; listUserInfoAndLogMap() &#123;<br>        <span class="hljs-keyword">final</span> List&lt;UserInfo&gt; userInfoList = list();<br>        <span class="hljs-keyword">final</span> List&lt;UserInfoLog&gt; userInfoLogList = userInfoLogRepository.findAll();<br>        <span class="hljs-keyword">final</span> Map&lt;Long, List&lt;UserInfoLog&gt;&gt; map = userInfoLogList.stream().collect(Collectors.groupingBy(UserInfoLog::getUserId));<br>        <span class="hljs-keyword">return</span> userInfoList.stream()<br>                .collect(Collectors.toMap(user -&gt; user, user -&gt; map.getOrDefault(user.getId(), Collections.emptyList())));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加简单的-RestAPI-进行测试"><a href="#添加简单的-RestAPI-进行测试" class="headerlink" title="添加简单的 RestAPI 进行测试"></a>添加简单的 RestAPI 进行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/user-info&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoApi</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserInfoService userInfoService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userInfoService.list();<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list-user-info-and-log-map&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, List&lt;UserInfoLog&gt;&gt; listUserInfoAndLogMap() &#123;<br>        <span class="hljs-keyword">return</span> userInfoService.listUserInfoAndLogMap().entrySet().stream()<br>                .collect(Collectors.toMap(kv -&gt; JsonUtil.toJson(kv.getKey()), Map.Entry::getValue));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试-RestAPI"><a href="#测试-RestAPI" class="headerlink" title="测试 RestAPI"></a>测试 RestAPI</h3><p>现在，我们启动项目并打开浏览器，应当可以在以下地址看到对应的 JSON 数据</p><ul><li><p><a href="http://localhost:8080/api/user-info/list">用户信息列表</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;rx&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">17</span>,<br>    <span class="hljs-attr">&quot;sex&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot; 琉璃 &quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">&quot;sex&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure></li><li><p><a href="http://localhost:8080/api/user-info/list-user-info-and-log-map">用户信息及对应日志映射表</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;&#123;\&quot;id\&quot;:\&quot;1\&quot;,\&quot;name\&quot;:\&quot;rx\&quot;,\&quot;age\&quot;:17,\&quot;sex\&quot;:false&#125;&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">&quot;operate&quot;</span>: <span class="hljs-string">&quot; 登录 &quot;</span>,<br>      <span class="hljs-attr">&quot;logTime&quot;</span>: <span class="hljs-string">&quot;2019-02-22T16:22:16.099&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">&quot;operate&quot;</span>: <span class="hljs-string">&quot; 退出 &quot;</span>,<br>      <span class="hljs-attr">&quot;logTime&quot;</span>: <span class="hljs-string">&quot;2019-02-22T16:22:16.099&quot;</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;&#123;\&quot;id\&quot;:\&quot;2\&quot;,\&quot;name\&quot;:\&quot;琉璃 \&quot;,\&quot;age\&quot;:18,\&quot;sex\&quot;:false&#125;&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;operate&quot;</span>: <span class="hljs-string">&quot; 登录 &quot;</span>,<br>      <span class="hljs-attr">&quot;logTime&quot;</span>: <span class="hljs-string">&quot;2019-02-22T16:22:16.099&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2></li></ul><ol><li><p>Mybatis Plus 扫包范围<br> 使用 <code>@MapperScan</code> 限制 Mybatis Plus 扫描 <code>Dao</code> 的范围，注意不要扫到 MongoDB 的 <code>Repository</code>，否则会抛出异常</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Caused by: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name &#x27;userInfoLogRepository&#x27; defined in null: Cannot register bean definition [Root bean: class [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null] for bean &#x27;userInfoLogRepository&#x27;: There is already [Generic bean: class [org.mybatis.spring.mapper.MapperFactoryBean]; scope=singleton; abstract=false; lazyInit=false; autowireMode=2; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [D:\Text\spring-boot\spring-boot-mybatis-plus-mongo\out\production\classes\com\rxliuli\example\springbootmybatisplusmongo\repository\UserInfoLogRepository.class]] bound.<br></code></pre></td></tr></table></figure><p> 原因是在 SpringMongoData 处理之前 Mybatis Plus 先扫描到并进行了代理，然后就会告诉你无法注册 SpringMongoData 相关的 <code>Repository</code></p></li><li><p>使用 <code>@EnableMongoRepositories</code> 限制 SpringMongoData 扫描的范围</p><p> 既然说到限制，自然也不得不说一下 SpringMongoData 本身，如果你已经使用了 <code>@MapperScan</code> 扫描 Mybatis 需要处理的 Dao，那么添加与否并不重要。但是，吾辈要说但是了，但是，如果你先使用的 MongoDB，那么如果没有使用 <code>@MapperScan</code> 处理 Mybatis 的 Dao 的话，就会抛出以下异常，所以为了安全起见还是都定义了吧</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="hljs-string">&#x27;userInfoServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="hljs-string">&#x27;baseMapper&#x27;</span>; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type <span class="hljs-string">&#x27;com.rxliuli.example.springbootmybatisplusmongo.dao.UserInfoDao&#x27;</span> available: expected at least <span class="hljs-number">1</span> bean which qualifies as autowire candidate. Dependency annotations: &#123;<span class="hljs-meta">@org</span>.springframework.beans.factory.annotation.Autowired(required=<span class="hljs-keyword">true</span>)&#125;<br></code></pre></td></tr></table></figure><p> 说的是自动注入 <code>BaseMapper</code> 失败，实际上是因为 Mybatis 的 Dao SpringMongoData 无法处理。</p></li><li><p>最好使用不同的后缀名区分 <code>Mybatis Mapper</code> 和 <code>Mongo Repository</code>，或者放到不同的包<br> 也是为了避免扫描混乱，出现 <code>Mybatis</code> 扫描到 <code>Mongo Repository</code> 或是 <code>Mongo</code> 扫描到 <code>Mybatis Mapper</code> 的情况，出现上面的那两个错误。</p></li></ol><hr><p>那么，关于在 SpringBoot 中同时使用 Mybatis Plus 和 MongoDB 的搭建就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC @RequestParam 参数不能自动转换泛型集合</title>
    <link href="/p/7b7530bb8811483bae3a891a0b133ca7/"/>
    <url>/p/7b7530bb8811483bae3a891a0b133ca7/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/rxliuli/springmvc-not-generic-param-example">GitHub example</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用 SpringMVC 传参的时候遇到的一个问题，本来需要的参数类型是 <code>Map&lt;Integer, Integer&gt;l</code>。然而浏览器传递过来的是 <code>Map&lt;String, String&gt;</code>。然而，此时 SpringMVC 并没有直接说参数类型错误。</p><p>Controller 大概是下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@PostMapping(&quot;testMap&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Integer, Integer&gt; <span class="hljs-title">testMap</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>        <span class="hljs-comment">// 简单的打印 map</span><br>        log.info(<span class="hljs-string">&quot;map: &#123;&#125;&quot;</span>, map);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，当吾辈调用这个接口时，却出现了错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fd = <span class="hljs-keyword">new</span> FormData();<br>fd.append(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>fd.append(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>fd.append(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>fetch(<span class="hljs-string">&quot;/testMap&quot;</span>, &#123;<br>  method: <span class="hljs-string">&quot;post&quot;</span>,<br>  body: fd,<br>&#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.json())<br>  .then(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(json));<br></code></pre></td></tr></table></figure><p>报错信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;2019-01-17T09:59:16.809+0000&quot;</span>,<br>  <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-number">500</span>,<br>  <span class="hljs-attr">&quot;error&quot;</span>: <span class="hljs-string">&quot;Internal Server Error&quot;</span>,<br>  <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;Could not write JSON: java.lang.String cannot be cast to java.lang.Number; nested exception is com.fasterxml.jackson.databind.JsonMappingException: java.lang.String cannot be cast to java.lang.Number&quot;</span>,<br>  <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/testMap&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Spring 告诉我们，不能转换 <code>String</code> 为 <code>Integer</code>。这是为什么呢？让我们来调试一下！</p><p>可以看到，确实进入了方法，然而最后一步却报错了<br><img src="https://img.rxliuli.com/20190117180704.png" alt="进入了方法"></p><p>报错原因</p><ul><li>泛型只在编译期有约束，运行时泛型实际并不存在，所以可以进入方法而非出现参数错误</li><li>最终转换类型为 <code>Map&lt;Integer, Integer&gt;</code> 的时候发现类型错误</li></ul><p>那么，我们是否可以手动将之转换为 <code>Map&lt;Integer, Integer&gt;</code> 呢？修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@PostMapping(&quot;testMap&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Integer, Integer&gt; <span class="hljs-title">testMap</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;map: &#123;&#125;&quot;</span>, map);<br>        <span class="hljs-keyword">return</span> map.entrySet().stream().collect(Collectors.toMap(kv -&gt; Integer.parseInt(kv.getKey()), kv -&gt; Integer.parseInt(kv.getValue())));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次调用，发现在 <code>kv.getKey()</code> 这里就已经发生了异常。那么，我们应该如何解决呢？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="使用-Map-lt-String-String-gt"><a href="#使用-Map-lt-String-String-gt" class="headerlink" title="使用 Map&lt;String, String&gt;"></a>使用 <code>Map&lt;String, String&gt;</code></h3><p>其实，我们只要将参数类型声明为 <code>Map&lt;String, String&gt;</code>，然后再手动转换即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@PostMapping(&quot;testMap&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Integer, Integer&gt; <span class="hljs-title">testMap</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; map)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;map: &#123;&#125;&quot;</span>, map);<br>        <span class="hljs-keyword">return</span> map.entrySet().stream().collect(Collectors.toMap(kv -&gt; Integer.parseInt(kv.getKey()), kv -&gt; Integer.parseInt(kv.getValue())));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次调用，一切恢复了正常！</p><h3 id="使用-RequestBody"><a href="#使用-RequestBody" class="headerlink" title="使用 @RequestBody"></a>使用 <code>@RequestBody</code></h3><p>除此之外，我们或许还有另外一种方法，使用支持泛型的参数的 <code>@RequestBody</code> 标识为 <code>json</code> 参数。修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@PostMapping(&quot;testMap&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Integer, Integer&gt; <span class="hljs-title">testMap</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;map: &#123;&#125;&quot;</span>, map);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，客户端也要修改为以 <code>json</code> 的形式，将参数传递给服务端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">fetch(<span class="hljs-string">&quot;/testMap&quot;</span>, &#123;<br>  method: <span class="hljs-string">&quot;post&quot;</span>,<br>  body: <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">3</span>: <span class="hljs-number">3</span>,<br>  &#125;),<br>  headers: &#123;<br>    <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,<br>  &#125;,<br>&#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.json())<br>  .then(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(json));<br></code></pre></td></tr></table></figure><hr><p>那么，关于 SpringMVC 不能自动转换泛型集合便到这里就结束啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 行列转换</title>
    <link href="/p/82bfd9d4a02e400a91ac917ac034cccb/"/>
    <url>/p/82bfd9d4a02e400a91ac917ac034cccb/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>面试的时候遇到的一个问题，之前没有碰到过这种场景，所以却是无论如何都回答不了呢！然而本着遇到的坑跌倒过一次就够了的理念，回来时吾辈稍微 Google 了一下这个问题，结果便在此记录一下好啦</p><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><p>指的是将数据行根据状态区分为不同的列，主要应用场景应该是统计报表吧</p><p>例如下面这个 <code>exam</code> 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> exam;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> exam (<br>  name    <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  subject <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;考试科目&#x27;</span>,<br>  score   <span class="hljs-type">int</span>         <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;考试成绩&#x27;</span><br>)<br>  comment <span class="hljs-string">&#x27;考试记录&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-number">90</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>, <span class="hljs-number">85</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;楚轩&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;楚轩&#x27;</span>, <span class="hljs-string">&#x27;物理&#x27;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;化学&#x27;</span>, <span class="hljs-number">40</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;生物&#x27;</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>直接查询会是下面这个样子</p><table><thead><tr><th>姓名</th><th>科目</th><th>分数</th></tr></thead><tbody><tr><td>琉璃</td><td>语文</td><td>90</td></tr><tr><td>琉璃</td><td>英语</td><td>85</td></tr><tr><td>楚轩</td><td>数学</td><td>100</td></tr><tr><td>楚轩</td><td>物理</td><td>100</td></tr><tr><td>张三</td><td>化学</td><td>40</td></tr><tr><td>李四</td><td>生物</td><td>100</td></tr></tbody></table><p>然而需要的结果却是</p><table><thead><tr><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>物理</th><th>化学</th><th>生物</th></tr></thead><tbody><tr><td>张三</td><td>0</td><td>0</td><td>0</td><td>0</td><td>40</td><td>0</td></tr><tr><td>李四</td><td>0</td><td>0</td><td>0</td><td>100</td><td>0</td><td>0</td></tr><tr><td>楚轩</td><td>0</td><td>100</td><td>0</td><td>100</td><td>0</td><td>0</td></tr><tr><td>琉璃</td><td>90</td><td>0</td><td>85</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>大致的实现思路是判断 <code>subject</code> 的值，如果等于 <code>转换列</code> 的值，就将之设置为该 <code>转换列</code> 的值。（此处的 <code>转换列</code> 指的是根据 <code>subject</code> 的值查询的新列）</p><p>目前网络上能找到的方法有下面两种</p><h3 id="使用-if-实现行转列"><a href="#使用-if-实现行转列" class="headerlink" title="使用 if 实现行转列"></a>使用 if 实现行转列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name                              <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;语文&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;语文&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数学&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;英语&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;物理&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;物理&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;化学&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;化学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;生物&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;生物&#x27;</span><br><span class="hljs-keyword">from</span> exam<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>优点：简单方便，即便是将几列合并也可以简单做到。例如我们想要统计主科/副科的总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name                                                                  <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-built_in">sum</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;语文&#x27;</span> <span class="hljs-keyword">or</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">or</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;英语&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;主科&#x27;</span>,<br>  <span class="hljs-built_in">sum</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;物理&#x27;</span> <span class="hljs-keyword">or</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;化学&#x27;</span> <span class="hljs-keyword">or</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;生物&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;副科&#x27;</span><br><span class="hljs-keyword">from</span> exam<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>查询结果</p><table><thead><tr><th>姓名</th><th>主科</th><th>副科</th></tr></thead><tbody><tr><td>张三</td><td>0</td><td>40</td></tr><tr><td>李四</td><td>0</td><td>100</td></tr><tr><td>楚轩</td><td>100</td><td>100</td></tr><tr><td>琉璃</td><td>250</td><td>0</td></tr></tbody></table><p>或者简单的实现小计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  <span class="hljs-comment">-- 这里的 ifnull 其实是为了让最后一行的统计不为 null</span><br>  ifnull(name, <span class="hljs-string">&#x27;total&#x27;</span>)             <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;语文&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;语文&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数学&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;英语&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;物理&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;物理&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;化学&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;化学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(if(subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;生物&#x27;</span>, score, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;生物&#x27;</span>,<br>  <span class="hljs-comment">-- 统计每一行数据</span><br>  <span class="hljs-built_in">sum</span>(score)                        <span class="hljs-keyword">as</span> total<br><span class="hljs-keyword">from</span> exam<br><span class="hljs-comment">-- 按照 name 进行分组并进行小计</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name <span class="hljs-keyword">with</span> <span class="hljs-keyword">rollup</span>;<br></code></pre></td></tr></table></figure><p>查询结果</p><table><thead><tr><th>姓名</th><th>语文</th><th>数学</th><th>英语</th><th>物理</th><th>化学</th><th>生物</th><th>total</th></tr></thead><tbody><tr><td>张三</td><td>0</td><td>0</td><td>0</td><td>0</td><td>40</td><td>0</td><td>40</td></tr><tr><td>李四</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>100</td><td>100</td></tr><tr><td>楚轩</td><td>0</td><td>100</td><td>0</td><td>100</td><td>0</td><td>0</td><td>200</td></tr><tr><td>琉璃</td><td>90</td><td>0</td><td>85</td><td>0</td><td>0</td><td>0</td><td>250</td></tr><tr><td>total</td><td>90</td><td>100</td><td>85</td><td>100</td><td>40</td><td>100</td><td>590</td></tr></tbody></table><h3 id="使用-case-when-实现行转列"><a href="#使用-case-when-实现行转列" class="headerlink" title="使用 case when 实现行转列"></a>使用 case when 实现行转列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;语文&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;语文&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;英语&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;物理&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;物理&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;化学&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;化学&#x27;</span>,<br>  <span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> subject <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;生物&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;生物&#x27;</span><br><span class="hljs-keyword">from</span> exam<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>优点：相比于 <code>if</code> 更加灵活，可以对每个 <code>转换列</code> 的值进行单独的处理。例如我们想要统计主科/副科的总分，并设置计算语文/数学时增加一半，而英语的分数则忽略不计</p><blockquote><p>感觉这个优势相当的小，当然如果用到的话却是无需多言的</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name     <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> subject<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;语文&#x27;</span><br>        <span class="hljs-keyword">then</span> score <span class="hljs-operator">*</span> <span class="hljs-number">1.5</span><br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;数学&#x27;</span><br>        <span class="hljs-keyword">then</span> score <span class="hljs-operator">*</span> <span class="hljs-number">1.5</span><br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;英语&#x27;</span><br>        <span class="hljs-keyword">then</span> <span class="hljs-number">0</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>      <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;主科&#x27;</span>,<br>  <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">case</span> subject<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;物理&#x27;</span><br>        <span class="hljs-keyword">then</span> score<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;化学&#x27;</span><br>        <span class="hljs-keyword">then</span> score<br>      <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;生物&#x27;</span><br>        <span class="hljs-keyword">then</span> score<br>      <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>      <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;副科&#x27;</span><br><span class="hljs-keyword">from</span> exam<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>查询结果</p><table><thead><tr><th>姓名</th><th>主科</th><th>副科</th></tr></thead><tbody><tr><td>张三</td><td>0.0</td><td>40</td></tr><tr><td>李四</td><td>0.0</td><td>100</td></tr><tr><td>楚轩</td><td>150.0</td><td>100</td></tr><tr><td>琉璃</td><td>247.5</td><td>0</td></tr></tbody></table><h3 id="使用子查询实现行转列"><a href="#使用子查询实现行转列" class="headerlink" title="使用子查询实现行转列"></a>使用子查询实现行转列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name,<br>  if(<span class="hljs-keyword">language</span> <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-keyword">language</span>, <span class="hljs-number">0</span>)       <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;语文&#x27;</span>,<br>  if(mathematics <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, mathematics, <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span>,<br>  if(english <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, english, <span class="hljs-number">0</span>)         <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span>,<br>  if(physical <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, physical, <span class="hljs-number">0</span>)       <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;物理&#x27;</span>,<br>  if(chemistry <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, chemistry, <span class="hljs-number">0</span>)     <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;化学&#x27;</span>,<br>  if(biological <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;null&#x27;</span>, biological, <span class="hljs-number">0</span>)   <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;生物&#x27;</span><br><span class="hljs-keyword">from</span> (<br>       <span class="hljs-keyword">select</span><br>         e.name,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;语文&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">language</span>,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> mathematics,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;英语&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> english,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;物理&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> physical,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;化学&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> chemistry,<br>         (<span class="hljs-keyword">select</span> e1.score <span class="hljs-keyword">from</span> exam e1 <span class="hljs-keyword">where</span> subject <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;生物&#x27;</span> <span class="hljs-keyword">and</span> e1.name <span class="hljs-operator">=</span> e.name limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> biological<br>       <span class="hljs-keyword">from</span> exam e<br>       <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name<br>     ) temp;<br></code></pre></td></tr></table></figure><p>优点：使用起来最灵活，但代码量也是最大的。可以对每一个列的多条/单条数据进行单独的处理，不需要必须使用统计函数（<code>sum/avg/max/min/count</code>）。例如上面就是如果查到了多条数据就直接取第一条，当然也可以对第一条数据做后续处理。</p><h3 id="使用-group-concat-简单的行连接"><a href="#使用-group-concat-简单的行连接" class="headerlink" title="使用 group_concat 简单的行连接"></a>使用 group_concat 简单的行连接</h3><p>并非是真正的行转列，实际上只是把不同字段的数据 <em>连接</em> 了起来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name                              <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  group_concat(subject, <span class="hljs-string">&#x27; &#x27;</span>, score) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;成绩单&#x27;</span><br><span class="hljs-keyword">from</span> exam<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>查询结果</p><table><thead><tr><th>姓名</th><th>成绩单</th></tr></thead><tbody><tr><td>张三</td><td>化学 40</td></tr><tr><td>李四</td><td>生物 100</td></tr><tr><td>楚轩</td><td>数学 100,物理 100</td></tr><tr><td>琉璃</td><td>语文 75,语文 90,英语 85</td></tr></tbody></table><h2 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h2><p>将类似的列按照某种规则变成一列，并生成等同倍数的行。</p><p>我们需要将上面行转列得到的表转换回来，例如下面的 <code>exam_score</code> 表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> exam_score (<br>  name        <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  <span class="hljs-keyword">language</span>    <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;语文&#x27;</span>,<br>  mathematics <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;数学&#x27;</span>,<br>  english     <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;英语&#x27;</span>,<br>  physical    <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;物理&#x27;</span>,<br>  chemistry   <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;化学&#x27;</span>,<br>  biological  <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;生物&#x27;</span><br>)<br>  comment <span class="hljs-string">&#x27;考试成绩&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam_score (name, <span class="hljs-keyword">language</span>, mathematics, english, physical, chemistry, biological)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam_score (name, <span class="hljs-keyword">language</span>, mathematics, english, physical, chemistry, biological)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam_score (name, <span class="hljs-keyword">language</span>, mathematics, english, physical, chemistry, biological)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;楚轩&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> exam_score (name, <span class="hljs-keyword">language</span>, mathematics, english, physical, chemistry, biological)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>, <span class="hljs-number">85</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>直接查询结果是</p><table><thead><tr><th>name</th><th>language</th><th>mathematics</th><th>english</th><th>physical</th><th>chemistry</th><th>biological</th></tr></thead><tbody><tr><td>张三</td><td>0</td><td>0</td><td>0</td><td>0</td><td>40</td><td>0</td></tr><tr><td>李四</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>100</td></tr><tr><td>楚轩</td><td>0</td><td>100</td><td>0</td><td>100</td><td>0</td><td>0</td></tr><tr><td>琉璃</td><td>90</td><td>0</td><td>85</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>然而我们需要得到</p><table><thead><tr><th>姓名</th><th>科目</th><th>分数</th></tr></thead><tbody><tr><td>琉璃</td><td>语文</td><td>90</td></tr><tr><td>琉璃</td><td>英语</td><td>85</td></tr><tr><td>楚轩</td><td>数学</td><td>100</td></tr><tr><td>楚轩</td><td>物理</td><td>100</td></tr><tr><td>张三</td><td>化学</td><td>40</td></tr><tr><td>李四</td><td>生物</td><td>100</td></tr></tbody></table><h3 id="使用-union-all-联合查询"><a href="#使用-union-all-联合查询" class="headerlink" title="使用 union all 联合查询"></a>使用 union all 联合查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;语文&#x27;</span>     <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  <span class="hljs-keyword">language</span> <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">language</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;数学&#x27;</span>        <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  mathematics <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> mathematics <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;英语&#x27;</span>    <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  english <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> english <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;物理&#x27;</span>     <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  physical <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> physical <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;化学&#x27;</span>      <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  chemistry <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> chemistry <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>  name,<br>  <span class="hljs-string">&#x27;生物&#x27;</span>       <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;subject&#x27;</span>,<br>  biological <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> exam_score<br><span class="hljs-keyword">where</span> biological <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>唔，好长的 sql 语句，这还只是 6 个 <code>转换列</code>，如果有更多的话恐怕。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="sql-行转列的问题"><a href="#sql-行转列的问题" class="headerlink" title="sql 行转列的问题"></a>sql 行转列的问题</h3><p>sql 的技巧确实很多，然而相比之下 sql 只是一门 <a href="https://zh.wikipedia.org/wiki/SQL">结构化查询语言</a>，并不算是真正的编程语言呢！行转列/列转行这些需求放到真正的编程语言中是很容易处理的，下面演示使用 js 的实现</p><h3 id="使用-JavaScript-实现行转列"><a href="#使用-JavaScript-实现行转列" class="headerlink" title="使用 JavaScript 实现行转列"></a>使用 JavaScript 实现行转列</h3><p>假设有下面这样一个 json 数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;琉璃&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;语文&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">75</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;琉璃&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;语文&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">90</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;琉璃&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;英语&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">85</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;楚轩&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;数学&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;楚轩&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;物理&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;化学&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">40</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>    <span class="hljs-attr">&quot;subject&quot;</span>: <span class="hljs-string">&quot;生物&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: <span class="hljs-number">100</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>转换方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 行转列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>arr 需要进行行转列的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>行转列得到的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rowToCol</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * js 数组按照某个条件进行分组</span><br><span class="hljs-comment">   * 注：分组完成后会得到一个二维数组，并且顺序会被打乱</span><br><span class="hljs-comment">   * 时间复杂度为 2On</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-type">&#123;fn&#125;</span> </span>元素分组的方法，默认使用 &#123;<span class="hljs-doctag">@link </span>JSON.stringify()&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>新的数组</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Array</span>.prototype.groupBy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn = (item) =&gt; <span class="hljs-built_in">JSON</span>.stringify(item)</span>) </span>&#123;<br>    <span class="hljs-comment">// 将元素按照分组条件进行分组得到一个 条件 -&gt; 数组 的对象</span><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>    <span class="hljs-built_in">this</span>.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> name = fn(item);<br>      <span class="hljs-comment">// 如果已经有这个键了就直接追加, 否则先将之赋值为 [] 再追加元素</span><br>      (obj[name] || (obj[name] = [])).push(item);<br>    &#125;);<br>    <span class="hljs-comment">// 将对象转换为数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> obj[key]);<br>  &#125;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * js 的数组去重方法</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-type">&#123;fn&#125;</span> </span>唯一标识元素的方法，默认使用 &#123;<span class="hljs-doctag">@link </span>JSON.stringify()&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>进行去重操作之后得到的新的数组 (原数组并未改变)</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Array</span>.prototype.uniqueBy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn = (item) =&gt; <span class="hljs-built_in">JSON</span>.stringify(item)</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> obj.hasOwnProperty(fn(item)) ? <span class="hljs-literal">false</span> : (obj[fn(item)] = <span class="hljs-literal">true</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取所有的科目 -&gt; 分数映射表</span><br><span class="hljs-comment">   * 看起来函数有点奇怪，但实际上只是一个闭包函数而已</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Object&#125;</span> </span>所有的科目 -&gt; 分数映射表的拷贝</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">const</span> subjectMap = (<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj))(<br>    arr<br>      .map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.subject)<br>      .uniqueBy()<br>      .reduce(<span class="hljs-function">(<span class="hljs-params">res, subject</span>) =&gt;</span> &#123;<br>        res[subject] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;, &#123;&#125;)<br>  );<br>  <span class="hljs-keyword">return</span> arr<br>    .groupBy(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.name)<br>    .map(<span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span><br>      arr<br>        .uniqueBy(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.subject)<br>        .reduce(<span class="hljs-function">(<span class="hljs-params">res, temp</span>) =&gt;</span> &#123;<br>          res = <span class="hljs-built_in">Object</span>.assign(subjectMap(), res);<br>          res.name = temp.name;<br>          res[temp.subject] = temp.score;<br>          <span class="hljs-keyword">return</span> res;<br>        &#125;, &#123;&#125;)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来好像更长了？但实际上 <code>groupBy()/uniqueBy()</code> 都是通用的函数，所以实际代码应该不超过 20 行。转换后的数据如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;语文&quot;</span>: <span class="hljs-number">75</span>,<br>    <span class="hljs-attr">&quot;英语&quot;</span>: <span class="hljs-number">85</span>,<br>    <span class="hljs-attr">&quot;数学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;物理&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;化学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;生物&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;琉璃&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;语文&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;英语&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;数学&quot;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">&quot;物理&quot;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">&quot;化学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;生物&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;楚轩&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;语文&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;英语&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;数学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;物理&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;化学&quot;</span>: <span class="hljs-number">40</span>,<br>    <span class="hljs-attr">&quot;生物&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;语文&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;英语&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;数学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;物理&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;化学&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;生物&quot;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="使用-JavaScript-实现列转行"><a href="#使用-JavaScript-实现列转行" class="headerlink" title="使用 JavaScript 实现列转行"></a>使用 JavaScript 实现列转行</h3><p>那么，如何转换回来呢？转换回来的话却是简单许多了呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 列转行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>arr 需要进行列转行的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>列转行得到的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">colToRow</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-comment">// 定义好需要进行合并列的数组</span><br>  <span class="hljs-keyword">var</span> cols = [<span class="hljs-string">&quot;语文&quot;</span>, <span class="hljs-string">&quot;英语&quot;</span>, <span class="hljs-string">&quot;数学&quot;</span>, <span class="hljs-string">&quot;物理&quot;</span>, <span class="hljs-string">&quot;化学&quot;</span>, <span class="hljs-string">&quot;生物&quot;</span>];<br>  <span class="hljs-keyword">return</span> arr.flatMap(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span><br>    cols<br>      .map(<span class="hljs-function">(<span class="hljs-params">subject</span>) =&gt;</span> (&#123;<br>        name: row.name,<br>        subject: subject,<br>        score: row[subject],<br>      &#125;))<br>      .filter(<span class="hljs-function">(<span class="hljs-params">newRow</span>) =&gt;</span> newRow.score != <span class="hljs-number">0</span>)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>那么，关于 MySQL 行列转换的问题就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 微信公众号开发</title>
    <link href="/p/a639856713894b5cb3d9813cb1635ee6/"/>
    <url>/p/a639856713894b5cb3d9813cb1635ee6/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#java-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91">Java 微信公众号开发</a><ul><li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li><li><a href="#%E6%B3%A8%E5%86%8C%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7">注册微信公众号</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95%E8%B4%A6%E5%8F%B7">使用测试账号</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A0%81">服务端编码</a><ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">初始化项目</a></li><li><a href="#%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F">内网穿透</a></li><li><a href="#%E5%BE%AE%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A4%E8%AF%81">微信服务器认证</a></li><li><a href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86">消息处理</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95">创建菜单</a></li></ul></li></ul></li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>公司需要做一个微信的公众号，以前没有玩过结果踩了一堆坑，也是无奈了，便在这里记录一下</p><h2 id="注册微信公众号"><a href="#注册微信公众号" class="headerlink" title="注册微信公众号"></a>注册微信公众号</h2><p>首先在 <a href="https://mp.weixin.qq.com/">微信公众平台</a> 注册一个账号，这里选择了 _订阅号_，填写一堆乱七八糟的信息后就得到了一个微信公众号（订阅号）了。之后登录的话却是要进行扫码操作（反人类操作）。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在【开发 &gt; 基本配置】中设定好相关的信息，主要有</p><ul><li>开发者 ID(AppID)：自动生成</li><li>开发者密码(AppSecret)：修改完之后记录下来，一会还要用到</li><li>IP 白名单：可以公网访问的服务器 IP 地址（没有也行，后面会说到 <strong>内网穿透</strong>）</li><li>服务器地址(URL)：用于给微信校验的服务器地址，没有公网服务器也行</li><li>令牌(Token)：自定义，随机字符串即可，可以在 <a href="https://www.lastpass.com/zh/password-generator">LastPass</a> 生成一个</li><li>消息加解密密钥(EncodingAESKey)：点击随机生成即可</li><li>消息加解密方式：目前选择明文模式</li></ul><blockquote><p>配置服务器地址时会报错，先不管了就行，后面会再回来配置的。</p></blockquote><h2 id="使用测试账号"><a href="#使用测试账号" class="headerlink" title="使用测试账号"></a>使用测试账号</h2><p>有了自己的微信公众号当然很好，但不可能每次都直接修改真正的公众号吧，修改挂了怎么办？所以就有了测试公众号，而且测试公众号的权限是要高于普通的未认证订阅号的。</p><p>在【开发 &gt; 公众平台测试帐号 &gt; 公众平台测试帐号】中申请一个测试账号，如 <a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</a> 所述中配置一下。</p><blockquote><p>安全域名设置：如果你有的自己的域名和服务器的话就配置，否则就先不管。</p></blockquote><h2 id="服务端编码"><a href="#服务端编码" class="headerlink" title="服务端编码"></a>服务端编码</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>为了简化配置这里使用 SpringBoot Web 项目作为例子（注意勾上 web 模块依赖）</p><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>使用内网穿透工具 serveo 实现将本地内网服务映射到外网的 80 端口上</p><blockquote><p>下面的命令要求系统已经安装了 SSH 客户端，Linux 已经默认安装了，如果是 Windows 可以使用 Cmder 或 Git For Windows 之类的。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh -o ServerAliveInterval=60 -R rx:80:localhost:8080 serveo.net<br></code></pre></td></tr></table></figure><blockquote><p>具体可以参考 <a href="https://serveo.net/">官网</a> 或 <a href="https://blog.rxliuli.com/p/5ad7fa84/">使用 Serveo 进行内网穿透</a></p></blockquote><p>现在，访问 <a href="https://rx.serveo.net/">https://rx.serveo.net/</a>，是不是已经可以啦（出现的 <code>Whitelabel Error Page</code> 不用管，因为我们本来也没有处理 <code>/</code> 路径的访问）</p><h3 id="微信服务器认证"><a href="#微信服务器认证" class="headerlink" title="微信服务器认证"></a>微信服务器认证</h3><p>引入额外的依赖（SpringBoot Web 项目默认引入 <code>spring-boot-starter</code>，<code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-test</code> 模块）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--微信的公众号依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.binarywang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>weixin-java-mp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置文件 <code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 非必需，但这里还是设定一下端口，方便后面写启动脚本</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">custom:</span><br>  <span class="hljs-attr">wx:</span><br>    <span class="hljs-attr">mp:</span><br>      <span class="hljs-comment"># 基本上都是微信公众号那边的设置（这里是测试的）</span><br>      <span class="hljs-attr">appId:</span> <span class="hljs-string">appId</span><br>      <span class="hljs-attr">secret:</span> <span class="hljs-string">secret</span><br>      <span class="hljs-attr">token:</span> <span class="hljs-string">token</span><br>      <span class="hljs-attr">aesKey:</span> <span class="hljs-string">aesKey</span><br></code></pre></td></tr></table></figure><p>将配置读取到 Java Bean 对象上方便在程序中使用 <code>WxMpPropertiesConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信公众号属性配置</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;custom.wx.mp&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpPropertiesConfig</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String appId;<br>    <span class="hljs-keyword">private</span> String secret;<br>    <span class="hljs-keyword">private</span> String token;<br>    <span class="hljs-keyword">private</span> String aesKey;<br>    <span class="hljs-comment">// getter() and setter()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加微信相关的主配置类 <code>WxMpMainConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信公众号主要的配置类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(WxMpPropertiesConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpMainConfig</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WxMpPropertiesConfig wxMpPropertiesConfig;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信公众号的服务对象</span><br><span class="hljs-comment">     * 用户调用微信的各种 API, 例如获取 access_token</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> WxMpService wxMpService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxMpMainConfig</span><span class="hljs-params">(WxMpPropertiesConfig wxMpPropertiesConfig)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.wxMpPropertiesConfig = wxMpPropertiesConfig;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化路由列表和微信服务 api 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//配置微信 api 对象的策略（目前在内存中）</span><br>        <span class="hljs-keyword">final</span> WxMpInMemoryConfigStorage storage = <span class="hljs-keyword">new</span> WxMpInMemoryConfigStorage();<br>        storage.setAppId(wxMpPropertiesConfig.getAppId());<br>        storage.setSecret(wxMpPropertiesConfig.getSecret());<br>        storage.setAesKey(wxMpPropertiesConfig.getAesKey());<br>        storage.setToken(wxMpPropertiesConfig.getToken());<br>        <span class="hljs-comment">//设置策略到服务对象中</span><br>        wxMpService = <span class="hljs-keyword">new</span> WxMpServiceImpl();<br>        wxMpService.setWxMpConfigStorage(storage);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WxMpService <span class="hljs-title">wxMpService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> wxMpService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加一个窗口 api 用于给微信调用 <code>WxMpPortalApi</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信服务窗口 api</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/wx/portal&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpPortalApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WxMpService wxMpService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxMpPortalApi</span><span class="hljs-params">(WxMpService wxMpService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.wxMpService = wxMpService;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信认证当前服务可用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> signature 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timestamp 时间戳</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nonce     随机数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> echostr   成功后回传的随机字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> echostr&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">authGet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            String signature,</span></span><br><span class="hljs-function"><span class="hljs-params">            String timestamp,</span></span><br><span class="hljs-function"><span class="hljs-params">            String nonce,</span></span><br><span class="hljs-function"><span class="hljs-params">            String echostr</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isAnyEmpty(signature, timestamp, nonce, echostr)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;请求非法参数!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (wxMpService.checkSignature(timestamp, nonce, signature)) &#123;<br>            <span class="hljs-keyword">return</span> echostr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;非法请求&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启项目，将 <a href="https://rx.serveo.net/wx/portal">https://rx.serveo.net/wx/portal</a> 填到服务器配置中的 url 里面，点击 <strong>提交</strong>，应该可以看到 [修改成功] 的提示了。</p><h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>很显然，如果我们只让微信认证我们的服务器的话是做不了什么的，所以我们需要监听并处理用户在微信公众号中的操作并返回结果。</p><p>修改微信服务窗口 api <code>WxMpPortalApi</code>，添加对 <code>post</code> 请求的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信服务窗口 api</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/wx/portal&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpPortalApi</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WxMpService wxMpService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WxMpMessageRouter router;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxMpPortalApi</span><span class="hljs-params">(WxMpService wxMpService, WxMpMessageRouter router)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.wxMpService = wxMpService;<br>        <span class="hljs-keyword">this</span>.router = router;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信认证当前服务可用</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> signature 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timestamp 时间戳</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nonce     随机数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> echostr   成功后回传的随机字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> echostr&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">authGet</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            String signature,</span></span><br><span class="hljs-function"><span class="hljs-params">            String timestamp,</span></span><br><span class="hljs-function"><span class="hljs-params">            String nonce,</span></span><br><span class="hljs-function"><span class="hljs-params">            String echostr</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isAnyEmpty(signature, timestamp, nonce, echostr)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;请求非法参数!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (wxMpService.checkSignature(timestamp, nonce, signature)) &#123;<br>            <span class="hljs-keyword">return</span> echostr;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;非法请求&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对所有来自微信服务器的消息进行预处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestBody 请求体（xml 格式）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 明文消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">authPost</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestBody</span> String requestBody,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;signature&quot;)</span> String signature,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;timestamp&quot;)</span> String timestamp,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;nonce&quot;)</span> String nonce,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(name = &quot;encrypt_type&quot;, required = false)</span> String encType,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(name = &quot;msg_signature&quot;, required = false)</span> String msgSignature</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!wxMpService.checkSignature(timestamp, nonce, signature)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;非法请求, 并非微信发来的&quot;</span>);<br>        &#125;<br><br>        WxMpXmlMessage inMessage = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (encType == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//明文传输</span><br>            inMessage = WxMpXmlMessage.fromXml(requestBody);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;aes&quot;</span>.equals(encType)) &#123;<br>            <span class="hljs-comment">//aes 加密</span><br>            inMessage = WxMpXmlMessage.fromEncryptedXml(requestBody, wxMpService.getWxMpConfigStorage(), timestamp, nonce, msgSignature);<br>        &#125;<br>        WxMpXmlOutMessage outMessage = router.route(inMessage);<br>        log.info(<span class="hljs-string">&quot;客户端发送的消息: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(outMessage));<br>        <span class="hljs-keyword">return</span> outMessage == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : outMessage.toXml();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加一个用户消息处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基础微信消息处理器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WxMpMessageHandler</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认空实现</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wxMessage      微信的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context        上下文环境(用于在 handler 中传递信息)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wxMpService    微信 api 服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessionManager 会话管理</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> xml 格式的消息, 异步可返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WxMpXmlOutMessage <span class="hljs-title">handle</span><span class="hljs-params">(WxMpXmlMessage wxMessage, Map&lt;String, Object&gt; context, WxMpService wxMpService, WxSessionManager sessionManager)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户发送消息的处理器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WxMpXmlOutMessage <span class="hljs-title">handle</span><span class="hljs-params">(WxMpXmlMessage wxMessage, Map&lt;String, Object&gt; context, WxMpService wxMpService, WxSessionManager sessionManager)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;接收到消息: &#123;&#125;&quot;</span>, wxMessage.getMsg());<br>        <span class="hljs-keyword">final</span> String content = <span class="hljs-string">&quot;您发送的消息为: &quot;</span> + wxMessage.getContent();<br>        <span class="hljs-keyword">return</span> WxMpXmlOutMessage.TEXT().content(content)<br>                .fromUser(wxMessage.getToUser())<br>                .toUser(wxMessage.getFromUser())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改微信公众号主要的配置类 <code>WxMpMainConfig</code>，添加路由管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信公众号主要的配置类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(WxMpPropertiesConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpMainConfig</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WxMpPropertiesConfig wxMpPropertiesConfig;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MsgHandler msgHandler;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信公众号监听管理路由映射表</span><br><span class="hljs-comment">     * 其实就是监听用户在公众号的操作罢了, 比如点击了某个菜单, 发送了一些消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> WxMpMessageRouter wxMpMessageRouter;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信公众号的服务对象</span><br><span class="hljs-comment">     * 用户调用微信的各种 API, 例如获取 access_token</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> WxMpService wxMpService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WxMpMainConfig</span><span class="hljs-params">(WxMpPropertiesConfig wxMpPropertiesConfig, MsgHandler msgHandler)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.wxMpPropertiesConfig = wxMpPropertiesConfig;<br>        <span class="hljs-keyword">this</span>.msgHandler = msgHandler;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化路由列表和微信服务 api 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//配置微信 api 对象的策略（目前在内存中）</span><br>        <span class="hljs-keyword">final</span> WxMpInMemoryConfigStorage storage = <span class="hljs-keyword">new</span> WxMpInMemoryConfigStorage();<br>        storage.setAppId(wxMpPropertiesConfig.getAppId());<br>        storage.setSecret(wxMpPropertiesConfig.getSecret());<br>        storage.setAesKey(wxMpPropertiesConfig.getAesKey());<br>        storage.setToken(wxMpPropertiesConfig.getToken());<br>        <span class="hljs-comment">//设置策略到服务对象中</span><br>        wxMpService = <span class="hljs-keyword">new</span> WxMpServiceImpl();<br>        wxMpService.setWxMpConfigStorage(storage);<br>        <span class="hljs-comment">//添加路由</span><br>        wxMpMessageRouter = <span class="hljs-keyword">this</span>.newRouter(wxMpService);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据微信 api 服务对象创建一个微信监听路由</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> wxMpService 微信 api 服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 微信监听路由对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> WxMpMessageRouter <span class="hljs-title">newRouter</span><span class="hljs-params">(WxMpService wxMpService)</span> </span>&#123;<br>        WxMpMessageRouter router = <span class="hljs-keyword">new</span> WxMpMessageRouter(wxMpService);<br>        <span class="hljs-comment">//发送消息(默认)</span><br>        router.rule().async(<span class="hljs-keyword">false</span>).handler(<span class="hljs-keyword">this</span>.msgHandler).end();<br>        <span class="hljs-keyword">return</span> router;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WxMpService <span class="hljs-title">wxMpService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> wxMpService;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WxMpMessageRouter <span class="hljs-title">wxMpMessageRouter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> wxMpMessageRouter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在向公众号发送消息，就可以得到回复了（简单的）。还有日志，菜单，关注，取消关注等处理器这里就不赘述了</p><h3 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单"></a>创建菜单</h3><p>创建一个简单的公众号菜单 Api 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信公众号菜单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/wx/menu/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WxMpMenuApi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WxMpBaseApi</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个默认的菜单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 菜单 id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;create&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createDefault</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WxErrorException </span>&#123;<br>        <span class="hljs-keyword">final</span> WxMenu wxMenu = <span class="hljs-keyword">new</span> WxMenu();<br>        <span class="hljs-keyword">final</span> WxMenuButton buttonLeft = <span class="hljs-keyword">new</span> WxMenuButton();<br>        buttonLeft.setType(WxConsts.MenuButtonType.CLICK);<br>        buttonLeft.setName(<span class="hljs-string">&quot;点击&quot;</span>);<br>        buttonLeft.setKey(IdWorker.getIdStr());<br><br>        <span class="hljs-keyword">final</span> WxMenuButton buttonRight = <span class="hljs-keyword">new</span> WxMenuButton();<br>        buttonRight.setType(WxConsts.MenuButtonType.VIEW);<br>        buttonRight.setName(<span class="hljs-string">&quot;链接&quot;</span>);<br>        buttonRight.setUrl(<span class="hljs-string">&quot;https://blog.rxliuli.com&quot;</span>);<br>        buttonRight.setKey(IdWorker.getIdStr());<br>        wxMenu.getButtons().add(buttonLeft);<br>        wxMenu.getButtons().add(buttonRight);<br>        <span class="hljs-keyword">return</span> wxMpService.getMenuService().menuCreate(wxMenu);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 <a href="https://rx.serveo.net/wx/menu/create">https://rx.serveo.net/wx/menu/create</a> 就可以为微信公众号创建一个简单的菜单了。点击左边的“点击”按钮会回复文字说点击了什么，右边的链接则会跳转到一个网页。</p><blockquote><p>其他的功能就放到后面再实现吧，更多公众号开发相关的内容可以参考 <a href="https://mp.weixin.qq.com/wiki">微信官方文档</a> 和 <a href="https://github.com/Wechat-Group/weixin-java-tools">微信开发工具包</a>。当然，所有的示例代码吾辈都已经放到了 <a href="https://github.com/rxliuli/wx-mp-example">GitHub</a>，却是可以参考一下的呢</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 上 Maven 安装与使用</title>
    <link href="/p/aba4a6b2c531479980e3993b60f1bdfb/"/>
    <url>/p/aba4a6b2c531479980e3993b60f1bdfb/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://maven.apache.org/">官网</a>, <a href="https://github.com/apache/maven">GitHub</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Maven 已经是 Java 事实上的依赖管理标准工具了，所以学习使用 maven 有益无害。</p><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><ul><li>[x] 必须已经安装了 JDK 并设置了环境变量，如果还没有安装，请参考 <a href="https://blog.rxliuli.com/p/d0cf29fa/">Windows 上安装 JDK 并设置环境变量</a> 进行安装</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在官网 <a href="https://maven.apache.org/download.cgi">下载页面</a> 找到 <strong>Binary zip archive</strong> 下载二进制数据。</p><p><img src="https://img.rxliuli.com/20181109124211.png" alt="Maven 下载页面"></p><blockquote><p>这里不使用二进制安装包的原因是绿色版更容易迁移，而且是跨平台的。</p></blockquote><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>将文件夹解压到某个位置，然后在环境变量 <strong>Path</strong> 中添加 <em>/bin/</em> 目录</p><p><img src="https://img.rxliuli.com/20181109124557.png" alt="Maven 设置环境变量"></p><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>使用 cmd 打开命令行，输入 <code>mvn --version</code>，你应该得到了类似于下面的输出</p><p><img src="https://img.rxliuli.com/20181109124924.png" alt="查看 Maven 的版本"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>创建一个普通的项目</p><p> 直接使用命令行根据模板创建项目在实际中极为罕见，这里只是演示一下 maven 可以使用命令行创建项目而已</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn archetype:generate -DgroupId=com.rxliuli.maven.example -DartifactId=HelloWorld -DarchetypeArtifactId<br>=maven-archetype-quickstart -DinteractiveMode=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p> 应该会得到如下输出</p><p> <img src="https://img.rxliuli.com/20181109130243.png" alt="Maven 使用命令行创建模板项目"></p></li><li><p>进入项目</p><p> 项目目录结构</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">HelloWorld<br>└─src<br>├─main<br>│  └─java<br>│      └─com<br>│          └─rxliuli<br>│              └─maven<br>│                  └─example<br>└─<span class="hljs-built_in">test</span><br>    └─java<br>        └─com<br>            └─rxliuli<br>                └─maven<br>                    └─example<br></code></pre></td></tr></table></figure><p> maven 项目的配置文件是 <code>pom.xml</code>，而 <strong>源码</strong> 与 <strong>测试</strong> 代码则分离到了两个单独的文件夹</p></li><li><p>maven 基本命令</p><ul><li>package(mvn package): 打包项目</li><li>clean(mvn clean): 清理打包目录</li><li>test(mvn test): 执行 test 目录下的测试</li><li>install(mvn install): 打包项目并安装到本地</li></ul></li></ol><p>其实原生 maven 了解多少并没有什么，因为 IDE 基本都集成了这些开源的工具，并不需要我们手动输入 maven 命令了。嘛，多少了解一些也是挺好的啦ヽ(=^･ω･^=)丿</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 集成 Thymeleaf 模板引擎</title>
    <link href="/p/aff1cf51e02c43a28fe6c5c006bad2cd/"/>
    <url>/p/aff1cf51e02c43a28fe6c5c006bad2cd/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近开始了一个新的项目，后端使用了 SpringBoot。因为没有进行前后端分离，所以还需要模板引擎。经过调查，我们放弃 <code>JSP/JSTL</code> 而选择了 SpringBoot 默认推荐的 <code>Thymeleaf</code>。</p><blockquote><p>附：不要吐槽 <code>JSP/JSTL</code> 很老，吾辈自己都觉得很老，然而公司不允许前后端分离，无解。。。（或许有？）</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用 <a href="https://start.spring.io/">springboot.io</a> 创建项目，选择 <code>Web</code> 和 <code>Thymeleaf</code> 依赖，生成的 <code>build.gradle</code> 配置如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;org.springframework.boot&#x27;</span> version <span class="hljs-string">&#x27;2.1.3.RELEASE&#x27;</span><br>    id <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;io.spring.dependency-management&#x27;</span><br><br>group = <span class="hljs-string">&#x27;com.rxliuli.example&#x27;</span><br>version = <span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>sourceCompatibility = <span class="hljs-string">&#x27;1.8&#x27;</span><br><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27;</span><br>    implementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加公共-js-依赖管理"><a href="#添加公共-js-依赖管理" class="headerlink" title="添加公共 js 依赖管理"></a>添加公共 js 依赖管理</h3><p>公共 <code>JavaScript</code> 依赖: <em>templates/common/common-lib-js.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;common-lib-js&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加公共顶部"><a href="#添加公共顶部" class="headerlink" title="添加公共顶部"></a>添加公共顶部</h3><p>公共的顶部: <em>templates/common/common-header.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;common-header&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;common-header&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-id">#common-header</span> &#123;</span><br>          height: 100px;<br>          width: 100%;<br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#common-header</span> <span class="hljs-selector-class">.text-center</span> &#123;</span><br>          text-align: center;<br>        &#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span>这里是公共顶部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加公共底部"><a href="#添加公共底部" class="headerlink" title="添加公共底部"></a>添加公共底部</h3><p>公共的底部: <em>templates/common/common-footer.html</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;common-footer&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;common-footer&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-id">#common-footer</span> &#123;</span><br>          height: 100px;<br>          width: 100%;<br>        &#125;<br><br><span class="css">        <span class="hljs-selector-id">#common-footer</span> <span class="hljs-selector-class">.text-center</span> &#123;</span><br>          text-align: center;<br>        &#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span>这里是公共底部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="在页面中引入"><a href="#在页面中引入" class="headerlink" title="在页面中引入"></a>在页面中引入</h3><p>下面在页面中引入看看效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    &lt;meta<br>      name=&quot;viewport&quot;<br>      content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;<br>    /&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;x-ua-compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">      <span class="hljs-selector-class">.text-center</span> &#123;</span><br>        text-align: center;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-header::common-header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span>这里是页面单独的内容部分<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-footer::common-footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-lib-js::common-lib-js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log($);</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="https://img.rxliuli.com/20190309095422.png" alt="效果图"></p><p>可以看到 <code>common-lib-js</code>, <code>common-header</code>, <code>common-footer</code> 都已经引入成功</p><p>注意，我们在页面中引入的顺序是</p><ol><li> <code>common-header</code>: 公共头部</li><li> 页面自定义 HTML 内容</li><li> <code>common-footer</code>: 公共底部</li><li> <code>common-lib-js</code>: 公共 JavaScript 依赖</li><li> 页面自定义 JavaScript 脚本</li></ol><p>主要遵循下面几个原则</p><ul><li>JavaScript 必须在 HTML body 结尾处引入，避免加载的速度问题</li><li>自定义的 JavaScript 必须在公共的 JavaScript 之后引入，避免依赖找不到</li></ul><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>难道每个页面我们都需要引入这些公共的文件么？有什么更好的方法么？例如每个页面只要写单独的部分，在渲染的时候 <strong>自动</strong> 将页面中的单独部分渲染到某个布局页面中。<br>很遗憾的是，<code>Thymeleaf</code> 本身并未提供这个功能。然而，<code>Thymeleaf</code> 已经有人做出了第三方的库以提供此功能。</p><p>1.添加依赖项</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:2.3.0&#x27;</span><br></code></pre></td></tr></table></figure><p>2.添加布局文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br>&lt;html<br>  lang=&quot;zh-CN&quot;<br>  xmlns:th=&quot;http://www.thymeleaf.org&quot;<br>  xmlns:layout=&quot;http://www.ultraq.net.nz/thymeleaf/layout&quot;<br>&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    &lt;meta<br>      name=&quot;viewport&quot;<br>      content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;<br>    /&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;x-ua-compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>layout<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--公共的头部--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-header::common-header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--页面自定义的 HTML--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">layout:fragment</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--公共的尾部--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-footer::common-footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--公共的 js 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;common/common-lib-js::common-lib-js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--页面的 js 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">layout:fragment</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.使用布局文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br>&lt;html<br>  lang=&quot;zh-CN&quot;<br>  xmlns:layout=&quot;http://www.ultraq.net.nz/thymeleaf/layout&quot;<br>  layout:decorator=&quot;common/layout&quot;<br>&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    &lt;meta<br>      name=&quot;viewport&quot;<br>      content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;<br>    /&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;x-ua-compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">      <span class="hljs-selector-class">.text-center</span> &#123;</span><br>        text-align: center;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">layout:fragment</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span>这里是页面单独的内容部分<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">layout:fragment</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log($);</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再次刷新，将看到与直接引入有着相同的效果！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring 配置静态资源访问后结果发生 404 了？</title>
    <link href="/p/b542563af92a47e1bb8d1e564fd110fd/"/>
    <url>/p/b542563af92a47e1bb8d1e564fd110fd/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>这两天使用 SpringMVC 时突然发现了一个问题，在 <code>spring-mvc.xml</code> 中配置静态资源访问以后，突然发现访问什么 <code>Controller</code> 控制的页面都 404 了。<br>如果把这个配置删除后，就能正常访问了，后来在与曾经的项目配置文件对比时发现是缺少了配置 <code>&lt;mvc:annotation-driven/&gt;</code>。<br>然而，在没有添加静态资源访问时，没有这个配置也能够使用 <code>Controller</code> 控制器。吾辈好奇的去网络上查询了一下 <code>&lt;mvc:annotation-driven/&gt;</code> 相关的信息，在此记录到 blogger 中，以供日后查阅。</p><p>吾辈的 <code>spring-mvc.xml</code> 中的静态资源访问配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描静态资源文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/statics/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/statics/&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>那么，下面就说一下 <code>&lt;mvc:annotation-driven/&gt;</code> 具体有什么作用好啦！<br><code>&lt;mvc:annotation-driven&gt;</code> 相当于注册了 <code>Spring MVC</code> 分发请求到控制器所必须 <code>DefaultAnnotationHandlerMapping</code> 和 <code>AnnotationMethodHandlerAdapter</code> 两个 Bean，配置一些 messageconvert。即解决了 <code>@Controller</code> 注解的使用前提配置。</p><p>配置中如果没有 <code>&lt;mvc:annotation-driven/&gt;</code>，那么所有的 <code>Controller</code> 可能就没有解析，所有当有请求时候都没有匹配的处理请求类，就都去 <code>&lt;mvc:default-servlet-handler/&gt;</code> 即 <code>default servlet</code> 处理了。添加上 <code>&lt;mvc:annotation-driven/&gt;</code> 后，相应的请求被 <code>Controller</code> 处理，而静态资源因为没有相应的 <code>Controller</code> 就会被 <code>default servlet</code> 处理。总之没有相应的 <code>Controller</code> 就会被 <code>default servlet</code> 处理就 ok 了。</p><p>然后，<code>&lt;mvc:annotation-driven/&gt;</code> 标签配置的这 2 个 Bean 可以根据 classpath 中的内容默认提供以下功能：</p><ol><li>Support for Spring 3’s Type ConversionService in addition to JavaBeans PropertyEditors during Data Binding.A ConversionService instance produced by the org.springframework.format.support.FormattingConversionServiceFactoryBean is used by default.This can be overriden by setting the conversion-service attribute.<br> 支持 spring3 的 javaBeans 属性编辑器数据绑定时的类型转换服务。<br> 类型转换服务实例默认为 org.springframework.format.support.FormattingConversionServiceFactoryBean。<br> 可以覆盖 conversion-service 属性来指定类型转换服务实例类。</li><li>Support for formatting Number fields using the @NumberFormat annotation.<br> 支持 @NumberFormat 注解格式化数字类型字段。</li><li>Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation, if Joda Time 1.3 or higher is present on the classpath.<br> @DateTimeFormat 注解格式化 Date, Calendar, Long 和 Joda Time（如 classpath 下存在 Joda Time 1.3 或更高版本）字段</li><li>Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath.The validation system can be explicitly configured by setting the validator attribute.<br> 支持 @Valid 注解验证控制器数据，classpath 中需 JSR-303 的 **。可以使用 setting 明确的配置</li><li>Support for reading and writing XML, if JAXB is present on the classpath.<br> 支持读写 xml，classpath 中需 JAXB 。</li><li>Support for reading and writing JSON, if Jackson is present on the classpath.<br> 支持读写 json，classpath 中需 Jackson 。</li></ol><p>嗯，这篇 blogger 就这么多啦(其实大部分都是借鉴网络上诸位大佬的啦)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 跨域问题处理</title>
    <link href="/p/c620ae8543be423cad220c0ae09d6be2/"/>
    <url>/p/c620ae8543be423cad220c0ae09d6be2/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在页面上要使用 <code>Ajax</code> 请求去获取另外一个服务的数据，由于浏览器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>，所以直接请求会得到一个 <code>Error</code>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Failed to load https://www.baidu.com/: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;http://localhost:3000&#x27; is therefore not allowed access. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.<br></code></pre></td></tr></table></figure><p>大概就是这样的一个错误，关键词是 <strong>Access-Control-Allow-Origin</strong>，一般出现这个都是跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决跨域问题的方式有很多，但这里之说 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">Cors</a> 的方案。</p><p>在后台添加一个 <code>Filter</code> 过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用自定义的 Filter 拦截器实现跨域请求、</span><br><span class="hljs-comment"> * 适用于所有的 Java Web 项目并且不局限于某个框架</span><br><span class="hljs-comment"> * 注：此处的 <span class="hljs-doctag">@Component</span> 仅为让 Spring 知道这个 Bean, 不然拦截器不会加载</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCorsFilterConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <span class="hljs-comment">//允许所有来源</span><br>        String allowOrigin = <span class="hljs-string">&quot;*&quot;</span>;<br>        <span class="hljs-comment">//允许以下请求方法</span><br>        String allowMethods = <span class="hljs-string">&quot;GET,POST,PUT,DELETE,OPTIONS&quot;</span>;<br>        <span class="hljs-comment">//允许以下请求头</span><br>        String allowHeaders = <span class="hljs-string">&quot;Content-Type,X-Token,Authorization&quot;</span>;<br>        <span class="hljs-comment">//允许有认证信息（cookie）</span><br>        String allowCredentials = <span class="hljs-string">&quot;true&quot;</span>;<br><br>        String origin = request.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>);<br>        <span class="hljs-comment">//此处是为了兼容需要认证信息(cookie)的时候不能设置为 * 的问题</span><br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, origin == <span class="hljs-keyword">null</span> ? allowOrigin : origin);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, allowMethods);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, allowCredentials);<br>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, allowHeaders);<br><br>        <span class="hljs-comment">//处理 OPTIONS 的请求</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(request.getMethod())) &#123;<br>            response.setStatus(HttpServletResponse.SC_OK);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        filterChain.doFilter(request, response);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>web.xml</code> 文件中添加拦截器配置（注：如果可能就配置成第一个 <code>Filter</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--cors 跨域访问--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>customCorsFilterConfig<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>CustomCorsFilterConfig<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>customCorsFilterConfig<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Spring-Web-的解决方案"><a href="#Spring-Web-的解决方案" class="headerlink" title="Spring Web 的解决方案"></a>Spring Web 的解决方案</h2><p>配置一个每次请求都过滤一次的 <code>Filter</code> 就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OncePerRequestFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OncePerRequestFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>                <span class="hljs-comment">//允许所有来源</span><br>                String allowOrigin = <span class="hljs-string">&quot;*&quot;</span>;<br>                <span class="hljs-comment">//允许以下请求方法</span><br>                String allowMethods = <span class="hljs-string">&quot;GET,POST,PUT,DELETE,OPTIONS&quot;</span>;<br>                <span class="hljs-comment">//允许以下请求头</span><br>                String allowHeaders = <span class="hljs-string">&quot;Content-Type,X-Token,Authorization&quot;</span>;<br>                <span class="hljs-comment">//允许有认证信息（cookie）</span><br>                String allowCredentials = <span class="hljs-string">&quot;true&quot;</span>;<br><br>                String origin = request.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>);<br>                <span class="hljs-comment">//此处是为了兼容需要认证信息(cookie)的时候不能设置为 * 的问题</span><br>                response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, origin == <span class="hljs-keyword">null</span> ? allowOrigin : origin);<br>                response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, allowMethods);<br>                response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, allowCredentials);<br>                response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, allowHeaders);<br><br>                <span class="hljs-comment">//处理 OPTIONS 的请求</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>.equals(request.getMethod())) &#123;<br>                    response.setStatus(HttpServletResponse.SC_OK);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                filterChain.doFilter(request, response);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面是一些简单的使用 <code>fetch</code> 进行跨域请求的示例：</p><ul><li><p>简单 fetch 请求，和正常使用 fetch 并无区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fetch(url)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.json())<br>  .then(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(json));<br></code></pre></td></tr></table></figure></li><li><p>表单请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData();<br>fd.append(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;rx&quot;</span>);<br>fd.append(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;rx&quot;</span>);<br><br>fetch(url, &#123;<br>  method: <span class="hljs-string">&quot;POST&quot;</span>,<br>  body: fd,<br>&#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.json())<br>  .then(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(json));<br></code></pre></td></tr></table></figure></li><li><p>需要认证的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">fetch(url, &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 关键就在这里，代表用户是否应该在跨域的情况下发送 cookies 和 HTTP Basic authentication 等验信息以及服务端能否返回 Set-Cookie（服务端 Session 需要使用这个向 cookie 中设置 sessionId）。</span><br><span class="hljs-comment">   * 包含三个可选值：omit(从不发送), same-origin(同源才发送), include(总会发送)</span><br><span class="hljs-comment">   * 参考链接：&lt;https://developer.mozilla.org/zh-CN/docs/Web/API/Request/credentials&gt;</span><br><span class="hljs-comment">   */</span><br>  credentials: <span class="hljs-string">&quot;include&quot;</span>,<br>&#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.json())<br>  .then(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(json));<br></code></pre></td></tr></table></figure><blockquote><p>注：如果想要服务端返回 <code>Set-Cookie</code>（<code>SessionId</code> 也需要通过这个响应属性去设置） 就必须设置这个请求参数！</p></blockquote></li></ul><p>那么，之后在前端跨域请求的时候就可以愉快地玩耍啦（ｖ＾＿＾）ｖ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 GitHub 作为 Maven 仓库</title>
    <link href="/p/d5cd688875914bbbb7afdf0b801c54c3/"/>
    <url>/p/d5cd688875914bbbb7afdf0b801c54c3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/rxliuli/maven-repository-example">GitHub 示例</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在日常工具中也有一些公共的代码库，一直想分离成单独的类库却没有机会，看到使用 github 就能部署 maven 仓库就尝试了一下。</p><blockquote><p>这里吐槽一下 maven 中央仓库的发布流程，不知道为什么不能像 npm 一样一个简单的命令就能发布多好！</p></blockquote><h2 id="创建一个-maven-项目上传到-github"><a href="#创建一个-maven-项目上传到-github" class="headerlink" title="创建一个 maven 项目上传到 github"></a>创建一个 maven 项目上传到 github</h2><p>这是初始的 <code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- pom.xml --&gt;</span><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 项目的组织名，如果没有域名或组织的话就是用 com.github.[你的用户名] --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rxliuli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 项目的名字 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-repository-example<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 版本号，默认是 1.0-SNAPSHOT --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加一个忽略配置 <em>.gitignore</em> 就可以上传到 GitHub 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ignore">target&#x2F;<br>pom.xml.tag<br>pom.xml.releaseBackup<br>pom.xml.versionsBackup<br>pom.xml.next<br>release.properties<br>dependency-reduced-pom.xml<br>buildNumber.properties<br>.mvn&#x2F;timing.properties<br>.mvn&#x2F;wrapper&#x2F;maven-wrapper.jar<br><br># 忽略 IDEA 配置文件<br>*.iml<br>.idea&#x2F;<br>rebel.xml<br></code></pre></td></tr></table></figure><h2 id="修改-maven-deploy-plugin-插件"><a href="#修改-maven-deploy-plugin-插件" class="headerlink" title="修改 maven-deploy-plugin 插件"></a>修改 <code>maven-deploy-plugin</code> 插件</h2><p>主要是设置部署目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置部署目录--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">altDeploymentRepository</span>&gt;</span><br>          internal.repo::default::file://$&#123;project.build.directory&#125;/mvn-repo<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">altDeploymentRepository</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="在-settings-xml-中添加-github-用户信息"><a href="#在-settings-xml-中添加-github-用户信息" class="headerlink" title="在 settings.xml 中添加 github 用户信息"></a>在 settings.xml 中添加 github 用户信息</h2><p>找到 maven 用户配置文件，默认位置在 _~/.m2/settings.xml_。如果不存在，则从 maven 安装目录复制一份过来，具体位置在 _MAVEN_HOME/conf/settings.xml_。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- id，这只是一个标识名，根据它找到用户名和密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>github<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- github 用户名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>rxliuli<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- github 密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="添加插件-com-github-github"><a href="#添加插件-com-github-github" class="headerlink" title="添加插件 com.github.github"></a>添加插件 com.github.github</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 设置 github 服务器使用的配置，在 ~/.m2/settings.xml 中定义 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">github.global.server</span>&gt;</span>github<span class="hljs-tag">&lt;/<span class="hljs-name">github.global.server</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.github<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>site-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        这里需要使用 0.12, 0.9 部署时会出错，具体查看</span><br><span class="hljs-comment">        https://github.com/github/maven-plugins/issues/105</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--git 提交的消息--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>Maven artifacts for $&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--禁用网页处理--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">noJekyll</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">noJekyll</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--部署的目录，这里是和上面的 maven-deploy-plugin 的 configuration.altDeploymentRepository 对应--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/mvn-repo<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span> <span class="hljs-comment">&lt;!-- matches distribution management repository url above --&gt;</span><br>        <span class="hljs-comment">&lt;!--远程分支名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">branch</span>&gt;</span>refs/heads/mvn-repo<span class="hljs-tag">&lt;/<span class="hljs-name">branch</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--github 仓库的名字--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repositoryName</span>&gt;</span>maven-repository-example<span class="hljs-tag">&lt;/<span class="hljs-name">repositoryName</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--github 用户名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repositoryOwner</span>&gt;</span>rxliuli<span class="hljs-tag">&lt;/<span class="hljs-name">repositoryOwner</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--suppress MybatisMapperXmlInspection --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>site<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他内容。。。 --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h2><p>使用命令进行部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn clean deploy<br></code></pre></td></tr></table></figure><p>查看 github 项目库，可以看到已经自动创建了一个分支 <code>mvn-repo</code> 并存放了部署后的文件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加仓库地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-repository-example<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 格式是 https://raw.githubusercontent.com/[github 用户名]/[github 仓库名]/[分支名]/repository --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>      https://raw.githubusercontent.com/rxliuli/maven-repository-example/mvn-repo/repository<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就像其他 maven 仓库一样，我们知道 <code>groupId</code>, <code>artifactId</code> 与 <code>version</code>，自然可以直接使用啦</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rxliuli<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-repository-example<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注: 这种使用 github 部署的 maven 仓库，在 <a href="https://mvnrepository.com/">maven 中央仓库</a> 中并不能搜索到的哦</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 创建用户及授权</title>
    <link href="/p/d7509104a7f64b8da88c89b66722eac6/"/>
    <url>/p/d7509104a7f64b8da88c89b66722eac6/</url>
    
    <content type="html"><![CDATA[<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>使用 <code>root</code> 用户登录到 MySQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> rxliuli<br>  IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> rxliuli;<br></code></pre></td></tr></table></figure><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h3 id="添加授权"><a href="#添加授权" class="headerlink" title="添加授权"></a>添加授权</h3><p>命令格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> privilegesCode <span class="hljs-keyword">ON</span> dbName.tableName <span class="hljs-keyword">TO</span> username<span class="hljs-variable">@host</span> IDENTIFIED <span class="hljs-keyword">BY</span> &quot;password&quot;;<br></code></pre></td></tr></table></figure><p>例如下面就是为 rxliuli 用户赋予了 mytimelinedb 数据库所有表的所有操作权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> mytimelinedb.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> rxliuli<br>IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>privilegesCode</code> 代表权限，常用选项如下：</p><ul><li>ALL PRIVILEGES ：所有权限</li><li>SELECT：读取权限</li><li>DELETE ：删除权限</li><li>UPDATE ：更新权限</li><li>CREATE ：创建权限</li><li>DROP ：删除数据库、数据表权限</li></ul><p><code>dbName.tableName</code> 代表数据库.数据表，常用选项如下：</p><ul><li>.：所有数据库的所有表的权限</li><li>dbName.*：指定数据库的所有表的权限</li><li>dbName.tableName：指定数据库下指定数据表的权限</li></ul><p><code>username@host</code> 表示授予的用户及允许该用户登录的 IP 地址。host 常用选项是：</p><ul><li>不填：允许任意 IP 地址登录</li><li>localhost：只允许本地登录</li><li>%：只允许远程登录</li><li>192.168.2.100：只允许指定 IP 地址登录</li></ul><p><code>password</code> 代表该用户的登录密码<br><code>FLUSH PRIVILEGES</code> 代表刷新权限</p><h3 id="查看授权"><a href="#查看授权" class="headerlink" title="查看授权"></a>查看授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> rxliuli;<br></code></pre></td></tr></table></figure><h3 id="删除授权"><a href="#删除授权" class="headerlink" title="删除授权"></a>删除授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> rxliuli;<br></code></pre></td></tr></table></figure><h3 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush privileges;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Java 实现 setTimeout/setInterval</title>
    <link href="/p/d980de2022714005b329c0ba9580959a/"/>
    <url>/p/d980de2022714005b329c0ba9580959a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>之前想把 Java 代码中使用回调函数的方法改成 <code>Promise</code> 风格，苦思冥想而不得其解。然而突发奇想之下，吾辈尝试在 Java 中实现 JavaScript 的 <code>setTimeout/setInterval</code>，并在之后想到了如何封装回调为 <code>Promise</code>，所以便先在此将这个想法的写出来以供参考。</p><blockquote><p><code>Promise</code> 是 ES6 添加的一个重要的元素，它将回调函数压平为了一级调用，并在 ES7 的 <code>async/await</code> 中彻底改变了异步的使用方式！</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(AsyncUtil.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将当前线程休眠指定的时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> millis 毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(millis);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现 JavaScript 中的 setTimeout</span><br><span class="hljs-comment">     * 注：由于 &#123;<span class="hljs-doctag">@link</span> CompletableFuture#cancel(boolean)&#125; 方法的限制，该定时器无法强制取消</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ms 等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 异步对象</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-keyword">long</span> ms)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.runAsync(() -&gt; sleep(ms));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现等待指定资源加载完成</span><br><span class="hljs-comment">     * 注：由于 &#123;<span class="hljs-doctag">@link</span> CompletableFuture#cancel(boolean)&#125; 方法的限制，该定时器无法强制取消</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> condition 临界条件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 异步对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">waitResource</span><span class="hljs-params">(Supplier&lt;Boolean&gt; condition)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.runAsync(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!condition.get()) &#123;<br>                sleep(<span class="hljs-number">100</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现 JavaScript 中的 setInterval 周期函数</span><br><span class="hljs-comment">     * 该方法并不是非常精确的定时器，仅适用于一般场景，如有需要请使用 &#123;<span class="hljs-doctag">@link</span> ScheduledExecutorService&#125; 类</span><br><span class="hljs-comment">     * 注：由于 &#123;<span class="hljs-doctag">@link</span> CompletableFuture#cancel(boolean)&#125; 方法的限制，该定时器无法强制取消</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ms       间隔毫秒数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> runnable 回调函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 永远不会完成的异步对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title">setInterval</span><span class="hljs-params">(<span class="hljs-keyword">long</span> ms, Runnable runnable)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.runAsync(() -&gt; &#123;<br>            <span class="hljs-comment">//noinspection InfiniteLoopStatement</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    runnable.run();<br>                    sleep(ms);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;使用 setInterval 发生异常: &quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncUtilTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> AsyncUtilTest asyncUtilTest = <span class="hljs-keyword">new</span> AsyncUtilTest();<br>        asyncUtilTest.setTimeout();<br>        asyncUtilTest.waitResource();<br>        asyncUtilTest.setInterval();<br>        AsyncUtil.sleep(<span class="hljs-number">4000</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTimeout</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;setTimeout completed before time: &#123;&#125;&quot;</span>, LocalDateTime.now());<br>        AsyncUtil.setTimeout(<span class="hljs-number">1000</span>)<br>                .thenRunAsync(() -&gt; log.info(<span class="hljs-string">&quot;setTimeout completed after time: &#123;&#125;&quot;</span>, LocalDateTime.now()));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitResource</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;waitResource completed before time: &#123;&#125;&quot;</span>, LocalDateTime.now());<br>        <span class="hljs-keyword">final</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>        AsyncUtil.waitResource(() -&gt; i.get() == <span class="hljs-number">3</span>)<br>                .thenRunAsync(() -&gt; log.info(<span class="hljs-string">&quot;waitResource completed after time: &#123;&#125;&quot;</span>, LocalDateTime.now()));<br>        AsyncUtil.sleep(<span class="hljs-number">2</span>);<br>        i.set(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInterval</span><span class="hljs-params">()</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;setInterval completed before time: &#123;&#125;&quot;</span>, LocalDateTime.now());<br>        <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; future = AsyncUtil.setInterval(<span class="hljs-number">100</span>, () -&gt; log.info(<span class="hljs-string">&quot;setInterval in the loop, current time: &#123;&#125;&quot;</span>, LocalDateTime.now()));<br>        AsyncUtil.sleep(<span class="hljs-number">500</span>);<br>        future.complete(<span class="hljs-keyword">null</span>);<br>        AsyncUtil.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下 MongoDB 便携版安装与初始化</title>
    <link href="/p/e830e32fa0164e87885c45920912da24/"/>
    <url>/p/e830e32fa0164e87885c45920912da24/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.mongodb.org/">官网</a></p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote><p><a href="https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl">下载位置</a></p></blockquote><p>选择一个便携版本下载（<code>.zip</code> 结尾），例如吾辈选择的就是 <a href="http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-4.0.1.zip">win32/mongodb-win32-x86_64-2008plus-ssl-4.0.1.zip</a></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>下载完成后解压到本地，将 <code>/bin/</code> 目录添加环境变量 <code>Path</code> 中以方便使用 <code>mongodb</code> 的命令。</p><p>配置完成后验证一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongo -version<br></code></pre></td></tr></table></figure><p>如果环境变量配置正确的话会有类似于下面的这种输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">MongoDB shell version v4.0.1<br></code></pre></td></tr></table></figure><h2 id="配置日志文件与数据目录"><a href="#配置日志文件与数据目录" class="headerlink" title="配置日志文件与数据目录"></a>配置日志文件与数据目录</h2><p>吾辈的 <code>mongodb</code> 的安装目录是 <code>D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1</code>，所以就在安装目录下创建数据与日志目录了。</p><p>目录列表如下：</p><ul><li>mongodb_data<ul><li>log<ul><li>mongodb.log</li></ul></li><li>data</li></ul></li></ul><p>指定日志文件的位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongod --logpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\log\mongodb.log&quot;</span><br></code></pre></td></tr></table></figure><p>指定数据存放的目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongod --dbpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\data&quot;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">2018-08-08T22:26:35.411+0800 I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols <span class="hljs-string">&#x27;none&#x27;</span><br></code></pre></td></tr></table></figure><p>然后，就停住了，其实这里并未发生错误，仔细看最后一行 <code>NETWORK [listener] connection accepted from 127.0.0.1:12598</code>，指的是正在监听连接 <code>127.0.0.1:12598</code>。所以这个时候在开一个新的 <code>cmd</code> 标签输入 <code>mongo</code> 命令就进入到 <code>mongo shell</code> 里面玩耍啦</p><h2 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h2><p>每次打开都要手动输入命令指定数据目录并启动 <code>mongod</code> 未免麻烦，我们可以将之添加到系统服务中，以后需要的时候只要启动服务就好了，也能设置自动启动什么的了呢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongod --dbpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\data&quot;</span> --logpath <span class="hljs-string">&quot;D:\Program\mongodb-win32-x86_64-2008plus-ssl-4.0.1\mongodb_data\log\mongodb.log&quot;</span> --auth --install --serviceName <span class="hljs-string">&quot;MongoDB&quot;</span><br></code></pre></td></tr></table></figure><p>检查一下系统服务里面是否有 <code>MongoDB</code>，如果没有的话使用管理员权限打开 <code>cmd</code> 再执行一次上面的命令就好了，如果服务没有启动的话就启动它。</p><p>这样便安装完成了，在命令行输入 <code>mongo</code> 就可以啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下安装 Gradle</title>
    <link href="/p/eb05b67ae4bc44e6a7542ebfc3e8e762/"/>
    <url>/p/eb05b67ae4bc44e6a7542ebfc3e8e762/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://gradle.org/">官网</a>, <a href="https://github.com/gradle/gradle">GitHub</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈需要在 Windows 下 build Android 的项目，作为 Android 官方推荐的构建工具，Gradle 也却是不得不用呀</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在官网的版本 <a href="https://gradle.org/releases/">发布页面</a> 找到 Download 的 <strong>binary-only</strong> 链接，点击即可下载了（后面的 <strong>complete</strong> 指的是完整版，我们只是使用的话并不需要下载那个）。<br><img src="https://img.rxliuli.com/20181116203320.png" alt="版本发布"><br><img src="https://img.rxliuli.com/20181116203612.png" alt="下载详情"></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>下载完成后，将文件解压出来，解压出来的文件夹内大概是这个样子</p><p><img src="https://img.rxliuli.com/20181116203858.png" alt="Gradle 解压目录"></p><p>现在，我们需要设置环境变量了</p><p>在 <em>控制面板 &gt; 系统和安全 &gt; 系统</em> 中找到 <em>高级系统设置</em> 项<br><img src="https://img.rxliuli.com/20181116204013.png" alt="系统"></p><p>点击 _环境变量_<br><img src="https://img.rxliuli.com/20181116204130.png" alt="系统属性"></p><p>双击 _系统变量 &gt; Path_<br><img src="https://img.rxliuli.com/20181116204344.png" alt="Path"></p><p>点击 <strong>新建</strong> 创建一个环境变量，随便输入点什么，然后点击 <strong>浏览</strong><br><img src="https://img.rxliuli.com/20181116204638.png" alt="新建环境变量"></p><p>选择 gradle 解压后的文件夹位置，之后点击确定<br><img src="https://img.rxliuli.com/20181116205022.png" alt="选择解压后的文件夹位置"></p><p>然后一路点击确认关闭这 3 个窗口<br><img src="https://img.rxliuli.com/20181116205528.png" alt="关闭窗口"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开 Cmd，下面是从菜单中找到 _Windows 系统 &gt; 命令提示符_<br><img src="https://img.rxliuli.com/20181116205716.png" alt="打开 Cmd"></p><p>在 Cmd 中输入 <code>gradle -v</code> 验证一下，如果得到的是类似于下面的输出，那么 gradle 便是安装成功了<br><img src="https://img.rxliuli.com/20181116210006.png" alt="在 Cmd 下验证 Gradle"></p><p>那么，Gradle 的安装到这里便是基本结束了呢 (★^O^★)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 使用阿里云的短信服务出现问题</title>
    <link href="/p/ee25fb473e3c4a7aafd558d7f70a277e/"/>
    <url>/p/ee25fb473e3c4a7aafd558d7f70a277e/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NoSuchMethodError: org.json.JSONArray.iterator()Ljava/util/Iterator;<br>at com.aliyuncs.regions.LocalEndpointResolver.&lt;init&gt;(LocalEndpointResolver.java:<span class="hljs-number">39</span>)<br>at com.aliyuncs.profile.DefaultProfile.&lt;init&gt;(DefaultProfile.java:<span class="hljs-number">72</span>)<br>at com.aliyuncs.profile.DefaultProfile.getProfile(DefaultProfile.java:<span class="hljs-number">209</span>)<br>at com.rx.f3d.common.util.SmsSendUtil.main(SmsSendUtil.java:<span class="hljs-number">28</span>)<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>NoSuchMethodError</code> 不能找到方法，吾辈第一感觉就是包冲突了。去网络找了一圈，大概有下面这几种说法</p><ul><li>从 <code>spring-boot-*-starter</code> 中排除掉 <code>andriod-json</code> 包，避免与 <code>aliyun-java-sdk-core</code> 依赖的 <code>json</code> 包冲突<br>链接：<a href="https://github.com/qcloudsms/qcloudsms_java/wiki/maven%E8%A7%A3%E5%86%B3org.json%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B">https://github.com/qcloudsms/qcloudsms_java/wiki/maven%E8%A7%A3%E5%86%B3org.json%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B</a></li><li>不使用 <code>Maven</code>，手动引入 <code>Jar</code> 到项目中<br>链接：<a href="https://blog.csdn.net/liuxiaochang_2011/article/details/80468746">https://blog.csdn.net/liuxiaochang_2011/article/details/80468746</a></li><li>修改 <code>aliyun-java-sdk-core</code> 的版本<br>链接：<a href="http://www.mamicode.com/info-detail-2396491.html">http://www.mamicode.com/info-detail-2396491.html</a></li></ul><p>对于吾辈而言，只有最后一种方法是有效的。当然，吾辈修改的版本是 <code>3.3.1</code> 才行的呢</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改完后记得清空缓存并重启 <code>IDE</code> ，然后删除 <code>maven</code> 本地仓库下的 <code>aliyun-java-sdk-core</code> 包以避免缓存问题。</p><blockquote><p>注：吾辈使用的 <code>SpringBoot</code> 版本是 <code>1.5.12.RELEASE</code>，可能和这个也有关系呢</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 字符串数字比较大小的问题以及解决方案</title>
    <link href="/p/efcb3337ccc54b1b971bd5ffdc806f68/"/>
    <url>/p/efcb3337ccc54b1b971bd5ffdc806f68/</url>
    
    <content type="html"><![CDATA[<p>为什么要写这篇文章呢？因为吾辈碰到了 MySQL 中字符串数字比较起来的坑。</p><blockquote><p>字符串数字：明明是数字却在数据库中使用 varchar 等类型进行存储的数字。</p></blockquote><p>例如以下的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_table (<br>  id      <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>  COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,<br>  int_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>  COMMENT <span class="hljs-string">&#x27;使用 varchar 保存数字的列&#x27;</span><br>)<br>  COMMENT <span class="hljs-string">&#x27;测试用的数据表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>当吾辈想要查询 <code>big_int_column</code> 大于某个值的数据时，最初是这样写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> test_table<br><span class="hljs-keyword">WHERE</span> int_str <span class="hljs-operator">&gt;</span> ?;<br></code></pre></td></tr></table></figure><p>但后来发现一个问题。。。</p><p>其实很简单，因为字符串的比较规则和数字并不一样，虽然很多时候看起来好像没什么不同。</p><p>例如下面的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span>; #结果为 <span class="hljs-number">0</span>(<span class="hljs-literal">false</span>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;12&#x27;</span>; #结果为 <span class="hljs-number">1</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>只是类型变化了，但结果却截然相反，因为字符串是按照字符依次进行对比，而数字则是按照大小直接比较。</p><blockquote><p>按照字母依次进行对比的意思是：<br>例如上面的 ‘2’ 和 ‘12’，首先会比较字符 ‘2’ 和 ‘1’ 的大小，如果不是相等，就立刻得出结果，否则继续比较下一位，直到得到结果或没有可以继续比较的情况为止，所以就会得到看似荒谬的 1(true)。</p></blockquote><p>所以后来去稍微查询了一下，发现了 MySQL 中的两个函数：</p><ul><li><p>cast()<br>标准语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">cast</span>(<span class="hljs-keyword">value</span> <span class="hljs-keyword">as</span> type)<br></code></pre></td></tr></table></figure><p>或者（不是重点）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">cast</span>(<span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> <span class="hljs-type">CHAR</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> encoding)<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 转换为整数(值区间 [<span class="hljs-number">-9223372036854775808</span> <span class="hljs-operator">~</span> <span class="hljs-number">9223372036854775807</span>])<br><span class="hljs-built_in">cast</span>(<span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-keyword">AS</span> SIGNED)<br># 或者转换为无符号整数(值区间 [<span class="hljs-number">0</span> <span class="hljs-operator">~</span> <span class="hljs-number">18446744073709551615</span>])<br><span class="hljs-built_in">cast</span>(<span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-keyword">AS</span> UNSIGNED)<br></code></pre></td></tr></table></figure></li><li><p>convert()</p><p>标准语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">convert</span>(<span class="hljs-keyword">value</span>, type)<br></code></pre></td></tr></table></figure><p>或者（不是重点）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">convert</span>(<span class="hljs-keyword">value</span> <span class="hljs-keyword">using</span> charset)<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 转换为整数<br><span class="hljs-keyword">convert</span>(<span class="hljs-string">&#x27;12&#x27;</span>, SIGNED)<br># 或者转换为无符号整数<br><span class="hljs-keyword">convert</span>(<span class="hljs-string">&#x27;12&#x27;</span>, UNSIGNED)<br></code></pre></td></tr></table></figure><p>所以吾辈将查询的 SQL 语句修改成如下样子：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> test_table<br><span class="hljs-keyword">WHERE</span> int_str <span class="hljs-operator">&gt;</span> <span class="hljs-built_in">cast</span>(? <span class="hljs-keyword">AS</span> UNSIGNED);<br></code></pre></td></tr></table></figure><p>算是解决了一些问题，然而如果 <code>int_str</code> 的值大于 <code>UNSIGNED</code> 类型的最大值又会发生问题。。。</p><p>然后从网络上看到了一种推荐的 SQL 的写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但经过了测试，甚至比上面的 <code>cast()</code> 和 <code>convert()</code> 表现更糟。</p><p>例如下面的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;9223372036854775807&#x27;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>; #结果是：<span class="hljs-number">9223372036854776000</span><br></code></pre></td></tr></table></figure><p>所以说，还是直接直接用数字存储数字最好啦！（＿´ω ｀）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>成为 Java 高级程序员需要掌握哪些？</title>
    <link href="/p/22dfbce551e24b8b8c1cf4c1d836b47c/"/>
    <url>/p/22dfbce551e24b8b8c1cf4c1d836b47c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://blog.csdn.net/zhibuguonicuo/article/details/60345715">https://blog.csdn.net/zhibuguonicuo/article/details/60345715</a>，吾辈只修改了部分排版/错字以更好的阅读。</p></blockquote><h2 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h2><ol><li><p> Core Java，就是 Java 基础、JDK 的类库，很多童鞋都会说，JDK 我懂，但是懂还不足够，知其然还要知其所以然，JDK 的源代码写的非常好，要经常查看，对使用频繁的类，比如 String，集合类（List，Map，Set）等数据结构要知道它们的实现，不同的集合类有什么区别，然后才能知道在一个具体的场合下使用哪个集合类更适合、更高效，这些内容直接看源代码就 OK 了</p></li><li><p> 多线程并发编程，现在并发几乎是写服务端程序必须的技术，那对 Java 中的多线程就要有足够的熟悉，包括对象锁机制、synchronized 关键字，concurrent 包都要非常熟悉，这部分推荐你看看《Java 并发编程实践》这本书，讲解的很详细</p></li><li><p> I/O，Socket 编程，首先要熟悉 Java 中 Socket 编程，以及 I/O 包，再深入下去就是 Java NIO, 再深入下去是操作系统底层的 Socket 实现, 了解 Windows 和 Linux 中是怎么实现 socket 的</p></li><li><p> JVM 的一些知识，不需要熟悉，但是需要了解，这是 Java 的本质，可以说是 Java 的母体, 了解之后眼界会更宽阔，比如 Java 内存模型（会对理解 Java 锁、多线程有帮助）、字节码、JVM 的模型、各种垃圾收集器以及选择、JVM 的执行参数（优化 JVM）等等, 这些知识在《深入 Java 虚拟机》这本书中都有详尽的解释, 或者去 oracle 网站上查看具体版本的 JVM 规范.</p></li><li><p> 一些常用的设计模式，比如单例、模板方法、代理、适配器等等，以及在 Core Java 和一些 Java 框架里的具体场景的实现，这个可能需要慢慢积累，先了解有哪些使用场景，见得多了，自己就自然而然会去用。</p></li><li><p> 常用数据库（Oracle、MySQL 等）、SQL 语句以及一般的优化</p></li><li><p> JavaWeb 开发的框架，比如 Spring、iBatis 等框架，同样他们的原理才是最重要的，至少要知道他们的大致原理。</p></li><li><p> 其他一些有名的用的比较多的开源框架和包，Netty 网络框架，Apache common 的 N 多包，Google 的 Guava 等等，也可以经常去 Github 上找一些代码看看。</p></li></ol><h2 id="section-2"><a href="#section-2" class="headerlink" title="section 2"></a>section 2</h2><p>每逢长假都会有很多程序员跳槽，十一、过年是跳槽黄金时刻，尤其是过年。过年的时候年终奖到手，没有了多少牵挂，年终同学同事聚会比较多，沟通的就多，各种工作机会的消息也相应会多，所以跳槽的机会也就会多。跳槽就必不可少的要经过面试，那么作为一个 Java 程序员需要准备哪些面试知识呢？下面就给大家说说。</p><ol><li><p>集合框架<br> <img src="https://img.rxliuli.com/20181126223446.png" alt="集合框架"><br> 从上图可以看到主要是 Collection 和 Map 的继承类和 Iterator 的实现类，重点掌握 ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、TreeMap、HashTable 的特点和实现原理，还有多线程使用场景和插入多还是删除多的时候使用什么样的集合类效率会更高。</p></li><li><p>IO 框架<br> <img src="https://img.rxliuli.com/20181126223616.png" alt="IO 框架"><br> 主要掌握 Reader、Writer、InputStream、OutputStream 的继承类，重点掌握字节流 (FileInputStream、FileOutputSteam、BufferedInputStream、BufferedOutputStream、DataInputStream、DataOutputStream) 和字符流(FileReader、FileWriter、BufferedReader、BufferedWriter、InputStreamReader、OutputStreamWriter)，并熟练运用。还有就是 NIO 的工作原理要知道。</p></li><li><p>String 相关<br> 主要考察对 String 的处理，顺带考察多线程和算法，大公司就是喜欢考察字符串的算法，主要是字符串查找或者剔除，多线程打印字符串，超大字符串处理。</p></li><li><p>异常处理<br> <img src="https://img.rxliuli.com/20181126223820.png" alt="异常处理"><br> 掌握 Throwable 继承类，理解 Error 和 Exception 的区别，理解运行时异常和编译异常的区别，掌握异常的处理方法，掌握 try、catch、finally、throw、throws 关键字的意义，掌握 try-catch-finally 语句的执行顺序，掌握异常的工作原理，知道常见的异常有哪些。</p></li><li><p>多线程<br> 如何创建和启动一个线程，有哪些方法？多线程如何交互，线程之间的调度、让步、合并，如何同步？生产和消费者模型。还有就是掌握线程安全、线程池，死锁。</p></li><li><p>JVM 知识<br> 掌握常见的垃圾回收机制，掌握程序计数器、堆、栈、方法区的作用，掌握类的加载机制。掌握内存分代模型和工作原理。掌握 JVM 启动参数常见配置，了解 JVM 调优。</p></li><li><p>数据结构与算法：<br> 掌握常见查找和排序算法实现及其时间、空间复杂度。掌握常见数据结构如链表、队列、栈的基本原理和实现。</p></li></ol><h2 id="section-3"><a href="#section-3" class="headerlink" title="section 3"></a>section 3</h2><p>经常主持对高级工程师和中基层 Tech Leader 的面试，一年下来总有百八十场，我给大家分享一下我对于高级工程师的定位吧，虽然我主要负责. Net 团队，但是对于其他语言应该也是适用的。</p><p><strong>一、理论基础：</strong> 高级工程师必须有较好的理论基础，既包含一些基础的学科知识，也要包含个人专攻方向的前沿理论。我遇到过形形色色的求职者，有人自称精通领域模式，却不明白什么是聚合根（领域根）。甚至有人无法列举常用的非线性结构，更别提伪码实现和应用场景分析了。这些人普遍振振有词地说， 我有丰富的开发经验，项目需要实现的功能我都能做出来，我只是没有去记那些术语名词。抱歉，你不是没有记术语名词，你是根本没有潜心看技术文章的心态，你所谓的学习就是看一些诸如《21 天精通 Java》，《7 天，从菜鸟到专家》之类的垃圾书，或者看点视频。那么你这个高工，比别人高在哪里呢？当单位需要你代表团队和合作机构沟通，甚至发表专栏的时候，你是不是也准备跟大家讲” 这个东西我不知道该怎么讲，大家可以看一下我的代码 “。只有代码可秀的人是码农，不是高工，所以我给这类求职者的综评是中 + 封顶。</p><p><strong>二、工作经验：</strong> 高级工程师必须有过在项目中担心核心模块开发或者整体架构设计的经验，并且项目越高大上越好，比如你在互联网企业搞过读写分离的实现，你在电商搞过秒杀算法，你在电信行业做过网络层，我必定会高看一眼。如果你就仅仅只是一个人全栈搞过几个小网站，啪啪啪一大堆成熟框架用得倍溜，那么你只是一个装配工。我给这类求职者的综评是中 + 封顶。</p><p><strong>三、培养潜力：</strong> 高级工程师必须有全局思维，如果在你过往的工作历程中，你对你兄弟团队或者部门的工作情形一问三不知，甚至于一个项目中，你只懂自己的模块，其他同事负责的模块你就只会 call 个 API，那么你就是一个很难再进一步的人。对于企业来说，有你不多，无你不少，所以我给这类求职者的综评是中 + 封顶。</p><p><strong>四、沟通能力：</strong> 高级工程师在技术团队中是绝对的核心人中，小项目中你就是负责人，大项目中你也要负责带新人，那么良好的沟通能力必不可少，如果你仅仅是自己一个人心里亮堂，你对企业的价值就要大打折扣。这类求职者，我也有录用过不少，因为程序员木讷可以说是一种共性，在这方面没法太挑剔，但是我给他们的综评是高 - 封顶。</p><h2 id="section-4"><a href="#section-4" class="headerlink" title="section 4"></a>section 4</h2><p>如果要应聘高级开发工程师职务，仅仅懂得 Java 的基础知识是远远不够的，还必须懂得常用数据结构、算法、网 络、操作系统等知识。因此本文不会讲解具体的技术，笔者综合自己应聘各大公司的经历，整理了一份大公司对 Java 高级开发工程师职位的考核纲要，希望可以帮助到需要的人。</p><h3 id="1、Java-基础"><a href="#1、Java-基础" class="headerlink" title="1、Java 基础"></a>1、Java 基础</h3><h4 id="1-1-Collection-和-Map"><a href="#1-1-Collection-和-Map" class="headerlink" title="1.1 Collection 和 Map"></a>1.1 Collection 和 Map</h4><ol><li> 掌握 Collection 和 Map 的继承体系。</li><li> 掌握 ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、 LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、 TreeMap、HashTable 的特点和实现原理。</li><li> 掌握 CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap 的实现原理和适用场景。</li></ol><h4 id="1-2-IO"><a href="#1-2-IO" class="headerlink" title="1.2 IO"></a>1.2 IO</h4><ol><li> 掌握 InputStream、OutputStream、Reader、Writer 的继承体系。</li><li> 掌握字节流 (FileInputStream、DataInputStream、BufferedInputStream、 FileOutputSteam、DataOutputStream、BufferedOutputStream) 和字符流 (BufferedReader、InputStreamReader、FileReader、BufferedWriter、 OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。</li><li> 掌握 NIO 实现原理及使用方法。</li></ol><h4 id="1-3-异常"><a href="#1-3-异常" class="headerlink" title="1.3 异常"></a>1.3 异常</h4><ol><li> 掌握 Throwable 继承体系。</li><li> 掌握异常工作原理。</li><li> 了解常见受检异常 (比如 FileNotFoundException)、非受检异常(比如 NullPointerException) 和错误(比如 IOError)。</li></ol><h4 id="1-4-多线程"><a href="#1-4-多线程" class="headerlink" title="1.4 多线程"></a>1.4 多线程</h4><ol><li> 掌握 Executors 可以创建的三种 (JAVA8 增加了一种，共四种) 线程池的特点及适用范围。</li><li> 掌握多线程同步机制，并熟练运用。</li></ol><h4 id="1-5-Socket"><a href="#1-5-Socket" class="headerlink" title="1.5 Socket"></a>1.5 Socket</h4><ol><li> 掌握 Socket 通信原理。</li><li> 熟练使用多线程结合 Socket 进行编程。</li></ol><h3 id="2、Java-虚拟机"><a href="#2、Java-虚拟机" class="headerlink" title="2、Java 虚拟机"></a>2、Java 虚拟机</h3><h4 id="2-1-JVM-内存区域划分"><a href="#2-1-JVM-内存区域划分" class="headerlink" title="2.1 JVM 内存区域划分"></a>2.1 JVM 内存区域划分</h4><ol><li> 掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8 已移除）、元空间（JAVA8 新增）的作用及基本原理。</li><li> 掌握堆的划分：新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理。</li><li> 掌握 JVM 内存参数设置及调优。</li></ol><h4 id="2-2-类加载"><a href="#2-2-类加载" class="headerlink" title="2.2 类加载"></a>2.2 类加载</h4><ol><li> 掌握类的加载阶段：加载、链接（验证、准备、解析）、初始化、使用、卸载。</li><li> 掌握类加载器分类及其应用：启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器。</li></ol><h4 id="3、J2EE"><a href="#3、J2EE" class="headerlink" title="3、J2EE"></a>3、J2EE</h4><ol><li> 掌握 JSP 内置对象、动作及相关特点和工作原理。</li><li> 掌握 Servlet 的特点和工作原理。</li><li> 掌握 Spring 框架的 IOC 和 AOP 实现原理（反射和动态代理）。</li><li> 至少掌握一个 MVC 框架（Spring MVC，Struts 等）的工作原理，并熟练运用。</li><li> 至少掌握一个 ORM 框架 (Hibernate，MyBatis 等) 的工作原理，并熟练运用。</li></ol><h4 id="4、数据结构与算法"><a href="#4、数据结构与算法" class="headerlink" title="4、数据结构与算法"></a>4、数据结构与算法</h4><ol><li> 掌握线性表和树的特点并熟练运用。</li><li> 掌握常用排序和查找算法：插入排序 (直接插入排序、希尔排序)、选择排序 (直接选择排序、堆排序)、交换排序 (冒泡排序、快速排序)、归并排序，顺序查找、二分查找、哈希查找。</li><li> 熟练运用常见排序和查找算法思想解决编程问题。</li><li> 了解几大基本算法：贪心算法、分治策略、动态规划。</li></ol><h4 id="5、计算机网络"><a href="#5、计算机网络" class="headerlink" title="5、计算机网络"></a>5、计算机网络</h4><ol><li> 掌握网络的分层结构，及每层的功能特点。</li><li> 掌握 TCP/IP 的通信原理 (三次握手、四次挥手)</li></ol><h4 id="6、数据库"><a href="#6、数据库" class="headerlink" title="6、数据库"></a>6、数据库</h4><ol><li> 掌握复杂的 SQL 语句编写。</li><li> 掌握数据库的优化（SQL 层面和表设计层面）。</li><li> 至少掌握一款数据库产品。</li><li> 熟悉高并发、大数据情况下的数据库开发。</li></ol><h4 id="7、Web-技术"><a href="#7、Web-技术" class="headerlink" title="7、Web 技术"></a>7、Web 技术</h4><ol><li> 掌握 AJAX 的工作原理。</li><li> 至少熟悉一款 JS 框架 (比如 JQuery)。</li></ol><h4 id="8、设计模式"><a href="#8、设计模式" class="headerlink" title="8、设计模式"></a>8、设计模式</h4><ol><li> 熟悉常见的设计模式。</li><li> 会将设计模式理论应用到实际开发中。</li></ol><h4 id="9、Linux"><a href="#9、Linux" class="headerlink" title="9、Linux"></a>9、Linux</h4><ol><li> 熟练运用 Linux 常见命令。</li><li> 熟悉 Linux 操作系统基本概念及特点。</li><li> 熟悉 Shell 脚本。</li></ol><h4 id="10、操作系统"><a href="#10、操作系统" class="headerlink" title="10、操作系统"></a>10、操作系统</h4><ol><li> 掌握操作系统的进程管理。</li><li> 了解操作系统的 I/O。</li></ol><h4 id="11、正则表达式"><a href="#11、正则表达式" class="headerlink" title="11、正则表达式"></a>11、正则表达式</h4><ol><li> 掌握常见正则表达式符号。</li><li> 熟练运用正则表达式解决实际问题 (比如匹配电话号码、邮箱、域名等)。</li></ol><h2 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5"></a>Section 5</h2><ul><li>h5edu 的源码</li><li>pure– 响应式 css 框架</li><li>Hadoop 大数据</li><li>ERP 系统开发</li><li>linux</li><li>freemarker</li><li>weblogic/jobss</li><li>webwhpere</li><li>webservice <a href="http://www.iteye.com/topic/1135747">http://www.iteye.com/topic/1135747</a></li><li>bootstrap</li><li>HTML5</li><li>android</li><li>css/jslever</li><li>spring aop ssh ssm 徒手搭建</li><li>jquery 源码分析融汇</li><li>缓存 echacge</li><li>并发</li><li>页面静态化</li><li>UML</li><li>shell</li><li>pathy</li><li>github</li><li>网络编程</li><li>ExtJS</li><li>网络爬虫</li><li>设计模式</li><li>多线程与并发</li><li>第三方支付 / 登录</li></ul><h2 id="高级工程"><a href="#高级工程" class="headerlink" title="============= 高级工程 ============="></a>============= 高级工程 =============</h2><h3 id="1、Core-Java-部分"><a href="#1、Core-Java-部分" class="headerlink" title="1、Core Java 部分"></a>1、Core Java 部分</h3><p>这是最基础的, 对于一个 java 高级开发 / 设计人员, 你需要对这一部分达到精通的水平, 重点内容如下:</p><ol><li> 面向对象编程思想 (封装继承多态接口)</li><li> 字符串处理</li><li> java.lang 包, java.util 包等常用包</li><li> java 异常处理</li></ol><h3 id="2、Java-高级部分"><a href="#2、Java-高级部分" class="headerlink" title="2、Java 高级部分"></a>2、Java 高级部分</h3><ol><li> Java I/O 流</li><li> Java 多线程技术</li><li> Java 网络编程</li><li> Java Swing</li></ol><blockquote><p>后两项可以了解即可, 如果项目需要可以深入研究</p></blockquote><h3 id="3、前端基本技能"><a href="#3、前端基本技能" class="headerlink" title="3、前端基本技能"></a>3、前端基本技能</h3><ul><li>HTML + CSS 网页开发</li><li>JavaScript</li><li>Jquery</li><li>浏览器兼容性 CSS hack(了解)</li></ul><h3 id="4、熟练使用-JSP-Servlet-进行开发"><a href="#4、熟练使用-JSP-Servlet-进行开发" class="headerlink" title="4、熟练使用 JSP + Servlet 进行开发"></a>4、熟练使用 JSP + Servlet 进行开发</h3><h3 id="5、MVC-设计模式-原理-以及相关框架-如-Struts"><a href="#5、MVC-设计模式-原理-以及相关框架-如-Struts" class="headerlink" title="5、MVC 设计模式, 原理, 以及相关框架, 如 Struts"></a>5、MVC 设计模式, 原理, 以及相关框架, 如 Struts</h3><h3 id="6、SSH-框架"><a href="#6、SSH-框架" class="headerlink" title="6、SSH 框架"></a>6、SSH 框架</h3><h3 id="7、缓存技术-session-amp-cookie"><a href="#7、缓存技术-session-amp-cookie" class="headerlink" title="7、缓存技术 session &amp; cookie"></a>7、缓存技术 session &amp; cookie</h3><h3 id="8、熟练使用一种以上-Java-开发工具"><a href="#8、熟练使用一种以上-Java-开发工具" class="headerlink" title="8、熟练使用一种以上 Java 开发工具"></a>8、熟练使用一种以上 Java 开发工具</h3><p>Eclipse/MyEclipse/Jbuilder/Jcreator</p><h3 id="9、熟练使用-XML"><a href="#9、熟练使用-XML" class="headerlink" title="9、熟练使用 XML"></a>9、熟练使用 XML</h3><p>JDOM w3c.dom SAX</p><h3 id="10、Java-设计模式"><a href="#10、Java-设计模式" class="headerlink" title="10、Java 设计模式"></a>10、Java 设计模式</h3><p>工厂模式, 单例模式 ==</p><h3 id="11、Java-反射机制"><a href="#11、Java-反射机制" class="headerlink" title="11、Java 反射机制"></a>11、Java 反射机制</h3><p>反射的各种用法</p><h3 id="12、了解或熟悉-C-C-NET"><a href="#12、了解或熟悉-C-C-NET" class="headerlink" title="12、了解或熟悉 C, C++, .NET"></a>12、了解或熟悉 C, C++, .NET</h3><h3 id="13、熟悉-JDK-的配置-环境变量"><a href="#13、熟悉-JDK-的配置-环境变量" class="headerlink" title="13、熟悉 JDK 的配置, 环境变量"></a>13、熟悉 JDK 的配置, 环境变量</h3><h3 id="14、数据库-oracle-必学-其他最好了解一种以上-mysql-sql-server-access"><a href="#14、数据库-oracle-必学-其他最好了解一种以上-mysql-sql-server-access" class="headerlink" title="14、数据库 oracle 必学, 其他最好了解一种以上 (mysql,sql server,access==)"></a>14、数据库 oracle 必学, 其他最好了解一种以上 (mysql,sql server,access==)</h3><p>oracle: 视图, 索引, 存储过程, 触发器, 游标, 包, 常用函数 ==</p><h3 id="15、数据库原理"><a href="#15、数据库原理" class="headerlink" title="15、数据库原理"></a>15、数据库原理</h3><p>事务的原理, 锁机制, 表连接, 复杂查询语句 (工作经验), 性能调优, 锁表以及解决方案 ==</p><h3 id="16、JDBC-连接池"><a href="#16、JDBC-连接池" class="headerlink" title="16、JDBC, 连接池"></a>16、JDBC, 连接池</h3><h3 id="17、Ajax-反向-Ajax"><a href="#17、Ajax-反向-Ajax" class="headerlink" title="17、Ajax, 反向 Ajax"></a>17、Ajax, 反向 Ajax</h3><h3 id="18、HTTP-协议-request-和-response-的原理-HTTP-status-了解常用的-Https-原理"><a href="#18、HTTP-协议-request-和-response-的原理-HTTP-status-了解常用的-Https-原理" class="headerlink" title="18、HTTP 协议, request 和 response 的原理, HTTP status(了解常用的),Https 原理"></a>18、HTTP 协议, request 和 response 的原理, HTTP status(了解常用的),Https 原理</h3><h3 id="19、熟悉-Linux-基本命令-使用过-Linux-Unix-系统-可以编写-shell-脚本-可以在-Linux-上部署项目"><a href="#19、熟悉-Linux-基本命令-使用过-Linux-Unix-系统-可以编写-shell-脚本-可以在-Linux-上部署项目" class="headerlink" title="19、熟悉 Linux 基本命令, 使用过 Linux/Unix 系统, 可以编写 shell 脚本, 可以在 Linux 上部署项目"></a>19、熟悉 Linux 基本命令, 使用过 Linux/Unix 系统, 可以编写 shell 脚本, 可以在 Linux 上部署项目</h3><h3 id="20、了解-windows-系统批处理脚本-bat"><a href="#20、了解-windows-系统批处理脚本-bat" class="headerlink" title="20、了解 windows 系统批处理脚本 bat"></a>20、了解 windows 系统批处理脚本 bat</h3><h3 id="21、了解-HTML5-最好学习过"><a href="#21、了解-HTML5-最好学习过" class="headerlink" title="21、了解 HTML5, 最好学习过"></a>21、了解 HTML5, 最好学习过</h3><h3 id="22、熟悉一种-JS-框架-如-Prototype"><a href="#22、熟悉一种-JS-框架-如-Prototype" class="headerlink" title="22、熟悉一种 JS 框架, 如 Prototype"></a>22、熟悉一种 JS 框架, 如 Prototype</h3><h3 id="23、J2EE-原理-熟悉一种以上-web-容器如-Tomcat-JBoss-websphere-weblogic"><a href="#23、J2EE-原理-熟悉一种以上-web-容器如-Tomcat-JBoss-websphere-weblogic" class="headerlink" title="23、J2EE 原理 熟悉一种以上 web 容器如 Tomcat,JBoss,websphere,weblogic=="></a>23、J2EE 原理 熟悉一种以上 web 容器如 Tomcat,JBoss,websphere,weblogic==</h3><h3 id="24、熟悉-ant-或-maven"><a href="#24、熟悉-ant-或-maven" class="headerlink" title="24、熟悉 ant 或 maven"></a>24、熟悉 ant 或 maven</h3><h3 id="25、熟悉一门脚本语言-如-python-ruby"><a href="#25、熟悉一门脚本语言-如-python-ruby" class="headerlink" title="25、熟悉一门脚本语言, 如 python ,ruby"></a>25、熟悉一门脚本语言, 如 python ,ruby</h3><ol start="26"><li>了解 php/ asp</li></ol><h3 id="27、了解-ftp-协议及原理"><a href="#27、了解-ftp-协议及原理" class="headerlink" title="27、了解 ftp 协议及原理"></a>27、了解 ftp 协议及原理</h3><h3 id="28、熟练使用-Junit-测试-熟悉-Mockito-等测试工具"><a href="#28、熟练使用-Junit-测试-熟悉-Mockito-等测试工具" class="headerlink" title="28、熟练使用 Junit 测试, 熟悉 Mockito 等测试工具"></a>28、熟练使用 Junit 测试, 熟悉 Mockito 等测试工具</h3><h3 id="29、熟悉-javac-javadoc-native-native2ascii-等常用命令"><a href="#29、熟悉-javac-javadoc-native-native2ascii-等常用命令" class="headerlink" title="29、熟悉 javac,javadoc,native,native2ascii 等常用命令"></a>29、熟悉 javac,javadoc,native,native2ascii 等常用命令</h3><h3 id="30、熟悉常用的排序算法-如冒泡排序-快速排序等-最好自己研究过一些的算法-下面的这个就是我曾经研究过的一个"><a href="#30、熟悉常用的排序算法-如冒泡排序-快速排序等-最好自己研究过一些的算法-下面的这个就是我曾经研究过的一个" class="headerlink" title="30、熟悉常用的排序算法, 如冒泡排序, 快速排序等, 最好自己研究过一些的算法, 下面的这个就是我曾经研究过的一个:"></a>30、熟悉常用的排序算法, 如冒泡排序, 快速排序等, 最好自己研究过一些的算法, 下面的这个就是我曾经研究过的一个:</h3><p>http wenku baidu com /view/391db3f0941ea76e58fa04e9 点 html<br><a href="http://wenku.baidu.com/view.391db3f0941ea76e58fa04e9.html">http://wenku.baidu.com/view.391db3f0941ea76e58fa04e9.html</a></p><h3 id="31、了解-Flex-不学也没关系"><a href="#31、了解-Flex-不学也没关系" class="headerlink" title="31、了解 Flex(不学也没关系)"></a>31、了解 Flex(不学也没关系)</h3><h3 id="32、了解敏捷开发模式"><a href="#32、了解敏捷开发模式" class="headerlink" title="32、了解敏捷开发模式"></a>32、了解敏捷开发模式</h3><h3 id="33、工作流-workflow-至少用过一种-如-OSworkflow-了解原理"><a href="#33、工作流-workflow-至少用过一种-如-OSworkflow-了解原理" class="headerlink" title="33、工作流 workflow 至少用过一种, 如 OSworkflow, 了解原理"></a>33、工作流 workflow 至少用过一种, 如 OSworkflow, 了解原理</h3><h3 id="34、使用过-VPN-了解其原理"><a href="#34、使用过-VPN-了解其原理" class="headerlink" title="34、使用过 VPN 了解其原理"></a>34、使用过 VPN 了解其原理</h3><h3 id="35、熟悉-jstl-表达式和-el-表达式"><a href="#35、熟悉-jstl-表达式和-el-表达式" class="headerlink" title="35、熟悉 jstl 表达式和 el 表达式"></a>35、熟悉 jstl 表达式和 el 表达式</h3><h3 id="36、熟悉-webservice-WSDL-SOAP"><a href="#36、熟悉-webservice-WSDL-SOAP" class="headerlink" title="36、熟悉 webservice,WSDL,SOAP"></a>36、熟悉 webservice,WSDL,SOAP</h3><h3 id="37、图片处理-如图片上传-预览-限制大小等-下面共享一-垃圾勿喷"><a href="#37、图片处理-如图片上传-预览-限制大小等-下面共享一-垃圾勿喷" class="headerlink" title="37、图片处理, 如图片上传, 预览, 限制大小等, 下面共享一 (垃圾勿喷):"></a>37、图片处理, 如图片上传, 预览, 限制大小等, 下面共享一 (垃圾勿喷):</h3><p>http wenku baidu com/view/05337bfc770bf78a6529541b 点 html</p><h3 id="38、版本控制工具-CVS-VSS-SVN"><a href="#38、版本控制工具-CVS-VSS-SVN" class="headerlink" title="38、版本控制工具, CVS VSS SVN"></a>38、版本控制工具, CVS VSS SVN</h3><h3 id="39、JSON-技术-JSON-AJAX"><a href="#39、JSON-技术-JSON-AJAX" class="headerlink" title="39、JSON 技术, JSON+AJAX"></a>39、JSON 技术, JSON+AJAX</h3><h3 id="40、分页技术-最好自己实现过不仅仅是用过要知道原理"><a href="#40、分页技术-最好自己实现过不仅仅是用过要知道原理" class="headerlink" title="40、分页技术, 最好自己实现过不仅仅是用过要知道原理"></a>40、分页技术, 最好自己实现过不仅仅是用过要知道原理</h3><h3 id="41、Java-Mail"><a href="#41、Java-Mail" class="headerlink" title="41、Java Mail"></a>41、Java Mail</h3><h3 id="42、Java-读写-txt-excel"><a href="#42、Java-读写-txt-excel" class="headerlink" title="42、Java 读写 txt,excel"></a>42、Java 读写 txt,excel</h3><p>JXL 技术</p><h3 id="43、JVM-原理-JVM-内存管理-GC-Java-堆栈池"><a href="#43、JVM-原理-JVM-内存管理-GC-Java-堆栈池" class="headerlink" title="43、JVM 原理, JVM 内存管理, GC,Java 堆栈池"></a>43、JVM 原理, JVM 内存管理, GC,Java 堆栈池</h3><h3 id="44、熟练使用下面的工具"><a href="#44、熟练使用下面的工具" class="headerlink" title="44、熟练使用下面的工具:"></a>44、熟练使用下面的工具:</h3><ul><li>office 办公软件, word,excel,ppt 等</li><li>plsql,sqldevelop 数据库开发工具</li><li>outlook 大公司都用</li><li>ue 编辑器</li><li>浏览器控制台, 调试</li><li>SHH/PUTTY 远程</li></ul><h3 id="45、UML-建模工具-Rational-Rose-等"><a href="#45、UML-建模工具-Rational-Rose-等" class="headerlink" title="45、UML 建模工具 Rational Rose 等"></a>45、UML 建模工具 Rational Rose 等</h3><h3 id="46、使用-log4j"><a href="#46、使用-log4j" class="headerlink" title="46、使用 log4j"></a>46、使用 log4j</h3><h3 id="47、使用过开放-API-如百度地图-腾讯街景-新浪微博等"><a href="#47、使用过开放-API-如百度地图-腾讯街景-新浪微博等" class="headerlink" title="47、使用过开放 API 如百度地图, 腾讯街景, 新浪微博等"></a>47、使用过开放 API 如百度地图, 腾讯街景, 新浪微博等</h3><h3 id="48、页面静态化技术-伪静态页面-UrlRwriter"><a href="#48、页面静态化技术-伪静态页面-UrlRwriter" class="headerlink" title="48、页面静态化技术 (伪静态页面)UrlRwriter"></a>48、页面静态化技术 (伪静态页面)UrlRwriter</h3><h3 id="49、报表技术-使用过报表制作工具-如水晶易表"><a href="#49、报表技术-使用过报表制作工具-如水晶易表" class="headerlink" title="49、报表技术, 使用过报表制作工具, 如水晶易表"></a>49、报表技术, 使用过报表制作工具, 如水晶易表</h3><h3 id="50、定时任务-如-Spring-batch-学会自定义-batch-任务-不适用第三方工具"><a href="#50、定时任务-如-Spring-batch-学会自定义-batch-任务-不适用第三方工具" class="headerlink" title="50、定时任务, 如 Spring batch, 学会自定义 batch 任务 (不适用第三方工具)"></a>50、定时任务, 如 Spring batch, 学会自定义 batch 任务 (不适用第三方工具)</h3><h3 id="51、了解-uuid"><a href="#51、了解-uuid" class="headerlink" title="51、了解 uuid"></a>51、了解 uuid</h3><h3 id="52、B-s-和-C-s-架构"><a href="#52、B-s-和-C-s-架构" class="headerlink" title="52、B/s 和 C/s 架构"></a>52、B/s 和 C/s 架构</h3><h3 id="53、正则表达式"><a href="#53、正则表达式" class="headerlink" title="53、正则表达式"></a>53、正则表达式</h3><h3 id="54、了解-JNDI-JMS"><a href="#54、了解-JNDI-JMS" class="headerlink" title="54、了解 JNDI JMS"></a>54、了解 JNDI JMS</h3><h3 id="55、ERP"><a href="#55、ERP" class="headerlink" title="55、ERP"></a>55、ERP</h3><h3 id="56、unicode-编码-乱码的解决"><a href="#56、unicode-编码-乱码的解决" class="headerlink" title="56、unicode 编码, 乱码的解决"></a>56、unicode 编码, 乱码的解决</h3><h3 id="57、开源网络编辑器-如-ckEditor"><a href="#57、开源网络编辑器-如-ckEditor" class="headerlink" title="57、开源网络编辑器, 如 ckEditor"></a>57、开源网络编辑器, 如 ckEditor</h3><h3 id="58、二进制原理"><a href="#58、二进制原理" class="headerlink" title="58、二进制原理"></a>58、二进制原理</h3><h3 id="59、使用过-了解开源论坛框架-如-discuzz"><a href="#59、使用过-了解开源论坛框架-如-discuzz" class="headerlink" title="59、使用过, 了解开源论坛框架, 如 discuzz"></a>59、使用过, 了解开源论坛框架, 如 discuzz</h3><h3 id="60、GWT-Closure-框架"><a href="#60、GWT-Closure-框架" class="headerlink" title="60、GWT ,Closure 框架"></a>60、GWT ,Closure 框架</h3><h3 id="61、了解-大数据-云计算"><a href="#61、了解-大数据-云计算" class="headerlink" title="61、了解 大数据, 云计算"></a>61、了解 大数据, 云计算</h3><h3 id="62、搜索引擎搜索技术"><a href="#62、搜索引擎搜索技术" class="headerlink" title="62、搜索引擎搜索技术"></a>62、搜索引擎搜索技术</h3><h3 id="63、软件工程-项目管理"><a href="#63、软件工程-项目管理" class="headerlink" title="63、软件工程, 项目管理"></a>63、软件工程, 项目管理</h3><p><img src="https://img.rxliuli.com/20181126225820.png" alt="软件工程, 项目管理"></p><ol><li> 你需要精通面向对象分析与设计 (OOA/OOD)、涉及模式(GOF，J2EEDP) 以及综合模式。你应该十分了解 UML，尤其是 class，object，interaction 以及 statediagrams。</li><li> 你需要学习 JAVA 语言的基础知识以及它的核心类库 (collections，serialization，streams，networking， multithreading，reflection，event，handling，NIO，localization，以及其他)。</li><li> 你应该了解 JVM，classloaders，classreflect，以及垃圾回收的基本工作机制等。你应该有能力反编译一个类文件并且明白一些基本的汇编指令。</li><li>如果你将要写客户端程序，你需要学习 WEB 的小应用程序 (applet)，必需掌握 GUI 设计的思想和方法，以及桌面程序的 SWING，AWT， SWT。你还应该对 UI 部件的 JAVABEAN 组件模式有所了解。<br> JAVABEANS 也被应用在 JSP 中以把业务逻辑从表现层中分离出来。</li><li> 你需要学习 java 数据库技术，如 JDBCAPI 并且会使用至少一种 persistence/ORM 构架，例如 Hibernate，JDO， CocoBase，TopLink，InsideLiberator(国产 JDO 红工厂软件) 或者 iBatis。</li><li> 你还应该了解对象关系的阻抗失配的含义，以及它是如何影响业务对象的与关系型数据库的交互，和它的运行结果，还需要掌握不同的数据库产品运用，比如: oracle，mysql，mssqlserver。</li><li>你需要学习 JAVA 的沙盒安全模式 (classloaders，bytecodeverification，managers，policyandpermissions，<br> codesigning， digitalsignatures，cryptography，certification，Kerberos，以及其他) 还有不同的安全 / 认证 API，例如 JAAS(JavaAuthenticationandAuthorizationService)，<br> JCE (JavaCryptographyExtension)，JSSE(JavaSecureSocketExtension)，以及 JGSS (JavaGeneralSecurityService)。</li><li> 你需要学习 Servlets，JSP，以及 JSTL(StandardTagLibraries) 和可以选择的第三方 TagLibraries。</li><li> 你需要熟悉主流的网页框架，例如 JSF，Struts，Tapestry，Cocoon，WebWork，以及他们下面的涉及模式，如 MVC/MODEL2。</li><li> 你需要学习如何使用及管理 WEB 服务器，例如 tomcat，resin，Jrun，并且知道如何在其基础上扩展和维护 WEB 程序。</li><li> 你需要学习分布式对象以及远程 API，例如 RMI 和 RMI/IIOP。</li><li> 你需要掌握各种流行中间件技术标准和与 java 结合实现，比如 Tuxedo、CROBA，当然也包括 javaEE 本身。</li><li> 你需要学习最少一种的 XMLAPI，例如 JAXP(JavaAPIforXMLProcessing)，JDOM(JavaforXMLDocumentObjectModel)，DOM4J，或 JAXR(JavaAPIforXMLRegistries)。</li><li>你应该学习如何利用 JAVAAPI 和工具来构建 WebService。例如 JAX-RPC(JavaAPIforXML/RPC)，SAAJ (SOAPwithAttachmentsAPIforJava)，JAXB(JavaArchitectureforXMLBinding)，<br> JAXM(JavaAPIforXMLMessaging)， JAXR(JavaAPIforXMLRegistries)，或者 JWSDP(JavaWebServicesDeveloperPack)。</li><li> 你需要学习一门轻量级应用程序框架，例如 Spring，PicoContainer，Avalon，以及它们的 IoC/DI 风格 (setter，constructor，interfaceinjection)。</li><li> 你需要熟悉不同的 J2EE 技术，例如 JNDI(JavaNamingandDirectoryInterface)，JMS (JavaMessageService)，JTA/JTS(JavaTransactionAPI/JavaTransactionService)</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 集成 WebSocket</title>
    <link href="/p/6886ab3897dd418bb78f2f884df97ad1/"/>
    <url>/p/6886ab3897dd418bb78f2f884df97ad1/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#springboot-%E9%9B%86%E6%88%90-websocket">SpringBoot 集成 WebSocket</a><ul><li><a href="#%E5%9C%BA%E6%99%AF--%E9%9C%80%E6%B1%82">场景 &amp; 需求</a></li><li><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">前置知识</a></li><li><a href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">引入依赖</a></li><li><a href="#%E9%85%8D%E7%BD%AE-springboot-websocket-%E6%94%AF%E6%8C%81">配置 <code>SpringBoot WebSocket</code> 支持</a></li><li><a href="#%E5%8F%8C%E5%90%91%E5%B9%BF%E6%92%AD%E6%9C%8D%E5%8A%A1%E7%AB%AF">双向广播服务端</a></li><li><a href="#%E5%8F%8C%E5%90%91%E5%B9%BF%E6%92%AD%E5%AE%A2%E6%88%B7%E7%AB%AF">双向广播客户端</a></li><li><a href="#%E5%8D%95%E5%90%91%E5%B9%BF%E6%92%AD%E6%9C%8D%E5%8A%A1%E7%AB%AF">单向广播服务端</a></li><li><a href="#%E5%8D%95%E5%90%91%E5%B9%BF%E6%92%AD%E5%AE%A2%E6%88%B7%E7%AB%AF">单向广播客户端</a></li><li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF">点对点推送服务端</a></li><li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%8E%A8%E9%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">点对点推送客户端</a></li><li><a href="#%E5%8D%95%E5%90%91%E7%82%B9%E5%AF%B9%E7%82%B9%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF">单向点对点推送服务端</a></li><li><a href="#%E5%8D%95%E5%90%91%E7%82%B9%E5%AF%B9%E7%82%B9%E6%8E%A8%E9%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">单向点对点推送客户端</a></li><li><a href="#%E8%AE%B0%E5%BD%95-user---socket-%E4%BC%9A%E8%AF%9D%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%A0%E5%B0%84%E8%A1%A8">记录 user -&gt; Socket 会话对应的映射表</a></li><li><a href="#%E6%8E%A5%E5%8F%97%E8%BF%94%E5%9B%9E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF">接受/返回复杂类型的消息（服务端）</a></li><li><a href="#%E5%8F%91%E9%80%81%E8%AE%A2%E9%98%85%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B6%88%E6%81%AF%E5%AE%A2%E6%88%B7%E7%AB%AF">发送/订阅复杂类型的消息（客户端）</a></li><li><a href="#websocket-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B0%81%E8%A3%85">WebSocket 客户端封装</a></li></ul></li></ul><h2 id="场景-amp-需求"><a href="#场景-amp-需求" class="headerlink" title="场景 &amp; 需求"></a>场景 &amp; 需求</h2><ol><li> 客户端发送请求后，服务端进行处理后可以对所有的客户端进行 <strong>广播</strong></li><li> 服务端可以在任何时候主动对所有客户端进行 <strong>广播</strong></li><li> 客户端发送请求后，服务端进行处理后可以对指定客户端进行 <strong>点对点推送</strong></li><li> 服务端可以在任何时候主动对指定客户端进行 <strong>点对点推送</strong></li><li> 服务端可以在任何时候主动对指定某些客户端进行 <strong>广播</strong></li><li> 服务端可以识别客户端（状态），并以此进行 <strong>点对点推送</strong></li></ol><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><p>本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。</p><ul><li>[x] Java</li><li>[x] Maven</li><li>[x] SpringBoot</li></ul><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>创建一个 <code>SpringBoot</code> 项目，并添加 <code>spring-boot-starter-websocket</code> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring boot web socket--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置-SpringBoot-WebSocket-支持"><a href="#配置-SpringBoot-WebSocket-支持" class="headerlink" title="配置 SpringBoot WebSocket 支持"></a>配置 <code>SpringBoot WebSocket</code> 支持</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置 SpringBoot WebSocket 支持</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocketMessageBroker</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringWebSocketConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册一个 Socket 端点</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stompEndpointRegistry stomp 端点注册表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry stompEndpointRegistry)</span> </span>&#123;<br>        stompEndpointRegistry.addEndpoint(<span class="hljs-string">&quot;/endpoint&quot;</span>)<br>                <span class="hljs-comment">//设置允许所有源请求（跨域）</span><br>                .setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .withSockJS();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册一些广播消息代理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry 消息代理注册对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">//注册简单代理（里面是前缀）</span><br>        <span class="hljs-comment">//注：默认 topic 是主题（广播），user 则是用户（点对点）</span><br>        registry.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>, <span class="hljs-string">&quot;/user&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向广播服务端"><a href="#双向广播服务端" class="headerlink" title="双向广播服务端"></a>双向广播服务端</h2><p>客户端发送请求后，服务端进行处理后可以对所有的客户端进行 <strong>广播</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向广播控制器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BilateralBroadcastingSocket</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 广播推送</span><br><span class="hljs-comment">     * 注解 <span class="hljs-doctag">@Payload</span> 是为了绑定消息到参数 text 上</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text      简单的文本信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessionId 当前请求 socket 会话 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 会话 id 和消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@MessageMapping(value = &quot;/talk&quot;)</span><br>    <span class="hljs-meta">@SendTo(&quot;/topic/broadcasting/bilateral/allClient&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">talk</span><span class="hljs-params">(<span class="hljs-meta">@Payload</span> String text, <span class="hljs-meta">@Header(&quot;simpSessionId&quot;)</span> String sessionId)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//模拟处理其他事情</span><br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[ &quot;</span> + sessionId + <span class="hljs-string">&quot;] 说: [&quot;</span> + text + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向广播客户端"><a href="#双向广播客户端" class="headerlink" title="双向广播客户端"></a>双向广播客户端</h2><p>向服务端发送消息，并监听服务端的广播。客户端发送消息与监听是分离的，也可以只向服务端发送消息而不监听广播，或者只接收广播不发送消息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    &lt;script<br>      type=&quot;application/javascript&quot;<br>      src=&quot;https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js&quot;<br>    &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    &lt;script<br>      type=&quot;application/javascript&quot;<br>      src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js&quot;<br>    &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">&quot;http://127.0.0.1:8080/endpoint&quot;</span>);</span><br>      stompClient = Stomp.over(socket);<br>      stompClient.connect(<br>        &#123;&#125;,<br><span class="javascript">        <span class="hljs-comment">// 连接成功回调函数</span></span><br>        (frame) =&gt; &#123;<br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务端 Socket 连接建立&quot;</span>);</span><br><br><span class="javascript">          <span class="hljs-comment">// 获取 websocket 连接的 sessionId</span></span><br><span class="javascript">          <span class="hljs-keyword">const</span> sessionId = <span class="hljs-regexp">/\/([^\/]+)\/websocket/</span>.exec(</span><br>            socket._transport.url<br>          )[1];<br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;connected, session id: &quot;</span> + sessionId);</span><br><br><span class="javascript">          <span class="hljs-comment">// 订阅广播消息（双向通信）</span></span><br><span class="javascript">          <span class="hljs-comment">// 这里是关键（订阅了服务端的 topic）</span></span><br>          stompClient.subscribe(<br><span class="javascript">            <span class="hljs-string">&quot;/topic/broadcasting/bilateral/allClient&quot;</span>,</span><br>            (res) =&gt; &#123;<br><span class="javascript">              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[广播（双向通信）]: <span class="hljs-subst">$&#123;res.body&#125;</span>`</span>);</span><br>            &#125;<br>          );<br><br><span class="javascript">          <span class="hljs-comment">// 发送请求</span></span><br>          send();<br>        &#125;,<br>        (error) =&gt; &#123;<br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Socket 连接失败&quot;</span>);</span><br>        &#125;<br>      );<br><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">// 发送一个消息到服务端</span></span><br><span class="javascript">        <span class="hljs-comment">// 发送消息到服务端</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> headers = &#123;&#125;;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> body = &#123;</span><br><span class="javascript">          message: <span class="hljs-string">&quot;消息内容&quot;</span>,</span><br>        &#125;;<br><span class="javascript">        stompClient.send(<span class="hljs-string">&quot;/talk&quot;</span>, headers, <span class="hljs-built_in">JSON</span>.stringify(body));</span><br>      &#125;<br><br>      /**<br>       * 监听窗口关闭事件，窗口关闭前，主动关闭连接，防止连接还没断开就关闭窗口，server 端会抛异常<br>       */<br><span class="javascript">      <span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (stompClient !== <span class="hljs-literal">null</span>) &#123;</span><br>          stompClient.disconnect();<br>          socket.close();<br>        &#125;<br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;断开连接&quot;</span>);</span><br>      &#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="单向广播服务端"><a href="#单向广播服务端" class="headerlink" title="单向广播服务端"></a>单向广播服务端</h2><p>从服务端推送消息到所有客户端，是单向推送到客户端的，不接受从客户端的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向广播控制器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnidirectionalBroadcastingSocket</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从服务端推送消息到所有客户端</span><br><span class="hljs-comment">     * 这是单向推送到客户端的，不接受从客户端的输入</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SendTo(&quot;/topic/broadcasting/unidirectional/allClient&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">broadcasting</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 Scheduled 不停的推送信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledRefreshJob</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SimpMessagingTemplate simpMessagingTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 不停地推送消息到客户端</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(fixedDelay = 10 * 1000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduledBroadcasting</span><span class="hljs-params">()</span> </span>&#123;<br>        simpMessagingTemplate.convertAndSend(<span class="hljs-string">&quot;/topic/broadcasting/unidirectional/allClient&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-keyword">false</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向广播客户端"><a href="#单向广播客户端" class="headerlink" title="单向广播客户端"></a>单向广播客户端</h2><p>客户端只需要添加一个监听器就好了，不需要也不能向服务端发送消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅广播消息（服务端单向推送）</span><br><span class="hljs-keyword">const</span> subscription_broadcast = stompClient.subscribe(<br>  <span class="hljs-string">&quot;/topic/broadcasting/unidirectional/allClient&quot;</span>,<br>  (response) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[广播（服务端单向推送）]: <span class="hljs-subst">$&#123;response.body&#125;</span>`</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="点对点推送服务端"><a href="#点对点推送服务端" class="headerlink" title="点对点推送服务端"></a>点对点推送服务端</h2><p>服务端使用 <code>@SendToUser(path)</code> 向单个客户端推送消息，这里的 <code>@Header(&quot;simpSessionId&quot;)</code> 指的是从客户端的请求头中的 <code>simpSessionId</code> 参数赋值给 <code>sessionId</code>（<code>WebSocket</code> 会话 <code>ID</code>，和用户 <code>Session</code> 不同，是每一个 <code>WebSocket</code> 唯一的 #即和用户不是一一对应）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双向点对点推送控制器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BilateralPushSocket</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 点对点推送（双向通信）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text      消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessionId 会话 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 推送到当前会话的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@MessageMapping(&quot;/speak&quot;)</span><br>    <span class="hljs-meta">@SendToUser(&quot;/push/bilateral/thisClient&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">speak</span><span class="hljs-params">(<span class="hljs-meta">@Payload</span> String text, <span class="hljs-meta">@Header(&quot;simpSessionId&quot;)</span> String sessionId)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//模拟处理其他事情</span><br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[ &quot;</span> + sessionId + <span class="hljs-string">&quot;] send: [&quot;</span> + text + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="点对点推送客户端"><a href="#点对点推送客户端" class="headerlink" title="点对点推送客户端"></a>点对点推送客户端</h2><p>客户端请求的路径需要注意一下，是以 <code>/user/$&#123;sessionId&#125;</code> 开头，后面才是 <code>@SendToUser(path)</code> 中设置的 <code>path</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅私人消息（双向通信）</span><br>stompClient.subscribe(<span class="hljs-string">`/user/<span class="hljs-subst">$&#123;sessionId&#125;</span>/push/bilateral/thisClient`</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[点对点推送（双向通信）]: <span class="hljs-subst">$&#123;res.body&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="单向点对点推送服务端"><a href="#单向点对点推送服务端" class="headerlink" title="单向点对点推送服务端"></a>单向点对点推送服务端</h2><p>其实和上面双向的点对点推送没什么太大的差别，就是只用 <code>@SendToUser(path)</code> 而不用 <code>@MessageMapping(path)</code> 了而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单向点对点推送服务端</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnidirectionalPushSocket</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从服务端推送消息到所有客户端</span><br><span class="hljs-comment">     * 这是单向推送到客户端的，不接受从客户端的输入</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SendToUser(&quot;/push/unidirectional/thisClient&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 Scheduled 不停的推送信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledRefreshJob</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SimpMessagingTemplate simpMessagingTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 不停推送消息到某个指定的客户端</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(fixedDelay = 10 * 1000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduledPush</span><span class="hljs-params">()</span> </span>&#123;<br>        simpMessagingTemplate.convertAndSendToUser(<span class="hljs-string">&quot;r2qspi4s&quot;</span>, <span class="hljs-string">&quot;/push/unidirectional/thisClient&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-number">2L</span>, <span class="hljs-string">&quot;琉璃&quot;</span>, <span class="hljs-keyword">false</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向点对点推送客户端"><a href="#单向点对点推送客户端" class="headerlink" title="单向点对点推送客户端"></a>单向点对点推送客户端</h2><p>客户端和上面的双向点对点推送基本一致（完全一样好么？！）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅私人消息（单向通信）</span><br>stompClient.subscribe(<br>  <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;sessionId&#125;</span>/push/unidirectional/thisClient`</span>,<br>  (res) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[点对点推送（单向通信）]：<span class="hljs-subst">$&#123;res.body&#125;</span>`</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="记录-user-gt-Socket-会话对应的映射表"><a href="#记录-user-gt-Socket-会话对应的映射表" class="headerlink" title="记录 user -&gt; Socket 会话对应的映射表"></a>记录 user -&gt; Socket 会话对应的映射表</h2><p>上面的点对点推送客户端几乎是没什么用处的（尤其而且是 <a href="#%E5%8D%95%E5%90%91%E7%82%B9%E5%AF%B9%E7%82%B9%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF">单向点对点推送</a>），因为每次创建的 <code>Socket</code> 连接都会变化，而没有与用户建立对应关系的话怎无法知道哪个用户对应的哪个人，也就不能发送消息给指定的用户（非 <code>Socket Session Id</code>）了<br>。</p><ol><li> 首先需要一个记录用户 <code>Socket Session Id</code> 的类，并注册为 SpringBoot 的组件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用户 session 记录类</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketSessionRegistry</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 未登录的用户默认存储的 user id</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_TOURIST = <span class="hljs-string">&quot;DIRECT_TOURIST&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 这个集合存储 用户 id -&gt; session 列表</span><br><span class="hljs-comment">    * 单个用户可能打开多个页面，就会出现多个 Socket 会话</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, Set&lt;String&gt;&gt; userSessionIds = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据 user id 获取 sessionId</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> user 用户 id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 用户关联的 sessionId</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSessionIds</span><span class="hljs-params">(String user)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">this</span>.userSessionIds.get(user);<br>        <span class="hljs-keyword">return</span> set != <span class="hljs-keyword">null</span> ? set : Collections.emptySet();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取所有 session</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 所有的 用户 id -&gt; session 列表</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> ConcurrentMap&lt;String, Set&lt;String&gt;&gt; getAllSessionIds() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userSessionIds;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据用户 id 注册一个 session</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> user      用户 id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sessionId Socket 会话 id</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerSessionId</span><span class="hljs-params">(String user, String sessionId)</span> </span>&#123;<br>        Assert.notNull(user, <span class="hljs-string">&quot;User must not be null&quot;</span>);<br>        Assert.notNull(sessionId, <span class="hljs-string">&quot;Session ID must not be null&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.lock) &#123;<br>            Set&lt;String&gt; set = <span class="hljs-keyword">this</span>.userSessionIds.get(user);<br>            <span class="hljs-keyword">if</span> (set == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.userSessionIds.put(user, <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;());<br>            &#125;<br>            set.add(sessionId);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据用户 id 删除一个 session</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> user      用户 id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sessionId Socket 会话 id</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterSessionId</span><span class="hljs-params">(String user, String sessionId)</span> </span>&#123;<br>        Assert.notNull(user, <span class="hljs-string">&quot;User Name must not be null&quot;</span>);<br>        Assert.notNull(sessionId, <span class="hljs-string">&quot;Session ID must not be null&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.lock) &#123;<br>            Set set = <span class="hljs-keyword">this</span>.userSessionIds.get(user);<br>            <span class="hljs-keyword">if</span> (set != <span class="hljs-keyword">null</span> &amp;&amp; set.remove(sessionId) &amp;&amp; set.isEmpty()) &#123;<br>                <span class="hljs-keyword">this</span>.userSessionIds.remove(user);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li> 监听 <code>WebSocket</code> 连接建立和关闭事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 会话事件监听基类</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseSessionEventListener</span>&lt;<span class="hljs-title">Event</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSubProtocolEvent</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">Event</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">protected</span> SocketSessionRegistry webAgentSessionRegistry;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 计算出 user id 和 session id 并传入到自定义的函数中</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> event      事件</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> biConsumer 自定义的操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">using</span><span class="hljs-params">(Event event, BiConsumer&lt;String, String&gt; biConsumer)</span> </span>&#123;<br>        StompHeaderAccessor sha = StompHeaderAccessor.wrap(event.getMessage());<br>        <span class="hljs-comment">//login get from browser</span><br>        List&lt;String&gt; shaNativeHeader = sha.getNativeHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        String user;<br>        <span class="hljs-keyword">if</span> (shaNativeHeader == <span class="hljs-keyword">null</span> || shaNativeHeader.isEmpty()) &#123;<br>            user = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            user = shaNativeHeader.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果当前用户没有登录（没有认证信息），就添加到游客里面</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(user) || <span class="hljs-string">&quot;undefined&quot;</span>.equals(user) || <span class="hljs-string">&quot;null&quot;</span>.equals(user)) &#123;<br>            user = SocketSessionRegistry.DIRECT_TOURIST;<br>        &#125;<br>        String sessionId = sha.getSessionId();<br>        biConsumer.accept(user, sessionId);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Socket 连接建立监听</span><br><span class="hljs-comment">* 用于 session 注册 以及 key 值获取</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionConnectEventListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseSessionEventListener</span>&lt;<span class="hljs-title">SessionConnectEvent</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(SessionConnectEvent event)</span> </span>&#123;<br>        using(event, (user, sessionId) -&gt; webAgentSessionRegistry.registerSessionId(user, sessionId));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Socket 会话断开监听</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionDisconnectEventListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseSessionEventListener</span>&lt;<span class="hljs-title">SessionDisconnectEvent</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(SessionDisconnectEvent event)</span> </span>&#123;<br>        <span class="hljs-comment">//这里先根据 session id 查询出 user，然后删除对应的会话 id</span><br>        <span class="hljs-comment">//前端无法传递 token 到这里却是只能出此下策了</span><br>        using(event, (user, sessionId) -&gt; webAgentSessionRegistry.getAllSessionIds().entrySet().stream()<br>                .filter(sse -&gt; sse.getValue().contains(sessionId))<br>                .findFirst()<br>                .ifPresent(sse -&gt; &#123;<br>                    webAgentSessionRegistry.unregisterSessionId(sse.getKey(), sessionId);<br>                    log.info(<span class="hljs-string">&quot;Socket 连接断开，用户：&#123;&#125;，会话：&#123;&#125;&quot;</span>, sse.getKey(), sessionId);<br>                &#125;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li> 客户端在打开和关闭连接的时候需要发送 user 给服务端</li></ol><p>这里使用 <code>headers</code> 存放用户认证信息（唯一标识），所以在连接和关闭时要带上请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">stompClient.connect(getHeaders(), function()&#123;<br>    console.log(<span class="hljs-string">&#x27;打开 Socket 连接&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// TODO 这里还有一些问题，无法带上 headers 到后端</span><br>stompClient.disconnect(function () &#123;<br>    console.log(<span class="hljs-string">&#x27;断开连接&#x27;</span>);<br>&#125;, getHeaders());<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取一个认证的 headers 信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;&#123;&quot;X-Requested-With&quot;: string, Authorization: any&#125;&#125; 含有认证信息的 headers 对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">function <span class="hljs-title">getHeaders</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;X-Requested-With&#x27;</span>,<br>          <span class="hljs-string">&#x27;Authorization&#x27;</span>: localStorage.token<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li> 使用记录的 <code>user -&gt; session id</code> 发送消息给指定的用户</li></ol><p>下面是获取到所有已经登录的用户的 <code>WebSocket</code> 连接并发送一条消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">socketSessionRegistry.getAllSessionIds().entrySet().stream()<br>        .filter(kv -&gt; !SocketSessionRegistry.DIRECT_TOURIST.equals(kv.getKey()))<br>        .forEach(kv -&gt; kv.getValue().forEach(sessionId -&gt; simpMessagingTemplate.convertAndSendToUser(sessionId, <span class="hljs-string">&quot;/push/unidirectional/thisClient&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-number">2L</span>, <span class="hljs-string">&quot;琉璃&quot;</span>, <span class="hljs-keyword">false</span>))));<br></code></pre></td></tr></table></figure><h2 id="接受-返回复杂类型的消息（服务端）"><a href="#接受-返回复杂类型的消息（服务端）" class="headerlink" title="接受/返回复杂类型的消息（服务端）"></a>接受/返回复杂类型的消息（服务端）</h2><p>其实看起来和刚才是没什么区别的，但 <code>SpringBoot WebSocket</code> 原本就对消息进行了解析/封装，所以我们不需要再去手动转换了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接受和发送复杂类型的消息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexMessageSocket</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收/返回复杂类型 Person 的对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> person Person 类对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Person 类对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@MessageMapping(&quot;/complexMessage&quot;)</span><br>    <span class="hljs-meta">@SendTo(&quot;/topic/complexMessage/allClient&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">complexMessage</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person().setName(<span class="hljs-string">&quot;Mr. &quot;</span> + person.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-订阅复杂类型的消息（客户端）"><a href="#发送-订阅复杂类型的消息（客户端）" class="headerlink" title="发送/订阅复杂类型的消息（客户端）"></a>发送/订阅复杂类型的消息（客户端）</h2><p>客户端和之前的也差不多，需要注意的就是无论是发送/接受都需要将复杂类型的对象序列化为字符串（<code>JavaScript</code> 原生支持）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 订阅返回复杂类型的消息</span><br>stompClient.subscribe(<span class="hljs-string">&quot;/topic/complexMessage/allClient&quot;</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;订阅复杂类型类型的返回消息：&#123;&#125;&quot;</span>, <span class="hljs-built_in">JSON</span>.parse(res.body));<br>&#125;);<br><br><span class="hljs-comment">// 发送一个复杂类型的消息</span><br>stompClient.send(<br>  <span class="hljs-string">&quot;/complexMessage&quot;</span>,<br>  headers,<br>  <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>    id: <span class="hljs-number">17</span>,<br>    name: <span class="hljs-string">&quot;rxliuli&quot;</span>,<br>    sex: <span class="hljs-literal">false</span>,<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><h2 id="WebSocket-客户端封装"><a href="#WebSocket-客户端封装" class="headerlink" title="WebSocket 客户端封装"></a>WebSocket 客户端封装</h2><p>每次这么一大堆的代码可以封装一下，吾辈也封装了一个 <code>StopmClient</code> 的客户端工具类，如果有什么不好的地方欢迎提出！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * websocket 连接的工具类</span><br><span class="hljs-comment"> * 该工具类依赖于 sockjs-client 与 webstomp-client 两个类库</span><br><span class="hljs-comment"> * 使用方法：</span><br><span class="hljs-comment"> * 1. 设定 endpoint 属性</span><br><span class="hljs-comment"> * 2. 添加连接成功 / 失败的回调函数进行连接</span><br><span class="hljs-comment"> * 3. 订阅 / 发送消息</span><br><span class="hljs-comment"> * 4. 断开连接</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> socketUtil = &#123;<br>  <span class="hljs-comment">//最大重连次数</span><br>  maxLen: <span class="hljs-number">10</span>,<br>  <span class="hljs-comment">//当前重连次数</span><br>  currentLen: <span class="hljs-number">0</span>,<br>  <span class="hljs-comment">// 每次连接的时间间隔</span><br>  timeInterval: <span class="hljs-number">3000</span>,<br>  <span class="hljs-comment">// 连接的 Socket 节点</span><br>  endpoint: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-comment">// Socket 连接信息</span><br>  stompClient: <span class="hljs-literal">undefined</span>,<br>  socket: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Socket 连接的方法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">connectWebSocket</span>(<span class="hljs-params">successFn, errorFn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-built_in">this</span>.endpoint);<br>    <span class="hljs-built_in">this</span>.stompClient = Stomp.over(<span class="hljs-built_in">this</span>.socket);<br>    <span class="hljs-built_in">this</span>.stompClient.connect(<span class="hljs-built_in">this</span>.getHeaders(), successFn, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentLen++ &lt; <span class="hljs-built_in">this</span>.maxLen) &#123;<br>        <span class="hljs-built_in">console</span>.log(<br>          <span class="hljs-string">`Socket 连接失败，将在 <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.timeInterval / <span class="hljs-number">1000</span>&#125;</span>s 后重试`</span><br>        );<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.connectWebSocket(), <span class="hljs-number">3000</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Socket 连接失败次数过多，将不再重试&quot;</span>);<br>      &#125;<br>      errorFn(error);<br>    &#125;);<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 断开连接的方法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">disconnectWebSocket</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stompClient) &#123;<br>      <span class="hljs-built_in">this</span>.stompClient.disconnect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;断开连接&quot;</span>);<br>      &#125;, <span class="hljs-built_in">this</span>.getHeaders());<br>      <span class="hljs-built_in">this</span>.socket.close();<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取当前 Socket 连接的 session id</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">getSessionId</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\/([^\/]+)\/websocket/</span>.exec(<span class="hljs-built_in">this</span>.socket._transport.url)[<span class="hljs-number">1</span>];<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取一个认证的 headers 信息</span><br><span class="hljs-comment">   * 该方法可以被覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;&#123;&quot;X-Requested-With&quot;: string, Authorization: any&#125;</span></span>&#125; 含有认证信息的 headers 对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">getHeaders</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;X-Requested-With&quot;</span>,<br>      Authorization: <span class="hljs-built_in">localStorage</span>.token,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 发送简单文本类型的消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">sendText</span>(<span class="hljs-params">url, body, headers = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stompClient.send(url, headers, body);<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 发送 json 类型的消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">sendJSON</span>(<span class="hljs-params">url, body, headers = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stompClient.send(url, headers, <span class="hljs-built_in">JSON</span>.stringify(body));<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 订阅简单文本类型的消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">subscribeText</span>(<span class="hljs-params">url, successFn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stompClient.subscribe(url, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> successFn(res));<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 订阅 json 类型的消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">subscribeJSON</span>(<span class="hljs-params">url, successFn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stompClient.subscribe(url, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span><br>      successFn(<span class="hljs-built_in">JSON</span>.parse(res.body))<br>    );<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 取消订阅</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>obj 订阅对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">unsubscribe</span>(<span class="hljs-params">obj</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj &amp;&amp; obj.unsubscribe) &#123;<br>      obj.unsubscribe();<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Spring 时进行测试</title>
    <link href="/p/d5187232899b475982b26e999ed4f2a9/"/>
    <url>/p/d5187232899b475982b26e999ed4f2a9/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BD%BF%E7%94%A8-spring-%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">使用 Spring 时进行测试</a><ul><li><a href="#%E5%89%8D%E7%BD%AE%E8%A6%81%E6%B1%82">前置要求</a></li><li><a href="#%E6%A6%82%E7%95%A5">概略</a></li><li><a href="#%E6%99%AE%E9%80%9A%E6%B5%8B%E8%AF%95">普通测试</a></li><li><a href="#daoservice-%E5%B1%82%E6%B5%8B%E8%AF%95">Dao/Service 层测试</a><ul><li><a href="#%E6%89%8B%E5%8A%A8%E4%BD%BF%E7%94%A8-applicationcontext-%E5%8E%BB%E8%8E%B7%E5%8F%96-bean-%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">手动使用 <code>ApplicationContext</code> 去获取 Bean 然后进行测试</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD-spring-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83">使用注解自动加载 Spring 测试环境</a></li></ul></li><li><a href="#web-%E5%B1%82%E6%B5%8B%E8%AF%95">Web 层测试</a><ul><li><a href="#%E7%8B%AC%E7%AB%8B%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95">独立安装测试</a></li><li><a href="#%E9%9B%86%E6%88%90-web-%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95">集成 Web 环境测试</a></li></ul></li></ul></li></ul><h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><ul><li>Java</li><li>Spring/SpringMVC</li><li>Maven</li></ul><h2 id="概略"><a href="#概略" class="headerlink" title="概略"></a>概略</h2><p>单元测试/集成测试是软件开发时重要的一项流程，而 Spring 对于测试提供了非常强大的支持。</p><ul><li>支持主流测试框架 <code>Junit</code>/<code>TestNG</code></li><li>支持在测试中使用依赖注入</li><li>支持在测试中事物自动回滚</li><li>支持使用各种注解增强功能</li></ul><p>那么，测试基本上按照场景分为三种情况：</p><ul><li>普通测试：不需要使用 Spring 容器的测试（工具类）</li><li>Dao/Service 层测试：需要使用 Spring 容器的依赖注入</li><li>Web 层测试：测试对外部提供的接口</li></ul><p>这里新建一个用来测试的项目，吾辈将之丢到了 GitHub 上面</p><blockquote><p><a href="https://github.com/rxliuli/springtest">项目链接</a></p></blockquote><p>你也可以自己创建一个基础的 Maven 项目，项目结构应当如下：</p><ul><li>/<ul><li>src/<ul><li>main/<ul><li>java/</li><li>resources/</li></ul></li><li>test/<ul><li>java/</li></ul></li></ul></li><li>pom.xml</li></ul></li></ul><h2 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h2><p>假设吾辈有一个 <code>SpringUtil</code>（路径是 <code>/src/main/java/com/rxliuli/study/springtest/util/SpringUtil.java</code>） 工具类，想要测试怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于测试的字符串工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringUtil</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string 要进行判断的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(String string)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> string == <span class="hljs-keyword">null</span> || string.isEmpty();<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string 要进行判断的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">(String string)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !isEmpty(string);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否有字符串为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> strings 要进行判断的一个或多个字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否有 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnyEmpty</span><span class="hljs-params">(String... strings)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(strings)<br>                .anyMatch(StringUtil::isEmpty);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断字符串是否全部为空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> strings 要进行判断的一个或多个字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否全部为 null 或者空字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAllEmpty</span><span class="hljs-params">(String... strings)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(strings)<br>                .allMatch(StringUtil::isEmpty);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要引入以下依赖</p><ul><li><code>Junit4</code>：流行的 Java 测试框架。虽然吾辈个人更喜欢 <code>TestNG</code>，但 <code>Junit</code> 的流行度要更高一点，<code>SpringBoot</code> 甚至将之默认引入了，所以这里使用 <code>Junit</code> 框架。</li><li><code>AssertJ</code>：流行的 Java 流畅式断言框架。<code>Junit</code> 也有自己的断言方法，但和 <code>AssertJ</code> 相比就是小巫见大巫了。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.assertj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>assertj-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：生产环境中 <strong>version</strong> 应该放到 <strong>properties</strong> 节点下，这里只做演示。<br>此篇不对 <code>Junit</code> 和 <code>AssertJ</code> 进行详细的讲解，如果想要入门了解参考 <a href="http://wiki.jikexueyuan.com/project/junit/">Junit</a>, <a href="http://hao.jobbole.com/assertj/">AssertJ</a></p></blockquote><p>然后创建一个对应的测试类 <code>StringUtilTest</code>（<code>/src/test/java/com/rxliuli/study/springtest/util/SpringUtilTest.java</code>）直接进行测试即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringUtilTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String strNull = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> String strEmpty = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">private</span> String strSome = <span class="hljs-string">&quot;str&quot;</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//测试 null</span><br>        assertThat(StringUtil.isEmpty(strNull))<br>                .isTrue();<br>        <span class="hljs-comment">//测试 empty</span><br>        assertThat(StringUtil.isEmpty(strEmpty))<br>                .isTrue();<br>        <span class="hljs-comment">//测试 some</span><br>        assertThat(StringUtil.isEmpty(strSome))<br>                .isFalse();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//测试 null</span><br>        assertThat(StringUtil.isNotEmpty(strNull))<br>                .isFalse();<br>        <span class="hljs-comment">//测试 empty</span><br>        assertThat(StringUtil.isNotEmpty(strEmpty))<br>                .isFalse();<br>        <span class="hljs-comment">//测试 some</span><br>        assertThat(StringUtil.isNotEmpty(strSome))<br>                .isTrue();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAnyEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty, strSome))<br>                .isTrue();<br>        assertThat(StringUtil.isAnyEmpty())<br>                .isFalse();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAllEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        assertThat(StringUtil.isAllEmpty(strNull, strEmpty, strSome))<br>                .isFalse();<br>        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty))<br>                .isTrue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面测试流程基本如下：</p><ul><li>构建出测试需要的参数（非必需）</li><li>调用需要测试的方法</li><li>使用 AssertJ 对得到的结果进行断言</li></ul><h2 id="Dao-Service-层测试"><a href="#Dao-Service-层测试" class="headerlink" title="Dao/Service 层测试"></a>Dao/Service 层测试</h2><p>准确的说是需要使用 Spring 容器的测试，测试方法有 2 种。</p><ol><li> 手动使用 <code>ApplicationContext</code> 去获取 Bean 然后进行测试</li><li> 使用注解自动加载 Spring 测试环境</li></ol><h3 id="手动使用-ApplicationContext-去获取-Bean-然后进行测试"><a href="#手动使用-ApplicationContext-去获取-Bean-然后进行测试" class="headerlink" title="手动使用 ApplicationContext 去获取 Bean 然后进行测试"></a>手动使用 <code>ApplicationContext</code> 去获取 Bean 然后进行测试</h3><p>这里先演示手动使用 <code>ApplicationContext</code> 的做法进行测试，为了简化测试，这里直接使用 <code>H2DB</code> 和 <code>SpringJdbcTemplate</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--h2 db--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.h2database<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>h2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.196<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建初始化 sql 文件 <code>hsqldb/initDatabase.sql</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> (<br>  id   <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)        <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;名字&#x27;</span>,<br>  sex  <span class="hljs-type">boolean</span>            <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>  age  <span class="hljs-type">int</span>                <span class="hljs-keyword">null</span><br>  comment <span class="hljs-string">&#x27;年龄&#x27;</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (id, name, sex, age)<br><span class="hljs-keyword">values</span><br>  (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;琉璃&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">17</span>),<br>  (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;月姬&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>Spring 配置文件 <code>spring/spring-context.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--自动扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.rxliuli.study.springtest&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;H2&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--初始化 db--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:hsqldb/initDatabase.sql&quot;</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置 Spring JdbcTemplate--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">p:dataSource-ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来我们可以编写实体类 <code>com.rxliuli.study.springtest.entity.User</code>，dao 层 <code>com.rxliuli.study.springtest.dao.UserDao</code> 和 dao 对应的测试类 <code>com.rxliuli.study.springtest.dao.UserDaoTest</code>。</p><ul><li>User</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Boolean sex;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, Boolean sex, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name, Boolean sex, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setSex</span><span class="hljs-params">(Boolean sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RowMapper&lt;User&gt; userRowMapper = (rs, rowNum) -&gt; <span class="hljs-keyword">new</span> User(<br>            rs.getInt(<span class="hljs-string">&quot;id&quot;</span>),<br>            rs.getString(<span class="hljs-string">&quot;name&quot;</span>),<br>            rs.getBoolean(<span class="hljs-string">&quot;sex&quot;</span>),<br>            rs.getInt(<span class="hljs-string">&quot;age&quot;</span>)<br>    );<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 id 获取一个对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 根据 id 查询到的对象，如果没有查到则为 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from user where id = ?&quot;</span>, userRowMapper, id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询全部用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 全部用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(<span class="hljs-string">&quot;select * from user&quot;</span>, userRowMapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：这里直接使用了 Dao 类，生产过程中最好使用接口。</p></blockquote><ul><li>UserDaoTest</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用 spring xml 配置文件初始化 ApplicationContext</span><br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;classpath:/spring/spring-context.xml&quot;</span>);<br>        <span class="hljs-comment">//然后使用 ApplicationContext 获取 UserDao 的对象</span><br>        userDao = context.getBean(UserDao.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br>        User result = userDao.get(id);<br>        <span class="hljs-comment">//断言 id 和 get id 相同</span><br>        assertThat(result)<br>                .extracting(User::getId)<br>                .contains(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = userDao.listForAll();<br>        <span class="hljs-comment">//断言不为空</span><br>        assertThat(userList)<br>                .isNotEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>手动加载的基本思路就是：</p><ul><li>先加载 ApplicationContext 初始化 Spring 环境<br>注：这一步实际上就已经加载了 Spring 容器，并且使用 <code>initDatabase.sql</code> 初始化 h2 DB 了</li><li>使用 ApplicationContext 对象获得 UserDao 实例</li><li>调用被测试的方法</li><li>对结果进行断言</li></ul><p>但这里实际上，ApplicationContext 是会被初始化两次的，所以会造成浪费和麻烦（例如初始化 sql 脚本也会被执行两次，当然这里吾辈先把 user 表删除后再创建的所以没事）。其实 Spring 早已想到了这一切，并为我们准备了解决方案。</p><p>使用 <code>SpringTest</code> 整合测试！</p><h3 id="使用注解自动加载-Spring-测试环境"><a href="#使用注解自动加载-Spring-测试环境" class="headerlink" title="使用注解自动加载 Spring 测试环境"></a>使用注解自动加载 Spring 测试环境</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 SpringTest 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//加载 Spring 配置文件</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:/spring/spring-context.xml&quot;)</span><br><span class="hljs-comment">//使用 SpringJUnit4ClassRunner 来运行 test</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoSpringTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直接注入 UserDao 就好了</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br>        User result = userDao.get(id);<br>        <span class="hljs-comment">//断言 id 和 get id 相同</span><br>        assertThat(result)<br>                .extracting(User::getId)<br>                .contains(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = userDao.listForAll();<br>        <span class="hljs-comment">//断言不为空</span><br>        assertThat(userList)<br>                .isNotEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里我们甚至可以使用 Spring 的自动注入注解 <code>@Autowired</code> 了</p><p>当然，现在还有一个问题就是现在测试对数据库的影响是持久的，也就是说不能重复的测试。<br>例如删除了一个为 id 为 1 的用户，返回值应当是 1，但第二次删除时，因为 id 为 1 的用户已经不存在了，所以返回值是 0，然后就报错了 23333</p><p>我们可以测试一下</p><ol><li> 在 UserDao 中新增方法 <code>deleteById</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据 id 删除用户</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 用户 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 受影响行数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> jdbcTemplate.update(<span class="hljs-string">&quot;delete from user where id = ?&quot;</span>, id);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在测试类 <code>UserDaoSpringTest</code> 中添加两个删除测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = userDao.deleteById(<span class="hljs-number">1</span>);<br>    assertThat(result)<br>            .isGreaterThan(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteByIdForTransaction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//这个仅仅是为了测试事物与自动回滚是否生效</span><br>    <span class="hljs-keyword">int</span> result = userDao.deleteById(<span class="hljs-number">1</span>);<br>    assertThat(result)<br>            .isGreaterThan(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行测试类，你会得到一个错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.AssertionError:<br>Expecting:<br> &lt;<span class="hljs-number">0</span>&gt;<br>to be greater than:<br> &lt;<span class="hljs-number">0</span>&gt;<br></code></pre></td></tr></table></figure><p>所以我们需要让所有测试的操作都不影响到数据库，即 <strong>全局事物</strong> + <strong>默认回滚</strong>。</p><p>首先需要在 <code>spring-context.xml</code> 中添加数据库事务管理的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据库事务并开启注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">p:dataSource-ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在 <code>UserDaoSpringTest</code> 测试类上添加两个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为这个测试类开启事物</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-comment">//默认回滚所有数据库操作</span><br><span class="hljs-meta">@Rollback</span><br></code></pre></td></tr></table></figure><p>再次运行，一切便都正常了，是不是感觉很棒！但每个测试类头上都加那么一大堆注解也很麻烦，所以我们需要将之抽出一个父类直接继承就好了</p><p>以下是一个最简单的测试基类 <code>BaseTest</code>(common.test.BaseTest)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单的测试基类</span><br><span class="hljs-comment"> * &lt;BaseBean&gt; 需要自动注入的 Bean 类型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:/spring/spring-context*.xml&quot;)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTest</span>&lt;<span class="hljs-title">BaseBean</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动注入的 Bean</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;SpringJavaInjectionPointsAutowiringInspection&quot;)</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BaseBean base;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后创建测试类 <code>UserDaoBaseTest</code>(com.rxliuli.study.springtest.dao.UserDaoBaseTest) 继承 <code>BaseTest</code> 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoBaseTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTest</span>&lt;<span class="hljs-title">UserDao</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br>        User result = base.get(id);<br>        <span class="hljs-comment">//断言 id 和 get id 相同</span><br>        assertThat(result)<br>                .extracting(User::getId)<br>                .contains(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; userList = base.listForAll();<br>        <span class="hljs-comment">//断言不为空</span><br>        assertThat(userList)<br>                .isNotEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = base.deleteById(<span class="hljs-number">1</span>);<br>        assertThat(result)<br>                .isGreaterThan(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteByIdForTransaction</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//这个仅仅是为了测试事物与自动回滚是否生效</span><br>        <span class="hljs-keyword">int</span> result = base.deleteById(<span class="hljs-number">1</span>);<br>        assertThat(result)<br>                .isGreaterThan(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果也是一切正常呢，对 Dao/Service 需要加载 Spring 容器的测试暂且到这里便结束了。。。</p><h2 id="Web-层测试"><a href="#Web-层测试" class="headerlink" title="Web 层测试"></a>Web 层测试</h2><p>绝大部分时候，很多人喜欢写完代码就到前台页面直接看效果。但人眼是不一定准确的，而且可重复性/可靠性不足。如果是 API，大部分人或许会选择诸如 <strong>Postman</strong>, <strong>IDEA HttpClient</strong> 这一类的工具吧，但实际上，SpringTest 已经考虑到了对 Web 层的测试并集成了这些。</p><p>首先还是需要添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-module-jaxb-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--json-path-assert 对 MockMvc response 中返回的 json 数据进行断言--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-path-assert<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置 maven 打包时为 <code>war</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置文件 <code>spring/spring-mvc.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置支持注解并自动扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.rxliuli.study.springtest&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.web.bind.annotation.RestController&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加 web 的根目录 <code>/src/main/webapp</code> 并在 webapp 目录下创建 <code>web.xml</code>(WEB-INF/web.xml)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--context configLocation --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath*:/spring/spring-context*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--encoding filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--MVC Servlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath*:/spring/spring-mvc*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>至此，项目中便添加了 web 环境支持。</p><p>下面开始编写要测试的接口 <code>UserController</code>(com.rxliuli.study.springtest.web.UserController)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取用户信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 用户 id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户对象信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.get(id);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取全部的用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 全部的用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/user/listForAll&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.listForAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候启动 web 项目在浏览器中访问 <code>localhost:8080/&#123;上下文&#125;/user/1</code> 应当会得到一个 User 对象。</p><blockquote><p>注：上下文 IDEA 默认为空，Eclipse 默认为项目名</p></blockquote><p>然而测试却是有两种方法：</p><ol><li>独立安装测试<br> 手动加载单个 Controller，所以测试其他 Controller 中的接口会发生异常。但测试速度上较快，所以应当优先选择。</li><li>集成 Web 环境测试<br> 将启动并且加载所有的 Controller, 所以效率上之于 BaseWebUnitTest 来说非常低下, 仅适用于集成测试多个 Controller 时使用。</li></ol><h3 id="独立安装测试"><a href="#独立安装测试" class="headerlink" title="独立安装测试"></a>独立安装测试</h3><p>简单的独立安装测试类 <code>UserControllerUnitTest</code>(com.rxliuli.study.springtest.web.UserControllerUnitTest)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:/spring/spring-*.xml&quot;)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-meta">@WebAppConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerUnitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserController userController;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于测试 API 的模拟请求对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//模拟一个 Mvc 测试环境，获取一个 MockMvc 实例</span><br>        mockMvc = MockMvcBuilders.standaloneSetup(userController)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试能够正常获取</span><br>        Integer id = <span class="hljs-number">1</span>;<br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 get 请求</span><br>                get(<span class="hljs-string">&quot;/user/&quot;</span> + id)<br>        )<br>                <span class="hljs-comment">//断言请求的状态是成功的(200)</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回对象的 id 和请求的 id 相同</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$.id&quot;</span>).value(id));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试正常获取</span><br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 post 请求</span><br>                post(<span class="hljs-string">&quot;/user/listForAll&quot;</span>)<br>        )<br>                <span class="hljs-comment">//断言请求状态</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回结果是数组</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isArray())<br>                <span class="hljs-comment">//断言返回数组不是空的</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isNotEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="集成-Web-环境测试"><a href="#集成-Web-环境测试" class="headerlink" title="集成 Web 环境测试"></a>集成 Web 环境测试</h3><p>简单的独立安装测试类 <code>UserControllerIntegratedTest</code>(com.rxliuli.study.springtest.web.UserControllerIntegratedTest)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/7/31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:/spring/spring-*.xml&quot;)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Rollback</span><br><span class="hljs-meta">@WebAppConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControllerIntegratedTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WebApplicationContext context;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于测试 API 的模拟请求对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//这里把整个 WebApplicationContext 上下文都丢进去了，所以可以测试所有的 Controller</span><br>        mockMvc = MockMvcBuilders.webAppContextSetup(context)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试能够正常获取</span><br>        Integer id = <span class="hljs-number">1</span>;<br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 get 请求</span><br>                get(<span class="hljs-string">&quot;/user/&quot;</span> + id)<br>        )<br>                <span class="hljs-comment">//断言请求的状态是成功的(200)</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回对象的 id 和请求的 id 相同</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$.id&quot;</span>).value(id));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listForAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//测试正常获取</span><br>        mockMvc.perform(<br>                <span class="hljs-comment">//发起 post 请求</span><br>                post(<span class="hljs-string">&quot;/user/listForAll&quot;</span>)<br>        )<br>                <span class="hljs-comment">//断言请求状态</span><br>                .andExpect(status().isOk())<br>                <span class="hljs-comment">//断言返回结果是数组</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isArray())<br>                <span class="hljs-comment">//断言返回数组不是空的</span><br>                .andExpect(jsonPath(<span class="hljs-string">&quot;$&quot;</span>).isNotEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>其实从上面可以看出来主要就是获得 MockMvc 的方式不同，所以其实也可以抽出来公共的测试父类。这里就不再赘述，具体的做法可以参考 <a href="https://github.com/rxliuli/springtest/tree/master/src/test/java/common">测试基类</a></p><p>那么，有关使用 Spring 进行测试的问题就像说到这里啦</p><blockquote><p>附：用了 SpringBoot 之后才觉得 Spring 的各种配置好麻烦。。。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 优雅的拷贝对象属性</title>
    <link href="/p/ee1c7fa2f4a24d8c86089bdb440f9df6/"/>
    <url>/p/ee1c7fa2f4a24d8c86089bdb440f9df6/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在 Java 项目中，经常遇到需要在对象之间拷贝属性的问题。然而，除了直接使用 <code>Getter/Stter</code> 方法，我们还有其他的方法么？<br>当然有，例如 <code>Apache Common Lang3</code> 的 <code>BeanUtils</code>，然而 <code>BeanUtils</code> 却无法完全满足吾辈的需求，所以吾辈便自己封装了一个，这里分享出来以供参考。</p><ul><li>需要大量复制对象的属性</li><li>对象之间的属性名可能是不同的</li><li>对象之间的属性类型可能是不同的</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>简单易用的 API</p><ul><li><code>copy</code>: 指定需要拷贝的源对象和目标对象</li><li><code>prop</code>: 拷贝指定对象的字段</li><li><code>props</code>: 拷贝指定对象的多个字段</li><li><code>exec</code>: 执行真正的拷贝操作</li><li><code>from</code>: 重新开始添加其他对象的属性</li><li><code>get</code>: 返回当前的目标对象</li><li><code>config</code>: 配置拷贝的一些策略</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li> 定义门面类 <code>BeanCopyUtil</code> 用以暴露出一些 API</li><li> 定义每个字段的操作类 <code>BeanCopyField</code>，保存对每个字段的操作</li><li> 定义 <code>BeanCopyConfig</code>，用于配置拷贝属性的策略</li><li> 定义 <code>BeanCopyOperator</code> 作为拷贝的真正实现</li></ol><p>图解</p><p><img src="https://img.rxliuli.com/20190227215703.png" alt="图解"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>注：反射部分依赖于 <a href="https://github.com/jOOQ/jOOR">joor</a>, JDK1.8 请使用 <a href="https://mvnrepository.com/artifact/org.jooq/joor-java-8/0.9.7">joor-java-8</a></p></blockquote><h3 id="定义门面类-BeanCopyUtil-用以暴露出一些-API"><a href="#定义门面类-BeanCopyUtil-用以暴露出一些-API" class="headerlink" title="定义门面类 BeanCopyUtil 用以暴露出一些 API"></a>定义门面类 <code>BeanCopyUtil</code> 用以暴露出一些 API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * java bean 复制操作的工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanCopyUtil</span>&lt;<span class="hljs-title">F</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> F from;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 目标对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T to;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝的字段信息列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;BeanCopyField&gt; copyFieldList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BeanCopyConfig config = <span class="hljs-keyword">new</span> BeanCopyConfig();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BeanCopyUtil</span><span class="hljs-params">(F from, T to)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.from = from;<br>        <span class="hljs-keyword">this</span>.to = to;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定需要拷贝的源对象和目标对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> from 源对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> to   目标对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;F&gt;  源对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;  目标对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个 &#123;<span class="hljs-doctag">@link</span> BeanCopyUtil&#125; 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;F, T&gt; <span class="hljs-function">BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">copy</span><span class="hljs-params">(F from, T to)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanCopyUtil&lt;&gt;(from, to);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝指定对象的字段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fromField 源对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> toField   目标对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> converter 将源对象中字段转换为目标对象字段类型的转换器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">prop</span><span class="hljs-params">(String fromField, String toField, Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; converter)</span> </span>&#123;<br>        copyFieldList.add(<span class="hljs-keyword">new</span> BeanCopyField(fromField, toField, converter));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝指定对象的字段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fromField 源对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> toField   目标对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">prop</span><span class="hljs-params">(String fromField, String toField)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> prop(fromField, toField, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝指定对象的字段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> field     源对象中与目标对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> converter 将源对象中字段转换为目标对象字段类型的转换器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">prop</span><span class="hljs-params">(String field, Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; converter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> prop(field, field, converter);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝指定对象的字段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> field 源对象中与目标对象中的字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">prop</span><span class="hljs-params">(String field)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> prop(field, field, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拷贝指定对象的多个字段</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fields 源对象中与目标对象中的多个字段名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">props</span><span class="hljs-params">(String... fields)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (String field : fields) &#123;<br>            prop(field);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行真正的拷贝操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">exec</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> BeanCopyOperator&lt;&gt;(from, to, copyFieldList, config).copy();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重新开始添加其他对象的属性</span><br><span class="hljs-comment">     * 用于在执行完 &#123;<span class="hljs-doctag">@link</span> #exec()&#125; 之后还想复制其它对象的属性</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> from 源对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;R&gt;  源对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 一个新的 &#123;<span class="hljs-doctag">@link</span> BeanCopyUtil&#125; 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">BeanCopyUtil&lt;R, T&gt; <span class="hljs-title">from</span><span class="hljs-params">(R from)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanCopyUtil&lt;&gt;(from, to);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回当前的目标对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前的目标对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> to;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置拷贝的一些策略</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> config 拷贝配置对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回 &#123;<span class="hljs-doctag">@code</span> this&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyUtil&lt;F, T&gt; <span class="hljs-title">config</span><span class="hljs-params">(BeanCopyConfig config)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.config = config;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义每个字段的操作类-BeanCopyField，保存对每个字段的操作"><a href="#定义每个字段的操作类-BeanCopyField，保存对每个字段的操作" class="headerlink" title="定义每个字段的操作类 BeanCopyField，保存对每个字段的操作"></a>定义每个字段的操作类 <code>BeanCopyField</code>，保存对每个字段的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拷贝属性的每一个字段的选项</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanCopyField</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String from;<br>    <span class="hljs-keyword">private</span> String to;<br>    <span class="hljs-keyword">private</span> Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; converter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanCopyField</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanCopyField</span><span class="hljs-params">(String from, String to, Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; converter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.from = from;<br>        <span class="hljs-keyword">this</span>.to = to;<br>        <span class="hljs-keyword">this</span>.converter = converter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> from;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyField <span class="hljs-title">setFrom</span><span class="hljs-params">(String from)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.from = from;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> to;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyField <span class="hljs-title">setTo</span><span class="hljs-params">(String to)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.to = to;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; getConverter() &#123;<br>        <span class="hljs-keyword">return</span> converter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyField <span class="hljs-title">setConverter</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> Object, ? <span class="hljs-keyword">super</span> Object&gt; converter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.converter = converter;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义-BeanCopyConfig，用于配置拷贝属性的策略"><a href="#定义-BeanCopyConfig，用于配置拷贝属性的策略" class="headerlink" title="定义 BeanCopyConfig，用于配置拷贝属性的策略"></a>定义 <code>BeanCopyConfig</code>，用于配置拷贝属性的策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拷贝属性的配置</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanCopyConfig</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同名的字段自动复制</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> same = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 覆盖同名的字段</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> override = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 忽略 &#123;<span class="hljs-doctag">@code</span> null&#125; 的源对象属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ignoreNull = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试进行自动转换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> converter = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanCopyConfig</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanCopyConfig</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> same, <span class="hljs-keyword">boolean</span> override, <span class="hljs-keyword">boolean</span> ignoreNull, <span class="hljs-keyword">boolean</span> converter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.same = same;<br>        <span class="hljs-keyword">this</span>.override = override;<br>        <span class="hljs-keyword">this</span>.ignoreNull = ignoreNull;<br>        <span class="hljs-keyword">this</span>.converter = converter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSame</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> same;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyConfig <span class="hljs-title">setSame</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> same)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.same = same;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOverride</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> override;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyConfig <span class="hljs-title">setOverride</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> override)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.override = override;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIgnoreNull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ignoreNull;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyConfig <span class="hljs-title">setIgnoreNull</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> ignoreNull)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ignoreNull = ignoreNull;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConverter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> converter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanCopyConfig <span class="hljs-title">setConverter</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> converter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.converter = converter;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义-BeanCopyOperator-作为拷贝的真正实现"><a href="#定义-BeanCopyOperator-作为拷贝的真正实现" class="headerlink" title="定义 BeanCopyOperator 作为拷贝的真正实现"></a>定义 <code>BeanCopyOperator</code> 作为拷贝的真正实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真正执行 copy 属性的类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanCopyOperator</span>&lt;<span class="hljs-title">F</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(BeanCopyUtil.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> F from;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T to;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanCopyConfig config;<br>    <span class="hljs-keyword">private</span> List&lt;BeanCopyField&gt; copyFieldList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanCopyOperator</span><span class="hljs-params">(F from, T to, List&lt;BeanCopyField&gt; copyFieldList, BeanCopyConfig config)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.from = from;<br>        <span class="hljs-keyword">this</span>.to = to;<br>        <span class="hljs-keyword">this</span>.copyFieldList = copyFieldList;<br>        <span class="hljs-keyword">this</span>.config = config;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//获取到两个对象所有的属性</span><br>        <span class="hljs-keyword">final</span> Map&lt;String, Reflect&gt; fromFields = Reflect.on(from).fields();<br>        <span class="hljs-keyword">final</span> Reflect to = Reflect.on(<span class="hljs-keyword">this</span>.to);<br>        <span class="hljs-keyword">final</span> Map&lt;String, Reflect&gt; toFields = to.fields();<br>        <span class="hljs-comment">//过滤出所有相同字段名的字段并进行拷贝</span><br>        <span class="hljs-keyword">if</span> (config.isSame()) &#123;<br>            <span class="hljs-keyword">final</span> Map&lt;ListUtil.ListDiffState, List&lt;String&gt;&gt; different = ListUtil.different(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(fromFields.keySet()), <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(toFields.keySet()));<br>            copyFieldList = Stream.concat(different.get(ListUtil.ListDiffState.common).stream()<br>                    .map(s -&gt; <span class="hljs-keyword">new</span> BeanCopyField(s, s, <span class="hljs-keyword">null</span>)), copyFieldList.stream())<br>                    .collect(Collectors.toList());<br>        &#125;<br>        <span class="hljs-comment">//根据拷贝字段列表进行拷贝</span><br>        copyFieldList.stream()<br>                <span class="hljs-comment">//忽略空值</span><br>                .filter(beanCopyField -&gt; !config.isIgnoreNull() || fromFields.get(beanCopyField.getFrom()).get() != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//覆盖属性</span><br>                .filter(beanCopyField -&gt; config.isOverride() || toFields.get(beanCopyField.getTo()).get() == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//如果没有转换器，则使用默认的转换器</span><br>                .peek(beanCopyField -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (beanCopyField.getConverter() == <span class="hljs-keyword">null</span>) &#123;<br>                        beanCopyField.setConverter(Function.identity());<br>                    &#125;<br>                &#125;)<br>                .forEach(beanCopyField -&gt; &#123;<br>                    <span class="hljs-keyword">final</span> String fromField = beanCopyField.getFrom();<br>                    <span class="hljs-keyword">final</span> F from = fromFields.get(fromField).get();<br>                    <span class="hljs-keyword">final</span> String toField = beanCopyField.getTo();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        to.set(toField, beanCopyField.getConverter().apply(from));<br>                    &#125; <span class="hljs-keyword">catch</span> (ReflectException e) &#123;<br>                        log.warn(<span class="hljs-string">&quot;Copy field failed, from &#123;&#125; to &#123;&#125;, exception is &#123;&#125;&quot;</span>, fromField, toField, e.getMessage());<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="使用流程图"><a href="#使用流程图" class="headerlink" title="使用流程图"></a>使用流程图</h3><p><img src="https://img.rxliuli.com/20190228000845.png" alt="使用流程图"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>代码写完了，让我们测试一下！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanCopyUtilTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());<br>    <span class="hljs-keyword">private</span> Student student;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;琉璃&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-number">4</span>);<br>        teacher = <span class="hljs-keyword">new</span> Teacher();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//简单的复制（类似于 BeanUtils.copyProperties）</span><br>        BeanCopyUtil.copy(student, teacher).exec();<br>        log.info(<span class="hljs-string">&quot;teacher: &#123;&#125;&quot;</span>, teacher);<br>        assertThat(teacher)<br>                .extracting(<span class="hljs-string">&quot;age&quot;</span>)<br>                .containsOnlyOnce(student.getAge());<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//不同名字的属性</span><br>        BeanCopyUtil.copy(student, teacher)<br>                .prop(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, sex -&gt; Objects.equals(sex, <span class="hljs-string">&quot;男&quot;</span>))<br>                .prop(<span class="hljs-string">&quot;realname&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)<br>                .exec();<br>        assertThat(teacher)<br>                .extracting(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br>                .containsOnlyOnce(student.getRealname(), student.getAge(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prop1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//不存的属性</span><br>        assertThat(BeanCopyUtil.copy(student, teacher)<br>                .prop(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, sex -&gt; Objects.equals(sex, <span class="hljs-string">&quot;男&quot;</span>))<br>                .prop(<span class="hljs-string">&quot;realname&quot;</span>, <span class="hljs-string">&quot;name2&quot;</span>)<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br>                .containsOnlyOnce(student.getAge(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">from</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Teacher lingMeng = <span class="hljs-keyword">new</span> Teacher()<br>                .setName(<span class="hljs-string">&quot;灵梦&quot;</span>)<br>                .setAge(<span class="hljs-number">17</span>);<br>        <span class="hljs-comment">//测试 from 是否覆盖</span><br>        assertThat(BeanCopyUtil.copy(student, teacher)<br>                .prop(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, sex -&gt; Objects.equals(sex, <span class="hljs-string">&quot;男&quot;</span>))<br>                .prop(<span class="hljs-string">&quot;realname&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)<br>                .exec()<br>                .from(lingMeng)<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br>                .containsOnlyOnce(lingMeng.getName(), lingMeng.getAge(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//测试 get 是否有效</span><br>        assertThat(BeanCopyUtil.copy(student, teacher)<br>                .prop(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, sex -&gt; Objects.equals(sex, <span class="hljs-string">&quot;男&quot;</span>))<br>                .prop(<span class="hljs-string">&quot;realname&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>)<br>                .containsOnlyOnce(student.getRealname(), student.getAge(), <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">config</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//不自动复制同名属性</span><br>        assertThat(BeanCopyUtil.copy(<span class="hljs-keyword">new</span> Student().setAge(<span class="hljs-number">15</span>), <span class="hljs-keyword">new</span> Teacher())<br>                .config(<span class="hljs-keyword">new</span> BeanCopyConfig().setSame(<span class="hljs-keyword">false</span>))<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;age&quot;</span>)<br>                .containsOnlyNulls();<br>        <span class="hljs-comment">//不覆盖不为空的属性</span><br>        assertThat(BeanCopyUtil.copy(<span class="hljs-keyword">new</span> Student().setAge(<span class="hljs-number">15</span>), <span class="hljs-keyword">new</span> Teacher().setAge(<span class="hljs-number">10</span>))<br>                .config(<span class="hljs-keyword">new</span> BeanCopyConfig().setOverride(<span class="hljs-keyword">false</span>))<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;age&quot;</span>)<br>                .containsOnlyOnce(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//不忽略源对象不为空的属性</span><br>        assertThat(BeanCopyUtil.copy(<span class="hljs-keyword">new</span> Student(), student)<br>                .config(<span class="hljs-keyword">new</span> BeanCopyConfig().setIgnoreNull(<span class="hljs-keyword">false</span>))<br>                .exec()<br>                .get())<br>                .extracting(<span class="hljs-string">&quot;realname&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;grade&quot;</span>)<br>                .containsOnlyNulls();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试学生类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 姓名</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String realname;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 年龄</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> Integer age;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 性别，男/女</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String sex;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 年级，1 - 6</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> Integer grade;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String realname, Integer age, String sex, Integer grade)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.realname = realname;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>            <span class="hljs-keyword">this</span>.grade = grade;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRealname</span><span class="hljs-params">()</span> </span>&#123;<br><br>            <span class="hljs-keyword">return</span> realname;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">setRealname</span><span class="hljs-params">(String realname)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.realname = realname;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> sex;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getGrade</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> grade;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">setGrade</span><span class="hljs-params">(Integer grade)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.grade = grade;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> ToStringBuilder.reflectionToString(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试教师类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 姓名</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 年龄</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> Integer age;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 性别，true 男，false 女</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> Boolean sex;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 职位</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String post;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(String name, Integer age, Boolean sex, String post)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>            <span class="hljs-keyword">this</span>.post = post;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> sex;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">setSex</span><span class="hljs-params">(Boolean sex)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.sex = sex;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPost</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> post;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">setPost</span><span class="hljs-params">(String post)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.post = post;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> ToStringBuilder.reflectionToString(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有发生什么意外，那么一切将能够正常运行！</p><hr><p>好了，那么关于在 Java 中优雅的拷贝对象属性就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 上安装 JDK 并设置环境变量</title>
    <link href="/p/8e5d9aba9ab845a9924c10565d53ecb7/"/>
    <url>/p/8e5d9aba9ab845a9924c10565d53ecb7/</url>
    
    <content type="html"><![CDATA[<h2 id="从-Oracle-官网下载-JDK"><a href="#从-Oracle-官网下载-JDK" class="headerlink" title="从 Oracle 官网下载 JDK"></a>从 Oracle 官网下载 JDK</h2><p>首先在浏览器打开 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK8 下载页面</a></p><p>找到 <strong>Java SE Development Kit 8uXXX</strong> 勾选 <strong>Accept License Agreement</strong>，点击下载平台对应的二进制文件，这里以 Windows 平台为例，选择 <strong>jdk-8u191-windows-x64.exe</strong> 下载就好了</p><p><img src="https://img.rxliuli.com/20181017141137.png" alt="JDK8 下载"></p><h2 id="运行安装程序"><a href="#运行安装程序" class="headerlink" title="运行安装程序"></a>运行安装程序</h2><p>双击打开 JDK 安装，其实基本上就是一路 Next 下去就好啦</p><p><img src="https://img.rxliuli.com/20181017145812.png" alt="JDK 安装 01"></p><p><img src="https://img.rxliuli.com/20181017145854.png" alt="JDK 安装 02"></p><p><img src="https://img.rxliuli.com/20181017145932.png" alt="JDK 安装 02"></p><p><img src="https://img.rxliuli.com/20181017150018.png" alt="JDK 安装 03"></p><p>这里需要注意一下，对于安装 JDK 的人来说，Java 安装是可有可无的，所以我们这里直接点 X 就好再确定就好。</p><p><img src="https://img.rxliuli.com/20181017150310.png" alt="不安装 Java"></p><p><img src="https://img.rxliuli.com/20181017150357.png" alt="安装完成"></p><p>安装完成，关闭安装窗口即可，然而我们并不能立刻开始使用 JDK，因为我们还需要设置 JDK 的环境变量</p><h2 id="设置-JDK-的环境变量"><a href="#设置-JDK-的环境变量" class="headerlink" title="设置 JDK 的环境变量"></a>设置 JDK 的环境变量</h2><ol><li> 在 <strong>此电脑</strong> 上右键选择 <strong>属性</strong></li></ol><p><img src="https://img.rxliuli.com/20181017142509.png" alt="此电脑右键属性"></p><ol start="2"><li> 在 <strong>控制面板\系统和安全\系统</strong> 选择 <strong>高级系统设置</strong></li></ol><p><img src="https://img.rxliuli.com/20181017142726.png" alt="高级系统设置"></p><ol start="3"><li> 在 <strong>系统属性 &gt; 高级</strong> 选项卡选择 <strong>环境变量</strong></li></ol><p><img src="https://img.rxliuli.com/20181017142652.png" alt="环境变量"></p><p>JDK：需要设置 3 个环境变量（如果找不到就添加）</p><blockquote><p>附：这里一般设置到 <strong>系统变量</strong> 里面</p></blockquote><p><img src="https://img.rxliuli.com/20181017143203.png" alt="环境变量设置"></p><ul><li><p>JAVA_HOME：浏览文件夹选择 JDK 安装路径就行了</p><p><img src="https://img.rxliuli.com/20181017143629.png" alt="JAVA_HOME 环境变量"></p></li><li><p>CLASSPATH：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></p><p><img src="https://img.rxliuli.com/20181017144048.png" alt="CLASSPATH 环境变量"></p></li><li><p>Path：添加 <code>%JAVA_HOME%\bin</code> 和 <code>%JAVA_HOME%\jre\bin</code></p><p><img src="https://img.rxliuli.com/20181017143940.png" alt="Path 环境变量"></p></li></ul><p>设置完环境变量之后一定要按确定依次关闭 <strong>环境变量</strong>，<strong>系统属性</strong> 窗口</p><p>JDK 安装完成了，现在测试一下能否正常使用，使用 <code>Win + R</code> 输入 <code>cmd</code> 打开 CMD 命令行窗口，或者在菜单中找到 <em>Windows 系统 &gt; 命令提示符</em> 点击也同样能打开 CMD。</p><h2 id="测试-JDK-是否安装成功"><a href="#测试-JDK-是否安装成功" class="headerlink" title="测试 JDK 是否安装成功"></a>测试 JDK 是否安装成功</h2><p><img src="https://img.rxliuli.com/20181017145201.png" alt="在菜单中打开 CMD"></p><p>在命令行输入 <code>javac</code>，你应该得到类似于下面的这些输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">用法: javac &lt;options&gt; &lt;<span class="hljs-built_in">source</span> files&gt;<br>其中, 可能的选项包括:<br>  -g                         生成所有调试信息<br>  -g:none                    不生成任何调试信息<br>  -g:&#123;lines,vars,<span class="hljs-built_in">source</span>&#125;     只生成某些调试信息<br>  -nowarn                    不生成任何警告<br>  -verbose                   输出有关编译器正在执行的操作的消息<br>  -deprecation               输出使用已过时的 API 的源位置<br>  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置<br>  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置<br>  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置<br>  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置<br>  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置<br>  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置<br>  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。<br>  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程<br>  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置<br>  -parameters                生成元数据以用于方法参数的反射<br>  -d &lt;目录&gt;                    指定放置生成的类文件的位置<br>  -s &lt;目录&gt;                    指定放置生成的源文件的位置<br>  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置<br>  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件<br>  -encoding &lt;编码&gt;             指定源文件使用的字符编码<br>  -<span class="hljs-built_in">source</span> &lt;发行版&gt;              提供与指定发行版的源兼容性<br>  -target &lt;发行版&gt;              生成特定 VM 版本的类文件<br>  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用<br>  -version                   版本信息<br>  -<span class="hljs-built_in">help</span>                      输出标准选项的提要<br>  -A关键字[=值]                  传递给注释处理程序的选项<br>  -X                         输出非标准选项的提要<br>  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统<br>  -Werror                    出现警告时终止编译<br>  @&lt;文件名&gt;                     从文件读取选项和文件名<br></code></pre></td></tr></table></figure><p>如果你得到了类似下面错误的输出，请务必重新检查上面的安装步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;javac&#x27;</span> 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。<br></code></pre></td></tr></table></figure><p>到此 JDK 的安装就算完成了</p>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在现代前端中使用 Worker</title>
    <link href="/p/f2c9b4e1b70a4f218216a521698989be/"/>
    <url>/p/f2c9b4e1b70a4f218216a521698989be/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>由于需要在 Browser 进行大量的计算，所以吾辈开始尝试使用 webworker 分离 CPU 密集型的计算操作，最终找到了 comlink 这个库，但之前在 vue 中使用时发生了错误，目前看起来已经得到了解决，所以在此记录一下。</p><h2 id="调研方案"><a href="#调研方案" class="headerlink" title="调研方案"></a>调研方案</h2><ul><li><a href="https://github.com/satya164/web-worker-proxy">web-worker-proxy</a>：结合了 proxy/promise/webworker 的强大工具库，但如何在 ts 中使用却是个问题</li><li><a href="https://github.com/miozzz/sandbox/tree/master/orc">Orc.js</a>：一个简单的 worker 封装</li><li><a href="https://github.com/israelss/vue-worker">VueWorker</a>：结合 vue 的 worker 封装，无法理解，难道真的会有人在 vue 组件中进行大量计算么？</li><li><a href="https://github.com/GoogleChromeLabs/comlink">comlink</a>：Chrome 的一个基于 proxy/promise/webworker 的封装库</li><li><a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a>：和上面的同属 chrome 实验室的一个 webpack 插件</li></ul><p>最后决定使用 comlink 结合 worker-plugin 实现简单的 worker 使用。</p><blockquote><p>相关问题：<a href="https://segmentfault.com/q/1010000022359546">comlink-loader 工作不正常</a></p></blockquote><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>添加相关依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add comlink<br>yarn add -D worker-plugin<br></code></pre></td></tr></table></figure><p>在 webpack 中添加插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  plugins: [<span class="hljs-keyword">new</span> WorkerPlugin()];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里一般不需要配置，如果需要，可以参考：<a href="https://github.com/GoogleChromeLabs/worker-plugin">worker-plugin</a></p></blockquote><p>添加一个简单的 <em>hello.worker.ts</em></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; expose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;comlink&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; HelloWorker &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hello.worker.type&quot;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  counter: <span class="hljs-number">0</span>,<br>  <span class="hljs-function"><span class="hljs-title">inc</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.counter++;<br>  &#125;,<br>  info: &#123; <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;GZ&quot;</span> &#125;,<br>&#125;;<br><br>expose(obj);<br></code></pre></td></tr></table></figure><p>在 <code>main.ts</code> 中使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = wrap(<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./hello.worker.ts&quot;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;module&quot;</span> &#125;)) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br><span class="hljs-keyword">await</span> obj.inc();<br>alert(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>但这里并不是类型安全的，所以我们可以实现正确的类型。</p><p>添加一个 <em>hello.worker.ts</em> 暴露出来的类型 <code>HelloWorkerType</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> HelloWorker = &#123;<br>  counter: <span class="hljs-built_in">number</span>;<br>  inc(): <span class="hljs-built_in">void</span>;<br>  info: &#123;<br>    city: <span class="hljs-built_in">string</span>;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同时为了支持在 <em>main.ts</em> 中使用正确的类型，需要使用泛型</p><p><em>main.ts</em> 修改如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = wrap&lt;HelloWorker&gt;(<br>  <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&quot;./hello.worker.ts&quot;</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;module&quot;</span> &#125;)<br>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br><span class="hljs-keyword">await</span> obj.inc();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.counter&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Counter: <span class="hljs-subst">$&#123;<span class="hljs-keyword">await</span> obj.info.city&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>本质上这里使用 <code>.</code> 的方式访问 worker 中的内容依赖于 <code>Proxy</code>，所以不需要使用类似于 <code>await (await obj.info).city</code> 这种奇怪的代码。</p><blockquote><p>参考：<a href="https://juejin.im/post/5b5fdb185188251aa01656d7">web workers 简介（二）动态创建 worker</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/">Integrating web workers in a React app with Comlink</a></li><li><a href="https://lorefnon.tech/2019/03/24/using-comlink-with-typescript-and-worker-loader/">Using comlink with typescript and worker-loader</a></li><li><a href="https://medium.com/lacolaco-blog/an-issue-around-angular-cli-comlink-workerplugin-585be1c8d087">An issue around Angular CLI + Comlink + WorkerPlugin</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 函数根据第一个参数推导后面参数的类型</title>
    <link href="/p/68f77629c640450983935d2ebcd6adbd/"/>
    <url>/p/68f77629c640450983935d2ebcd6adbd/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在编写一个重载函数时，吾辈发现了 ts 的方法签名问题。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> TypeEnum &#123;<br>  A,<br>  B,<br>&#125;<br><br><span class="hljs-keyword">type</span> A = &#123;<br>  a: <span class="hljs-built_in">string</span>;<br>&#125;;<br><span class="hljs-keyword">type</span> B = &#123;<br>  b: <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-comment">//region 普通参数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum.A, obj: A</span>): <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum.B, obj: B</span>): <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum, obj: A | B</span>) </span>&#123;&#125;<br><br><span class="hljs-comment">//endregion</span><br></code></pre></td></tr></table></figure><p>上面是一个简单的重载函数，吾辈希望在输入第一个参数 <code>type</code> 之后，ts 就能匹配到正确的参数，然而事实上，ts 并没能完全做到。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402140820.png" alt="ts 类型提示"></p><p>当然，如果真的这样写 ts 的类型检查仍然能正确地抛出错误消息，然而未能推导终究是有点问题的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TS2769: No overload matches this call.   Overload 1 of 2, &#x27;(type: TypeEnum.A, obj: A): void&#x27;, gave the following error.     Argument of type &#x27;&#123; a: string; b: number; &#125;&#x27; is not assignable to parameter of type &#x27;A&#x27;.       Object literal may only specify known properties, and &#x27;b&#x27; does not exist in type &#x27;A&#x27;.   Overload 2 of 2, &#x27;(type: TypeEnum.B, obj: B): void&#x27;, gave the following error.     Argument of type &#x27;TypeEnum.A&#x27; is not assignable to parameter of type &#x27;TypeEnum.B&#x27;</span><br>fn1(TypeEnum.A, &#123;<br>  a: <span class="hljs-string">&quot;&quot;</span>,<br>  b: <span class="hljs-number">1</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后，吾辈想到了几种方式可以尝试解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>尝试使用继承限制字段的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//region 对象参数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">arg: &#123; <span class="hljs-keyword">type</span>: TypeEnum.A; obj: A &#125;</span>): <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">arg: &#123; <span class="hljs-keyword">type</span>: TypeEnum.B; obj: B &#125;</span>): <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">arg: &#123; <span class="hljs-keyword">type</span>: TypeEnum; obj: A | B &#125;</span>) </span>&#123;&#125;<br><br>fn2(&#123;<br>  <span class="hljs-keyword">type</span>: TypeEnum.A,<br>  obj: &#123;<br>    a: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">//endregion</span><br></code></pre></td></tr></table></figure><p>很遗憾的是，这是行不通的，即便是下面的这种变体，仍然是不可行的。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145908.png" alt="继承"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Base&lt;T <span class="hljs-keyword">extends</span> TypeEnum&gt; &#123;<br>  <span class="hljs-keyword">type</span>: T;<br>&#125;<br><br><span class="hljs-keyword">interface</span> IA <span class="hljs-keyword">extends</span> Base&lt;TypeEnum.A&gt; &#123;<br>  obj: A;<br>&#125;<br><span class="hljs-keyword">interface</span> IB <span class="hljs-keyword">extends</span> Base&lt;TypeEnum.B&gt; &#123;<br>  obj: B;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">arg: IA | IB</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>事实上，使用泛型确实可以做到让 ts 的类型更加 <strong>正确</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145745.png" alt="泛型"></p><p>缺点：</p><ul><li>不能使用 ts 的重载</li><li>需要函数的作者改变思维</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//region 泛型</span><br><br><span class="hljs-keyword">type</span> EnumTypeMapGen&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[], M <span class="hljs-keyword">extends</span> &#123; [P <span class="hljs-keyword">in</span> TypeEnum]: <span class="hljs-built_in">any</span> &#125;&gt; = [<br><br>];<br><span class="hljs-keyword">type</span> TypeMap = &#123;<br>  [TypeEnum.A]: A;<br>  [TypeEnum.B]: B;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">TypeEnum</span>, <span class="hljs-title">Arg</span> <span class="hljs-title">extends</span> <span class="hljs-title">TypeMap</span>[<span class="hljs-title">T</span>]&gt;(<span class="hljs-params"><span class="hljs-keyword">type</span>: T, obj: Arg</span>) </span>&#123;&#125;<br><br>fn3(TypeEnum.A, &#123;<br>  a: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;);<br><br><span class="hljs-comment">//endregion</span><br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>最后，高阶函数可以简单的解决这个问题，它将一次调用更改为两次调用，第一次调用返回的函数便已经确认了类型。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145633.png" alt="高阶函数"></p><p>缺点：</p><ul><li>需要使用者接收这种 <strong>函数式</strong> 的调用方式</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//region 高阶函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn4</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum.A</span>): (<span class="hljs-params">obj: A</span>) =&gt; <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn4</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum.B</span>): (<span class="hljs-params">obj: B</span>) =&gt; <span class="hljs-title">void</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn4</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeEnum</span>): <span class="hljs-title">any</span> </span>&#123;&#125;<br><br>fn4(TypeEnum.A)(&#123;<br>  a: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;);<br><br><span class="hljs-comment">//endregion</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的而言，泛型和高阶函数都能解决这个问题，吾辈个人倾向于泛型，因为它并未改变调用者的使用方式，而是让作者去改变，避免改变函数的接口本身。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 使用技巧</title>
    <link href="/p/5443e970161e4079985109abd12153c1/"/>
    <url>/p/5443e970161e4079985109abd12153c1/</url>
    
    <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li><code>Win-E</code>：打开系统文件浏览器</li><li><code>Win-Tab</code>：打开程序网格面板，类似于 <code>C-Tab</code>，但默认不会切换，而是展开全屏面板选择一个正在运行的程序切换过去</li><li><code>Win-R</code>：打开<strong>运行</strong></li><li><code>Win-S</code>：搜索任何东西</li><li><code>Win-A</code>：展开右侧通知面板</li><li><code>C-Tab</code>：切换程序</li><li><code>CS-Esc</code>：打开任务管理器</li><li><code>C-F</code>：在当前页内容中搜索关键字<ul><li><code>Enter</code>：下一个匹配关键字</li><li><code>S-Enter</code>：上一个匹配关键字</li></ul></li></ul><h3 id="非常见"><a href="#非常见" class="headerlink" title="非常见"></a>非常见</h3><ul><li><code>C-空格</code>：切换半角/全角标点符号</li><li><code>C-.</code>：切换中英文标点符号（隐藏的很深。。。）</li><li><code>Win-长按</code>: 显示快捷键指南</li><li><code>Win-Top</code>: 最大化</li><li><code>Win-Down</code>: 最小化</li><li><code>Win-Left</code>: 左侧贴靠</li><li><code>Win-Left</code>: 右侧贴靠</li></ul><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="定时关机"><a href="#定时关机" class="headerlink" title="定时关机"></a>定时关机</h3><p>使用以下命令会在指定时间后关机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">shutdown –s –t [second time]<br></code></pre></td></tr></table></figure><p>例如以下命令指的是在 1h 后关机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">shutdown –s –t 3600<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://jingyan.baidu.com/article/93f9803f06bb90e0e46f55ec.html">百度 win10 怎么定时关机？</a></p></blockquote><h3 id="PowerToys-使用"><a href="#PowerToys-使用" class="headerlink" title="PowerToys 使用"></a><a href="/p/0bfcb8d2846a4c37ad37d7f0f7ff709a">PowerToys 使用</a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具网站</title>
    <link href="/p/964e8ddc28dc41c3888f53c7f8f01af9/"/>
    <url>/p/964e8ddc28dc41c3888f53c7f8f01af9/</url>
    
    <content type="html"><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><a href="https://frontendmasters.com/books/front-end-handbook/2019/">2019 前端开发者学习路线汇总</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://i18ns.com/">i18ns</a>: 国际化 i18n 全语言翻译</li><li><a href="https://codepen.io/">codepen</a>: 前端页面代码分享(<code>HTML/CSS/JavaScript</code>)</li><li><a href="https://www.appsgeyser.com/">appsgeyser</a>: 封装前端/网站为 App</li><li><a href="https://www.cloudflare.com/">cloudflare</a>: CDN/免费的 HTTPS</li><li><a href="https://www.netlify.com/">netlify</a>: 前端免费 CI(持续集成)</li><li><a href="https://sm.ms/">smms</a>: 免费稳定的图床(国内)</li><li><a href="https://cn.office-converter.com/Online-Document-Converter">office-converter</a>: 文档在线转换</li><li><a href="https://msdn.itellyou.cn/">I tell you</a>: 微软相关资源下载</li><li><a href="https://vectormagic.com/">vectormagic</a>: 图像类型在线转换</li><li><a href="https://send.firefox.com/">Firefox Send</a>: 安全的分享文件</li><li><a href="https://www.draw.io/">draw</a>: 画图工具</li><li><a href="https://www.flaticon.com/">flaticon</a>: 矢量图标库</li><li><a href="https://www.iconfont.cn/">iconfont</a>: 阿里矢量图标库</li><li><a href="https://colorhunt.co/">colorhunt</a>: CSS 颜色搭配</li><li><a href="https://uigradients.com/">uigradients</a>: 渐变颜色推荐</li><li><a href="https://www.cssfontstack.com/">cssfontstack</a>: 查看字体在各个系统的预装概率</li><li><a href="https://tb.rg-adguard.net/">rg-adguard</a>: Windows 第三方下载站（实际调用 MS 的链接）</li><li><a href="https://picsum.photos/">Picsum</a>: 图片占位网站</li><li><a href="http://patorjk.com/software/taag/">taag</a>: 文字转字符画</li><li><a href="http://asciiflow.com/">asciiflow</a>: 手绘字符画</li><li><a href="https://www.geogebra.org/">GeoGebra</a>: 数学作图工具</li><li><a href="https://send-anywhere.com/">send anywhere</a>: 文件共享</li></ul><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><a href="https://codepen.io/pens/">Explore Pens on CodePen</a>: CSS/Canvas/SVG 创意分享</li><li><a href="https://www.namesilo.com/">namesilo</a>: 域名服务</li><li><a href="https://www.vultr.com/">vultr</a>: VPS 服务</li><li><a href="https://www.inoreader.com/">inoreader</a>: RSS 订阅/管理/阅读</li><li><a href="https://leetcode.com/problemset/all/">leetcode</a>: 算法刷题</li><li><a href="https://www.owllook.net/">owllook</a>: 在线开源小说阅读</li><li><a href="https://unbug.github.io/codelf/">codelf</a>: 变量命名神器</li><li><a href="https://sourceforge.net/projects/crportable/files/">旧版 Chromium 下载</a>: 便于调试之用</li><li><a href="https://www.picdiet.com/zh-cn">picdiet</a>: 图片在线本地压缩</li><li><a href="https://www.aconvert.com/">aconvert</a>：在线常用工具网站，包括图像转换（<code>png &lt;=&gt; ico</code>），文档转换等等</li><li><a href="https://zhongzisc.blogspot.com/">种子书城</a>：一个有趣的 epub 书籍分享/下载网站</li><li><a href="https://www.deepl.com/translator">DeepL 深度翻译</a></li></ul><h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><ul><li><a href="https://segmentfault.com/">SegmentFault</a>: 国内前端问答论坛</li><li><a href="https://developer.mozilla.org/zh-CN/">MDN 开发者网站</a>: 世界上最好的前端文档（详尽的本地化）</li><li><a href="https://developers.google.com/web/">Google Web</a>: Google Web 的开发者文档(包含最新但不一定实用的知识)</li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ul><li><a href="https://git-scm.com/book/zh/v1">Pro Git</a>: Git 功能详述</li><li><a href="http://es6.ruanyifeng.com/">ES6 教程</a>: 通俗易懂的 ES6 入门教程</li><li><a href="https://material.io/design/">material desgin</a>: materail 主题设计原则</li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul><li><a href="http://ru23.com/">Frank’s Blog/前端迷</a>: 前端底层知识</li><li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络博客</a>: 通俗易懂的博客</li><li><a href="http://xbeta.info/">善用佳软</a>: 精品的软件评测系列（很久没更新了）</li><li><a href="https://liqi.io/">利器</a>: 分享创造者和他们的工具（不一定是编程领域）</li><li><a href="https://colachan.com/">可乐橙</a>：有着奇思妙想的 UI 设计师</li></ul><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul><li><a href="https://www.chartjs.org/">chartjs</a>: JavaScript 图表</li><li><a href="https://jquery.com/">jquery</a>: 上个世代最流行的前端库</li><li><a href="https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md">Commander.js</a>: nodejs 命令行解析工具</li></ul><h2 id="优秀文章"><a href="#优秀文章" class="headerlink" title="优秀文章"></a>优秀文章</h2><ul><li><a href="https://juejin.im/post/5aa0d65a5188251880387b01">程序员跳槽时，如何高效地准备面试？</a></li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li><a href="https://www.freecodecamp.org/learn/front-end-libraries/react/create-a-simple-jsx-element">freecodecamp 免费学习认证网站</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>liuli-cli TS JS SDK CLI 工具</title>
    <link href="/p/1a9c52f7628f4d39af4b3d074ba06d63/"/>
    <url>/p/1a9c52f7628f4d39af4b3d074ba06d63/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈最初尝试写 JS SDK 发布到 NPM 上，过程中遇到了很多问题，也因此消耗了大量的时间。<br>包括但不限于以下这些</p><ul><li>折腾 Rollup 打包</li><li>折腾 JS 的模块（umd/esm）</li><li>折腾单元测试</li><li>折腾 ES6 怎么通过 Babel 编译</li><li>使用 JS 编写，没有提供类型定义</li><li>没有进行打包</li><li>没有编译成 ES5</li><li>没有单元测试</li><li>没有 API 文档</li><li>没有 Linter 和 Prettier 统一格式化</li></ul><blockquote><p>具体的过程可以参考 <a href="https://blog.rxliuli.com/p/c30dd206/">使用 rollup 打包 JavaScript SDK</a></p></blockquote><p>吾辈在过程中遇到的一些问题</p><ul><li><a href="https://segmentfault.com/q/1010000018386874/">使用 Rollup + Babel 打包出错</a></li><li><a href="https://segmentfault.com/q/1010000018914964">npm 发布后的包安装后无法引用？</a></li><li><a href="https://segmentfault.com/q/1010000019587945">为什么上传到 GitHub Pages 的静态资源会 404 了呢？有人遇到过么？</a></li></ul><p>吾辈目前所在的公司中的 NPM 库也存在这些问题，内部的 npm 库几乎不能称为一个合格的库，以上的问题基本都存在。所以为了重构公司的 npm 包（主要是为了提供类型定义），就想是否能够把这部分单独抽离成一个脚手架，因而便开发了 SDK cli 供公司的前端 dev 创建一个标准（包含打包、编译、测试、文档、发布）的 SDK，并希望以此抹平不同 NPM 库配置的不一致性。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>所以吾辈后来创造了 <a href="https://www.npmjs.com/package/liuli-cli">liuli-cli</a>，用于简化和统一创建 JS/TS SDK 的步骤。</p><p>目前实现的功能如下</p><ul><li>[x] 基本打包支持</li><li>[x] 模块化 umd/es</li><li>[x] jest 单元测试支持</li><li>[x] 代码压缩支持</li><li>[x] babel 支持</li><li>[x] ts 支持</li><li>[x] linter 支持</li><li>[x] prettier 格式化支持</li><li>[x] git 钩子支持</li><li>[x] esdoc</li><li>[x] typedoc</li><li>[x] 许可证选择支持</li></ul><p>使用的话也很简单</p><p>全局安装 liuli-cli</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -g liuli-cli<br></code></pre></td></tr></table></figure><p>然后便可以使用命令 <code>li</code> 创建项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">li create &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p>目前支持以下三种类型（强烈推荐库的作者使用 TypeScript）</p><ul><li><code>JavaScript 模板</code></li><li><code>TypeScript 模板</code></li><li><code>命令行工具模板</code></li></ul><p>之后根据引导即可创建一个开箱即用的项目了</p><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><p>让我们看看那些大公司云服务的 JS SDK 是怎样的。</p><p>腾讯：提供的 SDK 大多是一个 JS 文件，需要在项目里手动引入，甚至有些是依赖了开源依赖，导致开源依赖使用 npm 管理，而私有服务的 SDK 仍然使用 JS 的方式引入。</p><ul><li><a href="https://cloud.tencent.com/document/product/436">对象存储</a></li><li><a href="https://cloud.tencent.com/document/product/266">腾讯云点播</a></li><li><a href="https://cloud.tencent.com/document/product/269">即时通信 IM</a></li></ul><p>讯飞：web 版 demo 明明有 package.json 这种版本控制工具，但却仍然是在一个 HTML 里直接 script 脚本引入，而非使用 npm/yarn 进行依赖管理，而 package.json 里面只是一个 http-server 用以开启一个静态服务器看 demo 罢了。</p><ul><li><a href="https://www.xfyun.cn/doc/asr/voicedictation/API.html">语音听写</a></li><li><a href="https://www.xfyun.cn/doc/asr/lfasr/API.html">语音转写</a></li><li><a href="https://www.xfyun.cn/doc/asr/rtasr/API.html">实时语音转写</a></li></ul><p>或许在大公司的这些 SDK 的开发者看来，会使用他们这些服务的公司都是小公司，以及一些没有接触过现代前端的开发者，所以都以这种方式提供 SDK。更不要说文档与类型定义，这两项几乎是 JS SDK 标准的需求，他们都没有做好。而且，明明他们的 SDK 也有版本号，甚至给出的 JS SDK 本身便是 umd 的，但实际上却未发布在 npm 或是其他公开的仓库中（作为库的使用者吾辈没有找到）。这些开发者宁愿用户提工单询问，并浪费了大量的沟通时间解决问题也不愿意最开始就将这些做的好一点。</p><blockquote><p>Pass1：文档可能过时，但 Demo 一定是最新的。<br>Pass2：这行代码不知道做什么的，但没有了就会出错，先放在这里。</p></blockquote><p>当然，或许创建第三方组织可以解决部分这个问题，像是 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 那个 ts 的开源项目一样，但问题仍然很多</p><ol><li> 目标对象不同：DefinitelyTyped 的目标是为了没有 types 的 js 库定义类型，它的目标对象也是开源（大多数时候也是）免费的库。而像是腾讯这些内部服务的 SDK 是收费、不开源的，很难让人免费为其做贡献。</li><li> 各家都有类似的云服务：提供这种云服务的公司并不止一家，难道要为每一家都添加创建类似的组织么？</li><li> 安全性问题：第三方组织不能保证每一行贡献的内容一定就和官方的一模一样，就算引入了恶意代码也很难立刻发现。</li><li> 法律风险：这样做的话是否会被官方发律师函也是未知之数。</li></ol><p>当然，也有一些个人为某些云服务创建的 NPM 库</p><ul><li><a href="https://www.npmjs.com/package/xunfeisdk">https://www.npmjs.com/package/xunfeisdk</a></li><li><a href="https://www.npmjs.com/package/xfy-node">https://www.npmjs.com/package/xfy-node</a></li></ul><p>但更多的服务是没有的，而且个人创建的这些库很难保证一直不过时（大多数都是某个项目用了一下罢了）。如果能简化项目的初始化流程，不知是否能让官方发布到 NPM 组织下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于使用 CLI 会阻碍人接触更<strong>底层</strong>的知识这点，属于仁者见仁智者见智的事情。毕竟，CLI 能够简化重复的劳动自然是会受到欢迎，前端三大框架也都有自己的 CLI 用于快速创建项目，降低框架的使用门槛，避免接触到一些琐碎的细节而专注于自己的需求开发。</p><blockquote><p>webpack/babel 真的不能说底层，尤其是 webpack，复杂性太高、知识的时效性太短导致现在它的风评并不好。。。</p></blockquote><p>最后，这个项目才写出来没多久，欢迎任何人使用、批评和建议！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 图片粘贴工具 PicGo</title>
    <link href="/p/0162e7b886294d45bb509a30861dfb0b/"/>
    <url>/p/0162e7b886294d45bb509a30861dfb0b/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 Markdown 的人都知道，想要在 Markdown 文件中插入图片并不是特别容易，因为你必须要先把图片上传到图床才行，一个好的图床能够节省很多时间。吾辈之前使用的是 smms，后来切换到了 GitHub，毕竟 GitHub 作为国外流行的托管网站，但事实上 GitHub 上传图片麻烦一点也不少。_add -&gt; commit -&gt; push -&gt; browser -&gt; copy url_，实在麻烦。直到，遇到了 PicGo。</p><p>PicGo 对于吾辈而言主要解决了下面的问题：</p><ul><li>上传之前重命名</li><li>上传一键就好</li><li>上传后图片管理</li></ul><blockquote><p><a href="https://molunerfinn.com/PicGo/">官网</a>, <a href="https://github.com/rxliuli/PicGo">GitHub</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181016231008.png" alt="官网首页截图"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在 <a href="https://github.com/Molunerfinn/picgo/releases">GitHub Releases</a> 下载最新版，然后安装一下即可开箱即用啦！</p><blockquote><p>注：上传图床默认是 <a href="https://sm.ms/">smms</a>，速度很快，也很稳定</p></blockquote><p>启动之后会看到一个上传页，将图片拖到这里就可以自动上传，并在完成之后自动将链接复制到剪切板上。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190205233313.png" alt="图片上传页"></p><p>在相册里可以对图片进行管理，方便浏览，复制 <code>URL</code>，删除本地记录等操作！<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190205233906.png" alt="上传图片管理"></p><h2 id="GitHub-设置"><a href="#GitHub-设置" class="headerlink" title="GitHub 设置"></a>GitHub 设置</h2><blockquote><p>如果你不玩 GitHub，可以跳过这一节</p></blockquote><p>这里可以参考 PicGo 的 <a href="https://github.com/Molunerfinn/PicGo/wiki/%E8%AF%A6%E7%BB%86%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8#github%E5%9B%BE%E5%BA%8A">官方教程</a></p><p>基本上就是需要以下三个配置</p><ul><li>仓库名：准确地说是 [用户名/仓库名]，例如吾辈的 GitHub 帐户名是 rxliuli，作为图床的仓库名是 img-bed，那么这里应该设置为 <strong>rxliuli/img-bed</strong></li><li>分支名：默认就是 master 分支，如果没什么特别的需求应该不用修改</li><li>Token：用来操作 GitHub 的钥匙，你可以在 <a href="https://github.com/settings/tokens">Token 设置</a> 中任意生成，但需要留意权限，默认选择第一个 repo 然后点击 <strong>Generator Token</strong> 按钮生成就行了</li></ul><p>吾辈的配置</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181016232104.png" alt="PicGo 配置"></p><h2 id="VSCode-插件"><a href="#VSCode-插件" class="headerlink" title="VSCode 插件"></a>VSCode 插件</h2><blockquote><p>如果你不玩 VSCode，也可以跳过这一节了</p></blockquote><p>如果你使用的编辑器是 VSCode 并且不需要管理图片的话，便可以使用 VSCode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo">PicGo</a></p><p>基本上安装完成之后就可以直接使用了，默认使用 <a href="https://sm.ms/">SMMS 图床</a>。</p><p>常用操作只有三个：</p><ul><li>截图上传 <code>Ctrl-Alt-U</code><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102050.gif" alt="截图上传"></li><li>文件管理器选择上传 <code>Ctrl-Alt-E</code><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102356.gif" alt="文件管理器选择上传"></li><li>输入文件路径上传 <code>Ctrl-Alt-O</code><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102418.gif" alt="输入文件路径上传"></li></ul><blockquote><p>如果你不想使用 SMMS 图床，也可以配置 GitHub 或者其他的图床，具体参考 <a href="https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo">官方文档</a>。</p></blockquote><hr><p>那么，关于 Markdown 图片粘贴工具到这里便结束了，愉快的使用 Markdown 写作吧 <code>o(〃＾▽＾〃)o</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome 踩坑笔记</title>
    <link href="/p/0a1c6f4ae59e41e2a260f56eb764a40b/"/>
    <url>/p/0a1c6f4ae59e41e2a260f56eb764a40b/</url>
    
    <content type="html"><![CDATA[<h2 id="Chrome-右键翻译不能使用"><a href="#Chrome-右键翻译不能使用" class="headerlink" title="Chrome 右键翻译不能使用"></a>Chrome 右键翻译不能使用</h2><blockquote><p>2018-10-11</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>其实是 SwitchyOmega 这个插件，之前一直没出过问题，结果现在 Chrome69 出现了。Chrome 浏览器右键翻译的 API 和 Google 翻译网页版使用的不是同一个！</p><ul><li>Google 网页版：<a href="https://translate.google.com/">https://translate.google.com</a></li><li>Google Chrome：<a href="https://translate.googleapis.com/">https://translate.googleapis.com</a></li></ul><p>结果就出现了 Google 翻译网页版明明能正常使用，但 Chrome 浏览器右键翻译功能就是不行的奇怪现象。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>直接访问 <a href="https://translate.googleapis.com/">https://translate.googleapis.com</a>，嗯，访问失败了。然后设置这个域名使用代理就好了，正常情况下应该显示 404，并不是错误。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书-[人类简史]</title>
    <link href="/p/19166db1a8854c98a5dfc7fe16bed657/"/>
    <url>/p/19166db1a8854c98a5dfc7fe16bed657/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>断断续续，最近终于读完了<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2">人类简史</a>。它是一个系列的书籍，一共三本「人类简史」，「未来简史」和「今日简史」，当然，系列的第一本「人类简史」是最出名的，吾辈也正是有所耳闻才去通读了该系列。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201213231.png" alt="封面"></p><h2 id="言"><a href="#言" class="headerlink" title="言"></a>言</h2><p>书里太多内容，读过之后却又没有记忆下来。然而，吾辈记忆深刻的有以下几点</p><h3 id="人类之所以成为「万物之灵」是因为想象力「虚构的故事」"><a href="#人类之所以成为「万物之灵」是因为想象力「虚构的故事」" class="headerlink" title="人类之所以成为「万物之灵」是因为想象力「虚构的故事」"></a>人类之所以成为「万物之灵」是因为想象力「虚构的故事」</h3><p>国家，政府，金钱，公司，资本主义，社会主义，不过都是虚构的概念，人类相信这些「故事」，所以能够形成大规模协作，而这是其他物种所不具备的。<br>老实说这点确实有点违反吾辈一直以来的认知，甚至比曾经「官僚系统是人类史上最伟大的发明，能让无数互不相识的人互相协作」更有冲击性。<br>附：之前吾辈的对官僚系统的认知基本上是腐败和权力，而且从小接受的教育告诉吾辈人类会使用工具才是人类成为万物之灵的关键（比如能够使用「火」）。</p><h3 id="人工智能会代替绝大多数人的工作，引起大规模失业"><a href="#人工智能会代替绝大多数人的工作，引起大规模失业" class="headerlink" title="人工智能会代替绝大多数人的工作，引起大规模失业"></a>人工智能会代替绝大多数人的工作，引起大规模失业</h3><p>这点和吾辈一直以来的想法不谋而合，重复的工作迟早被人工智能替代，但书中所言的现实更加绝望——连创造性的工作，文学和艺术都未能幸免于难。<br>人工智能还有多久才能出现，这点谁也不好说，但能知道的是现今的 Google，MS 这些顶级的大公司都在研究人工智能，并已然初见成效（Google 搜索/翻译/微软小娜）。<br>虽然现在人工智能看起来还很初级，只能在某个指定领域内击败人类，而且有些还很蠢（被称为人工智障），但不得不说人工智能的发展及其迅速，甚至自动驾驶汽车已经上路很多年了。</p><h3 id="一个人的职业会被迫需要改变"><a href="#一个人的职业会被迫需要改变" class="headerlink" title="一个人的职业会被迫需要改变"></a>一个人的职业会被迫需要改变</h3><p>曾经，一旦确定了职业，大多都是兢兢业业做一辈子。但现在，人类的寿命增加，社会变化又如此迅速，人类讲被迫适应一次次的职业改变。毕业即失业，学习到的东西到了社会上已然过时，这便是未来的真实写照了。<br>老实说这点在吾辈父母身上已经初见端倪，父母四十几岁的人，却不得不改变了职业。当然，他们不喜欢这样，用他们的话说：你知道改变有多难么？出问题家里老小怎么办？<br>现在，父母辈的人可能几十年换一次职业，但到了我们，却未必依然。或许，不久之后，十年换一次职业都是一件正常的事情了（#无奈）。</p><h3 id="法西斯在自身看来并不是邪恶的"><a href="#法西斯在自身看来并不是邪恶的" class="headerlink" title="法西斯在自身看来并不是邪恶的"></a>法西斯在自身看来并不是邪恶的</h3><p>很多描述法西斯的书籍都把法西斯描述的无比邪恶，而身处其中的人却很难意识到（像是现如今的国内 #笑）。<br>政府说什么是好的什么就是好的，权利比真相更重要，家长式的权威政府，前景难免不会变成 <a href="https://zh.wikipedia.org/zh/%E4%B8%80%E4%B9%9D%E5%85%AB%E5%9B%9B">1984</a> 般的反乌托邦世界。每个人都被监听，家人之间互相举报，毫无信任感可言。<br>现在，国内是世界上摄像头最多的地方，网络公司对隐私的侵犯也并不违反法律，这造成了国内公司的肆无忌惮，毫无底线的把数据收集用以收割韭菜，并且，报告给当局（参阅 <code>**IDC/ISP**</code> 数据上报规范）。</p><h2 id="思"><a href="#思" class="headerlink" title="思"></a>思</h2><p>人的认知无法超越时代，即便如牛顿，爱因斯坦他们，亦然如此。这本书的所言所述，也并不代表真理，更不代表其中的一切都是对的，只是作者如此认为——<strong>每个作者都有自己的偏见</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 为当前用户添加开机自启项</title>
    <link href="/p/1b2541739a154f95a67bd4c9690b52b9/"/>
    <url>/p/1b2541739a154f95a67bd4c9690b52b9/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>不知道你是否遇到过，每次打开电脑，开机之后总是要启动 Chrome 浏览器等一些常用应用，而常用应用中有的有开机自启的选项，有些则没有。每次打开都是重复性的操作，真是不厌其烦。。。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>下面是 Windows 当前用户的自启动目录的路径</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\&#123;你的用户名&#125;\<span class="hljs-title">AppData</span>\<span class="hljs-title">Roaming</span>\<span class="hljs-title">Microsoft</span>\<span class="hljs-title">Windows</span>\<span class="hljs-title">Start</span> <span class="hljs-title">Menu</span>\<span class="hljs-title">Programs</span>\<span class="hljs-title">Startup</span></span><br></code></pre></td></tr></table></figure><p>我们可以为想要自启动的程序创建一个快捷方式，然后将快捷方式放到这个目录下就可以啦</p><p>然而，直接放快捷方式太多的话管理起来可能会是个麻烦，所以我们可以使用脚本，下面给出两种脚本示例</p><ul><li><p>ahk 脚本</p><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ahk"><span class="hljs-comment">; 开机自启 Chrome 浏览器</span><br>Run Chrome<br></code></pre></td></tr></table></figure></li><li><p>cmd 脚本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-comment">rem 开机自启 Chrome 浏览器</span><br><span class="hljs-built_in">start</span> chrome<br></code></pre></td></tr></table></figure><p>那么，关于在 Windows 下添加自启项到这里边结束啦，很简单的吧！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode Markdown All in One 插件不能使用 TOC 命令创建文章目录</title>
    <link href="/p/23e9fc7d30f8442e855f1ee4ea9f30c9/"/>
    <url>/p/23e9fc7d30f8442e855f1ee4ea9f30c9/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 VSCode 写 Markdown 文档时，突然发现 VSCode 输入 <code>toc</code> 找不到生成文章目录的命令了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201211046.png" alt="输入 toc 创建文章目录"></p><p>然而输入 <code>markdown</code> 时发现仍然有创建文章目录的选项，说明这个功能还存在</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201211242.png" alt="输入 markdown 创建文章目录"></p><p>那么，到底是为什么输入 <code>toc</code> 没有匹配到创建文章目录的命令了呢？</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>吾辈突然发现一个奇怪的地方，是的，明明是英文状态下，<a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a> 插件的命令却是中文的，这是什么原因呢？</p><p>于是吾辈在 <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a> 插件的 <a href="https://github.com/neilsustc/vscode-markdown">GitHub</a> 仓库上提出了这个问题。<br><a href="https://github.com/neilsustc/vscode-markdown/issues/337">I can’t use the command to generate the title of the article, I don’t know what happened. . .</a><br>作者说有类似的问题<br><a href="https://github.com/neilsustc/vscode-markdown/issues/327">中文系统下，无法通过键入 TOC 命令快速创建目录</a>。</p><p><a href="https://github.com/neilsustc/vscode-markdown/issues/327">Issues</a> 中说是显示语言需要改成 <code>en</code>，然而吾辈并没有修改过 VSCode 的显示语言，所以这个解决方案对吾辈没有生效。。。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201212334.png" alt="VSCode 显示语言"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>不过因此吾辈想到了另一种可能，吾辈之前是安装了 <a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">Chinese (Simplified) Language Pack for Visual Studio Code</a> 插件，以让 VSCode 显示中文，后来因为一些原因放弃中文而使用原生 VSCode 了。所以就想会不会是这个原因，于是吾辈尝试重新安装中文语言插件。</p><p>结果，233333，真的是这个原因呢！</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201212821.png" alt="安装了 VSCode 中文语言插件之后"></p><p>这里吾辈的语言仍然为 <code>en</code>，仅仅只是安装了中文语言插件，命令由 <strong>创建目录</strong> 变成了 <code>Create Table of Contents</code>，插件是在中文系统下默认显示中文命令，在安装完中文语言插件后就变成了全英文（此时 VSCode 语言仍然设置为 <code>en</code>）。</p><p>应该是插件本身的问题，吾辈已经提交了 <a href="https://github.com/neilsustc/vscode-markdown/issues/337">Issues</a>，等待开发者回复。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 设置 Git-Bash 为默认 Terminal</title>
    <link href="/p/29f2a48fdf1d4d8c996d14b02768af1d/"/>
    <url>/p/29f2a48fdf1d4d8c996d14b02768af1d/</url>
    
    <content type="html"><![CDATA[<p>IDEA 默认集成了 <strong>Terminal</strong>，但默认使用的终端确是 <code>cmd.exe</code>（<code>Windows10</code> 默认则是 <code>PowerShell</code>）。而众所周知，<code>Windows</code> 在命令行上做得确实有够难用的，所以我们可以选择其他的第三方终端进行使用。</p><p>这里演示一下使用 <code>Git-Bash</code> 作为默认集成的终端</p><p>在设置 <code>Settings &gt; Tools &gt; Terminal</code> 下有一个 <code>Shell path</code> 的选择框。</p><p>在里面填写以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;D:\Program\cmder\vendor\git-for-windows\bin\bash.exe&quot;</span>  -login -i<br></code></pre></td></tr></table></figure><blockquote><p>注：这里吾辈直接使用了 <code>cmder</code> 内置的 <code>Git</code> 客户端，关于 <code>cmder</code> 可以参考另外一篇内容：<a href="https://blog.rxliuli.com/p/9ea2b223/">Cmder 启动报错</a><br>而且使用 Git-Bash 的话最好确保安装的 Git 是最新版本，否则 IDEA Terminal 有可能出现光标位置偏移的错误。</p></blockquote><p>字符串中的内容是本机上的 <code>Git-Bash</code> 的程序完全路径，后面两个参数则是为了避免在 <code>IDEA</code> 集成的终端下发生有中文时光标异常的问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在 Windows 上使用 FTP/SFTP 服务端</title>
    <link href="/p/3240627e8e6745dbbde569c1df169c32/"/>
    <url>/p/3240627e8e6745dbbde569c1df169c32/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在做 <code>WebService</code> 项目时遇到了定时上传统计报表的需求。协议是 <code>FTP/SFTP</code>，然而第三方服务暂时无法集成，所以只能在本地使用软件模拟出 <code>FTP/SFTP</code> 服务端，然后在代码中进行测试。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>吾辈并未使用 Windows 上大名鼎鼎的 <a href="https://filezilla-project.org/">FileZilla</a>。<br>谜之音：<strong>FileZilla 开源免费，而且 <code>FTP/SFTP/FTPS</code> 都能支持岂不美滋滋？</strong><br>吾辈：然而安装完成直接启动就报错了<br>谜之音：<strong>报错就去查一下，这都觉得麻烦却是没办法了呢！</strong></p><p>事实上这是很多开发者，尤其是 Linux 下的开发者，习惯了使用软件可能报错、可能有问题，对使用体验毫不在意。<br>所以吾辈滚了，滚去使用其他的软件了。</p><h2 id="使用-freeFTPd"><a href="#使用-freeFTPd" class="headerlink" title="使用 freeFTPd"></a>使用 freeFTPd</h2><blockquote><p><a href="http://www.freesshd.com/">freeFTPd 官网</a></p></blockquote><p>点击 <a href="http://www.freesshd.com/freeFTPd.exe">下载链接</a> 下载 freeFTPd，然后点击安装。第一次运行时会询问你 <strong>是否创建/使用私钥</strong> 和 <strong>是否运行系统服务</strong>，全部选择 <strong>是</strong> 即可。</p><ol><li>打开程序<br> 可以看到默认在 <code>Status</code> 标签，显示者 FTP 和 SFTP 服务都是关闭状态。<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217213152.png" alt="首页"></li><li>添加用户<br> 首先，我们需要添加一个用户，可以连接 FTP/SFTP 服务端的用户。<ol><li>点击 Users 标签，然后点击 Add 添加用户<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217213700.png" alt="Users 标签"></li><li>设置用户信息<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214421.png" alt="添加用户信息"><br> 依次<ol><li> 输入用户名</li><li> 选择使用密码认证</li><li> 输入密码</li><li> 选择用户的服务端根目录</li><li> 同时选择允许 FTP/SFTP 连接（默认选中）</li><li> 点击 Apply 完成添加</li></ol></li></ol></li><li>启动 FTP 服务端<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214719.png" alt="启动 FTP"></li><li>启动 SFTP 服务端<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214843.png" alt="启动 SFTP"></li><li>查看 Status 状态页<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214951.png" alt="Status 选项页"></li></ol><h2 id="测试-FTP-SFTP"><a href="#测试-FTP-SFTP" class="headerlink" title="测试 FTP/SFTP"></a>测试 FTP/SFTP</h2><p>如果仅仅是连接 FTP/SFTP 的话，我们确实可以使用 <a href="https://winscp.net/">WinSCP</a> 作为 FTP/SFTP 客户端。然而，作为开发者，连接 Linux 服务器也是家常便饭，所以我们选择 <a href="https://mobaxterm.mobatek.net/">MobaXterm</a>。</p><p>在 <a href="https://mobaxterm.mobatek.net/download-home-edition.html">下载页面</a> 选择 <strong>MobaXterm Home Edition v11.1 (Portable edition)</strong> 下载免费便携版。下载完成得到一个压缩包，解压之，点击 <strong>MobaXterm_Personal_11.1.exe</strong> 运行程序。</p><p>MobaXterm 首页<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220138.png" alt="MobaXterm 首页"></p><ol><li>点击 <strong>Session</strong> 添加会话<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220648.png" alt="连接 FTP"></li><li>设置用户认证信息<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220940.png" alt="设置用户认证信息"></li><li>选择用户认证信息<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221138.png" alt="选择用户认证信息"></li><li>连接 FTP 成功<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221321.png" alt="连接 FTP 成功"></li><li>同理添加 SFTP 连接<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221633.png" alt="同理添加 SFTP 连接"></li><li>连接 SFTP 成功<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221801.png" alt="连接 SFTP 成功"></li></ol><hr><p>最后，虽然概率很低，但如果在你的 PC 上按照该教程搭建失败，可以在文章底部进行评论告诉吾辈哦 （ｖ＾＿＾）ｖ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 创建和运行一个简单的 maven web 项目</title>
    <link href="/p/35f7849269eb442a89896fec0660415a/"/>
    <url>/p/35f7849269eb442a89896fec0660415a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>本文是为了帮助刚接触 IDEA 的萌新快速了解如何创建与运行一个 Maven Web 项目，但由于 <a href="https://en.wikipedia.org/wiki/Curse_of_knowledge">知识的诅咒</a>（#笑），如果有什么不太明白或者发现了什么问题，欢迎在最下方进行留言哦</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>首先打开 IDEA，进入到了 IDEA 欢迎页，点击 <strong>Create New Project</strong><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204181531.png" alt="IDEA 欢迎页"></p><p>来到项目创建面板</p><ol><li> 选择 Maven</li><li> 勾选上 <strong>Create from archetype</strong>（根据原型创建）</li><li>选择 <code>org.apche.maven.archetypes:maven-archetype-webapp</code> 原型<blockquote><p>这里可以输入 webapp，就可以通过 Top/Bottom 键来快速找到原型了</p></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204182057.png" alt="创建面板"></p><p>接下来设定一下 Maven 的基本配置</p><ul><li>GroupId：代表该项目的实体或组织。例如 <code>com.rxliuli.example</code> 就是一个组织 id。<blockquote><p>如果你对 maven 没有任何基础，可以直接使用 <code>com.&#123;你的英文名&#125;</code> 作为组织 id</p></blockquote></li><li>ArtifactId：实际的工件名称。例如 <code>idea-maven-webapp-example</code> 就指明了该项目就是一个 idea 创建的 maven webapp 案例项目</li><li>Version：该项目的版本号，没什么好说的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183441.png" alt="Maven 基本配置"></p><p>然后是使用的 Maven 程序，IDEA 内置了 Maven，所以如果你不怎么了解 Maven 可以直接 Next 过去<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183409.png" alt="使用的 Maven 程序"></p><p>最后一步是创建 IDEA 项目，基本上不需要修改什么，直接 FINISH 即可<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183707.png" alt="创建 IDEA 项目"></p><h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2><h3 id="项目初始配置"><a href="#项目初始配置" class="headerlink" title="项目初始配置"></a>项目初始配置</h3><p>创建完成后会提示是否选择自动引入依赖，这里选择 <strong>Enable Auto import</strong>。当然，另一个要我们去配置 Web 框架的提示就不用管了，IDEA 已经自动完成了这一切。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204184028.png" alt="创建完成提示"></p><h3 id="配置-Tomcat-容器"><a href="#配置-Tomcat-容器" class="headerlink" title="配置 Tomcat 容器"></a>配置 Tomcat 容器</h3><p>项目搭建好了，然而我们还需要一个 Web 容器，这里以 Tomcat 作为演示</p><ol><li> 使用快捷键 <code>CS-A</code> 打开 IDEA 结构化设置搜索</li><li> 输入 <code>edit config</code>，找到 <code>edit configurations...</code> 项</li><li>回车打开 IDEA 运行配置面板<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204185414.png" alt="IDEA 结构化设置搜索"></li><li>添加一个新的 Tomcat 容器运行配置项<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204185728.png" alt="Tomcat 容器运行配置"></li><li>配置 Application server，点击 CONFIGURETION 按钮<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190023.png" alt="配置 Application server"></li><li>选择本地 Tomcat 的目录并确定<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190127.png" alt="选择本地 Tomcat 的目录"></li><li>选择要运行的 war 包<br> 配置完成会发现下面多了一条警告 <code>Warning:No artifacts marked for deployment</code>，意思是没有 jar/war 包需要被部署，这里我们只要点一下 Fix，并且选择 <code>war exploded</code>，之后 IDEA 会自动完成剩余的事<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190459.png" alt="部署 war 项目"><blockquote><p>注：有人觉得每次都要配置 Tomcat 真的挺麻烦的，这里吾辈坚决声明这是误解，只有第一次才需要配置各种环境，后面 IDEA 是能够<strong>记住</strong>的。</p></blockquote></li><li>最后，修改一下运行配置的名字，然后点击 OK 按钮<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204191042.png" alt="修改运行配置的名字"></li><li>在右上角的运行配置里应该已经显示出刚才添加的运行配置项 Tomcat 了，这是点击右边的 Debug 按钮，一切就开始了<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204191242.png" alt="Debug 开始"></li><li>运行完成后会自动打开浏览器 <a href="http://localhost:8080/">http://localhost:8080/</a>，显示出这个项目的首页了呢<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204200454.png" alt="浏览器"></li></ol><p>至此，我们已经使用 IDEA 运行起来了一个基本的 Web 项目了呢！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="配置项目目录结构"><a href="#配置项目目录结构" class="headerlink" title="配置项目目录结构"></a>配置项目目录结构</h3><p>项目的文件菜单树大概长这样，初始只有这么几个文件，稍微解释一下用途</p><ul><li><code>pom.xml</code>：Maven 的配置文件，所有 Maven 搭建的项目都会有，记录着项目所有的依赖</li><li><code>web.xml</code>：Web 项目所需要的一个配置文件。主要用来配置 <code>Servlet</code>, <code>Filter</code>, <code>Listene</code>。</li><li><code>index.jsp</code>：Maven webapp 原型自带的一个初始的 jsp 首页</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204184248.png" alt="项目文件结构"></p><h3 id="配置-java-resources-目录"><a href="#配置-java-resources-目录" class="headerlink" title="配置 java/resources 目录"></a>配置 java/resources 目录</h3><p>现在，我们已经可以写 jsp 了，那么 <code>Servlet</code> 之类的 java 文件应该写到哪里呢？</p><ol><li><p>在 <em>src/main</em> 新建 <em>java</em> 和 <em>resources</em> 目录<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204194615.png" alt="新建 java/resources 目录"></p></li><li><p>点击 <em>File &gt; Project Structure</em> 打开项目结构配置面板（或者使用快捷键 <code>CSA-S</code>）<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204194742.png" alt="Project Structure"></p></li><li><p>标识目录</p><ol><li><p> 点击 Module 项</p></li><li><p> 选择需要的项目</p></li><li><p> 选中 java 文件夹</p></li><li><p> 点击 Source 使 java 目录变为蓝色</p></li><li><p> 选中 resources 目录</p></li><li><p> 点击 Resources 使 resources 目录变为紫色</p></li><li><p>完成后点击下方的 OK</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204195327.png" alt="标识目录"></p></li></ol></li></ol><h3 id="修改-web-xml-的-servlet-版本为-3-1"><a href="#修改-web-xml-的-servlet-版本为-3-1" class="headerlink" title="修改 web.xml 的 servlet 版本为 3.1"></a>修改 web.xml 的 servlet 版本为 3.1</h3><p>其实就是把 <code>web.xml</code> 的内容修改为下面这样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="添加-servlet-jsp-依赖"><a href="#添加-servlet-jsp-依赖" class="headerlink" title="添加 servlet/jsp 依赖"></a>添加 servlet/jsp 依赖</h3><p>虽然 tomcat 本身就有 servlet/jsp 的实现，但那是在项目运行时才会有的，而我们需要在代码中使用 Servlet 的类时，则需要添加对应的依赖。</p><p>找到 <code>pom.xml</code> maven 配置文件，在 dependencies 中添加 <code>javax.servlet</code> 和 <code>javax.servlet.jsp</code> 两项依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 其他内容 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 其他依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 其他内容 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建-Servlet"><a href="#创建-Servlet" class="headerlink" title="创建 Servlet"></a>创建 Servlet</h3><p>接下来，我们的 Java 源码就全部放到 <em>/src/main/java</em> 下即可</p><p>新建一个简单的 Servlet 类 <code>HomeServlet</code> (path: <code>com.rxliuli.example.ideamavenwebappexample.HomeServlet</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rxliuli.example.ideamavenwebappexample;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rxliuli</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@WebServlet(name = &quot;HomeServlet&quot;, urlPatterns = &quot;/home&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        <span class="hljs-keyword">final</span> PrintWriter out = resp.getWriter();<br>        out.println(<span class="hljs-string">&quot;这里是首页哦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，再次点击 Debug 按钮重新运行项目，在浏览器中访问 <a href="http://localhost:8080/home">http://localhost:8080/home</a>，可以看到我们的 Servlet 已经生效了呢<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204202042.png" alt="访问 home Servlet"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>这个演示项目吾辈也放到了 <a href="https://github.com/rxliuli/idea-maven-webapp-example">GitHub</a> 上，如果需要可以随便下载</li><li>如果你还不了解 maven 的话强烈建议稍微了解一下 maven 的基本概念。可以参照吾辈 blog 上的教程 <a href="https://blog.rxliuli.com/p/82700e2a/">Windows 上 Maven 安装与使用</a> 进行安装</li><li>如果你还不了解 IDEA（废话，这不是当然的嘛！#打），推荐阅读 <a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IntelliJ IDEA 简体中文专题教程</a> 进行入门</li></ul><p>那么，这篇教程到这里便结束啦，希望我们都能愉快地使用 IDEA 呢 o(〃＾ ▽ ＾〃)o</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 VSCode + Joplin 作为笔记工具</title>
    <link href="/p/3ecd3d18192d40779258639b68d838f5/"/>
    <url>/p/3ecd3d18192d40779258639b68d838f5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://joplinapp.org/">joplin</a>, <a href="https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin">joplin-vscode-plugin</a></p></blockquote><h2 id="为什么吾辈使用-Joplin"><a href="#为什么吾辈使用-Joplin" class="headerlink" title="为什么吾辈使用 Joplin"></a>为什么吾辈使用 Joplin</h2><blockquote><p>注: 开源、不受平台限制以及基于 markdown 容易迁移这是很重要的一点，因为没有人知道哪个笔记工具是最终的赢家，如果没有选对，那么至少要容易迁移。</p></blockquote><p>吾辈曾经使用过一些笔记工具，包括 印象、OneNote、Notion 这些，但最终都放弃了。<br>关键还是在于吾辈核心的一些需求未能得到满足:</p><ol><li> 搜索要快</li><li> 编辑器体验要好</li><li> 数据应该能够全部导出</li><li> 基于标准的 md，可以直接复制到其他平台</li><li> 可以基于它进行二次开发</li><li> 还没死</li></ol><p>下面让我们来细品以上工具的功能</p><p>印象笔记</p><p>好吧，印象笔记有国际版/国内版，但国内版本很明显属于收钱不做正事的典型，很长时间内都没有任何变化了。而且，markdown 支持并非官方自带，而是需要使用第三方插件才行（18 年底更新之后貌似支持了）。而且最近 <a href="https://www.zhihu.com/question/343856067">印象笔记又抢注国内的 notion 的图片商标</a>，真可谓是国内独树一帜的<strong>奇观</strong> 了。</p><p>OneNote</p><p>老实说，如果习惯使用 Office 全家桶整理文档的话，OneNote 还是很香的，编辑体验和 Word 保持一致，搜索极快。但很遗憾的是，吾辈是坚定的 <strong>万物基于 markdown</strong> 人士，所以不喜欢 OneNote。</p><p>Notion</p><p>是目前遇到的一个比较满意的笔记工具，但主要有 3 点不太满意。</p><ol><li> 编辑器比较卡</li><li> 搜索非常慢</li><li> 无法导出全部数据</li></ol><blockquote><p>具体参考：<a href="/p/b1d53b2d48c24af7904985f6c3764cdb">Notion 使用体验</a></p></blockquote><p>而 Joplin，则是吾辈能够解决 notion 的以上几个问题的笔记工具，同时开源免费，允许吾辈参与其中。</p><p>主要优点：</p><ol><li> 搜索很快，非常快</li><li> 可以使用外部编辑器打开</li><li> 数据都在自己手里，提供一次性导出全部的功能</li><li> 使用标准的 md，可以直接复制到其他平台</li><li> 可以基于它进行二次开发</li></ol><p>主要缺点：</p><ol><li> ui/ux 有点简陋</li><li> 没有 vsc 插件导致使用外部编辑器也并不是非常方便</li></ol><h2 id="为什么吾辈要写-vscode-的这个插件"><a href="#为什么吾辈要写-vscode-的这个插件" class="headerlink" title="为什么吾辈要写 vscode 的这个插件"></a>为什么吾辈要写 vscode 的这个插件</h2><ol><li> 作为专业的编辑器在编辑功能上 vscode 是笔记工具无法比拟的。例如快捷键支持</li><li> vscode 不仅仅是一个编辑器，更有着非常庞大的插件生态圈，所以在 markdown 格式化、linter 校验、pdf 导出等功能上早已实现，不需要在笔记工具里重复造轮子 – 还可能是方轮子</li><li> 事实上，我一直在使用 vscode 在进行 markdown 文档编辑工作，用 git + vscode 存储公司相关的文档。同时也在使用 joplin 存储个人的笔记资料，但目前经过一段时间发现我需要的是 vscode 的编辑 + joplin 的同步/搜索功能。</li></ol><p>所以我编写了这个插件，用以给与我有相同需求的人使用。</p><blockquote><p>参考: <a href="https://discourse.joplinapp.org/t/future-of-joplin/11306">Future of Joplin</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 VSCode 中集成 joplin，实现了 Joplin 的常用功能。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200623085740.png" alt="预览图"></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>先简单列出吾辈与笔记相关的插件列表，它们都实现了某项特定功能且可以组合。</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a>: Markdown 语言支持</li><li><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdown lint</a>: Markdown linter 工具</li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a>: 多语言格式化工具，对 markdown 的支持非常好</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo">PicGo</a>: 图片上传（这是一个第三方程序）</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a>: Markdown 导出 PDF</li><li><a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio">Draw.io Integration</a>: draw.io 流程图集成<ul><li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid">Markdown Preview Mermaid Support</a>: 支持 mermaid 流程图 DSL，但 draw.io 更好用</li></ul></li><li><a href="https://marketplace.visualstudio.com/items?itemName=eightHundreds.vscode-mindmap">vscode-mindmap</a>: 思维导图集成（此为 fork 版本，但更加好用）</li><li><a href="https://marketplace.visualstudio.com/items?itemName=xyz.local-history">Local History</a>: 本地历史记录</li><li><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">Code Spell Checker</a>: 单词拼写检查</li><li><a href="https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin">joplin-vscode-plugin</a>: joplin 笔记集成</li></ul><blockquote><p>你可能注意到其中部分插件和 markdown 没什么关系，但它们对于编辑而言仍然是重要的，例如 Joplin 最近（v1.4.*）才实现的拼写检查功能已经存在现有的 VSCode 插件了。</p></blockquote><p>这些插件解决的问题吾辈也在 <a href="https://discourse.joplinapp.org/t/future-of-joplin/11306/45?u=rxliuli">joplin 与 vscode 之类的编辑器区别</a> 提交，在此也不多赘述。</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>吾辈简单浏览了最近两周的 Joplin 帖子，其中下面这些问题在 VSCode 中似乎已经解决/实现了</p><ul><li><a href="https://discourse.joplinapp.org/t/please-add-an-easy-to-access-markdowns/12688">Please add an easy to access markdowns</a>: 快速添加列表</li><li><a href="https://discourse.joplinapp.org/t/markdown-keyboard-shortcuts/12668">Markdown keyboard shortcuts</a>: markdown 快捷键支持</li><li><a href="https://discourse.joplinapp.org/t/duplicate-line-command/12650">Duplicate line command</a>: 复制并粘贴到下一行</li><li><a href="https://discourse.joplinapp.org/t/please-auto-replace-to-bullet-number-checkbox-list/12319">Please auto replace to Bullet/Number/Checkbox list</a>: 同样是快速添加列表</li><li><a href="https://discourse.joplinapp.org/t/auto-attach-images-as-resources-after-external-editor/3121">Auto attach images as resources after external editor</a>: 外部编辑器粘贴图像支持 Joplin</li><li><a href="https://discourse.joplinapp.org/t/integration-of-plantuml/11029">Integration of PlantUML</a>: PlantUML 集成</li><li><a href="https://discourse.joplinapp.org/t/find-and-replace/7283">Find and Replace</a>: 查找和替换功能支持</li><li><a href="https://discourse.joplinapp.org/t/making-joplin-recognise-yaml-front-matter/12868">Making Joplin recognise YAML front matter</a>: markdown yaml 元数据支持</li><li><a href="https://discourse.joplinapp.org/t/plugin-note-tabs/12752">Plugin: Note Tabs</a>: 多标签页支持</li><li><a href="https://discourse.joplinapp.org/t/option-to-show-line-numbers-in-editor/8313">Option to show line numbers in editor</a>: 显示行号</li><li><a href="https://discourse.joplinapp.org/t/incomplete-toc-sidebar/10458">Incomplete TOC sidebar</a>: outline 支持</li><li><a href="https://discourse.joplinapp.org/t/feature-request-folding-sections-of-text/5752">Feature request: Folding sections of text</a>: 代码块折叠</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>最后，配置完成的 VSCode 编辑器编辑 Markdown 的效果图如下</p><p><img src="https://img.rxliuli.com/20181201165338.png" alt="编辑效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>vscode</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 自定义模板代码片段</title>
    <link href="/p/49d925fba15e46a8a4b3c9e513ea6b13/"/>
    <url>/p/49d925fba15e46a8a4b3c9e513ea6b13/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>VSCode 时常需要输入一些重复的代码片段，例如创建 vue 文件后总是要写一些类似于下面这样的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><br>&lt;/template&gt;<br><br>&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data: <span class="hljs-function">() =&gt;</span> (&#123;<br><br>  &#125;),<br>  methods: &#123;<br><br>  &#125;,<br>  mounted () &#123;<br><br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>能不能有什么办法使用快捷键，或者提示将之快捷打出来呢？VSCode 已经想到了这些并提供了一个名为 <strong>Snippet</strong> 的功能。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>打开<strong>命令面板</strong>（_查看 &gt; 命令面板_，快捷键是 _CS-P_），输入 <strong>Snippet</strong> 找到 <strong>Preferences: Configure User Snippets（配置用户代码片段）</strong>，选择你所需要配置的代码片段生效的语言。</p><p>这里以 <strong>Vue</strong> 为例，回车之后会打开一个名为 <em>vue.json</em> 的文件，初始配置大致如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and</span><br>  <span class="hljs-comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br>  <span class="hljs-comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the</span><br>  <span class="hljs-comment">// same ids are connected.</span><br>  <span class="hljs-comment">// Example:</span><br>  <span class="hljs-comment">// &quot;Print to console&quot;: &#123;</span><br>  <span class="hljs-comment">// &quot;prefix&quot;: &quot;log&quot;,</span><br>  <span class="hljs-comment">// &quot;body&quot;: [</span><br>  <span class="hljs-comment">// &quot;console.log(&#x27;$1&#x27;);&quot;,</span><br>  <span class="hljs-comment">// &quot;$2&quot;</span><br>  <span class="hljs-comment">// ],</span><br>  <span class="hljs-comment">// &quot;description&quot;: &quot;Log output to console&quot;</span><br>  <span class="hljs-comment">// &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面那些注释其实就给出了一个配置的例子。放开注释我们研究一些每一行的作用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and</span><br>  <span class="hljs-comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br>  <span class="hljs-comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the</span><br>  <span class="hljs-comment">// same ids are connected.</span><br>  <span class="hljs-comment">// Example:</span><br>  <span class="hljs-comment">// 代码片段的名字</span><br>  <span class="hljs-attr">&quot;Print to console&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-comment">// 前缀，在 vue 文件中输入这个前缀就会有代码提示</span><br>    <span class="hljs-comment">// 输入前缀回车之后在文件中生成的内容，单行直接用字符串，否则使用数组</span><br>    <span class="hljs-attr">&quot;body&quot;</span>: [<br>      <span class="hljs-comment">//下面是每一行的内容，$1 指的是第一个变量（光标会首先停在这里）</span><br>      <span class="hljs-string">&quot;console.log(&#x27;$1&#x27;);&quot;</span>,<br>      <span class="hljs-comment">// $2 是第二个变量，在输入完第一个变量后按 Tab 就能跳转到第二个变量所在的位置</span><br>      <span class="hljs-string">&quot;$2&quot;</span><br>    ],<br>    <span class="hljs-comment">// 关于这个代码片段的描述</span><br>    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Log output to console&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，我们也来模仿写一个自己代码片段吧</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// 在最下方追加</span><br>  <span class="hljs-attr">&quot;vue teamplte&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;vueTemplate&quot;</span>,<br>    <span class="hljs-attr">&quot;body&quot;</span>: [<br>      <span class="hljs-string">&quot;&lt;template&gt;&quot;</span>,<br>      <span class="hljs-string">&quot;  $1&quot;</span>,<br>      <span class="hljs-string">&quot;&lt;/template&gt;&quot;</span>,<br>      <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;&lt;script&gt;&quot;</span>,<br>      <span class="hljs-string">&quot;export default &#123;&quot;</span>,<br>      <span class="hljs-string">&quot;  data: () =&gt; (&#123;&quot;</span>,<br>      <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;  &#125;),&quot;</span>,<br>      <span class="hljs-string">&quot;  methods: &#123;&quot;</span>,<br>      <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;  &#125;,&quot;</span>,<br>      <span class="hljs-string">&quot;  mounted () &#123;&quot;</span>,<br>      <span class="hljs-string">&quot;&quot;</span>,<br>      <span class="hljs-string">&quot;  &#125;&quot;</span>,<br>      <span class="hljs-string">&quot;&#125;&quot;</span>,<br>      <span class="hljs-string">&quot;&lt;/script&gt;&quot;</span><br>    ],<br>    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;vue 的模板代码&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 <em>.vue</em> 文件中输入 <code>vueTemplate</code> 试试吧</p><blockquote><p>更多的详细信息（英文）可以参考 Microsoft 官方的 <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">VSCode 创建代码片段</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 hexo next 搭建静态博客</title>
    <link href="/p/5cfc10dd0067424c9398b79190fe0dcf/"/>
    <url>/p/5cfc10dd0067424c9398b79190fe0dcf/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在碎片化学习的时代，没有体系化/总结的知识很快会被彻底遗忘，而博客可以帮助我们记忆平时零碎的知识。有人似乎认为想玩博客就必须要域名/服务器，这里吾辈不得不说明一下，这个认知是错误的。</p><p>对于绝大多数网站来说，静态是无法满足复杂的需求的。然而我们只是想要日常写点博客，分享到网络上的话，却是不需要这些，静态博客也便是足够了。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>本文假设你是一位开发者并至少对下面打勾的内容有基本了解。</p><ul><li>[x] <a href="https://git-scm.com/">git</a>：分布式版本控制工具</li><li>[x] <a href="https://gitlab.com/">gitlab</a>：私有代码托管平台</li><li>[x] <a href=".">Bash/PowerShell/Cmd</a>：命令行操作</li><li>[x] <a href=".">域名</a>：让别人能记住你的博客</li><li>[ ] <a href="https://nodejs.org/">nodejs</a>：JavaScript 运行环境</li><li>[ ] <a href="https://www.netlify.com/">netlify</a>：静态网站托管服务</li><li>[ ] <a href="https://code.visualstudio.com/">VSCode</a>：文本编辑器（类 IDE）</li></ul><h2 id="使用-npm-全局安装-hexo"><a href="#使用-npm-全局安装-hexo" class="headerlink" title="使用 npm 全局安装 hexo"></a>使用 npm 全局安装 hexo</h2><p>如果你还没有安装 nodejs 的话可以去 <a href="https://nodejs.org/en/download/">nodejs 官网下载页面</a> 进行下载并安装，具体步骤可以参考 <a href=".">在 Windows 上安装 nodejs</a>。</p><p>全局安装 hexo 命令行工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i hexo -g<br></code></pre></td></tr></table></figure><p>安装过程</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209170408.png" alt="hexo cli 安装过程"></p><p>验证一下</p><p>输入 <code>hexo</code>，应该会得到类似下面的响应</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209170553.png" alt="hexo 安装验证"></p><h2 id="初始化-hexo-博客"><a href="#初始化-hexo-博客" class="headerlink" title="初始化 hexo 博客"></a>初始化 hexo 博客</h2><p>创建一个空的文件夹作为 hexo 博客目录，在命令行中进入这个文件夹然后执行初始化命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209174358.png" alt="hexo init 输出"></p><p>安装完成后文件夹如下</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209175833.png" alt="安装后的文件夹"></p><h2 id="本地运行博客"><a href="#本地运行博客" class="headerlink" title="本地运行博客"></a>本地运行博客</h2><p>使用命令运行一个本地的 hexo 博客服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo s<br></code></pre></td></tr></table></figure><p>在浏览器打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 页面，可以看到 hexo 博客的初始页面<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209175541.png" alt="hexo 博客的初始页面"></p><p>嗯，有点丑，我们可以更换一下主题，本文主要讲解使用 <a href="https://theme-next.iissnan.com/">hexo next</a> 主题。</p><h2 id="安装-next-主题"><a href="#安装-next-主题" class="headerlink" title="安装 next 主题"></a>安装 next 主题</h2><ol><li><p>克隆并安装主题最新版本</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure></li><li><p>启用主题<br> 打开根目录下的 <em>_config.yml</em> 文件，找到 <code>theme</code> 字段，将之修改为 <code>next</code> 即可<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209181850.png" alt="启用 next 主题"></p></li><li><p>重新打开本地服务器测试一下<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209182031.png" alt="next 主题首页"></p></li></ol><h2 id="将代码托管到-gitlab"><a href="#将代码托管到-gitlab" class="headerlink" title="将代码托管到 gitlab"></a>将代码托管到 gitlab</h2><blockquote><p>肯定有人会问，为什么不用 github？<br>原因很简单：如果你需要使用第三方服务的话肯定需要第三方服务的认证。例如 github 的 token，如果别人想要滥用这个 token 对你的博客做点什么，你却无法阻止，因为 github 托管代码是公开的。</p></blockquote><p>删除掉默认的 <em>landscape</em> 主题和 <em>next</em> 主题的 git 仓库，位置分别是</p><ul><li><em>themes/landscape/</em></li><li><em>themes/next/.git</em></li></ul><p>在本地也初始化一下 git 仓库，然后初始提交全部</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git init<br>git add -A<br>git commit -a -m <span class="hljs-string">&quot;Initial Commit&quot;</span><br></code></pre></td></tr></table></figure><p>所以，在 <a href="https://gitlab.com/">gitlab</a> 创建一个私有仓库（最好与本地博客文件夹同名）。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209182900.png" alt="gitlab 创建私有仓库"></p><p>创建完成后会得到一个 git 远程仓库的地址<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209183821.png" alt="git 远程仓库地址"></p><p>将之设置为本地仓库的远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add origin [这里替换成你的远程仓库地址]<br></code></pre></td></tr></table></figure><p>最后，提交一下吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push origin master<br></code></pre></td></tr></table></figure><p>提交完成后回到刚才创建的远程仓库的页面，会看到远程仓库中已经有文件了<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209184200.png" alt="提交完之后"></p><h2 id="托管网站"><a href="#托管网站" class="headerlink" title="托管网站"></a>托管网站</h2><blockquote><p>这里声明一下：之所以不使用 github 作为静态网站托管服务是因为 github 只能托管一个静态网站，老实说这是一件很麻烦的事情。毕竟，一个人并不止一个网站。</p></blockquote><p>具体差别如下：</p><table><thead><tr><th>对比</th><th>GitHub</th><th>Netlify</th></tr></thead><tbody><tr><td>价格</td><td>免费</td><td>免费</td></tr><tr><td>构建限制</td><td>每小时 10 次</td><td>每分钟 3 次</td></tr><tr><td>使用 HTTPS 的自定义域</td><td>是</td><td>是</td></tr><tr><td>单击 回滚</td><td>没有</td><td>是</td></tr><tr><td>资产优化</td><td>没有</td><td>是</td></tr><tr><td>表格处理</td><td>没有</td><td>是</td></tr><tr><td>部署预览</td><td>没有</td><td>是</td></tr><tr><td>持续部署</td><td>没有</td><td>是</td></tr><tr><td>自定义重写和重定向</td><td>没有</td><td>是</td></tr><tr><td>兼容所有静态站点生成器</td><td>没有</td><td>是</td></tr><tr><td>预呈现</td><td>没有</td><td>是</td></tr><tr><td>拆分测试</td><td>没有</td><td>是</td></tr><tr><td>Lambda 函数集成</td><td>没有</td><td>是</td></tr></tbody></table><h2 id="部署-netlify"><a href="#部署-netlify" class="headerlink" title="部署 netlify"></a>部署 netlify</h2><ol><li><p> 首先你需要一个 <a href="https://netlify.com/">netlify</a> 的账号，只需要邮箱即可注册。</p></li><li><p>登录之后进入你的 <a href="https://app.netlify.com/">个人首页</a><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211213.png" alt="个人首页"></p></li><li><p>由于我们的远程仓库使用的是 GitLab，所以我们连接自己的 GitLab 账户<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211441.png" alt="连接到 GitLab"></p></li><li><p>接下来找到我们的远程仓库<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211616.png" alt="远程仓库"></p></li><li><p>设定构建命令以及构建目录，没有意外的话 netlify 已经自动识别出这是 hexo 博客了<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211803.png" alt="设定构建命令"></p></li><li><p>部署站点<br> 点击部署之后就会帮你自动部署，部署完成后就可以在线访问你的博客啦<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209212501.png" alt="在线自动部署"></p></li><li><p>自定义域名</p><blockquote><p>如果你还没有自己的域名（本文假定你有），可以直接跳转到步骤 9</p></blockquote><ol><li><p> 点击 <strong>Domain settings</strong> 进入域名设置</p></li><li><p> 点击 <strong>Add custom domain</strong> 添加自定义的域名</p></li><li><p> 点击 <strong>Verify =&gt; Yes, add domain</strong> 验证并确认添加</p></li><li><p> 点击 <strong>Check DNS configuration</strong> 检查 DNS 配置</p></li><li><p>查看其中的 CNAME DNS 记录，一会还要用</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190110234441.gif" alt="Gif 图解"></p></li></ol></li><li><p>在你的域名 DNS 记录中添加上面的 CNAME 记录</p><ol><li><p> 打开你的 DNS 管理器，这里以 <a href="https://www.cloudflare.com/">cloudflare</a> 为例</p></li><li><p> 添加一条 CNAME 记录，Name 是我们自定义的二级域名前缀 <a href="https://blog-demo.rxliuli.com/">blog-demo</a>，Domain name 是 netlify 为我们自动生成的二级域名 <a href="https://confident-joliot-3c1548.netlify.com/">confident-joliot-3c1548.netlify.com</a>。</p></li><li><p>等待 DNS 刷新完成</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190110235636.gif" alt="Gif 图解"></p><blockquote><p>这里吾辈再推荐一次 <a href="https://www.cloudflare.com/">cloudflare</a>，DNS 刷新时间不会超过 5 分钟，真的是有够快的了！</p></blockquote></li></ol></li><li><p>访问博客<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209212636.png" alt="访问博客"></p></li></ol><h2 id="修改博客设置"><a href="#修改博客设置" class="headerlink" title="修改博客设置"></a>修改博客设置</h2><p>现在博客基本上部署到线上了，然而有很多地方需要配置，如果需要了解更多的功能可以访问 <a href="https://hexo.io/">hexo</a> 或 <a href="https://theme-next.iissnan.com/">hexo next 主题</a>，下面只说一些最重要的配置。</p><p>在 <em>_config.yml</em> 配置文件中</p><ul><li>title：博客标题</li><li>subtitle：博客子标题</li><li>language：博客显示语言</li><li>author：作者</li></ul><p>配置效果对照图</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209214854.png" alt="VSCode"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215051.png" alt="浏览器"></p><h2 id="写一个新的文章"><a href="#写一个新的文章" class="headerlink" title="写一个新的文章"></a>写一个新的文章</h2><p>使用 hexo 命令即可创建新的文章（本质上是一个含有 yml 关于文章简介的 markdown 文件）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new <span class="hljs-string">&quot;[文章名]&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215646.png" alt="创建新的文章"></p><p>随便写点什么<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215853.png" alt="编辑 markdown 文件"></p><p>最后使用 git 将之提交到 GitLab 远程仓库，netlify 会监听并帮我们自动部署好一切的，再访问网站可以看到新的篇章了（如果内容很多可能要等一段时间）<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209220703.png" alt="新的篇章"></p><p>这个示例 blog 被吾辈部署到 <a href="https://hexo-next-blog-demo.rxliuli.com/">https://hexo-next-blog-demo.rxliuli.com/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，吾辈推荐看看下面的内容</p><ul><li><a href="https://hexo.io/">hexo 官网</a></li><li><a href="https://theme-next.iissnan.com/">next 主题官网</a></li><li><a href="https://blog.rxliuli.com/p/5042aac0/">markdown 语法说明</a></li><li><a href="https://blog.rxliuli.com/p/43851eb5/">VSCode 搭建 markdown 写作环境</a></li><li><a href="https://blog.rxliuli.com/p/6138bec/">Markdown 图片粘贴工具 PicGo</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图床「神器」PicGo v2.0 更新，插件系统终于来了</title>
    <link href="/p/5eecec943fa54ed4b595eebf77c268c9/"/>
    <url>/p/5eecec943fa54ed4b595eebf77c268c9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://molunerfinn.com/picgo-v2.0-update">https://molunerfinn.com/picgo-v2.0-update</a>，作为一个经常使用 Markdown 写作的人而言，一个好的图床工具是很重要的，所以吾辈才会转载这篇文章呢！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上次更新 (v1.6.2) 已经过去了 5 个月，很抱歉 2.0 版本来得这么晚。本来想着在 18 年 12 月（PicGo 一周年的时候）发布 2.0 版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了 T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥你们的无限想象，PicGo 也能成为一个极致的效率工具。</p><p>除了发布 PicGo 2.0 <a href="https://github.com/Molunerfinn/PicGo/releases/">本体</a>，一同发布的还有 <a href="https://picgo.github.io/PicGo-Core-Doc/">PicGo-Core</a>（PicGo 2.0 的底层，支持 CLI 和 API 调用），以及 VSCode 的 PicGo 插件 <a href="https://github.com/Spades-S/vs-picgo">vs-picgo</a> 等。</p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p>PicGo 的底层核心其实是 <code>PicGo-Core</code>。这个核心主要就是一个流程系统。(它支持在 Node.js 环境下全局安装，可以通过命令行上传图片文件、也可以接入 Node.js 项目中调用 api 实现上传。)</p><p><code>PicGo-Core</code> 的上传流程如下：<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212302.png" alt="PicGo-Core 上传流程"></p><p><code>Input</code> 一般是文件路径，经过 <code>Transformer</code> 读取信息，传入 <code>Uploader</code> 进行上传，最后通过 <code>Output</code> 输出结果。而插件可以接入三个生命周期（<code>beforeTransform</code>、<code>beforeUpload</code>、<code>afterUpload</code>）以及两种部件（<code>Transformer</code> 和 <code>Uploader</code>）。</p><p>换句话说，如果你书写了合适的 <code>Uploader</code>，那么可以上传到不同的图床。如果你书写了合适的 <code>Transformer</code>，你可以通过 URL 先行下载文件再通过 <code>Uploader</code> 上传等等。</p><p>另外，如果你不想下载 PicGo 的 electron 版本，也可以通过 npm 安装 picgo 来实现命令行一键上传图片的快速体验。</p><p>PicGo 除了 <code>PicGo-Core</code> 提供的核心功能之外，额外给 GUI 插件给予一些自主控制权。</p><p>比如插件可以拥有自己的菜单项：<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212453.png" alt="菜单"></p><p>因此 GUI 插件除了能够接管 <code>PicGo-Core</code> 给予的上传流程，还可以通过 PicGo 提供的 guiApi 等接口，在插件页面实现一些以前单纯通过 <code>上传区</code> 实现不了的功能：</p><p>比如可以通过打开一个 <code>InputBox</code> 获取用户的输入：<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212549.png" alt="InputBox"></p><p>可以通过打开一个路径来执行其他功能（而非只是上传文件）：<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212808.gif" alt="打开一个路径来执行其他功能"></p><p>甚至还可以直接在插件面板通过调用 api 实现上传。</p><p>另外插件可以监听相册里图片删除的事件：<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212628.png" alt="远端删除"></p><p>这个功能就可以写一个插件来实现相册图片和远端存储里的同步删除了。</p><p>通过如上介绍，我现在甚至就已经能想到插件系统能做出哪些有意思的插件了。</p><p>比如：</p><ol><li> 结合 GitHub 刚刚开放的免费私人仓库，可以通过插件实现 PicGo 的相册以及配置文件同步。</li><li> 结合 TinyPng 等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）</li><li> 结合一些 Canvas 工具，可以在上传图片前给图片加水印。</li><li> 通过指定文件夹，将文件夹内部的 markdown 里的图片地址进行图床迁移。</li><li> 等等。。</li></ol><p>希望这个插件系统能够给 PicGo 带来更强大的威力，也希望它能够成为你的极致的效率工具。</p><p><strong>需要注意的是，想要使用 PicGo 2.0 的插件系统，需要先行安装 <a href="https://nodejs.org/en/">Node.js</a> 环境，因为 PicGo 的插件安装依赖 <code>npm</code>。</strong></p><h2 id="2-0-其他更新内容"><a href="#2-0-其他更新内容" class="headerlink" title="2.0 其他更新内容"></a>2.0 其他更新内容</h2><p>除了上面说的插件系统，PicGo 2.0 还更新了如下内容：</p><ul><li>底层重构了之后，某些图床上传不通过 <code>base64</code> 值的将会提升不少速度。比如 <code>SM.MS</code> 图床等。而原本就通过 <code>base64</code> 上传的图床速度不变。</li><li>增加一些配置项，比如打开配置文件（包括了上传的图片列表）、mini 窗口置顶、代理设置等。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212954.png" alt="更多配置项"></li><li>在相册页可以选择复制的链接格式，不用再跑去上传页改了。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213134.png" alt="相册允许复制链接格式"></li><li>增加不同页面切换的淡入淡出动画。</li><li>macOS 版本配色小幅更新。（Windows 版本配色更新 Fluent Design 效果预计在 2.1 版本上线）</li><li>更新 electron 版本从 1.8-&gt;4.0，启动速度更快了，性能也更好了。</li></ul><h2 id="Bug-Fixed"><a href="#Bug-Fixed" class="headerlink" title="Bug Fixed"></a>Bug Fixed</h2><ul><li>修复：macOS 多屏下打开详细窗口时位置错误的<a href="https://github.com/Molunerfinn/PicGo/issues/128">问题</a>。</li><li>修复：多图片上传重命名一致的<a href="https://github.com/Molunerfinn/PicGo/issues/136">问题</a>。</li><li>修复：拖拽图片到软件会自动在软件内部打开这张图片的 <a href="https://github.com/Molunerfinn/PicGo/issues/140">bug</a>。</li><li>修复：重命名窗口只出现在屏幕中央而不是跟随主窗口的 <a href="https://github.com/Molunerfinn/PicGo/issues/145">bug</a>。</li></ul><h2 id="VSCode-的-PicGo-插件-vs-picgo"><a href="#VSCode-的-PicGo-插件-vs-picgo" class="headerlink" title="VSCode 的 PicGo 插件 vs-picgo"></a>VSCode 的 PicGo 插件 vs-picgo</h2><p>在 PicGo-Core 发布不久，就有人根据 PicGo-Core 的 API 编写了 VSCode 版的 PicGo 插件。使用起来也非常方便：</p><ul><li>截图上传<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213411.gif" alt="截图上传"></li><li>文件浏览器选择文件上传<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213514.gif" alt="文件浏览器选择文件上传"></li><li>输入文件路径上传<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213547.gif" alt="输入文件路径上传"></li></ul><p>配置项与 PicGo 的图床的配置项基本保持一致。在 VSCode 插件栏搜索 PicGo 即可下载安装与体验！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PicGo 第一个稳定版本是在少数派上发布的，详见 <a href="https://sspai.com/post/42310">PicGo：基于 Electron 的图片上传工具</a>。支持 macOS、Windows、Linux 三平台，开源免费，界面美观，也得到了很多朋友的认可。如果你对它有什么意见或者建议，也欢迎在 <a href="https://github.com/Molunerfinn/PicGo/issues">issues</a> 里指出。如果你喜欢它，不妨给它点个 star。如果对你真的很有帮助，不妨请我喝杯咖啡（PicGo 的 GitHub <a href="https://github.com/Molunerfinn/PicGo">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a><br>Windows 用户请下载<code>.exe</code>文件，macOS 用户请下载<code>.dmg</code>文件，Linux 用户请下载<code>.AppImage</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于 nodejs 的热更新 http 开发服务器</title>
    <link href="/p/5ff6459647c740c7aafb50bccd4a5153/"/>
    <url>/p/5ff6459647c740c7aafb50bccd4a5153/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>之前一直在使用 <a href="https://www.npmjs.com/package/http-server">http-server</a> 作为本地快速启动静态 http 服务器的命令行工具，然而直到今天，吾辈实在难以忍受其在修改完 <code>HTML</code> 文件后，http-server 不会自动刷新浏览器重新渲染页面，而是需要手动刷新才行，真的是不厌其烦，所以吾辈开始找更好的工具。</p><blockquote><p>注：http-server 其实也已经热更新到内存中了，只不过不会触发浏览器刷新页面。</p></blockquote><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li>[x] 零配置使用</li><li>[x] 修改文件保存后将自动触发浏览器刷新页面</li><li>[x] 基于 nodejs 开发</li><li>[ ] 允许特定的配置</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>前端页面热更新</p><ul><li><a href="https://www.npmjs.com/search?q=live-server">live-server</a>: 自带热更新并启动即打开浏览器的 http 开发服务器</li><li><a href="https://www.npmjs.com/package/anywhere">anywhere</a>: 与上面的 live-server 类似（由国人开发，已经一年没有更新了）</li></ul><p>nodejs 热更新</p><ul><li><a href="https://www.npmjs.com/package/nodemon">nodemon</a>: 文件修改后自动重启 nodejs 程序</li><li><a href="https://www.npmjs.com/package/supervisor">supervisor</a>: nodejs 程序运行管理器，包含热更新功能（两年没有更新了）</li></ul><p>VSCode 插件</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">LiveServer</a>: VSCode 中的插件，可以将任何一个 HTML 当作 web 程序打开，并自带热更新</li></ul><h2 id="live-server"><a href="#live-server" class="headerlink" title="live-server"></a>live-server</h2><p><code>live-server</code> 是一个 npm 包，全局安装之后可以很方便的使用，所以吾辈选择了这个。主要特点如下：</p><ul><li>[x] 零配置</li><li>[x] 热插拔</li><li>[x] 自动打开浏览器</li></ul><p>下面来说一下如何使用</p><ol><li><p>使用 npm 全局安装</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -g live-server<br></code></pre></td></tr></table></figure></li><li><p>跳转到指定目录，然后使用 <code>live-server</code> 即可启动 http 服务器</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">live-server<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains 1024 程序员节优惠活动</title>
    <link href="/p/77f1a2a13e994ea3bb5de5c557bbd5e4/"/>
    <url>/p/77f1a2a13e994ea3bb5de5c557bbd5e4/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一年一次的 JetBrains 优惠活动，这次是买一赠一！</p><blockquote><p>注: 活动截止 10/31</p></blockquote><p><img src="https://i.loli.net/2019/10/24/b5AgNHKUhFmZ3xz.png" alt="image.png"><br><img src="https://i.loli.net/2019/10/24/DVdJPEtZjwpQbiG.png" alt="image.png"></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>该次活动老用户无法直接输入优惠码购买，必须提交请求后等待销售代表回复专属购买链接。（老用户没人权系列 QAQ）</p><p><img src="https://i.loli.net/2019/10/24/gAKEG28p5erO4iM.png" alt="image.png"></p><p>然后，果然手动化操作忙不过来了 23333<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026114627.png" alt="官方邮件"></p><p>重要的是，这个优惠码貌似可以针对任意产品，包括全家桶那个 $249 的那个也能免费 0 折一年！官方也太实诚了吧 emmmmm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026115028.png" alt="优惠码使用"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote><p><a href="https://www.jetbrains.com/zh-cn/lp/programmers-day/?tdsourcetag=s_pcqq_aiomsg">1024 程序员节 IDE++ 快乐翻倍！</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 上强制粘贴</title>
    <link href="/p/7c3c361a330c43b48da9940c0bce70a2/"/>
    <url>/p/7c3c361a330c43b48da9940c0bce70a2/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>前面吾辈曾经写过一篇 <a href="https://blog.rxliuli.com/p/58a7c146/">Chrome 强制复制粘贴</a> 的文章，然而那篇内容仅仅只是针对于 Chrome/Firefox 浏览器。对于 Windows 的客户端软件，例如 QQ、阿里旺旺之类，它们还是不允许粘贴密码。这点对于所有密码都是用密码管理器管理，随机生成的用户而言（吾辈），实在是太过讨厌了一点！</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>QQ 这种客户端是如何屏蔽粘贴功能的呢？很显然，QQ 不仅仅是禁用右键/快捷键那么简单，或许是添加键盘驱动了也说不定。但不管怎样，我们都可以从根本的地方下手 – <strong>模拟键盘输入，将剪切版的文字一个一个的输入进去！</strong></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>虽然不像 Linux 那样任何操作都可以使用脚本去控制（实际上也可以，只不过 Windows 的 <code>cmd</code> 脚本实在不怎么样），然而基于 Windows 丰富的生态，还是有人做出了第三方的脚本语言 – <strong>Autohotkey</strong>。</p><p>我们首先去 <a href="https://www.autohotkey.com/">官网</a> 看一下，介绍只有简单的两句话。</p><blockquote><p>Powerful. Easy to learn.<br>The ultimate automation scripting language for Windows.</p></blockquote><p>翻译过来就是：</p><blockquote><p>强大，简单易学<br>Windows 上的自动化脚本语言</p></blockquote><p>我们可以写一个 Autohotkey 自动化的脚本，在检测到 QQ 运行并且按下 <strong>CS-V</strong> 时将剪切版的字符逐个输入进去。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ahk"><span class="hljs-meta">#IfWinActive ahk_exe QQ.exe</span><br>&#123;<br>    <span class="hljs-comment">;热键为 Ctrl+Shift+V</span><br><span class="hljs-title">    ^+v::</span><br>    <span class="hljs-comment">;发送剪切版的内容到输入</span><br>    SendInput &#123;Raw&#125;<span class="hljs-variable">%Clipboard%</span><br>    <span class="hljs-keyword">Return</span><br>&#125;<br><span class="hljs-meta">#IfWinActive</span><br></code></pre></td></tr></table></figure><p>当然，如果不喜欢安装 Autohotkey 的话也没关系，吾辈转换了一个 <a href="https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/QQForcedPaste.exe">.exe 可执行文件</a>，也可以直接下载使用啦</p><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190219214116.gif" alt="使用示例"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 集成 ESLint 和 Prettier</title>
    <link href="/p/839407c9c7e647aca2c0518e4da075a7/"/>
    <url>/p/839407c9c7e647aca2c0518e4da075a7/</url>
    
    <content type="html"><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>ESLint 是一个前端代码质量检测工具，然而配置非常非常非常的麻烦（前端的配置真的是超多呢），所以在吾辈的 VueJS 项目中直接使用了 <code>standard</code> 规则。然而问题在于有了代码规则，还需要自动的格式化，否则为了手动格式化是一件极其痛苦的事情。。。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>VSCode 安装下面三个插件</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur">Vetur</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier - Code formatter</a></li></ul><p>然后在 <code>User Settings</code>，添加以下配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 配置 ESlint 和 Prettier</span><br>&quot;eslint.autoFixOnSave&quot;: true, // 每次保存的时候将代码按 eslint 格式进行修复<br>&quot;prettier.eslintIntegration&quot;: true, // 让 prettier 使用 eslint 的代码格式进行校验<br>&quot;prettier.semi&quot;: false, // 去掉代码结尾的分号<br>&quot;prettier.singleQuote&quot;: true, // 使用单引号替代双引号<br>&quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, // 让函数 (名) 和后面的括号之间加个空格<br>&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, // 格式化. vue 中 html<br>&quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, // 让 vue 中的 js 按编辑器自带的 ts 格式进行格式化<br>&quot;vetur.format.defaultFormatterOptions&quot;: &#123;<br>  &quot;js-beautify-html&quot;: &#123;<br>    &quot;wrap_attributes&quot;: &quot;force-aligned&quot; // 属性强制折行对齐<br>  &#125;<br>&#125;,<br>&quot;eslint.validate&quot;: [<br>  <span class="hljs-comment">// 开启对. vue 文件中错误的检查</span><br>  &quot;javascript&quot;,<br>  &quot;javascriptreact&quot;,<br>  &#123;<br>    <span class="hljs-attr">&quot;language&quot;</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>    <span class="hljs-attr">&quot;autoFix&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;language&quot;</span>: <span class="hljs-string">&quot;vue&quot;</span>,<br>    <span class="hljs-attr">&quot;autoFix&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>好了，现在可以正常使用 VSCode 的格式化功能了，保存时也会进行格式化同时修复 ESLint 发现的错误。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome 强制复制粘贴</title>
    <link href="/p/861b678411f24bf9ba710539bac7140a/"/>
    <url>/p/861b678411f24bf9ba710539bac7140a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>如果你是一位开发者，可以看一下另一篇博客 <a href="https://blog.rxliuli.com/p/4b2822b2/">使用 Greasemonkey 解除网页复制粘贴限制</a>。或许，你能找到更好的方式</p></blockquote><p>登录支付宝时突然发现密码框不能 C-V 粘贴，也无法使用右键了。提示说是为了安全，实际上不就是为了让人使用 App 扫码么。。。想尽办法为难 PC 用户，这次 Chrome 的强制复制插件也没能起到作用。然而不管其是如何实现禁用粘贴/禁用右键的，但其一定需要用到 JavaScript，有了这个思路，只要暂时禁用 JavaScript 就好了。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>使用 F12 打开 Chrome 开发者工具，勾选 <strong>Setting -&gt; Preferences -&gt; Debugger -&gt; Disable JavaScript</strong>，临时禁用掉 JavaScript，然后在粘贴密码之后记得要取消勾选哦，因为支付宝的登录还要用到 JavaScript 呢</p><ol><li>打开 Chrome 开发者工具<br> <a href="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221230.png"><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221230.png" alt="打开 Chrome 开发者工具"></a></li><li>临时禁用 JavaScript<br> <a href="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221505.png"><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221505.png" alt="临时禁用 JavaScript"></a></li></ol><blockquote><p>快速切换的方法暂且还没有找到 Chrome 插件呢，有什么好推荐的也可以告诉吾辈哦</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 在 markdown 文档中存在表格时不能格式化文档</title>
    <link href="/p/8adbedea5b52412b9ed010ad71d6cfbf/"/>
    <url>/p/8adbedea5b52412b9ed010ad71d6cfbf/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用 markdown 写文档时突然发现格式化功能失效了。这是个很麻烦的问题，吾辈经常要用 VSCode 写 markdown 文档，如果不能进行格式化真是个大麻烦了。</p><h2 id="确认是否为插件问题"><a href="#确认是否为插件问题" class="headerlink" title="确认是否为插件问题"></a>确认是否为插件问题</h2><p>吾辈有关 Markdown 的插件列表</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a></li></ul><p>不能进行格式化吾辈的第一想法就是 <strong>Markdown All in One</strong> 插件是不是出问题了，毕竟吾辈写 Markdown 文档这么久了，也是第一次遇到这种问题呢<br>吾辈尝试禁用了 <strong>Markdown All in One</strong> 插件后，发现文档确实能够正常格式化了。<br>然而这并没能解决问题，因为在 VSCode 书写 markdown 文档的话，<strong>Markdown All in One</strong> 插件的功能是必不可少的（更好的语法高亮，自动完成，生成标题等）。</p><p>实际上进行格式化的操作是由 <strong>Prettier</strong> 完成的，所以吾辈觉得应该是 <strong>Markdown All in One</strong> <strong>阻碍</strong> 了 <strong>Prettier</strong> 插件的格式化功能。</p><p>然而吾辈也明白了一件事：<strong>Markdown All in One</strong> 和 <strong>Prettier</strong> 插件居然不兼容！</p><h2 id="确认是否是普遍性问题"><a href="#确认是否是普遍性问题" class="headerlink" title="确认是否是普遍性问题"></a>确认是否是普遍性问题</h2><p>之后，吾辈想要确认这是否是一个普遍性的问题。测试了几个 markdown 文档后惊奇的发现有些能够正常格式化，有些就不行。<br>这就很奇怪了，吾辈在逐次删减部分 markdown 内容后终于发现了影响格式化的代码 – 表格。<br>这可真是太意外了，毕竟表格这种东西，感觉上不应该会影响到插件本身呀</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>吾辈正要打算去 <strong>Markdown All in One</strong> 插件 <a href="https://github.com/neilsustc/vscode-markdown/issues">GitHub Issues</a> 提出这个问题时，发现上面已经有人遇到了这个问题了。<a href="https://github.com/neilsustc/vscode-markdown/issues/317">https://github.com/neilsustc/vscode-markdown/issues/317</a></p><p>开发者回复说明了这样的内容</p><blockquote><p>Thanks for the detailed description. The problem is vscode implicitly only allows one “formatter” per language. Then this extension(‘s formatter) and that of Prettier cannot co-exist.<br>Related <a href="https://github.com/Microsoft/vscode/issues/41882">Microsoft/vscode#41882</a>.<br>Is there an option of Prettier to format GFM table? If it can do this, you can disable this extension’s formatter with <code>markdown.extension.tableFormatter.enabled</code></p></blockquote><p>大意是在 VSCode 中每种语言的格式化程序默认只能有一种，所以 <strong>Markdown All in One</strong> 的表格格式化 和 <strong>Prettier</strong> 的格式化就产生了冲突。然后他给出了解决方案，禁用掉表格格式化。<br>配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">// 禁用表格格式化功能</span><br>  <span class="hljs-string">&quot;markdown.extension.tableFormatter.enabled&quot;</span>: <span class="hljs-literal">false</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，添加这个配置之后需要重启 VSCode，不然可能不会生效哦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自建 Jrebel 反向代理</title>
    <link href="/p/95dd75f5600943b59bc0f7cb1b0189b3/"/>
    <url>/p/95dd75f5600943b59bc0f7cb1b0189b3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目位置：<a href="https://gitee.com/gsls200808/JrebelLicenseServerforJava">https://gitee.com/gsls200808/JrebelLicenseServerforJava</a></p></blockquote><p>不喜欢 Gitee 直接 <code>git clone https://gitee.com/gsls200808/JrebelLicenseServerforJava.git</code> 然后自己用 <code>maven</code> 编译一下就好！<br>或者吾辈也编译了一个 <a href="https://github.com/rxliuli/rxliuli.github.io/blob/53bf7d98827eea647822d4c8cf1a04c6c006a8f0/_posts/IDEA/JrebelBrainsLicenseServerforJava/JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar">链接</a></p><h2 id="普通启动（其中-p-指的是端口，服务器必须配置该端口可以访问）"><a href="#普通启动（其中-p-指的是端口，服务器必须配置该端口可以访问）" class="headerlink" title="普通启动（其中 -p 指的是端口，服务器必须配置该端口可以访问）"></a>普通启动（其中 -p 指的是端口，服务器必须配置该端口可以访问）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181<br></code></pre></td></tr></table></figure><h2 id="后台启动-jar（既便退出程序也不会结束）"><a href="#后台启动-jar（既便退出程序也不会结束）" class="headerlink" title="后台启动 jar（既便退出程序也不会结束）"></a>后台启动 jar（既便退出程序也不会结束）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nohup java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181 &gt; log.log &amp;<br></code></pre></td></tr></table></figure><blockquote><p><code>&gt; log.log &amp;</code> 指的是将程序的控制台输出写入到某个文件中</p></blockquote><h2 id="查看程序"><a href="#查看程序" class="headerlink" title="查看程序"></a>查看程序</h2><ol><li><p>使用 job 命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">jobs</span><br></code></pre></td></tr></table></figure><p> 输出可能是下面这样子：<br> <code>[1]+ Running nohup java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181 &gt; log.log &amp;</code></p><p> 想要结束的话使用 <code>fg 任务 id</code> 将任务调回前台，然后 <code>Ctrl+C</code> 即可。<br> 这里使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">fg</span> 1<br>Ctrl+C<br></code></pre></td></tr></table></figure></li><li><p>使用 Linux 下的 <code>ps</code> 命令</p><p> 使用以下命令列出所有含有 <strong>Jrebel</strong> 的进程</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef|grep Jrebel<br></code></pre></td></tr></table></figure><p> 吾辈启动了好几次，所以有 3 条</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">rxliuli   1877  1828  0 23:26 pts/0    00:00:00 java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar<br>rxliuli   1942  1921  0 23:33 pts/1    00:00:00 java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181<br>rxliuli   1967  1921  0 23:37 pts/1    00:00:00 grep --color=auto Jrebel<br></code></pre></td></tr></table></figure><p> 使用 <code>kill -9 进程 id</code> 杀死进程<br> 例如这里可以使用</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 1828<br></code></pre></td></tr></table></figure><p> 然后再次使用 ps 查看进程就发现已经被杀死了</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>激活服务器：<code>http://&#123;服务器 id&#125;:&#123;服务器端口, 这里是 8181&#125;/947122a0-7e9a-4bea-814d-876525d3767f</code><br>邮箱随意就好（至少格式要正确。。。）</p><p>有可能 Jrebel 还会让你输入认证信息，吾辈输入了服务器的 username/password 貌似就没问题了呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Xmind 激活</title>
    <link href="/p/ac35129ae2d6448b9a747b7a6df8b855/"/>
    <url>/p/ac35129ae2d6448b9a747b7a6df8b855/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://github.com/mounui/Xmind">原链</a>，对文法部分进行了复核。本文仅供参考，如有能力请支持正版！</p></blockquote><p>Xmind 不激活也是可以使用的，那么，你可能会问为什么还要激活？这是因为未激活的 Xmind 少了很多实用的功能。好了，废话不多说了，下面讲如何激活 Xmind。</p><h2 id="使用激活补丁"><a href="#使用激活补丁" class="headerlink" title="使用激活补丁"></a>使用激活补丁</h2><ol><li><p> 下载 Xmind 激活补丁 <a href="https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/XMindCrack.jar">XMindCrack.jar</a></p></li><li><p>打开 Xmind 取消检查更新选项 (下面两步可以一起设置)</p><blockquote><p>-&gt; 编辑 -&gt; 首选项 -&gt; 常规 -&gt; 启动 -&gt; 启动时检查更新和消息：取消勾选 (最后确定)</p></blockquote><p> 取消发送用户数据选项</p><blockquote><p>-&gt; 编辑 -&gt; 首选项 -&gt; 常规 -&gt; 启动 -&gt;发送用户数据: 取消勾选 (最后确定)<br>最后关闭 Xmind</p></blockquote></li><li><p> 将 XMindCrack.jar 复制到 Xmind 的安装目录下，默认安装路径为 C:\Program Files (x86)\XMind（如果你是自定义安装的请找到自己的安装目录）</p></li><li><p>在 Xmind 的安装目录下找到 XMind.ini 这个文件（部分人隐藏后缀名了，所以显示的是 xmind 这个名字，只要是在 xmind 图标后面的那个就是的）用记事本打开这个文件并在最后添加一行：</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">-javaagent:./XMindCrack.jar<br><span class="hljs-comment">; 注意此处-javaagent后面的地址应为补丁文件 XMindCrack.jar 的地址，因为我们把该文件放到了Xmind 的安装目录下，Xmind.ini 和 XMindCrack.jar 在同一目录下，因此这里我们可以使用相对路径，如果这两个文件不在同一个目录下，注意填写正确的路径</span><br></code></pre></td></tr></table></figure></li><li><p> 断开网络，或者使用防火墙阻止 XMind 联网，或者在 hosts 文件中添加一行<code>127.0.0.1 www.xmind.net</code>（建议采用断网或者增加 hosts 记录法）。其中 hosts 文件一般在：<em>C:\Windows\System32\drivers\etc</em> 目录下</p></li><li><p>再次启动 Xmind，进行软件激活 -&gt; 帮助 -&gt; 序列号 -&gt; 输入任意邮箱地址及以下序列号：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345<br></code></pre></td></tr></table></figure></li><li><p> 所有步骤完成之后，即可重新联网。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Notion 使用体验</title>
    <link href="/p/b1d53b2d48c24af7904985f6c3764cdb/"/>
    <url>/p/b1d53b2d48c24af7904985f6c3764cdb/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="http://notion.so/">官网</a></p></blockquote><p>Notion 是一个基于 Web 的跨平台笔记工具，在了解过印象笔记、OneNote、为知笔记和有道云笔记之后，吾辈选择了 Notion。</p><p>之所以没有选择上面列出的几个，都有一些原因</p><ul><li>印象笔记<ul><li>不直接支持 Markdown</li><li>编辑器体验并不好</li><li>不能以目录分割笔记</li></ul></li><li>OneNote<ul><li>完全不支持 Markdown</li></ul></li><li>为知笔记<ul><li>国产软件，肯定会上报数据</li></ul></li><li>为知笔记<ul><li>同上</li></ul></li></ul><p>吾辈的对笔记工具的要求也很简单</p><ul><li>[ ] 允许在线/本地编辑</li><li>[ ] 本地编辑器体验必须要好</li><li>[ ] 支持 Markdown 语法</li><li>[ ] 搜索速度要快并且支持中文</li></ul><p>很遗憾，虽然吾辈选择了 Notion，并不代表它满足了所有需求，只是目前存在的选择中，最适合吾辈的罢了（搜索速度和中文支持真的很硬伤）。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li><code>C-B</code>：将选定文字加粗，或者结束加粗模式</li><li><code>C-I</code>：将选定文字变成斜体，或者结束斜体模式</li><li><code>C-E</code>：将选定区域为行内代码，或者结束行内代码模式</li><li><code>S-鼠标滚轮</code>：水平滚动</li><li><code>CS-L</code>：切换夜间模式</li><li><code>C-V + Link</code>：选中文字粘贴链接，会直接将文字变成可点击链接</li><li><code>CS-Up/Down</code>：将当前行上移/下移</li><li><code>S-Enter</code>：不完成当前区块的情况下换行。类似于 QQ 的回车发送消息，<code>Shift-Enter</code> 换行一样。</li><li><code>Tab</code>：缩进一个 Tab</li><li><code>S-Tab</code>：反向缩进一个 Tab</li><li><code>/</code>：可以搜索并使用命令</li></ul><h2 id="快捷-Block-片段"><a href="#快捷-Block-片段" class="headerlink" title="快捷 Block 片段"></a>快捷 Block 片段</h2><p>输入后按空格即可生成的特定 Block 的字符</p><ul><li><code>-</code>：无序列表</li><li><code>Number</code>：有序列表</li><li><code>[]</code>：待办事项列表</li><li><code>&gt;</code>：可折叠层级列表（和 markdown 语义不同了）</li><li><code>&quot;</code>：引用（这才是 markdown 中 <code>&gt;</code> 在 notion 中的关键字）</li><li><code>``</code>：行内代码块<ul><li>必须在输入第一个 <code>之后，输入代码，再输入第二个</code> 才有效</li><li>生成行内代码片段后，必须紧跟一个空格，如果输入之后又删除掉，再次输入就会被当成行内代码，这时候使用 <code>C-E</code> 可将下一个字符指定为行内代码之外的文本。</li></ul></li><li><code>```</code>：区域代码块<ul><li>无法直接指定语言，必须在选择框内选择语言（鼠标）</li></ul></li></ul><h2 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h2><p>通过 <code>CS-L</code> 进行切换，也可以在 <code>Settings &amp; Members</code> 中找到 <code>Dark Mode</code> 这个切换。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201224609.png" alt="Notion 夜间模式"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>编辑真的很卡！</p></li><li><p>性能不好</p><ul><li>大文件</li><li>包含图片</li><li>导入 markdown</li></ul></li><li><p>粘贴富文本链接存在问题</p></li><li><p>没有列编辑</p></li><li><p>没有 <strong>标签</strong> 的概念，导致分类只能依赖于目录，不能跨目录进行某种关联。例如 <strong>未完成</strong></p></li><li><p>就单纯的编辑体验上还说不上非常好，至少比起 VSCode 还有一段距离</p></li><li><p>无法深度导出 PDF（需要企业版），导致想要打印资料会很不方便</p></li><li><p>bug</p><ul><li><p>从编辑器之外点击编辑器，第一次并不会获取到焦点，需要点第二次才行（只出现在 Windows 自动分屏）</p></li><li><p>代码块中同时存在中文和英文时粘贴后只剩中文部分，英文代码不见了</p></li><li><p>从 VSCode 的 markdown 预览区复制的区域代码块最后总是会多出空行</p></li><li><p>代码高亮渲染问题，目前 <code>TypeScript/HTML</code> 是存在问题的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 一个用于解构 Promise 中的泛型类</span><br><span class="hljs-keyword">type</span> PromiseDeconstruct&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer R&gt;<br>  ? R<br>  : <span class="hljs-built_in">never</span>;<br><span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> i: PromiseDeconstruct&lt;<span class="hljs-keyword">typeof</span> res&gt; = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2></li></ul></li></ul><p>笔记适合作为整理资料的方式，而作为写作工具的话体验却是还差了点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>优化 Google Chrome 的使用体验</title>
    <link href="/p/b6bc51a0a3794fc7af77ce5018f04704/"/>
    <url>/p/b6bc51a0a3794fc7af77ce5018f04704/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>假若我没有看见光明，我本可以忍受黑暗。</p></blockquote><p>下面是吾辈在使用 Chrome 遇到的一些不舒服的地方，以及对应的解决方法。一切皆是为了一个目标：<strong>提高浏览器的使用体验！</strong></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>在之前吾辈也未曾对字体有过什么注意，直到后来听闻 MacOS 的字体显示比 Windows 上好很多，去看了一下确实如此。想要有一个好看的字体，字体本身极为重要，这里吾辈目前在使用，也很推荐的字体是 <a href="https://github.com/be5invis/Sarasa-Gothic">Sarasa Gothic</a>。支持 <strong>简中/繁中/英/日</strong> 四种语言，虽然体积稍微庞大，但效果却是相当不错。</p><p>Windows 字体预览</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527190659.png" alt="更纱黑体"></p><blockquote><p>这里也推荐作为编程字体，毕竟程序中同时存在中英文，而一个同时支持中英文的等宽字体实在难得。</p></blockquote><h2 id="设置网页默认字体"><a href="#设置网页默认字体" class="headerlink" title="设置网页默认字体"></a>设置网页默认字体</h2><p>安装完了字体，然而 Chrome 默认并不会使用它，我们还需要 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Stylus</a> 进行指定。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527221308.png" alt="添加 UserCSS"></p><p>添加一个新的样式，内容只需要设置所有元素使用的字体为 <strong>Sarasa Mono CL</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 全局字体设置 */</span><br>* &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Sarasa Mono CL&quot;</span>;<br>&#125;<br><span class="hljs-comment">/* 强制指定 input 框中的字体 */</span><br><span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Sarasa Mono CL&quot;</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候查看一下字体效果</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527221458.png" alt="效果"></p><h2 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h2><p>如果你像吾辈一样，喜欢暗色的主题，可以使用插件 <a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">Dark Reader</a>，它能够让网页默认使用暗色模式，看起来和编辑器保持一致：并且，看起来很 <strong>Geek</strong>！</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531203702.png" alt="暗色模式"></p><p>看起来标题栏很违和？安装一个 <a href="https://chrome.google.com/webstore/detail/morpheon-dark/mafbdhjdkjnoafhfelkjpchpaepjknad">Dark 主题</a> 试试看。<br>现在，是不是变得很和谐了呢？</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531225833.png" alt="暗色标题栏"></p><h2 id="广告过滤"><a href="#广告过滤" class="headerlink" title="广告过滤"></a>广告过滤</h2><p>目前而言，浏览网站时，没有一个广告过滤插件的话，广告的数量将是难以置信的庞大，而且讨人厌！<br>吾辈目前在 Chrome 上仅推荐 <a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a>，开源免费，不推荐 <a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb">Adblock Plus</a> 与 <a href="https://chrome.google.com/webstore/detail/ublock/epcnnfbjfcgphgdmggkamkmgojdagdnn">Ublock</a>。前者将广告拦截做成了生意（参见 <a href="https://36kr.com/p/5052897">向来以屏蔽互联网广告为己任的 AdBlock Plus，为什么卖起广告了？</a>），后者则是接手开发者的自私接受捐款导致原作者 Fork 并开发了新版本 Ublock Origin（参见 <a href="https://zh.wikipedia.org/zh-hans/UBlock_Origin">Wiki uBlock Origin 历史</a>）。</p><p>虽然吾辈基本上日常 Google，不过为了比较这里来看一下未进行广告过滤前的百度搜索结果</p><p>搜索<strong>购物</strong>，天啊，第一页全都是<strong>广告</strong>，百度真的丧心病狂。。。</p><blockquote><p>注意每个搜索结果下面的小字 <strong>广告</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210354.png" alt="百度的广告"></p><p>使用插件后的效果</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210454.png" alt="过滤后的百度搜索"></p><p>嗯，清爽了许多呢 ~ o(*￣ ▽ ￣*)o</p><p>这里对比一下 Google 的搜索结果，可以明显看出来百度的广告的数量之多。。。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210759.png" alt="对比的 Google 搜索结果"></p><h2 id="自动翻页"><a href="#自动翻页" class="headerlink" title="自动翻页"></a>自动翻页</h2><p>如果你也觉得搜索结果需要翻页好麻烦，那么 <a href="https://chrome.google.com/webstore/detail/uautopagerize/kdplapeciagkkjoignnkfpbfkebcfbpb">uAutoPagerize</a> 可以一样可以帮到你！</p><blockquote><p>相比于 <a href="https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp">AutoPagerize</a> 万年不更新，uAutoPagerize 仍在积极维护中！</p></blockquote><p>下面是使用了 uAutoPagerize 后的 Google 搜索结果，会在滚动到接近底部时，自动获取下一页的内容并拼接到最后！</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191114123652.png" alt="使用 uAutoPagerize"></p><p>当然，它也支持百度哦</p><h2 id="屏蔽-Google-搜索结果"><a href="#屏蔽-Google-搜索结果" class="headerlink" title="屏蔽 Google 搜索结果"></a>屏蔽 Google 搜索结果</h2><p>当你搜索中文技术相关的内容时，一定会遇到一个令人厌恶的社区 – CSDN 博客。里面的内容基本上都是复制粘贴，甚至作者都并未真实尝试过就发出来了，实在是太烂了！<br>所以，使用 <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a> 油猴插件 + 油猴脚本便可以轻松屏蔽掉它们。</p><blockquote><p>吾辈并不否认 CSDN 有很多有趣的作者，但是啊，相比于这个平台的大多数人，他们实在太少了，简直如同大海捞针一般。<br><a href="https://zh.wikipedia.org/zh/Greasemonkey">油猴脚本</a>: 是一段可以在某个网页自动运行的 JavaScript 脚本，事实上，抛开 Tampermonkey 这个运行容器不说，油猴脚本就是彻头彻尾的 JavaScript 代码，任何了解过 Web 开发的人应该都能写一个简单的油猴脚本。如果你打算尝试玩玩油猴脚本，可以参考吾辈踩过的坑 <a href="https://blog.rxliuli.com/p/75bbc83f/">Greasemonkey 踩坑之路</a></p></blockquote><p>你需要先安装 <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a> 插件，然后在 <a href="https://greasyfork.org/zh-CN/">Greasy Fork</a> 安装脚本 <a href="https://greasyfork.org/zh-CN/scripts/1682">Google Hit Hider by Domain</a>。</p><p>然后在 Google 搜索 <a href="https://www.google.com/search?q=js+%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">js 数组去重</a>，可以看到包含了几个的 CSDN 博客的结果</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531213523.png" alt="CSND 博客搜索结果"></p><p>现在，让我们从 Google 搜索中屏蔽 blog.csdn.net 这个域名</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531214002.png" alt="Block 操作"></p><p>屏蔽后的搜索结果，CSDN Blog 那些垃圾博客不见了，心情大好！</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531214650.png" alt="屏蔽后的结果"></p><h2 id="冻结后台标签页"><a href="#冻结后台标签页" class="headerlink" title="冻结后台标签页"></a>冻结后台标签页</h2><p>你是否也曾因为 Chrome 开了太多标签页而占用了庞大的内存？那么 <a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">The Great Suspender</a> 就是最好的帮手，它能自动冻结后台一段时间没有访问的标签页，以便于释放系统内存。并且，当你再次访问时，标签页将会自动重新加载。如果你也经常开了很多个标签页忘记关闭了，那么它可以帮助你自动管理他们。</p><p>下面演示多个标签页被冻结的效果</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531220652.png" alt="冻结的标签页"></p><h2 id="下载增强"><a href="#下载增强" class="headerlink" title="下载增强"></a>下载增强</h2><p>你使用 Chrome 下载过资料么？是否也对 Chrome 单线程下载并且在下载完成后强制检查资源安全性感到不满？那么 <a href="https://www.freedownloadmanager.org/zh/">FDM</a> 应该是 Windows 上比较好的选择下载工具了，你可以下载并安装到 PC 上，然后安装 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp">Free Download Manager</a> 即可将所有 Chrome 中的下载请求交给 FDM，并且，它携带着 Cookie，所以即使是有权限校验的下载也能够胜任。</p><p>FDM 的优势</p><ul><li>多线程下载</li><li>断点续传</li><li>支持 BT</li><li>自动分类</li><li>下载限速</li><li>国际化</li><li>自由免费</li></ul><p>所以，如果经常下载资料的话推荐入坑 FDM，这里放一张首页</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531221709.png" alt="FDM 首页"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>使用浏览器，一些高频操作的快捷键也是必不可少的。</p><ul><li><code>CS-T</code>: 重新打开上一个关闭的标签页</li><li><code>中键/C-左键</code>: 强制在新标签页打开链接</li><li><code>中键(浏览器标签上)</code>: 关闭这个标签页</li><li><code>A-左键</code>: 选择链接中的文字（不会触发拖动链接）</li><li><code>S-滚轮</code>: 水平移动滚动条</li><li><code>空格</code>: 翻到下一页</li><li><code>F12</code>: 开启/关闭开发者工具</li><li><code>C-R</code>: 重新加载当前页面</li><li><code>CS-R</code>: 硬性重新加载</li><li><code>CS-N</code>: 打开隐私标签页</li><li><code>C-T</code>: 打开新的标签页</li><li><code>C-W</code>: 关闭当前标签页</li></ul><h2 id="GitHub-优化"><a href="#GitHub-优化" class="headerlink" title="GitHub 优化"></a>GitHub 优化</h2><p>众所周知，GitHub 作为最大的开源平台，平时访问的频率是相当高的，这里吾辈推荐一些插件/UserCSS 以增强使用体验。</p><h3 id="树结构浏览代码"><a href="#树结构浏览代码" class="headerlink" title="树结构浏览代码"></a>树结构浏览代码</h3><p>GitHub 浏览代码侧边栏没有一个文件栏实在难受，所以这里推荐 <a href="https://chrome.google.com/webstore/detail/gitako-github-file-tree/giljefjcheohhamkjphiebfjnlphnokk">Gitako</a>   这个插件。它能够为 GitHub 添加一个侧边栏，极大的方便了在线代码浏览。</p><blockquote><p>相比于 <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a>，Gitako 的性能更好，而且是完全免费的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191114123238.png" alt="Gitako 侧边文件夹"></p><h3 id="立体化-GitHub-用户活动"><a href="#立体化-GitHub-用户活动" class="headerlink" title="立体化 GitHub 用户活动"></a>立体化 GitHub 用户活动</h3><p>当你查看一个 GitHub 用户的活动概览时，总是平面方块未免有些无聊，而且以颜色深浅区分也尚不明了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531223619.png" alt="GitHub 用户活动平面图"></p><p>所以，你可以使用 <a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions</a> 插件，让活动变得更有趣一点，变成更直观的 3D 柱状图。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531223909.png" alt="GitHub 用户活动 3D 图"></p><h3 id="统计仓库大小"><a href="#统计仓库大小" class="headerlink" title="统计仓库大小"></a>统计仓库大小</h3><p>或许你也有 clone 之前先知道仓库大小的习惯，这在网络稍差的环境中尤为重要，例如 TypeScript 的仓库大小超过 1G，如果没有准备的话直接下载很容易炸！</p><blockquote><p>GitHub 下载仓库时并不会给出下载的百分比，所以什么时候下载完成是个玄学。。。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531224452.png" alt="统计仓库大小"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Chrome 有很多可以优化体验的地方，这里也只是吾辈所接触到的一部分罢了，欢迎在下面留言补充！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ 开发者之夜@深圳之行</title>
    <link href="/p/b83e9234d0a842d3b88e254ca41845bc/"/>
    <url>/p/b83e9234d0a842d3b88e254ca41845bc/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最早，吾辈是在 <a href="http://www.huodongxing.com/event/6459475264900">活动行</a> 上面看到这个活动的，然后果断报名参加了。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012304.png" alt="参与通知"></p><p>即便，吾辈本身并不住在深圳，但还是选择坐高铁赶过去了。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012102.png" alt="好吧，其实这张图是坐车回来的图片"></p><h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><p>吾辈去的比较早，接近四点钟左右到了，但那个时候活动并没有开始，也没有看到活动标识。于是，吾辈和朋友便先去咖啡厅坐了一会，然后在大约六点钟的时候到达了活动现场。嗯，还拿到了一些小礼物。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113014204.png" alt="小礼物"></p><blockquote><p>产品全系列五折优惠真的很良心了！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012612.png" alt="会场演讲"></p><p>其实活动只有是三个主题</p><ul><li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> 的使用技巧及新特性讲解</li><li><a href="https://www.jetbrains.com/teamcity/">TeamCity</a> 持续集成工具讲解</li><li><a href="https://kotlinlang.org/">Kotlin</a> 语言特性讲解</li></ul><p>在讲完 TeamCity 之后其实有个茶歇时间的，这里吾辈拍了一张会场入口的活动海报<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012530.png" alt="幕间休息"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>虽然 dalao 们都是用英语进行口语交流，吾辈只能听懂七七八八，但参加活动还是感到很高兴。讲真只有在第一个主题吾辈基本能够听懂/参与的，毕竟 IDEA 用了好久。第二个主题的 TeamCity 表示没用过不明觉厉。Kotlin 虽然吾辈也没有用过，但看起来与 Scala 非常相像（语法糖真的太多了！），感觉还是很不错的！</p><p>嘛，希望以后有更多的机会参加 IDEA 举办的活动就是了呢 o((*^▽^*))o</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>局域网内 Windows/Android 传输文件</title>
    <link href="/p/be51004274ee4095950e3c4cc24ff80b/"/>
    <url>/p/be51004274ee4095950e3c4cc24ff80b/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在写杂谈 <a href="/p/2be94bdac12d4122ad4c51a6dd413c54">手游-ウチの姫-回坑感想</a> 时，吾辈在手机上进行了多次截图，但苦于数量太多不方便使用 Telegram/QQ 之类的 IM 进行传输。在尝试了包括 FTP、Infinit、Feem、飞鸽传书这些软件之后，最终发现吾辈还是一如既往的绕远路 – Windows 本身就包含这个功能。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h2 id="Windows-设置共享文件夹"><a href="#Windows-设置共享文件夹" class="headerlink" title="Windows 设置共享文件夹"></a>Windows 设置共享文件夹</h2><p>Windows 在 <em>文件管理器 =&gt; 在文件夹上右键 =&gt; 属性</em> 中可以看到共享，接下来，设置该文件夹为共享文件夹，那么手机便能下载/上传文件到该目录中了。</p><ol><li> 点击共享</li><li> 选择共享的用户</li><li> 确认共享</li></ol><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229233129.gif" alt="GIF 示意图"></p><h2 id="手机上访问局域网"><a href="#手机上访问局域网" class="headerlink" title="手机上访问局域网"></a>手机上访问局域网</h2><p>这里使用 <a href="https://www.coolapk.com/apk/com.estrongs.android.pop">ES 文件浏览器</a> 作为客户端 App 访问 Windows 的共享文件夹。</p><ol><li> 找到 <em>网络 =&gt; 局域网</em></li><li>点击 <strong>扫描</strong><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232158.png" alt="扫描到的目录"></li><li> 点击扫描到的共享计算机</li><li> 输入上面选择的共享用户的 <code>Username/Password</code></li><li>然后就能看到共享文件夹，并且能够复制/粘贴文件了<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232200.png" alt="目录"><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232159.png" alt="粘贴"></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Windows 真的有很多相当好用的功能，只是由于功能太多导致吾辈未曾发现呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下 Cmder 安装 Chocolatey</title>
    <link href="/p/bf03bd6051c04544951b822c59a2d41f/"/>
    <url>/p/bf03bd6051c04544951b822c59a2d41f/</url>
    
    <content type="html"><![CDATA[<p>Chocolatey 是一个 Windows 下的软件包管理系统，追求一切皆可用命令解决。</p><blockquote><p><a href="https://chocolatey.org/">官网</a> / <a href="https://github.com/chocolatey/chocolatey">GitHub 仓库</a></p></blockquote><p>在 Cmder 的 Admin Bash 环境下输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">λ powershell -NoProfile -ExecutionPolicy unrestricted -Command <span class="hljs-string">&quot;iex ((new-object net.webclient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot;</span> &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211812.png" alt="安装图示"></p><blockquote><p>此处千万注意三点：</p></blockquote><ol><li>使用 <strong>Admin</strong> 权限打开的 Cmder（或者是打开的新选项卡）<br> 如果提示你权限不足肯定就是因为这个啦</li><li>使用的是 Cmder <strong>Bash</strong> 而非 PowerShell<br> 在 powershell 下也能够安装（命令不太一样），然而我们想要在 Cmder Bash 下安装，所以不要搞混淆了哦</li><li>命令不要复制错误了（吾辈就错了。。。）<br> 如果提示 <em>使用“1”个参数调用“DownloadString”时发生异常:“不支持给定路径的格式。”</em> 的话一般都是下载路径那里多了个空格之类，仔细找找吧</li></ol><p>安装完成之后输入 <code>choco</code> 验证一下，得到如下输出即为成功！<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211828.png" alt="成功的响应"><br>Chocolatey 常用的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">λ choco list softwareName //查询软件列表<br>λ choco install softwareName //安装软件<br>λ choco list -lo //列出当前使用 choco 所安装的软件<br>λ choco uninstall softwareName //卸载软件<br>λ clist softwareName //查询软件列表简写<br>λ cinst softwareName //安装软件简写<br></code></pre></td></tr></table></figure><p><a href="https://chocolatey.org/packages">可安装软件包列表</a></p><h2 id="Windows-下常用的开发环境软件包"><a href="#Windows-下常用的开发环境软件包" class="headerlink" title="Windows 下常用的开发环境软件包"></a>Windows 下常用的开发环境软件包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">λ choco install git.install     <span class="hljs-comment">#安装 git</span><br>λ choco install jdk8            <span class="hljs-comment">#安装 JDK8</span><br>λ choco install google-chrome-x64 <span class="hljs-comment">#Google Chrome (64-bit only)</span><br>λ choco install autohotkey.portable    <span class="hljs-comment">#安装 AutoHotkey (Portable)</span><br>λ choco install googlechrome    <span class="hljs-comment">#安装 Chrome</span><br>λ choco install firefox         <span class="hljs-comment">#安装 firefox</span><br>λ choco install python          <span class="hljs-comment">#安装 python</span><br>λ choco install nodejs.install  <span class="hljs-comment">#安装 node</span><br>λ choco install ruby            <span class="hljs-comment">#安装 ruby</span><br>λ choco install notepadplusplus.install <span class="hljs-comment">#安装 notepad++</span><br>λ choco install Atom                    <span class="hljs-comment">#安装 Atom</span><br>λ choco install SublimeText3            <span class="hljs-comment">#安装 SublimeText3</span><br></code></pre></td></tr></table></figure><p>Cmder 在使用 <code>Cmd</code> 原生命令时（例如 <code>clip</code> 复制命令），可能会出现乱码，使用命令即可切换默认代码页为 <code>UTF-8</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell -NoProfile -ExecutionPolicy unrestricted -Command <span class="hljs-string">&quot;chcp 65001&quot;</span><br></code></pre></td></tr></table></figure><p>如果有什么能够一劳永逸的方法就好了，泥萌知道的话可以去 <a href="https://github.com/rxliuli/rxliuli.github.io">GitHub</a> 提出 <a href="https://github.com/rxliuli/rxliuli.github.io/issues">Issues</a> 啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Serveo 进行内网穿透</title>
    <link href="/p/d6a6fe2f879943348874dbfe935e2cfb/"/>
    <url>/p/d6a6fe2f879943348874dbfe935e2cfb/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://serveo.net/">官网</a><br>这里只是记录一些吾辈需要的常用的命令，官网上虽然很详细但终归是英文（好像也没什么），不过还是记录一下不容易忘记呢</p></blockquote><h2 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 SSH 将本地的 localhost:3000 映射到到远程的 serveo.net:80</span><br>ssh -R 80:localhost:3000 serveo.net<br></code></pre></td></tr></table></figure><h2 id="保持连接不超时"><a href="#保持连接不超时" class="headerlink" title="保持连接不超时"></a>保持连接不超时</h2><p>添加 ssh 连接参数 <code>-o ServerAliveInterval=60</code> 就好了，每隔 60s 扫描一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -o ServerAliveInterval=60 -R 80:localhost:8888 serveo.net<br></code></pre></td></tr></table></figure><h3 id="连接到自定义的域名-子域名"><a href="#连接到自定义的域名-子域名" class="headerlink" title="连接到自定义的域名/子域名"></a>连接到自定义的域名/子域名</h3><p>添加 DNS 两条记录就行，吾辈推荐 <a href="https://dash.cloudflare.com/">cloudflare</a> 这个网站，能让 DNS 更改在 1 分钟内生效真的很厉害！</p><ol><li> 添加 A 纪录 <code>A | serveo | 159.89.214.31</code></li><li>添加 TXT 记录 <code>TXT | serveo | authkeyfp=SHA256:g6VHWesncgnhwPjvENkhgrC3tkx9SzAKoMOl9xvXgPo</code><blockquote><p>authkeyfp 后面跟的那一串东西其实是 rsa 密钥指纹，使用 <code>ssh-keygen -l</code> 可以查看，一般都在 <code>~/.ssh/id_rsa</code>，没有的话用 <code>ssh-keygen</code> 生成一个就好了</p></blockquote></li></ol><p>进行连接（其实也就是在远程端口前面加上自定义域名而已）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -R serveo.rxliuli.com:80:localhost:3000 serveo.net<br></code></pre></td></tr></table></figure><p>然后就可以通过 <a href="https://rxliuli.serveo.net/">https://rxliuli.serveo.net/</a> 来访问本地部署的项目啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书 [浪潮之巅]</title>
    <link href="/p/dc562ce399704f76a7ee0ab70d04cfc9/"/>
    <url>/p/dc562ce399704f76a7ee0ab70d04cfc9/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前些时日，吾辈读完了 [浪潮之巅] 这本书。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823011623.png" alt="封面"></p><p>它是 Google 开发者吴军所写的 IT 行业各个重要公司的兴衰历史，并进一步探讨了其中的原因。那些曾经无比耀眼的新星，压在每个公司头上的庞然大物，是如何一步步变成这样的。</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最初是在一位朋友的推荐下了解到这本书的，当然，那位推荐了不少有趣的书籍: 黑客与画家、浪潮之巅、人月神话等。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol><li><p>书中最有趣的一个观点是: 公司是由基因决定的，转基因大多都失败了。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823013804.png" alt="基因"></p><blockquote><p>两年前，我和李开复博士等人多次谈论科技公司的兴衰，我们一致认为一个公司的基因常常决定它今后的命运，比如 IBM 很难成为一个微机公司一样。摩托罗拉也是一样，它的基因决定了它在数字移动通信中很难维持它原来在模拟手机上的市场占有率。摩托罗拉并不是没有看出数字手机将来必将代替模拟手机，而是很不情愿看到这件事发生。作为第一代移动通信的最大收益者，摩托罗拉要尽可能地延长模拟手机的生命期，推迟数字手机的普及，因为它总不希望自己掘自己的墓。如果过早地放弃模拟手机，就等于放弃已经开采出来的金矿，而自降身价和诺基亚的公司一同从零开始。尤其在刚开始时，数字手机的语音质量还远不如摩托罗拉砖头大小的大哥大，更使摩托罗拉高估了模拟手机的生命期。和所有大公司一样，在摩托罗拉也是最挣钱的部门嗓门最大，开发数字手机的部门当然不容易盖过正在挣钱的模拟手机部门，因此，摩托罗拉虽然在数字手机研发上并不落后，但是，进展缓慢。一旦各个竞争对手推出各种各样小巧的数字手机时，摩托罗拉才发现自己慢了半拍。</p></blockquote><p> 当然，和所有的观点一样，也有人不同意基因决定论: <a href="https://www.chainnews.com/articles/460655320271.htm">吴军的公司基因论极其肤浅可笑</a></p></li><li><p>曾经，只知道比尔盖茨是世界首富，很强很厉害。具体如何很厉害，吾辈也说不上原因。曾经微软在开源领域骂名昭著，现如今却又大力拥抱开源，不仅开发了开源的 VSCode，甚至在去年收购了开源领域的圣地 – <a href="http://github.com/">GitHub</a>。甚至于，微软可以说是一直都四面皆敌，然而比尔盖茨还是领导着它一路走了过来，并且，除了近年来的 Google，没有公司真正挑战过微软 – 包括很多人喜欢的苹果。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823022335.png" alt="微软标志"></p><blockquote><p>乔布斯和盖茨都意识到了微机及其相关工业将是一个大产业，事实证明这确实是一个万亿美元的大产业。我们在前面已经分析过，计算机工业比任何行业都容易出现垄断公司。乔布斯和盖茨都想做垄断者，但是他们的方式不同。前者是想做原来 IBM 那样的垄断者，从硬件到软件全部垄断，这后来证明是行不通的。而盖茨天才之处在于，它在微机工业刚刚开始的时候，就意识到只要垄断了操作系统，就间接垄断了整个行业，因为操作系统和别的软件不同，是在买计算机时预装好了的，一般用户没有选择权。而其它的软件用户则有选择权。<br>如果说乔布斯是锋芒毕露，聪明写在脸上；盖茨就是一个平衡木冠军，聪明藏在肚子里。无疑，后者比前者更可怕。</p></blockquote></li><li><p>近来的几十年，对于 IT 行业来说真的是波澜壮阔的时代，<strong>无线通信 =&gt; 大型机 =&gt; 微机 =&gt; 互联网 =&gt; 智能手机</strong>，每一次的变化都导致了世界上许多人的命运被改变。</p><ul><li><p>无线通信: ATT 的贝尔实验室访华成员甚至受到了国家主席的接见</p></li><li><p>大型机: IBM 成功变成了 <strong>蓝大象</strong>，并统治了企业级市场</p></li><li><p>微机: 微软和苹果成功统治了操作系统，英特尔则统治了微机的心脏 – CPU</p></li><li><p>互联网: 雅虎，Google 成功崛起，实际上挑战了微软系统作为用户入口的统治地位</p></li><li><p>智能手机: Google Android 再获成功，再次对微机入口的统治地位造成威胁</p><blockquote><p>如果说基因决定性多少有些宿命论，那么人为的因素也加速了摩托罗拉的衰落。我们在介绍英特尔一章中介绍过，在科技工业发展最快的八九十年代，摩托罗拉的第三代家族领导人卡尔文三世没有能力在这个大时代中纵横捭阖，开拓疆土。摩托罗拉本来在手机、计算机处理器和数字处理器（DSP）三个领域均处于领先地位，前景不可限量。但是卡尔文实在没有能力将三个庞大的部门十几万人管理好，虽然他没有犯什么大的错误，但是他平平庸庸。也许，在五十年前，一个只需要守成的年代他可以坐稳他的位置，但是在上个世纪末那个一个英雄辈出、拒绝平庸的年代，盖茨、乔布斯、郭士纳、格罗夫、钱伯斯和通用电气的杰克·韦尔奇等人都在同场角逐，任何公司都在逆水行舟，不进则退。除了卡尔文，摩托罗拉的整个管理层也有责任，他们低估了摩尔定理的作用。虽然数字手机在一开始还比不上模拟手机，但这并不能说它要很长时间才能威胁模拟手机的地位。事实上，由于半导体技术按指数的速度发展，手机数字化比摩托罗拉高管们想象的时间表来得早得多，使得摩托罗拉几十年来积累的模拟技术变得无关紧要，市场的优势顿失。</p></blockquote></li></ul></li><li><p>IT 行业的发展速度非常之快，传统行业需要几十上百年才能垄断一个产业，在这个领域创造一个产业从形成到垄断只需要短短几年就可以完成。最终形成前面一两家公司占大头吃肉，后面的小公司跟在后面喝汤，例如桌面操作系统中的 Windows(80+%)，MacOS(10+%) 和 Linux (1+%)。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823023553.png" alt="操作系统比率图"></p><blockquote><p>虽然微软在操作系统市场的优势和高通在 3G 市场的垄断是极端的例子，但是，即使在一般情况下，在一个成熟的市场上占有主导地位的公司仍然能独占 60-70% 的市场。在处理器市场上，英特尔一年有近 400 亿的销售额，而第二名 AMD 仅有 60 亿。在网络设备市场上，思科销售额高达 400 亿，是它的对手华为（ 100 亿）和 Juniper （ 40 亿）总和的三倍。<br>附: 以下是吾辈的个人观点<br>虽说很多人鼓吹 Linux，甚至说世界上最快的电脑大多运行 Linux 或类 Unix，但实际上在桌面微机领域 Linux 的份额少得可怜，即便是近年来 Ubuntu，Fedora 这些开箱即用发行版的流行，也并不能改变整个领域已被微软垄断的事实。<br>一个支撑的证据就是: Linux 下大多数工具没有选择，而 Windows 下同一个功能的程序会有很多类似的，如果不好用，用户可以换另外一种。</p></blockquote></li><li><p>国内的很多公司似乎被很多 IT 技术人员看不起，但这其实也是一种偏见。平心而论，在开源方面，国内公司确实相当糟糕。矮个子里拔高个，要数阿里的开源项目是最好的了。即便如此，仍然会发生很恶心的事情，例如去年圣诞节沸沸扬扬的圣诞彩蛋事件。然而，在商业和技术方面，阿里都是相当领先的。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823024140.png" alt="圣诞彩蛋事件"></p><blockquote><p>中国的电子商务比实体商务更难做一－没有信用体系，真正意义上的信用卡不普及，没有在线支付手段，没有物流保障。大部分试水电子商务的公司，包括著名的 eBay 公司，都无法逾越这些障碍，很多公司不得不知难而退，很多商家和投资人甚至认定中国的电子商务发展必须再等很长的时间。而阿里巴巴的过人之处就是在于它以积极的态度，解决了大多数人认为无解的难题。没有信用系统，阿里巴巴就自己建立了一个；没有支付手段， 它就利用此契机开发了支付宝，这不仅解决了在阿里巴巴上交易的支付问题，而且扩展到解决中国整个在线甚至离线支付的问题；中小商家管理混乱，阿里巴巴就在它的 B2B 部门开发了面向企业的应用软件；至于物流，它起初并没有进入这个高投资、低回报的部门，而是利用它巨大的交易量，通过与第三方的合作，在保障商家和用户的基础上，规范了整个物流行业的经营 σ 可以毫不夸张地讲，在全世界没有哪家公司，包括 eBay 和亚马逊，像阿里巴巴那样做到了控制住整个电子商务产业链中的所有关键性环节。因此，我可以毫不夸张地预言， 阿里巴巴会在很短的时间里，超过 eBay 和亚马逊的总和，成为全球仅次于 Google 的第二大互联网公司。我甚至还可以进一步预言，如果中国政府对它不加限制，它可以成为中国市值最大的公司。</p></blockquote></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后以一句名言作为结尾: <strong>这是最好的时代，也是最坏的时代</strong>，而我们，正处于这个时代之中。</p><hr><p>刚看完第四版，里面更新了不少内容（据同事说将作者的另一本书 <a href="https://book.douban.com/subject/26665230/">硅谷之谜</a> 的内容糅合到这本书了），吾辈个人的直观感受是，相比于之前的版本，提出了许多有关国内的见解。例如阿里巴巴、腾讯，还有最近几年的明星公司小米、华为、滴滴等等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 调试技巧</title>
    <link href="/p/df187d25c5814bb7829d8e151e58c851/"/>
    <url>/p/df187d25c5814bb7829d8e151e58c851/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#idea-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7">IDEA 调试技巧</a><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E5%9F%BA%E6%9C%AC">基本</a><ul><li><a href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95">启动调试</a></li><li><a href="#%E6%96%AD%E7%82%B9">断点</a></li><li><a href="#%E7%A7%BB%E5%8A%A8">移动</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9">忽略所有断点</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">执行表达式</a></li><li><a href="#%E5%8F%98%E9%87%8F%E7%9B%91%E8%A7%86">变量监视</a></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7">高级</a><ul><li><a href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9">条件断点</a></li><li><a href="#%E6%96%AD%E7%82%B9%E7%AE%A1%E7%90%86">断点管理</a></li><li><a href="#%E5%BC%82%E5%B8%B8%E6%96%AD%E7%82%B9">异常断点</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%9B%9E%E9%80%80">代码回退</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E8%BF%94%E5%9B%9E">强制返回</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">模拟抛出异常</a></li></ul></li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>IDEA 最强大的功能之一就是 Debug 了，然而如此强大的工具却有很多人在使用了很久之后依旧只会使用断点，然后一步步的走下来，这里便稍微讲解一下 IDEA 的调试功能。</p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>最简单直观的就是点击工具栏的 Debug 按钮（<code>S-F9</code>）即可开始调试当前运行选项，然后便会弹出 Debug 选项卡（<code>A-5</code>）。</p><p>启动调试有三种情况：</p><ul><li><code>S-F9</code> 如果运行选项不为空，调试当前运行选项</li><li><code>CS-F9</code> 如果当前文件可以运行的话，就调试当前文件</li><li><code>SA-F9/F9</code> 显示所有可以调试的运行选项<br>注：<code>F9</code> 只有在非调试环境下生效，在调试环境下的作用是运行到下一个断点。</li></ul><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在左侧边栏上点击一下（亦或是 <code>A-F8</code> 添加一个？）就可以为当前可以运行到的代码行添加一个红色的小圆点（断点），当代码运行到断点时会自动停下（并自动跳转过来），然后我们就可以自己的查看运行时的细节了。</p><blockquote><p>注：我们不能为不可能运行到的位置添加断点。例如以下情况：</p><ul><li>方法右侧大括号单独所在的行（会报错但仍能添加），错误：<code>No executable code found at line</code></li><li>类的方法之间的空行，这些地方甚至不能打断点（<strong>因为毫无意义！</strong>）</li></ul></blockquote><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul><li><code>F7</code>：跳转到方法内部</li><li><code>S-F7</code>：选择跳转到哪个方法内部</li><li><code>F8</code>：执行到下一行代码，如果没有下一行代码，则跳转到调用者方法（非类库的）。</li><li><code>S-F8</code>：跳转到方法的调用者处，即便代码是类库里面的。</li><li><code>F9</code>：让程序恢复到运行状态（未遇到断点的情况下），想跳到下一个断点或者让程序恢复正常运行状态就用这个吧</li><li><code>A-F9</code>：跳转到当前行，主要用于在想进入方法内部看看时（一般很多人习惯打个断点吧？）</li></ul><h3 id="忽略所有断点"><a href="#忽略所有断点" class="headerlink" title="忽略所有断点"></a>忽略所有断点</h3><p>有这么一种情况，我们想要正常运行看一下效果，又不想重启服务器（一会有错误还要调试呢），就可以使用这个功能避免我们无谓的进入断点。</p><p>功能的名字是 <code>Mute Breakpoints</code>，但默认没有快捷键。可以使用结构查询 <code>CS-A</code> 输入这个名字进行查找，或者在调试选项卡中找到它点击一下就可以了。</p><h3 id="执行表达式"><a href="#执行表达式" class="headerlink" title="执行表达式"></a>执行表达式</h3><p>IDEA 调试非常棒的一个功能，有时候想看看某个表达式的值，但又不想真正执行它（例如调用有可能因为参数报错的方法），想先看一下结果，这里就可以使用执行表达式（<code>A-F8</code>）这个功能了。<br>IDEA 能够自动感知当前调试的环境（例如当前调试代码行能访问到的所有变量执行表达式窗口中都能访问，反之亦然）,也能在弹窗中自动提示代码。</p><p>但请注意，执行表达式中执行的代码是真的执行了，所以例如只能读取一次的流，数据库，文件等等，都是真正被改变的了，所以需要稍微注意一下哦</p><h3 id="变量监视"><a href="#变量监视" class="headerlink" title="变量监视"></a>变量监视</h3><p>上面的执行表达式可以查看表达式的值，然而如果我们想要看一个表达式的值在代码运行过程中发生了什么变化怎么办？难道每运行一行代码就使用执行表达式查看一下表达式的值么？那效率也太低了！<br>所以这里就需要用到变量监视这个功能了（<code>Add to Watches</code>），既可以右键将表达式的值添加到监视变量中，也能够在执行表达式窗口直接将当前表达式的值添加到监视变量中去（<code>CS-Enter</code>）。每一次代码走到下一步都会自动刷新值（其实就是执行了一次）。</p><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>可以给一个断点添加一个条件，指定在什么情况下会停留到这个断点（例如 if 语句里面的判断表达式为 <code>true</code> 时就停留），但断点条件只能是 <code>true/false</code>。操作的话在断点代码行使用 <code>CS-F8</code> 或者直接右键单击断点，就会弹出一个窗口，在 <code>Condition</code> 部分输入需要的条件就可以啦</p><h3 id="断点管理"><a href="#断点管理" class="headerlink" title="断点管理"></a>断点管理</h3><p>断点太多了怎么办？调试的时候想要测试某个请求的时候总是进入不相关的断点，这里可以使用断点管理功能。放在任意一个非断点代码行的位置按下 <code>CS-F8</code> 就会弹出一个断点管理弹窗，里面列出了所有，你可以在这里对断点进行更加细致的管理（启用/禁用/添加/删除/是否是多线程都有效/条件表达式/执行日志/相关代码修改/双击断点则后面的选项跳转到断点处）。</p><h3 id="异常断点"><a href="#异常断点" class="headerlink" title="异常断点"></a>异常断点</h3><p>有一种情况是我们在控制台看到了异常，但很想知道会在什么地方发生某个指定的异常。这时候就可以使用这个功能了。这个功能依赖于断点管理，需要在断点管理弹窗中进行添加断点异常（<code>A-Ins</code>）才可以。以后当每次发生指定异常时，都会停留在相应的代码处，以便于查看更加详细的原因。</p><h3 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h3><p>跳跃到上一个方法调用链处，或者在 <code>Frames</code> 选项卡中右键 <code>Drop Frame</code> 选择调用链的位置，然后回到这个位置。感觉上就像是回退一样，但其实并没有这么神奇。该功能只能回退到以前的方法调用位置，而且回退后 <em>未来</em> 的记录会被删除，总而言之这也是 IDEA 提供的一个调试的功能之一呢（吾辈个人用的不是很多）</p><h3 id="强制返回"><a href="#强制返回" class="headerlink" title="强制返回"></a>强制返回</h3><p>有时执行某个方法时已经发生了错误（例如参数有问题），但又不想继续执行下去（发生异常），所以就可以直接中断指定方法，强制返回指定的值。在方法调用链选项卡中选择一处（一般是当前方法），右键选择 <code>Force Return</code> 就可以强制结束该方法并返回指定的值了。</p><h3 id="模拟抛出异常"><a href="#模拟抛出异常" class="headerlink" title="模拟抛出异常"></a>模拟抛出异常</h3><p>场景：在需要测试方法在非正常执行时（例如测试数据库关闭发生数据库连接错误时的情况），如果还在手动添加测试异常代码就有点落后了，IDEA 已经为我们提供了优秀的工具！使用方法也很简单，就是在方法调用链选项卡指定位置右键选择 <code>Throw Exception</code>。</p><!--### JavaScript 调试#### 1. 单独启动 JavaScript 调试JavaScript 调试起来就有点意思了，基本上 IDEA 对 Google Chrome 非常友好（有专门的 Plugini），然而对 FireFox 却支持的并不怎么好。好了，还是先看一下怎么配置 JavaScript 的运行选项进行调试吧1. 打开配置运行弹窗  就在运行选项左边的下拉框的第一项（`Edit Configurations`）2. 添加一个 JavaScript 运行选项3. 设置调试的 url4. 启动调试#### 2. Java 与 JavaScript 混合调试 -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作为一名 developer 如何正确地使用 Chrome</title>
    <link href="/p/ec030b93f85d44cdbf46e5a24e9982dc/"/>
    <url>/p/ec030b93f85d44cdbf46e5a24e9982dc/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D-developer-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-chrome">作为一名 developer 如何正确地使用 Chrome</a><ul><li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li><li><a href="#devtool">DevTool</a><ul><li><a href="#network">Network</a></li><li><a href="#element">Element</a></li><li><a href="#sources">Sources</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6">使用插件</a><ul><li><a href="#%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8">日常使用</a></li><li><a href="#stylus">Stylus</a></li><li><a href="#tampermonkey">Tampermonkey</a></li></ul></li></ul></li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>现如今，<a href="https://www.google.com/chrome/">Google Chrome</a> 是全世界最流行的浏览器，具体有多流行，可以看看 <a href="https://www.netmarketshare.com/browser-market-share.aspx">浏览器市场份额统计</a>。然而，有许多人，只是简单的安装了 Chrome，然后直接使用，却并未想过如何才能更好的使用它。</p><h2 id="DevTool"><a href="#DevTool" class="headerlink" title="DevTool"></a>DevTool</h2><p>Chrome 的开发者工具可以说是目前最好的了，然而除了简单的查看 <code>Network/Element</code> 之外，你可还使用过其他的功能？下面让我们一起来探讨一下 DevTool 的 <strong>奇淫技巧</strong> 吧！</p><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ol><li><p><code>Copy =&gt; Copy as fetch</code><br> 以 <code>fetch</code> 方式复制这个请求，如果你对 <code>fetch</code> 还不了解，可以去 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">MDN: 使用 Fetch</a> 上查看它，并尝试使用它。这是一个浏览器原生的接口，用于进行 HTTP 操作。相比于 <code>XMLHttpRequest</code>，<code>fetch</code> 通常被称为下一代的 Ajax 技术。<br> 这也正是吾辈将之单独列出的重要原因，因为它是纯 JavaScript 的，所以我们可以直接在浏览器中对其进行测试/修改/执行，这点对于 <code>user.js</code> 和 <code>nodejs 爬虫</code> 尤其重要。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104212920.png" alt="Copy =&gt; Copy as fetch"></p></li><li><p>Network 设置</p><ul><li><p><code>Disable Cache</code>：禁用网络缓存，开发阶段必备。如果你不想在开发时使用 <code>CS-R</code> 进行硬性重新加载，那最好禁用掉它，避免修改的代码没有及时生效。</p></li><li><p><code>Preserve log</code>：保留日志。一般而言，当你刷新页面后，<code>Network</code> 将被清空。然而有时候，我们想知道代码修改前后请求发生了哪些变化（修改之前请求一切正常，修改之后就 GG 了），这是便需要使用该选项保留所有的网络请求，方便对比刷新前后请求的变化。</p></li><li><p><code>Group by frame</code>：根据 frame 对请求进行分组。常见于 Web 后台开发，很多后台项目都使用 frame 实现了标签页的功能，所以按照 frame 进行分组会方便进行查看一点。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104214338.png" alt="Network 设置"></p></li></ul></li></ol><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><ol><li><p><code>Copy =&gt; Copy selector</code><br> 复制 DOM 元素的选择器，该选择器实际上是供 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Locating_DOM_elements_using_selectors">Selectors API</a> 使用（<code>querySelector/querySelectorAll</code>），但 jquery 的选择器应该兼容它。我们复制完选择器后就可以使用 <code>Selectors API</code> 或 <code>jquery</code> 之类的选择器去获取到元素，然后对之进行操作。这对 <code>user.js</code>/<code>nodejs 爬虫</code>/<code>快速获取元素</code> 有着重要的意义。</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104220838.png" alt="Copy =&gt; Copy selector"></p></li><li><p><code>Break on</code><br> 在开发过程中，你是否遇到过这样的问题：“某个元素改变了，但始终不知道是那里的代码改变的”。这时候，DOM 断点就派上用场了，监听某个元素，并根据条件触发并暂停当前 JavaScript 进入 Debug 模式。</p><ul><li><p><code>subtree modification</code>：当子节点发生改变时触发</p></li><li><p><code>attribute modification</code>：当节点属性发生改变时触发</p></li><li><p><code>node removal</code>：当节点移除时触发</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104221816.png" alt="Break on"></p></li></ul></li><li><p>DOM 元素强制指定状态<br> 某个元素只有在指定状态下才会有某些效果，当你想让这个元素的状态一直维持不变以仔细观察时，就需要强制指定元素的状态了。<br> 思考以下场景<br> 下拉菜单只有在鼠标悬浮时才会展开，但鼠标移到 DOM 元素查看时却收起来了，感觉非常难受.JPG！幸好，浏览器为我们提供了这个功能。<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190726221706.png" alt="Force state"></p></li></ol><h3 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h3><ol><li><p><code>Drawer Show Search</code><br> 显示搜索框，全文搜索当前页面载入的代码，用于快速定位到指定的代码片段。如果你不知道某段代码在什么地方，就可以使用它快速查找。搜索的内容可以使用正则表达式以及区分大小写模式。</p><blockquote><p>在除了 Console 选项卡之外都可以使用 <code>CS-F</code> 直接打开</p></blockquote><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190108222409.png" alt="Drawer Show Search"></p></li><li><p>Debug</p><ul><li>预览表达式结果<br>当你选中一个表达式后，鼠标悬浮在选中的代码上，Chrome 就会自动计算出表达式的结果，并在鼠标附近显示出来。<blockquote><p>注：</p><ul><li>表达式不是代码片段，所以如果选中多段代码是不会得到结果的</li><li>非纯函数，例如使用了 Ajax 请求</li></ul></blockquote></li><li><code>Evaluate in console</code><br>想要查看某段代码执行的结果，便可以选中这段代码，然后右键选择在控制台中执行它。该功能与上面的预览表达式结果相辅相成。</li><li><code>Conditional breakpoint</code><br>条件断点。允许指定某个断点在指定表达式为 <code>true</code> 的情况下才停止，便于在循环中使用断点调试某种特殊情况。</li><li><code>Deactivate breakpoints</code><br>停用所有的断点。当我们打了一大堆断点之后，想直接看一下效果，又不想把现有的断点删除，就可以暂时停用现有断点，方便查看效果。</li></ul></li></ol><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>自从 Firefox59 以来，随着大量旧体系的插件大量失效，Firefox 的插件库已经不像以往了。如今，Chrome 的插件库是这个星球上最庞大的浏览器插件库了。如果你还没有使用过插件，那恐怕只能使用 Chrome 的一部分功能罢了。</p><h3 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h3><ul><li><a href="https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp">AutoPagerize</a>：自动翻页插件，浏览很多网站时不需要手动点击下一页了，可以自动加载出来下一页的结果。</li><li><a href="https://chrome.google.com/webstore/detail/checker-plus-for-gmail/oeopbcgkkoapgobdbedcemjljbihmemj">Checker Plus for Gmail™</a>：对于日常使用 Gmail 的吾辈而言非常有用</li><li><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo">crxMouse Chrome™ 手势</a>：鼠标手势插件，可以使用手势更简单地完成一些事情</li><li><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">Dark Reader</a>：为所有网站加上黑色主题，大部分情况下都还不错</li><li><a href="https://chrome.google.com/webstore/detail/anlikcnbgdeidpacdbdljnabclhahhmd">Enhanced Github</a>：显示 GitHub Repository 大小，允许单独下载每一个文件</li><li><a href="https://chrome.google.com/webstore/detail/enhancer-for-youtube/ponfpcnoihfmfllpaingbgckeeldkhle">Enhancer for YouTube™</a>：怎么说呢，Youtube 已经很好了，但吾辈还是觉得需要这个插件来优化播放体验</li><li><a href="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf">Fatkun 图片批量下载</a>：批量下载网页上的图片，偶尔用一下吧</li><li><a href="https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp">Free Download Manager</a>：FDM Chrome 集成插件，将 Chrome 下载链接使用 FDM 多线程下载</li><li><a href="https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk">GitHub Hovercard</a>：GitHub 增强插件，鼠标悬浮在仓库链接上面就可以预览</li><li><a href="https://chrome.google.com/webstore/detail/image-search-options/kljmejbpilkadikecejccebmccagifhl">Image Search Options</a>：使用右键以图搜图</li><li><a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions</a>：GitHub 美化插件，将 GitHub 贡献以 3D 的效果显示出来</li><li><a href="https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji">JetBrains IDE Support</a>：使用 Chrome 实时显示 IDEA 的 HTML/CSS/JavaScript 文件，与 IDEA 的插件配合使用</li><li><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd">LastPass: Free Password Manager</a>：跨平台的免费密码管理器，有了这个之后再也不用所有网站都使用同一个密码了</li><li><a href="https://chrome.google.com/webstore/detail/mailto-for-gmail/dgkkmcknielgdhebimdnfahpipajcpjn">Mailto: for Gmail™</a>：对于 mailto 协议的链接以 Gmail 网页版打开</li><li><a href="https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa">Markdown Here</a>：在线将 Markdown 转换为有格式的文档，例如在一个普通的富文本编辑器（不支持 Markdown）中，可以先用 Markdown 语法写内容，然后转换一下就得到了有样式的内容了。</li><li><a href="https://chrome.google.com/webstore/detail/neat-url/jchobbjgibcahbheicfocecmhocglkco">Neat URL</a>：移除网址中的无用段，例如返利链接后面的参数</li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a>：GitHub 代码树状图插件，方便查看项目文件</li><li><a href="https://chrome.google.com/webstore/detail/owo/ckfodameiahfhlainaclajkgfagkpodb">OwO</a>：颜文字插件，多亏了这个让吾辈能够愉快的刷推了</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">Proxy SwitchyOmega</a>：科学上网必需</li><li><a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Stylus</a>：使用自定义网站样式的插件，比 Stylish 的名声好一些</li><li><a href="https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp">Tabliss</a>：新标签页插件</li><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a>：使用自定义网站脚本的插件，可以使用各种 <code>user.js</code> 脚本，相当于小型的插件管理器了</li><li><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">The Great Suspender</a>：自动休眠标签页，避免 Chrome 使用的内存太过庞大</li><li><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a>：日常上网必须，屏蔽各种广告，比 ADBlock 的名声好一些</li><li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js devtools</a>：在 DevTool 中添加 VueJS 选项卡，便于对 VueJS 进行调试</li><li><a href="https://chrome.google.com/webstore/detail/webrtc-network-limiter/npeicpdbkakmehahjeeohfdhnlpdklia">WebRTC Network Limiter</a>：阻止浏览器通过 WebRTC 泄露 IP 地址</li><li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad">WEB 前端助手(FeHelper)</a>：貌似是百度的前端插件，但目前还没有什么流氓行为</li><li><a href="https://chrome.google.com/webstore/detail/%E5%BF%AB%E7%BF%BB%E8%AF%91/chpeaiibggkmaongjphijmielpkokcdg">快翻译</a>：这个翻译插件是真心不错，某种意义上讲比 Chrome 自带的翻译都要好（#大雾）</li><li><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">扩展管理器（Extension Manager）</a>：插件很少的时候还好，一多起来还是需要一个插件进行管理，快速启用和禁用一些插件，根据场景切换启用插件列表</li></ul><h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h3><p>为网页自定义 CSS 样式，主要用于网站美化，但也可以用于屏蔽网站内容（现在某些网站会检测用户浏览器是否安装了 uBlock Origin 之类的广告过滤插件）。</p><p>例如吾辈就写了一些 css 来提高使用浏览器的体验</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 全局字体设置 */</span><br>* &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;RTWS YueGothic Trial Regular&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/*滚动条美化*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">6px</span>;<br>&#125;<br><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-track-piece</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#cccccc</span>;<br>  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-number">6px</span>;<br>&#125;<br><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span><span class="hljs-selector-pseudo">:horizontal</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#cccccc</span>;<br>  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-number">6px</span>;<br>&#125;<br><br><span class="hljs-comment">/*滚动条滑块的宽高*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">9px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">9px</span>;<br>&#125;<br><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-track-piece</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: transparent;<br>&#125;<br><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-track-piece</span><span class="hljs-selector-pseudo">:no-button</span> &#123;<br>&#125;<br><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3994ef</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-comment">/*滑块的样式*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span><span class="hljs-selector-pseudo">:vertical</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4afffe</span>;<br>  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-number">6px</span>;<br>&#125;<br><br><span class="hljs-comment">/*鼠标悬浮于滑块上*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#39ffff</span>;<br>&#125;<br><br><span class="hljs-comment">/*鼠标按下于滑块上*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00fffd</span>;<br>&#125;<br><br><span class="hljs-comment">/*纵向滚动条的宽度*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:vertical</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">9px</span>;<br>&#125;<br><br><span class="hljs-comment">/*横向滚动条的宽度*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:horizontal</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">9px</span>;<br>&#125;<br><br><span class="hljs-comment">/*纵向滚动条的开始按钮（右上角）*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:vertical</span><span class="hljs-selector-pseudo">:start</span><span class="hljs-selector-pseudo">:decrement</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00fffd</span>;<br>&#125;<br><br><span class="hljs-comment">/*纵向滚动条的开始按钮（右下角）*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:vertical</span><span class="hljs-selector-pseudo">:end</span><span class="hljs-selector-pseudo">:increment</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00fffd</span>;<br>&#125;<br><br><span class="hljs-comment">/*横向滚动条的开始按钮（左下角）*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:horizontal</span><span class="hljs-selector-pseudo">:start</span><span class="hljs-selector-pseudo">:decrement</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00fffd</span>;<br>&#125;<br><br><span class="hljs-comment">/*横向滚动条的结束按钮（右下角）*/</span><br><span class="hljs-selector-pseudo">::-webkit-scrollbar-button</span><span class="hljs-selector-pseudo">:horizontal</span><span class="hljs-selector-pseudo">:end</span><span class="hljs-selector-pseudo">:increment</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00fffd</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span><span class="hljs-selector-pseudo">::-webkit-scrollbar-track-piece</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也安装了一些其他人写好的</p><ul><li><a href="https://userstyles.org/styles/37035/github-dark">GitHub Dark</a>：将 GitHub 页面设置为暗色护眼模式</li><li><a href="https://userstyles.org/styles/155039">A Better Twitter</a>：删除了 Twitter 上用不到的内容，例如广告，新闻栏</li><li><a href="https://userstyles.org/styles/144506/bilibili">Bilibili 屏蔽广告 &amp; 首页去除 舞蹈、生活、时尚、娱乐…… 分类区块</a>：精简 Bilibili，毕竟，现在 B 站无关的内容实在太多了</li></ul><h3 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h3><p>非常强大的一个插件，如果真要展开说明，恐怕又要写一篇博客了。可以将用户自定义的 js 代码 <strong>注入</strong> 到网页中，而这，其实就代表着，任何只要会 JavaScript 的人，都可以在自己浏览器上任意修改网站内容。</p><p>那么，说的好像很厉害的样子，具体能做些什么呢？下面列出吾辈常用的 user.js 脚本</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/375701">百度网盘导出数据</a>：百度网盘将文件数据导出出来便于二次分析</li><li><a href="https://greasyfork.org/scripts/2185">為什麼你們就是不能加個空格呢？</a>：网站本身不加空格吾辈帮它加咯</li><li><a href="https://greasyfork.org/scripts/1682">Google Hit Hider by Domain</a>：Google 搜索结果过滤域名</li><li><a href="https://greasyfork.org/scripts/41075">网页限制解除</a>：解除网页不能复制/粘贴/右键的问题</li><li><a href="https://greasyfork.org/zh-CN/scripts/372516">bilibili merged flv+mp4+ass+enhance</a>：下载 bilibili 上的视频</li><li><a href="https://greasyfork.org/scripts/40496">Ci-Aria2 百度云盘增强版</a>：提取百度网盘下载直链</li><li><a href="https://greasyfork.org/scripts/29762">网盘自动填写密码</a>：自动填写百度网盘提取密码</li><li><a href="https://greasyfork.org/scripts/34175">Booru Downloader + Viewer</a>：图站抓图之用</li><li><a href="https://greasyfork.org/zh-CN/scripts/369418">Youtube Download</a>：下载 Youtube 上的视频</li></ul><p>哦，如果你很懒，也可以先去 <a href="https://greasyfork.org/">Greasy Fork</a> 搜索一下是否有你需要的 user.js 脚本。有的话可以直接安装。</p><blockquote><p>Greasy Fork 上的脚本全部都是开源的，如果你不信任其他开发者，可以随意对脚本进行检查。</p></blockquote><hr><p>那么，有关 Chrome 的使用就到这里啦。如果你也知道什么有趣的操作，可以在下方留言告诉吾辈呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 设置配置文件的位置</title>
    <link href="/p/edc140a69a0c455aa77ab1e8c819f4ce/"/>
    <url>/p/edc140a69a0c455aa77ab1e8c819f4ce/</url>
    
    <content type="html"><![CDATA[<p>IDEA 虽然有着便携版本，但它的配置文件显然并非如此。默认设置在当前用户目录下，所以为了便携化考虑，还是将配置文件也放到 IDEA 程序的子目录更好一点。</p><p>主要需要修改的文件为：<br><strong>IDEAHome/bin/idea.properties</strong></p><p>找到内容为 <code>idea.config.path</code> 与 <code>idea.system.path</code> 的选项，放开注释，修改为你想要的路径就好了。</p><ul><li><code>idea.config.path</code>：IDEA 的配置文件目录，主要有安装的插件，自定义的配置等</li><li><code>idea.system.path</code>：IDEA 的缓存文件目录，主要有各个项目单独的配置，项目的索引等</li></ul><blockquote><p>注：<code>$&#123;idea.home.path&#125;</code> 代表的是 IDEA 程序的根目录。<br>例如：IDEA 的文件夹是：<code>C:/Users/rxliuli/Program/ideaIU-2018.1.6.win/</code>。 那么，<code>$&#123;idea.home.path&#125;/.IntelliJIdea/</code> 代表的就是 <code>C:/Users/rxliuli/Program/ideaIU-2018.1.6.win/.IntelliJIdea/</code></p></blockquote><p>以上便是使用 IDEA 设置配置文件的位置的方法，现在可以将 IDEA 程序和配置一起打包解压即用了呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cmder 启动报错</title>
    <link href="/p/f947981f526d4be79e1352cc1c24cd96/"/>
    <url>/p/f947981f526d4be79e1352cc1c24cd96/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>每次打开 <code>Cmder</code> 时都会出现这么一个错误，虽然貌似对之后的使用没什么影响，但强迫症表示受不了呀</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">WARNING! The MacType&#x27;s hooks are detected at 0x00007FF8E9D10000 D:\Program\MacType\MacType64.dll Please add ConEmuC.exe and ConEmuC64.exe to the exclusion list to avoid crashes! https://conemu.github.io/en/Installation.html#mactype<br></code></pre></td></tr></table></figure><p>其实在初次使用 <code>Cmder</code> 时可能会遇到这种情况，因为你的 PC 上肯定是同时安装了 <code>MacType</code>，在遇到这种情况时看一下官方的链接就好了（虽然官方也没给出如何将程序添加到排除列表中 23333）</p><blockquote><p><a href="https://conemu.github.io/en/Installation.html#mactype">官方链接</a></p></blockquote><p>官方的解释是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">If you are using MacType you can get crashes when starting any application from a shell started in ConEmu tab.<br>That is because MacType tries to hook ConEmuC.exe and ConEmuC64.exe processes. But ConEmuC is a console application and it does not draw any text on graphical canvas at all.<br></code></pre></td></tr></table></figure><p>大意就是说 <code>ConEmuC.exe</code> 和 <code>ConEmuC64.exe</code> 是命令行程序，不在窗口上绘制什么文本，所以在其中打开时可能会发生异常。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-使用图形编辑器"><a href="#1-使用图形编辑器" class="headerlink" title="1. 使用图形编辑器"></a>1. 使用图形编辑器</h3><p>详情见下面的 Gif</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211545.gif" alt="Cmder 启动报错"></p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2. 编辑配置文件"></a>2. 编辑配置文件</h3><p>修改 <code>MacType</code> 的配置文件 <code>MacType.ini</code>（位于 <code>$&#123;MacType&#125;/MacType.ini</code>），在 <code>UnloadDll</code>（排除的 <code>DLL</code>）下添加 <code>ConEmuC64.exe</code> 和 <code>ConEmuC.exe</code> 即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode VS WebStorm 横向对比</title>
    <link href="/p/0c417ba5085d476b8a1eb521da0662e1/"/>
    <url>/p/0c417ba5085d476b8a1eb521da0662e1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>不能认清自己，怎能看清别人？</p></blockquote><p>最近很长一段时间，VSCode 似乎成为了前端口中的标准开发编辑器，前端圈到处都在推荐 VSCode，劝说其他人放弃 Sublime, WebStorm, Atom 之流，仿佛真的是<strong>信巨硬，得永生</strong>一般。而吾辈作为一个长时间使用 JetBrains 系 IDE 的全沾开发者，这里就来对比一下 WebStorm 与后起之秀 VSCode 之前的异同点吧</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="插件生态"><a href="#插件生态" class="headerlink" title="插件生态"></a>插件生态</h3><p>VSCode 的生态无疑非常好，基于 Web 技术构建的编辑器同样可以使用 Web 技术开发插件，而 Web 开发人员的数量也确实非常庞大。且由于其轻量跨平台的特性，受到很多开发者的喜爱，将之作为主力文件编辑器或者将其打造成 IDE 使用。它们的插件市场首页分别如下</p><p>VSCode<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830232931.png" alt="VSCode 插件市场"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830232701.png" alt="WebStorm 插件市场"></p><p>WebStorm 官方给出的插件总数是 1607，而 VSCode 吾辈并未找到插件的总数量，但显而易见，VSCode 的插件数量应该远远高于这个数字。而且你可以看到 WebStorm 下载量第一的插件仅仅只下载过 <strong>5,558,762</strong> 次，而 VSCode 的热门插件的下载数量是以 M 来计算的。我们来搜索一下前端流行打包工具 <code>webpack</code>，对比一下结果。</p><p>VSCode<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830233610.png" alt="webpack for vscode"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830233724.png" alt="webpack for WebStorm"></p><p>是的，VSCode 搜索到了 16 个插件，而 WebStorm 的搜索结果是。。。<strong>0</strong>？不了解 WebStorm 的小伙伴可能会有疑问，难道 WebStorm 不支持 webpack 嘛？那要它何用，还是拉出去砍了吧！<br>泥萌先别急着掀桌子，个中缘由且听吾辈细细说来。之所以出现这种情况，主要是因为二者的策略不同造成的。WebStorm 的目标是让用户拥有开箱即用的生产力工具，下载安装完成后就可以立即进行项目开发了，所以它将很多功能内置了 IDE 之中，或者是由官方开发插件出来，然后直接集成到 IDE 中，给个人开发者开发插件的机会不多。<br>而 VSCode 由于官方的开发团队没那么强大，而且又是免费的开源产品，所以理所当然只能发动广大人民群众的力量了，所以有很多插件就只能交给第三方开发者进行开发和维护。而这点也造成了安装完 VSCode 之后并不能立即使用，还需要下载插件、进行配置等一系列操作。<br>以上两种模式的孰优孰劣早有人分析过，这里吾辈只说自己的使用体验。WebStorm 的开箱即用做的确实比 VSCode 更好，但问题在于如果官方不支持的话就会很难受，因为其实并没有太多人同时精通前端和 Java（是的，必须使用 Java 开发插件）。这也是吾辈目前仍然使用 VSCode 作为主力文本编辑器编辑配置文件，以及使用它写 Markdown 文章的原因，包括这篇文章亦是通过 VSCode 写出来的。<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830235425.png" alt="Markdown 写作截图"></p><blockquote><p>附: 插件开放让第三方实现与官方自己实现并集成的优劣之分参考知乎的一篇文章: <a href="https://zhuanlan.zhihu.com/p/35303567">Visual Studio Code 有哪些工程方面的亮点</a>。<br>通过插件来扩展功能的做法已经是司空见惯了，但如何保证插件和原生功能一样优秀呢？历史告诉我们：不能保证。大家可以参考 Eclipse，插件模型可以说是做得非常彻底了，功能层面也是无所不能，但存在几个烦人的问题：不稳定、难用、慢，所以不少用户转投 IntelliJ 的怀抱。可谓成也插件，败也插件。问题的本质在于信息不对称，它导致不同团队写出来的代码，无论是思路还是质量，都不一致。最终，用户得到了一个又乱又卡的产品。所以要让插件在稳定性、速度和体验的层面都做到和原生功能统一，只能是一个美好的愿望。<br>来看看其他 IDE 是怎么做的，Visual Studio 自己搞定所有功能，并且做到优秀，让别人无事可做，这也成就了其 “宇宙第一 IDE” 的美名；IntelliJ 与之相仿，开箱即用，插件可有可无。这么看起来，自己搞定所有的事情是个好办法，但大家是否知道，Visual Studio 背后有上千人的工程团队，显然，这不是 VS Code 这二十几号人能搞定的。他们选择了让大家来做插件，那怎么解决 Eclipse 所遇到的问题呢？<br>这里分享一个小知识 ——Eclipse 核心部分的开发者就是早期的 VS Code 团队。嗯，所以他们没有两次踏入同一条河流。与 Eclipse 不同，VS Code 选择了把插件关进盒子里。<br>这样做首先解决的问题就是稳定性，这个问题对于 VS Code 来说尤为重要。都知道 VS Code 基于 Electron，实质上是个 node.js 环境，单线程，任何代码崩了都是灾难性后果。所以 VS Code 干脆不信任任何人，把插件们放到单独的进程里，任你折腾，主程序妥妥的。<br>VS Code 团队的这一决策不是没有原因的，正如前面提到的，团队里很多人其实是 Eclipse 的旧部，自然对 Eclipse 的插件模型有深入的思考。Eclipse 的设计目标之一就是把组件化推向极致，所以很多核心功能都是用插件的形式来实现的。遗憾的是，Eclipse 的插件运行在主进程中，任何插件性能不佳或者不稳定，都直接影响到 Eclipse，最终结果是大家抱怨 Eclipse 臃肿、慢、不稳定。VS Code 基于进程做到了物理级别的隔离，成功解决了该问题。实际上进程级别的隔离也带出了另一个话题，那就是界面与业务逻辑的隔离。</p></blockquote><h3 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h3><p>作为写代码的工具，代码提示已经司空见惯了。但是，就算同样是代码提示，有的代码提示只是简单的代码片段（<code>snippets</code>），而有的却是基于代码语法树分析进行的，甚至于编辑器会学习使用者的习惯，将最常用的提示放在最前面。WebStorm 从始至终一直都是第三种，而 VSCode 最近官方才开发了基于 AI 自动学习的智能提示插件 <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode">Visual Studio IntelliCode</a>。</p><p>VSCode<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030339.gif" alt="VSCode 智能提示"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030506.gif" alt="WebStorm 智能提示"></p><h3 id="自动修复"><a href="#自动修复" class="headerlink" title="自动修复"></a>自动修复</h3><p>我们在日常开发中经常会遇到一些低级问题，而编辑器其实是有可能帮我们自动修复的。这里便对吾辈了解的一些问题进行对比，问题详细信息请参考文章 <a href="https://blog.rxliuli.com/p/6e442bc3/">JavaScript 规范整理</a></p><blockquote><p>注: VSCode 没有原生的自动修复功能，必须使用插件才行。</p></blockquote><table><thead><tr><th>分类</th><th>对比项</th><th>VSCode</th><th>WebStorm</th></tr></thead><tbody><tr><td>命名规范</td><td></td><td></td><td></td></tr><tr><td></td><td>不要使用拼音命名</td><td>支持</td><td>支持</td></tr><tr><td></td><td>函数中的变量</td><td>支持</td><td>支持</td></tr><tr><td></td><td>内部变量</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>不要使用无意义的前缀命名</td><td>支持</td><td>支持</td></tr><tr><td>ES6</td><td></td><td></td><td></td></tr><tr><td></td><td>优先使用 const/let</td><td>支持</td><td>支持</td></tr><tr><td></td><td>使用新的函数声明方式</td><td>支持</td><td>支持</td></tr><tr><td></td><td>优先使用箭头函数而非 function</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>不要使用 if 判断再赋予默认值</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>优先使用 Map 做键值对映射而非传统的对象</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>优先使用模板字符串拼接多个字符串变量</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>当独立参数超过 3 个时使用对象参数并解构</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>不要写多余的 await</td><td>支持</td><td>支持</td></tr><tr><td></td><td>不要使用 == 进行比较</td><td>支持</td><td>支持</td></tr><tr><td></td><td>使用计算属性名替代使用方括号表示法赋值</td><td>不支持</td><td>不支持</td></tr><tr><td>逻辑代码</td><td></td><td></td><td></td></tr><tr><td></td><td>不要判断一个 Boolean 值并以此返回 Boolean 值</td><td>支持</td><td>支持</td></tr><tr><td></td><td>不要使用多余的变量</td><td>支持</td><td>支持</td></tr><tr><td></td><td>不要使用嵌套 if</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>不要先声明空对象然后一个个追加属性</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>不要使用无意义的函数包裹</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>不要使用三元运算符进行复杂的计算</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>如果变量有所关联则使用对象而非多个单独的变量</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>应该尽量解决编辑器警告</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>使用类型定义参数对象</td><td>不支持</td><td>不支持</td></tr><tr><td></td><td>尽量扁平化代码</td><td>支持</td><td>支持</td></tr><tr><td></td><td>自执行函数前面必须加分号</td><td>不支持</td><td>不支持</td></tr></tbody></table><p>下面是一张 WebStorm 官方使用自动修复的动图<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030641.gif" alt="WebStorm 自动修复"></p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>说起重构的话，VSCode 可以简单的说是做的太<strong>少</strong>，而 WebStorm 则是相反做的太<strong>多</strong>，下面继续以表格的形式进行对比。</p><blockquote><p>WebStorm 较新版本已经修复了 2018.02 重命名会自动索引字符串的问题（变成可选项了）。</p></blockquote><table><thead><tr><th>分类</th><th>操作</th><th>VSCode</th><th>WebStorm</th></tr></thead><tbody><tr><td>重命名</td><td></td><td></td><td></td></tr><tr><td></td><td>变量重名名</td><td>支持</td><td>支持</td></tr><tr><td></td><td>复杂变量重命名</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>全局重命名</td><td>支持</td><td>支持</td></tr><tr><td></td><td>正则重命名</td><td>存在 bug</td><td>支持</td></tr><tr><td></td><td>文件重命名</td><td>不支持</td><td>支持</td></tr><tr><td>提取</td><td></td><td></td><td></td></tr><tr><td></td><td>提取表达式为变量</td><td>支持</td><td>支持</td></tr><tr><td></td><td>提取代码段为函数</td><td>支持</td><td>支持</td></tr><tr><td></td><td>提取函数到新文件</td><td>支持</td><td>支持</td></tr></tbody></table><p>WebStorm 重命名文件<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831031020.gif" alt="WebStorm 重命名文件"></p><h3 id="Git-GitHub-集成"><a href="#Git-GitHub-集成" class="headerlink" title="Git/GitHub 集成"></a>Git/GitHub 集成</h3><p>VSCode 的 Git 支持一直不太行，就算加了插件 <a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</a> 也无法比得上 WebStorm。</p><table><thead><tr><th>分类</th><th>操作</th><th>VSCode</th><th>WebStorm</th></tr></thead><tbody><tr><td>Git</td><td></td><td></td><td></td></tr><tr><td></td><td>commit 提交</td><td>难用</td><td>支持</td></tr><tr><td></td><td>push 推送</td><td>支持</td><td>支持</td></tr><tr><td></td><td>pull 拉取</td><td>支持</td><td>支持</td></tr><tr><td></td><td>merge 合并</td><td>支持</td><td>支持</td></tr><tr><td></td><td>历史记录</td><td>难用</td><td>支持</td></tr><tr><td></td><td>reset 回退</td><td>支持</td><td>支持</td></tr><tr><td></td><td>revert 回退</td><td>难用</td><td>支持</td></tr><tr><td></td><td>stash 暂存</td><td>支持</td><td>支持</td></tr><tr><td></td><td>branch 分支操作</td><td>支持</td><td>支持</td></tr><tr><td>GitHub</td><td></td><td></td><td></td></tr><tr><td></td><td>分享到 GitHub</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>从 GitHub 选择拉取</td><td>不支持</td><td>支持</td></tr><tr><td></td><td>分享到 Gist</td><td>支持</td><td>支持</td></tr></tbody></table><p>放两张图对比一下</p><p>VSCode GitLens<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831022549.png" alt="GitLens"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831022643.png" alt="WebStorm Git"></p><h3 id="前端支持"><a href="#前端支持" class="headerlink" title="前端支持"></a>前端支持</h3><p>前面提过，VSCode 生态很好，基本上很多语言/框架都有支持，而且官方也有一些非常优秀的插件。但是，有一些地方很重要，VSCode 对于 HTML/CSS/JavaScript 这些 Web 基本元素的支持相比于 WebStorm 确实可以说的上是糟糕。</p><p>先来测试前端三剑客: <code>HTML/CSS/JavaScript</code>。</p><p>VSCode<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831004550.gif" alt="VSCode"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831003352.gif" alt="WebStorm"></p><p>可以看到，对于 HTML/CSS 之间的代码提示、跳转这些基本功能，VSCode 其实并没有做好。现代前端说是不再写 HTML 了，但实际上终究还是要写（即便是 JSX 还是要符合写 HTML 的直觉的），VSCode 代码提示在这里明显不太够看。还有一点也很有趣，VSCode 在打完 <code>document.querySelector(&#39;#hello&#39;)</code> 之后彻底没了动静，而 WebStorm 在 <code>style</code> 输入完成之后，立刻就有了各种 CSS 属性提示了。</p><blockquote><p>附: VSCode 中通过输入 <code>h1.hello#hello</code> Tab 之后就得到代码是一种前端 HTML 代码编写方式，被称为 <a href="https://www.qianduan.net/zen-coding-a-new-way-to-write-html-code/">Zen Coding</a>。但实际上，这种编写方式在代码提示方面存在劣势，所以使用 WebStorm 时并未演示。<br>附: VSCode 引用文件路径提示需要插件 <a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a></p></blockquote><p>对于库的开发者而言最难受的地方是 VSCode 实质上依赖于 TypeScript 才能做到代码提示，如果你也像吾辈是一位 JavaScript SDK 的开发者，那么也会遇到这件令人郁闷的事情: 如果想要使用你的 JavaScript SDK 的 VSCode 用户有正常的代码提示的话，你就必须接触 TypeScript。要么使用 TypeScript 重构整个 SDK，要么写 <em>.d.ts</em> 专门为 VSCode 维护一份注释文档，详情可以参考文章 <a href="https://blog.rxliuli.com/p/eeb7bc5/">JavaScript =&gt; TypeScript 迁移体验</a>。</p><h3 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h3><p>不知你是否曾遇到过，正在编辑着一个文件，突然断电，或者是因为其他什么原因，导致文件内容被清空了。或者是误删了代码之后之前的代码还没提交，又不能撤回那么多次，导致代码重写的经历呢？吾辈就曾经经历过，所以对本地历史记录这个功能相当重视，然而很遗憾，VSCode 依旧需要第三方插件 <a href="https://marketplace.visualstudio.com/items?itemName=xyz.local-history">Local History</a> 才能支持。</p><p>VSCode Local History<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831024208.png" alt="VSCode Local History"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831024420.png" alt="WebStorm"></p><p>两者相比主要有以下不同</p><table><thead><tr><th>对比项</th><th>VSCode</th><th>WebStorm</th></tr></thead><tbody><tr><td>原始文件是否为人类可读</td><td>是</td><td>否（XML 不列入人类可读格式中）</td></tr><tr><td>是否可以添加标签</td><td>否</td><td>是</td></tr><tr><td>是否可以对比</td><td>是</td><td>是</td></tr><tr><td>是否可以合并</td><td>否</td><td>是</td></tr></tbody></table><h3 id="主题配色"><a href="#主题配色" class="headerlink" title="主题配色"></a>主题配色</h3><p>两者都支持黑暗主题，而且都是默认设置，也同样支持使用插件定制界面。下面是两者的截图</p><p>VSCode<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830231558.png" alt="VSCode 主界面"></p><p>WebStorm<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830231815.png" alt="WebStorm 主界面"></p><p>事实上，上面两者都使用了主题。VSCode 是 Monokai，WebStorm 是 Material。但其实 WebStorm 的 <a href="https://plugins.jetbrains.com/plugin/8006">Material 主题</a> 还是存在一些 Bug 的，例如有些地方图标莫名的错位之类，VSCode 目前吾辈还未曾遇到过这类问题。</p><h3 id="使用性能"><a href="#使用性能" class="headerlink" title="使用性能"></a>使用性能</h3><p>WebStorm 确实很吃内存，尤其是项目刚刚打开的时候，索引会疯狂地吃 CPU/内存/硬盘，如果电脑性能不行的话这个过程所需时间可能泡面都够了。但基于 Chrome 内核的 VSCode 在使用各种插件打造成前端 IDE 之后吃的内存也并不少。吾辈打开了项目 <a href="https://github.com/rxliuli/rx-util">rx-util</a>，可以看到 VSCode 每个插件确实都放在了单独的进程里（Chrome 系的习惯 #笑），相比之下 WebStorm 只有两个进程，其中一个还是启动的 nodejs，整体对比下来其实相差不大。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831000118.png" alt="任务管理器"></p><hr><p>不得不承认的是，WebStorm 吃的性能终究还是要比 VSCode 多。但是，能用钱堆硬件解决的问题，能算问题么？</p><p><img src="/resource/ab1b4964df014897afb3f1b2832313d0.png" alt="1613744562293"></p><h3 id="工具集成"><a href="#工具集成" class="headerlink" title="工具集成"></a>工具集成</h3><p>JetBrains IDE 深度集成工具链，倾向于一切都以可视化界面点击/快捷键完成操作。而 VSCode 则有所不同，它有很多功能需要使用命令行/配置文件的形式完成。吾辈最开始使用 VSCode 时它甚至还没有配置界面，也只能使用 <code>launch.json</code> 启动 debugger（最新版似乎已经不是了），真是被吓到了。<br>在调试、运行支持的工具时，一般 VSCode 仍然需要使用命令行工具，或者在需要调试时编写 <code>launch.json</code> 配置脚本。但 WebStorm 则更加深度集成的工具链，倾向于一切都以可视化界面点击/快捷键完成操作。拿运行和调试代码为例，统一支持可视化的形式运行或调试（自动生成 ide 配置，并支持在必要的时候调整），目前支持 npm/gulp/浏览器 js/jest/nodejs/electron/typescript/git。</p><p>至于有人说一个命令的事情为什么要 ide 集成？</p><ul><li>安装依赖的时候停止索引，避免影响性能</li><li>简单启动调试（至今吾辈仍然没有彻底搞懂 vscode 的调试，为什么不能点一下就启动调试？至于是浏览器、nodejs、electron 可能存在不同的差异，让 ide 去屏蔽这一层不就好了，反正 ide 能识别出来项目使用的技术栈（至少是 ide 支持的技术栈））</li><li>显示单独的命令视图</li><li>快速查找/运行命令</li></ul><blockquote><p>有可能通过插件支持，但使用 VSCode 的人似乎更倾向于使用命令行（懒得找）。</p></blockquote><h3 id="远程-协作编辑"><a href="#远程-协作编辑" class="headerlink" title="远程/协作编辑"></a>远程/协作编辑</h3><p>VSCode 通过 <a href="https://github.com/MicrosoftDocs/live-share">live-share</a> 实现了远程开发，但 WebStorm 至今为止仍然 <a href="https://blog.jetbrains.com/tag/codewithme/">未能完全支持</a>。</p><table><thead><tr><th>比较项</th><th>VSCode</th><th>WebStorm</th></tr></thead><tbody><tr><td>协同编辑</td><td>是</td><td>EAP 阶段</td></tr><tr><td>WSL 支持</td><td>是</td><td>否</td></tr><tr><td>远程项目</td><td>是</td><td>否</td></tr><tr><td>画板支持</td><td>是</td><td>否</td></tr><tr><td>聊天</td><td>是</td><td>否</td></tr><tr><td>语音</td><td>是</td><td>否</td></tr><tr><td>免费</td><td>是</td><td>EAP 免费</td></tr></tbody></table><h3 id="东家"><a href="#东家" class="headerlink" title="东家"></a>东家</h3><p>VSCode 背后站着微软，俗成 **M$**，开发了宇宙最强 IDE Visual Studio。而 WebStorm 则是基于 JetBrains 平台专门为前端进行特殊处理优化的 IDE，背后则是业界最智能的 IDE 的开发公司 JetBrains（捷克公司）。两者在 IDE/编辑的开发上都相当有经验，然而，有一点本质的不同：IDE 对于 JetBrains 而言几乎是全部，而 VSCode 对于 M$ 则只是开发的一部分 – 编辑器。</p><p><code>VSCode =&gt; VSCode Remote =&gt; GitHub =&gt; GitHub Actions =&gt; Azure</code>，从 M$ 的一系列变化来看，这对开发者是真的相当上心，从本地开发、远程协作、版本控制、自动化流程控制 CI/CD 到部署到云端，完全是一站式的体验。相比于国内的云服务商，MS 显然更加开放、更加为开发者着想。<br>而 JetBrains，虽然现在也有了编程语言 <code>Kotlin</code>、项目管理工具 <code>Space</code>（包含 CI/CD 工具 <code>TeamCity</code>），但本质上在其领域内，除了 IDE，其他的东西都没能形成特别大的优势（Kotlin 只能用于开发 Android 平台，而 Web 技术甚至能开发全端；<code>TeamCity</code> 虽然很漂亮，但似乎人们更喜欢开源的 <code>Jenkins</code>）。<br>未来 VSCode 一统天下似乎是必然之势，但目前而言，其尚且年幼，唯有 WebStorm 正值壮年。</p><blockquote><p>附：例如某只企鹅，开发的大多数云服务都是私有服务，使用上比开源的还难用而且还强制绑定到自家云服务上，使人不得不用全家桶（问题是体验又烂，文档死难找）<br>附: 居然连 “文档和 Demo 有可能过期，但代码一定是最新的” 这种话都能说出来，与 MS 花大力气创造开源的 <code>VSCode</code> 简直是天壤之别。<br>附: 没有对比就没有伤害！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实在 Atom/VSCode 出现之前，WebStorm 因为在这个领域没有对手而发展缓慢，它们的出现使得 WebStorm 有了压力，良性竞争，这当然是好事。即便如此，就目前而言，VSCode 作为一个 IDE 来讲仍然比不上 JetBrains 全家桶系列。<br>说了上面这么多，总的来说: 如果你需要一个文本编辑器，那么推荐你用 VSCode，因为它既漂亮又生态丰富，想写点什么很方便。但是，如果你需要真正开发项目，则 WebStorm 更加合适，完全开箱即用的体验，不需要安装/配置任何插件就能立刻开始项目，强大的编辑器可以让你写代码更舒服一点。（其实是没钱就用免费的 VSCode，有钱就上 WebStorm 啦！）</p><blockquote><p>ref link: <a href="https://dev.to/mokkapps/why-i-switched-from-visual-studio-code-to-jetbrains-webstorm-939">Why I Switched From Visual Studio Code To JetBrains WebStorm</a><br>吾辈个人非常同意作者及相关评论的观点：为 WebStorm 付费能减少折腾 VSCode 的时间，VSCode 的真正优势是启动时间，使用内存和免费。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书 [黑客与画家]</title>
    <link href="/p/9b97e55025d64d04b1487be92ebfd51d/"/>
    <url>/p/9b97e55025d64d04b1487be92ebfd51d/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>黑客新想法的最佳来源，并非那些名字里有［计算机］三个字的理论领域，而是来自于其他创作领域。</p></blockquote><p>这是一篇读书感悟的文章，来源于最近阅读的书籍 <a href="https://book.douban.com/subject/6021440/">黑客与画家</a>。</p><blockquote><p>摘抄自豆瓣<br><strong>书籍简介</strong>：<br>     本书是硅谷创业之父 Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。<br>     本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。<br><strong>作者简介</strong>:<br>     保罗・格雷厄姆，《黑客与画家》一书的作者，硅谷创业之父。1964 年，出生于匹兹堡郊区的一个中产阶级家庭。父亲是设计核反应堆的物理学家，母亲在家照看他和他的妹妹。青少年时代，格雷厄姆就开始编程。但是，他还喜欢许多与计算机无关的东西，这在编程高手之中是很少见的。<br>     保罗・格雷厄姆在康奈尔大学读完本科，然后在哈佛大学获得计算机科学博士学位。1995 年，他创办了 Viaweb，帮助个人用户在网上开店，这是世界上第一个互联网应用程序。1998 年夏天，Yahoo! 公司收购了 Viaweb，收购价约为 5000 万美元。<br>     此后，他架起了个人网站 paulgraham.com，在上面撰写了许许多多关于软件和创业的文章，以深刻的见解和清晰的表达而著称，迅速引起了轰动。2005 年，他身体力行，创建了风险投资公司 Y Combinator，将自己的理论转化为实践，目前已经资助了 80 多家创业公司。现在，他是公认的互联网创业权威。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190713024824.png" alt="书籍照片"></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前吾辈也曾经坚信电子书籍（<strong>Epub/PDF</strong>）要比纸质书籍更好，方便携带，随时都能阅读。直到遇到了一位 dalao 的指点 – <strong>只要买了书，放在那里，总有机会去看看的。</strong> 之后，吾辈便尝试买了一些实体书，晚上回来闲暇片刻便会看看。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190713024216.jpg" alt="书架图片"></p><p>最近一周，吾辈便把黑客与画家看完了。当然，之前已经看过电子版的了。作者真的很厉害，既是第一个互联网程序的开发者，也是一个画家，更是一个顶级<strong>黑客</strong>（非<strong>骇客</strong>）。然后，他写完这本书之后，还变成了作者。当然，译者也同样是位知名人物 – <a href="https://www.ruanyifeng.com/">阮一峰</a>。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>读这本书的时候，才发现<strong>真-大佬</strong>的想法真的很厉害，尤其是关于创造财富那一章，有许多思想值得吾辈深思。<br>下面摘抄一些内容并谈谈吾辈的想法</p><blockquote><p>书呆子不受欢迎的真正原因，是他们脑子里都在想着别的事情，他们的注意力都放在读书或者观察世界上面，而不是穿衣打扮、开晚会上面。</p></blockquote><p>嗯，吾辈想这大抵是作者的亲身体会：作为一个聪明人却不受欢迎 #笑 不过就吾辈经历而言，读书好的人一般也不会太受排挤，或许这是因为国情不同的原因吧 – 国内不论如何都把成绩作为第一位，而据作者所说美国的中学生并不会特别对待学习，至少，不会拼命去学，也不会因此自杀。</p><blockquote><p>黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。</p></blockquote><p>想想国内的大环境，吾辈瞬间心酸得落下了眼泪。说是创作者，但实际上，开发者被称为<strong>码农</strong>不是没有道理的 – 只是实现经理所要求的功能，而不是决定功能应该如何设计 – 这被交给了其他人！当然，拥有/参与开源项目可以减少这个问题，因为可以决定功能如何设计而非实现。但本质上还是在代码的圈子里打转，并没有创造出人们真正需要用到的东西。</p><blockquote><p>程序写出来是给人看的，附带能在机器上运行。</p></blockquote><p>这不是吾辈第一次看见这句话了，但在工作过程中，吾辈发现实际上这句话并没有多少开发者真的在意过 – 包括一些 dalao。为了性能死扣算法，没错吾辈就是在吐槽一些公司任何职位都要面试算法，简直成 <a href="https://leetcode.com/">leetcode</a> 算法面试公司了。大部分场景实际上并不需要开发者手写算法进行优化，因为现在的计算机已经足够快了。手写算法再加上耦合业务，只会让代码变得无比丑陋，难以维护 – 仅仅是为了在某个地方稍微快一点。</p><blockquote><p>在某些地方，自行其道，完全不替读者着想，被看成是高水平、高智商的表现，甚至都发展成了一种风尚。</p></blockquote><p>是的，有些人就是为了炫技而写出来各种<em>奇葩</em>的代码，导致其他人再看代码时，纷纷惊呼：“<strong>这是什么神仙代码？！</strong>”。在他们看来，写出来的代码让别人看不懂，自己说的话让别人听不懂，是一种<em>高水准</em>的表现，甚至于说：“<strong>这降低了 SB 来烦我的概率</strong>”。甚至于刻意不写注释，然后辩解说：“<strong>类型系统就是最好的注释</strong>”<br>关于这点，作者也在后面进一步评论了。</p><blockquote><p>但是，我不觉得 “换位思考” 与智商之间存在任何联系。在数学和自然科学领域，你用学习怎么向别人表达自己，也能却得很好的成就。而那些领域的人普遍很聪明，所以人们很自然地就把 “聪明” 与 “不懂得换位思考” 联系了起来。但是，世界上还有许许多多很笨的人，也同样不懂得 “换位思考”。</p></blockquote><p>最后一句真是说出了大实话 – <strong>伪-大佬</strong>。</p><blockquote><p>我家附近，一辆汽车的保险杠贴着一张粘纸，上面写着 “太麻烦，不如死”（death before inconvenience）。大多数人，在大多数时候，总是选择最省事的做法。如果互联网软件能够击败桌面软件，一定是赢在更方便这一优势上。无论从用户的角度还是从开发者的角度来看都是如此。</p></blockquote><p>是的，现在浏览器已经击败了客户端软件，甚至在原本必须要使用客户端的地方使用 Web 技术进行了入侵（<a href="https://electronjs.org/">Electron</a>，<a href="https://facebook.github.io/react-native/">React Native</a>）。但这并不意味人们知道这件事就会真的对用户更友好，尤其是对于免费的开源程序而言。用户不再是首位要素，动辄要求使用者去看源码，吐槽就会被说 “<strong>爱用用不用滚，You can you do？</strong>”。你敢相信？但这就是国内开源现状。</p><blockquote><p>开发软件需要的程序员人数减少，不仅意味着省下更多的钱。正如《人月神话》一书中所指出的，向一个项目增加人手，往往会拖慢项目进程。随着参与人数的增加，人与人之间需要的沟通呈现指数式增长。人数越来越多，开会讨论各个部分如何协同工作所需要的时间越来越长，无法预见的互相影响越多越大，产生的 bug 也越来越多。幸运的是，这个过程的逆向也成立：人数越来越少，软件开发的效率将指数式增长。</p></blockquote><p>所以说这就是小公司能生存下来的原因么？#笑 想到之前项目实际上只有 3 个人全职开发就发现，其实也不是那么奇怪呢</p><blockquote><p>桌面软甲迫使用户变成系统管理员，互联网软件则是迫使程序员变成系统管理员：用户的压力变小了，程序员的压力变大了。</p></blockquote><p>唉，小公司别说系统管理员了，就连前端，后端，运维，测试都要会一点才行，必须是 <strong>多面手/万金油</strong> 才能生存下去。</p><blockquote><p>许多人从小就认定世界上的财富总额是固定不变的，这样想的人数多的惊人。<br>小时候我就对这一点深信不疑：如果夫人拿走了所有的钱，那么其他人就变得更穷了。许多成年人至今都是类似看法的信徒。每当有人提到 <em>x%</em> 的人口占有了 <em>y%</em> 的财富，他的言下之意往往就包含了这种错误的观点。</p></blockquote><p>嘛，吾辈也曾经是这样想的人之一（一个普通的不能再普通的人）。但这个观点在看完本书后刷新了，财富在净增长 – 代价是地球本身。</p><blockquote><p>确实有一些 CEO 的收入太高，不合理，但是有没有 CEO 的收入不足以体现他所创造的财富的呢？乔布斯就是这样的例子。他拯救了濒临崩溃的苹果公司，扭转了危机，削减了成本，成功决策了下一代产品。他的收入就低于他的工作所创造的价值。</p></blockquote><p>是的，这点确实很厉害，尤其是吾辈正在看的 <a href="https://book.douban.com/subject/26792439/">浪潮之巅</a> 一书也谈及了他，确实是个 <strong>真-大佬</strong>。</p><blockquote><p>在垃圾邮件业中，如果发送销售类垃圾邮件受到限制，那么整个行业将不可避免地受到重创。“行业”这个词是很准确的，发送垃圾邮件的人其实都是商人，他们这么做只是因为这招很有效。虽然垃圾邮件的回应率低到不能再低了（不超过百万分之 15，相比之下，传统的邮寄商品目录的回应率是百万分之 3000），但是发送垃圾邮件的成本实际上为零，所以它还是有效的。但是对于收到垃圾邮件的人来说，成本却很高昂，假定有 100 万人分别收到一封垃圾邮件，每人花一秒钟删除，累计起来就相当于一个人 5 个星期的工作量，而发送人连一分钱也不用付出。<br>不过，虽然接近于零，发送垃圾邮件还是有成本的^。所以，只要我们把垃圾邮件的回应率降得很低（不管手段是直接过滤，还是让垃圾邮件被迫掩盖它们的销售意图），商家就会发现，发送垃圾邮件是一件经济上不值得的事情。</p></blockquote><p>这让吾辈想到了现在的广告过滤行业，嗯，没错是行业 – <a href="https://adblockplus.org/">Adblock Plus</a> 把这事做成了生意。广告屏蔽插件流行了起来之后，广告受益者就会烦恼，会提示让用户关闭广告过滤以支持网站，或者，直接关闭页面拒绝使用 – 直到关闭了广告过滤为止。后来，开始出现了屏蔽那些网页上检测广告的脚本 – 反屏蔽广告脚本。这个斗争其实可以一直进行下去，终究是收益与代价的权衡罢了。</p><blockquote><p>好设计是简单的设计。从数学领域到绘画领域，你都可以听到这种说法。在数学中，它表示简短的证明往往是更好的证明。特别是对于数学公理来说，少即是多。在编程中，这种说法也基本适用。</p></blockquote><p><strong>少即是多</strong>，能满足这一点的库/框架并不多，<a href="https://www.lodashjs.com/">Lodash</a> 是一个正例，<a href="https://reactjs.org/">React</a> 某种程度上来说是个反例。不管是程序（<a href="https://web.sanguosha.com/">三国杀</a>），还是库（<a href="https://github.com/rxliuli/rx-util">rx-util</a>），开发者总是喜欢增加功能，逐渐提高复杂度，最后让人难以接受。这里吐槽一下国产程序，只会逐渐增加功能，永远学不会什么叫<strong>减法</strong>。</p><blockquote><p>高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C 语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而 Lisp 语言的层次则是相当高。</p></blockquote><p><code>Lisp</code> 之前一直有听闻过，但吾辈还从未真正使用过。在编程语言领域，吾辈接触过 <code>Java</code>, <code>JavaScript</code>, <code>Scala</code>, <code>C#</code>，然而他们都不能支持 <code>Lisp</code> 中一些非常高级的功能（宏）。</p><p>下面作者列出了 Lisp 的创新功能</p><ol><li> 条件结构（即 if-then-else 结构）。现在大家都觉得这是理所当然的，但是 FortranI 就没有这个结构，它只有基于底层机器指令的 goto 结构。</li><li> 函数也是一种数据类型。在 Lisp 语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。</li><li>递归。Lisp 是第一种支持递归函数的高级语言^。<br> ^「Lisp 语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在 20 世纪 50 年代的 IPL-V 语言中出现过。但是，IPL-V 更像是汇编语言，它的程序中充满了操作码/地址对。参见 Alien Newell 等人编著的《IPL-V 语言操作手册》（Information Processing Language-V Manual），Prentice-Hail，1961 年出版。」</li><li>变量的动态类型。在 Lisp 语言中，所有变量实际上都是指针，所指向的值有类<br> 型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。</li><li> 垃圾回收机制。</li><li>程序由表达式组成。Lisp 程序是一些表达式树的集合，每个表达式都返回一个值。这与 Fortran 和大多数后来的语言都截然不同，它们的程序由表达式和语句组成。区分表达式和语句在 Fortran I 中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。<br> 后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从 Fortran 扩散到 Algol 语言，接着又扩散到它们两者的后继语言。</li><li>符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较<br> 两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。</li><li> 代码使用符号和常量组成的树形表示法。</li><li> 无论什么时候，整个语言都是可用的。Lisp 并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。</li></ol><p>Lisp 确实开创了许多功能，成功引起了吾辈的兴趣，以后有机会会去看一下作者写的 Lisp 的书籍吧</p><blockquote><p>大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有优秀软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。<br>编程语言的最高境界一直在发展之中。虽然语言的核心功能就像大海的深处，很少有变化，但是函数库和开发环境之类的东西就像大海的表面，一直在汹涌澎湃。</p></blockquote><p>是啊，所以现在流行 react，流行 webpack，流行 typescript，甚至曾经有人吐槽 <a href="https://blog.rxliuli.com/p/78dc231c/">2016 年里做前端是怎样一种体验</a>。各种各样的框架和库，说不定过不了一段时间就死掉了（前车之鉴），这些都是浪潮的表面。不过总有人喜欢折腾代码，而不是完成一个真正可以给其他人用的东西。疯狂造一堆<del>没人用的</del>轮子，美其名曰不做调参工程师。当然，尝试实现便于了解深层原理，然而如果不加节制什么东西都觉得自己造才好就是典型的浪费时间。</p><blockquote><p>先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果，这好比让你看到不远处就是唾手可得的奖励，你因此会受到激励和鼓舞。<br>跟你说实话吧，画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”这种情况对于第一线的程序员真是再熟悉不过了。</p></blockquote><p>是啊，能看到效果的原型很重要，看不到效果的开发是艰苦而烦躁的。而且出现错误了都无法进行调试，实在是不能更糟糕了。有些开源项目目标很大，花费的时间过长，长期做不出来一个可用版本，久而久之，就半路放弃了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，上面是一些看书的想法以及吐槽，这本书籍吾辈强烈推荐 – 即便不是 IT 行业。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown 语法说明</title>
    <link href="/p/bd28a44b915d42979c145bf8dfef8e98/"/>
    <url>/p/bd28a44b915d42979c145bf8dfef8e98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>已经有更好、更全面的介绍了，此页面将没有太多参考的价值。<br>参考：<a href="https://www.markdownguide.org/">markdown guide</a>, <a href="https://www.markdown.xyz/">中文翻译</a></p></blockquote><ul><li><a href="#markdown-%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E">markdown 语法说明</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#%E5%AE%97%E6%97%A8">宗旨</a></li><li><a href="#%E5%85%BC%E5%AE%B9-html">兼容 HTML</a></li><li><a href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">特殊字符自动转换</a></li></ul></li><li><a href="#%E5%8C%BA%E5%9D%97%E5%85%83%E7%B4%A0">区块元素</a><ul><li><a href="#%E6%AE%B5%E8%90%BD%E5%92%8C%E6%8D%A2%E8%A1%8C">段落和换行</a></li><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8-blockquotes">区块引用 Blockquotes</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97">代码区块</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li></ul></li><li><a href="#%E5%8C%BA%E6%AE%B5%E5%85%83%E7%B4%A0">区段元素</a><ul><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%BC%BA%E8%B0%83">强调</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li></ul></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a><ul><li><a href="#%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5">自动链接</a></li><li><a href="#%E5%8F%8D%E6%96%9C%E6%9D%A0">反斜杠</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">扩展语法</a><ul><li><a href="#%E4%BD%BF%E7%94%A8--%E6%8D%A2%E8%A1%8C">使用 <code>\</code> 换行</a></li><li><a href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%9D%97">语言特定代码块</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8">任务列表</a></li></ul></li><li><a href="#markdown-%E5%85%8D%E8%B4%B9%E7%BC%96%E8%BE%91%E5%99%A8">Markdown 免费编辑器</a></li></ul></li></ul><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本文引用自 <a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a>，吾辈添加/修复了一些内容。<br>本文同步部署到为了网站 <a href="https://md-syntax.rxliuli.com/">https://md-syntax.rxliuli.com/</a>，如有需要可以收藏（#笑）。</p></blockquote><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<strong>强调</strong>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p><h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p><p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p><p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p><p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">这是一个普通段落。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br>这是另一个普通段落。<br></code></pre></td></tr></table></figure><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p><p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p><p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p><h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;q=larry+bird<br></code></pre></td></tr></table></figure><p>你必须要把网址转换写为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//im</span>ages.google.com/images?num=<span class="hljs-number">30</span>&amp;amp;q=larry+bird<br></code></pre></td></tr></table></figure><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p><p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p><p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">&amp;<span class="hljs-keyword">copy</span><span class="bash">;</span><br></code></pre></td></tr></table></figure><p>Markdown 会保留它不动。而若你写：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">AT<span class="hljs-meta">&amp;T</span><br></code></pre></td></tr></table></figure><p>Markdown 就会将它转为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">AT</span>&amp;amp<span class="hljs-comment">;T</span><br></code></pre></td></tr></table></figure><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Markdown 将会把它转换为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>&amp;lt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p><hr><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p><p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p><p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p><p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p><p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">This is an H1<br>=============<br><br>This is an H2<br>-------------<br></code></pre></td></tr></table></figure><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 这是 H1<br><br>## 这是 H2<br><br>###### 这是 H6<br></code></pre></td></tr></table></figure><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 这是 H1 #<br><br>## 这是 H2 ##<br><br>### 这是 H3 ######<br></code></pre></td></tr></table></figure><h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.<br>&gt;<br>&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>&gt; id sem consectetuer libero luctus adipiscing.<br></code></pre></td></tr></table></figure><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.<br><br>&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.<br></code></pre></td></tr></table></figure><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt; This is the first level of quoting.<br>&gt;<br>&gt; &gt; This is nested blockquote.<br>&gt;<br>&gt; Back to the first level.<br></code></pre></td></tr></table></figure><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt; ## 这是一个标题。<br>&gt;<br>&gt; 1.   这是第一行列表项。<br>&gt; 2.   这是第二行列表项。<br>&gt;<br>&gt; 给出一些例子代码：<br>&gt;<br>&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);<br></code></pre></td></tr></table></figure><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号、加号或是减号作为列表标记：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*   </span>Red<br><span class="hljs-bullet">*   </span>Green<br><span class="hljs-bullet">*   </span>Blue<br></code></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span>   Red<br><span class="hljs-bullet">+</span>   Green<br><span class="hljs-bullet">+</span>   Blue<br></code></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">-   </span>Red<br><span class="hljs-bullet">-   </span>Green<br><span class="hljs-bullet">-   </span>Blue<br></code></pre></td></tr></table></figure><p>有序列表则使用数字接着一个英文句点：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>  Bird<br><span class="hljs-bullet">2.</span>  McHale<br><span class="hljs-bullet">3.</span>  Parish<br></code></pre></td></tr></table></figure><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bird<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>McHale<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Parish<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你的列表标记写成：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span>  Bird<br><span class="hljs-bullet">1.</span>  McHale<br><span class="hljs-bullet">1.</span>  Parish<br></code></pre></td></tr></table></figure><p>或甚至是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">3.</span> Bird<br><span class="hljs-bullet">1.</span> McHale<br><span class="hljs-bullet">8.</span> Parish<br></code></pre></td></tr></table></figure><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>    viverra nec, fringilla in, laoreet vitae, risus.<br>*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>    Suspendisse id sem consectetuer libero luctus adipiscing.<br></code></pre></td></tr></table></figure><p>但是如果你懒，那也行：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.<br>*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.<br></code></pre></td></tr></table></figure><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*   </span>Bird<br><span class="hljs-bullet">*   </span>Magic<br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bird<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Magic<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是这个：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*   </span>Bird<br><br><span class="hljs-bullet">*   </span>Magic<br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Bird<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Magic<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span>  This <span class="hljs-keyword">is</span> a <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span> <span class="hljs-keyword">with</span> two <span class="hljs-built_in">paragraphs</span>. Lorem ipsum dolor<br>    sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>    mi posuere lectus.<br><br>    Vestibulum enim wisi, viverra nec, fringilla <span class="hljs-keyword">in</span>, laoreet<br>    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>    sit amet velit.<br><br><span class="hljs-number">2.</span>  Suspendisse <span class="hljs-built_in">id</span> sem consectetuer libero luctus adipiscing.<br></code></pre></td></tr></table></figure><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">*   This <span class="hljs-keyword">is</span> a <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span> <span class="hljs-keyword">with</span> two <span class="hljs-built_in">paragraphs</span>.<br><br>    This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-built_in">paragraph</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">item</span>. You&#x27;re<br>only required <span class="hljs-keyword">to</span> indent <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> line. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit.<br><br>*   Another <span class="hljs-built_in">item</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">list</span>.<br></code></pre></td></tr></table></figure><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">*   A list <span class="hljs-keyword">item</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> blockquote:<br><br>    &gt; This is <span class="hljs-keyword">a</span> blockquote<br>    &gt; inside <span class="hljs-keyword">a</span> list <span class="hljs-keyword">item</span>.<br></code></pre></td></tr></table></figure><p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*   </span>一列表项包含一个列表区块：<br><br><span class="hljs-code">        &lt;代码写在这&gt;</span><br></code></pre></td></tr></table></figure><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1986.</span> What a great season.<br></code></pre></td></tr></table></figure><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1986</span>\. What a great season.<br></code></pre></td></tr></table></figure><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">这是一个普通段落：<br><br>    这是一个代码区块。<br></code></pre></td></tr></table></figure><p>Markdown 会转换成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个普通段落：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>这是一个代码区块。<br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Here <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">of</span> <span class="hljs-literal">AppleScript</span>:<br><br>    <span class="hljs-keyword">tell</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;Foo&quot;</span><br>        <span class="hljs-built_in">beep</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">tell</span><br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;p&gt;Here <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">of</span> <span class="hljs-literal">AppleScript</span>:&lt;/p&gt;<br><br>&lt;pre&gt;&lt;code&gt;<span class="hljs-keyword">tell</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;Foo&quot;</span><br>    <span class="hljs-built_in">beep</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">tell</span><br>&lt;/code&gt;&lt;/pre&gt;<br></code></pre></td></tr></table></figure><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;<br>    &amp;<span class="hljs-keyword">copy</span>; <span class="hljs-number">2004</span> Foo Corporation<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;pre&gt;</span><span class="hljs-params">&lt;code&gt;</span><span class="hljs-variable">&amp;lt</span>;div class=<span class="hljs-string">&quot;footer&quot;</span><span class="hljs-variable">&amp;gt</span>;<br>    <span class="hljs-variable">&amp;amp</span>;copy; <span class="hljs-number">2004</span> Foo Corporation<br><span class="hljs-variable">&amp;lt</span>;/div<span class="hljs-variable">&amp;gt</span>;<br><span class="hljs-params">&lt;/code&gt;</span><span class="hljs-params">&lt;/pre&gt;</span><br></code></pre></td></tr></table></figure><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* *</span><br><br><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-strong"><span class="hljs-emphasis"></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">****</span>*</span></span><br><span class="hljs-strong"></span><br><span class="hljs-strong">- - -</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">---------------------------------------</span><br></code></pre></td></tr></table></figure><hr><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">This <span class="hljs-built_in">is</span> [an <span class="hljs-built_in">example</span>](http://<span class="hljs-built_in">example</span>.com/ <span class="hljs-string">&quot;Title&quot;</span>) inline link.<br><br>[This link](http://<span class="hljs-built_in">example</span>.net/) has no <span class="hljs-built_in">title</span> attribute.<br></code></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Title&quot;</span>&gt;</span><br>an example<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> inline link.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.net/&quot;</span>&gt;</span>This link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> has no<br>title attribute.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">See my [About](<span class="hljs-regexp">/about/</span>) page <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This <span class="hljs-keyword">is</span> [an example][<span class="hljs-built_in">id</span>] <span class="hljs-keyword">reference</span>-style link.<br></code></pre></td></tr></table></figure><p>你也可以选择性地在两个方括号中间加上一个空格：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This <span class="hljs-keyword">is</span> [an example] [<span class="hljs-built_in">id</span>] <span class="hljs-keyword">reference</span>-style link.<br></code></pre></td></tr></table></figure><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[id]: http:<span class="hljs-regexp">//</span>example.com/  <span class="hljs-string">&quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">foo</span>]: <span class="hljs-link">http://example.com/  &quot;Optional Title Here&quot;</span><br>[<span class="hljs-symbol">foo</span>]: <span class="hljs-link">http://example.com/  &#x27;Optional Title Here&#x27;</span><br>[<span class="hljs-symbol">foo</span>]: <span class="hljs-link">http://example.com/  (Optional Title Here)</span><br></code></pre></td></tr></table></figure><p>**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用尖括号包起来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[id]: &lt;http:<span class="hljs-regexp">//</span>example.com/&gt;  <span class="hljs-string">&quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[id]: http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/longish/</span>path<span class="hljs-regexp">/to/</span>resource/here<br>    <span class="hljs-string">&quot;Optional Title Here&quot;</span><br></code></pre></td></tr></table></figure><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[link text][a]<br>[link text][A]<br></code></pre></td></tr></table></figure><p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[Google][]<br></code></pre></td></tr></table></figure><p>然后定义链接内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">Google</span>]: <span class="hljs-link">http://google.com/</span><br></code></pre></td></tr></table></figure><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Visit</span> [<span class="hljs-symbol">Daring</span> <span class="hljs-symbol">Fireball</span>][] for more information.<br></code></pre></td></tr></table></figure><p>然后接着定义链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">Daring Fireball</span>]: <span class="hljs-link">http://daringfireball.net/</span><br></code></pre></td></tr></table></figure><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">get</span> 10 <span class="hljs-selector-tag">times</span> <span class="hljs-selector-tag">more</span> <span class="hljs-selector-tag">traffic</span> <span class="hljs-selector-tag">from</span> <span class="hljs-selector-attr">[Google]</span> <span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-tag">than</span> <span class="hljs-selector-tag">from</span><br><span class="hljs-selector-attr">[Yahoo]</span> <span class="hljs-selector-attr">[2]</span> <span class="hljs-selector-tag">or</span> <span class="hljs-selector-attr">[MSN]</span> <span class="hljs-selector-attr">[3]</span>.<br><br>  <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">google</span><span class="hljs-selector-class">.com</span>/        &quot;<span class="hljs-selector-tag">Google</span>&quot;<br>  <span class="hljs-selector-attr">[2]</span>: <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">search</span><span class="hljs-selector-class">.yahoo</span><span class="hljs-selector-class">.com</span>/  &quot;<span class="hljs-selector-tag">Yahoo</span> <span class="hljs-selector-tag">Search</span>&quot;<br>  <span class="hljs-selector-attr">[3]</span>: <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">search</span><span class="hljs-selector-class">.msn</span><span class="hljs-selector-class">.com</span>/    &quot;<span class="hljs-selector-tag">MSN</span> <span class="hljs-selector-tag">Search</span>&quot;<br></code></pre></td></tr></table></figure><p>如果改成用链接名称的方式写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">get</span> 10 <span class="hljs-selector-tag">times</span> <span class="hljs-selector-tag">more</span> <span class="hljs-selector-tag">traffic</span> <span class="hljs-selector-tag">from</span> <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">than</span> <span class="hljs-selector-tag">from</span><br><span class="hljs-selector-attr">[Yahoo]</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">or</span> <span class="hljs-selector-attr">[MSN]</span><span class="hljs-selector-attr">[]</span>.<br><br>  <span class="hljs-selector-attr">[google]</span>: <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">google</span><span class="hljs-selector-class">.com</span>/        &quot;<span class="hljs-selector-tag">Google</span>&quot;<br>  <span class="hljs-selector-attr">[yahoo]</span>:  <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">search</span><span class="hljs-selector-class">.yahoo</span><span class="hljs-selector-class">.com</span>/  &quot;<span class="hljs-selector-tag">Yahoo</span> <span class="hljs-selector-tag">Search</span>&quot;<br>  <span class="hljs-selector-attr">[msn]</span>:    <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">search</span><span class="hljs-selector-class">.msn</span><span class="hljs-selector-class">.com</span>/    &quot;<span class="hljs-selector-tag">MSN</span> <span class="hljs-selector-tag">Search</span>&quot;<br></code></pre></td></tr></table></figure><p>上面两种写法都会产生下面的 HTML。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;p&gt;I <span class="hljs-builtin-name">get</span> 10 times more traffic <span class="hljs-keyword">from</span> &lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;http://google.com/&quot;</span><br><span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Google&quot;</span>&gt;Google&lt;/a&gt; than <span class="hljs-keyword">from</span><br>&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;http://search.yahoo.com/&quot;</span> <span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Yahoo Search&quot;</span>&gt;Yahoo&lt;/a&gt;<br><span class="hljs-keyword">or</span> &lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;http://search.msn.com/&quot;</span> <span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;MSN Search&quot;</span>&gt;MSN&lt;/a&gt;.&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">I get <span class="hljs-number">10</span> times more traffic from [Google](http:<span class="hljs-regexp">//g</span>oogle.com/ <span class="hljs-string">&quot;Google&quot;</span>)<br>than from [Yahoo](http:<span class="hljs-regexp">//</span>search.yahoo.com/ <span class="hljs-string">&quot;Yahoo Search&quot;</span>) or<br>[MSN](http:<span class="hljs-regexp">//</span>search.msn.com/ <span class="hljs-string">&quot;MSN Search&quot;</span>).<br></code></pre></td></tr></table></figure><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p><p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*single asterisks*</span><br><br><span class="hljs-emphasis">_single underscores_</span><br><br><span class="hljs-strong">**double asterisks**</span><br><br><span class="hljs-emphasis">__double underscores__</span><br></code></pre></td></tr></table></figure><p>会转成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>single asterisks<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>single underscores<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>double asterisks<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>double underscores<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">un<span class="hljs-number">*f</span>rigging<span class="hljs-number">*be</span>lievable<br></code></pre></td></tr></table></figure><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">\*<span class="hljs-keyword">this</span> text <span class="hljs-keyword">is</span> surrounded <span class="hljs-keyword">by</span> literal asterisks\*<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>Markdown 可以在一行中用两个 (<del>) 符号 包裹一段文字，会被转成 <code>&lt;del&gt;</code> 包裹起来的内容，显示为 ~~删除</del>。</p><p>例如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~删除~~<br></code></pre></td></tr></table></figure><p>会转成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要连续使用两个 ~ 符号，则可以使用反斜线：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">~<span class="hljs-symbol">\~</span>删除~<span class="hljs-symbol">\~</span><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>`</code>），例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Use</span> the `printf()` <span class="hljs-keyword">function</span>.<br></code></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Use the <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>printf()<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> function.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">``There is a literal backtick (`) here.``<br></code></pre></td></tr></table></figure><p>这段语法会产生：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>There is a literal backtick (`) here.<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">A single backtick in a code span:</span> `` ` ``<br><br><span class="hljs-title">A backtick-delimited string in a code span:</span> `` `foo` ``<br></code></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A single backtick in a code span: <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>`<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A backtick-delimited string in a code span: <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>`foo`<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Please don<span class="hljs-symbol">&#x27;t</span> <span class="hljs-keyword">use</span> any `&lt;blink&gt;` tags.<br></code></pre></td></tr></table></figure><p>转为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Please don&#x27;t use any <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>blink<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> tags.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你也可以这样写：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-string">`&amp;#8212;`</span> <span class="hljs-keyword">is</span> the decimal-encoded equivalent of <span class="hljs-string">`&amp;mdash;`</span>.<br></code></pre></td></tr></table></figure><p>以产生：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;amp;</span>#8212;<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> is the decimal-encoded<br>equivalent of <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-symbol">&amp;amp;</span>mdash;<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p><p>行内式的图片语法看起来像是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">![Alt <span class="hljs-type">text</span>](/<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/img.jpg)<br><br>![Alt <span class="hljs-type">text</span>](/<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/img.jpg &quot;Optional title&quot;)<br></code></pre></td></tr></table></figure><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">![Alt <span class="hljs-built_in">text</span>][<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[<span class="hljs-built_in">id</span>]: url/<span class="hljs-keyword">to</span>/image  <span class="hljs-string">&quot;Optional title attribute&quot;</span><br></code></pre></td></tr></table></figure><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;http:<span class="hljs-regexp">//</span>example.com/&gt;<br></code></pre></td></tr></table></figure><p>Markdown 会转为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;a href=<span class="hljs-string">&quot;http://example.com/&quot;</span>&gt;http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/&lt;/</span>a&gt;<br></code></pre></td></tr></table></figure><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;<span class="hljs-symbol">address@</span>example.com&gt;<br></code></pre></td></tr></table></figure><p>Markdown 会转成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#x6D;</span><span class="hljs-symbol">&amp;#x61;</span>i<span class="hljs-symbol">&amp;#x6C;</span><span class="hljs-symbol">&amp;#x74;</span><span class="hljs-symbol">&amp;#x6F;</span>:<span class="hljs-symbol">&amp;#x61;</span><span class="hljs-symbol">&amp;#x64;</span><span class="hljs-symbol">&amp;#x64;</span><span class="hljs-symbol">&amp;#x72;</span><span class="hljs-symbol">&amp;#x65;</span></span></span><br><span class="hljs-tag"><span class="hljs-string"><span class="hljs-symbol">&amp;#115;</span><span class="hljs-symbol">&amp;#115;</span><span class="hljs-symbol">&amp;#64;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#120;</span><span class="hljs-symbol">&amp;#x61;</span><span class="hljs-symbol">&amp;#109;</span><span class="hljs-symbol">&amp;#x70;</span><span class="hljs-symbol">&amp;#x6C;</span>e<span class="hljs-symbol">&amp;#x2E;</span><span class="hljs-symbol">&amp;#99;</span><span class="hljs-symbol">&amp;#111;</span></span></span><br><span class="hljs-tag"><span class="hljs-string"><span class="hljs-symbol">&amp;#109;</span>&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#x61;</span><span class="hljs-symbol">&amp;#x64;</span><span class="hljs-symbol">&amp;#x64;</span><span class="hljs-symbol">&amp;#x72;</span><span class="hljs-symbol">&amp;#x65;</span><span class="hljs-symbol">&amp;#115;</span><span class="hljs-symbol">&amp;#115;</span><span class="hljs-symbol">&amp;#64;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#120;</span><span class="hljs-symbol">&amp;#x61;</span><br><span class="hljs-symbol">&amp;#109;</span><span class="hljs-symbol">&amp;#x70;</span><span class="hljs-symbol">&amp;#x6C;</span>e<span class="hljs-symbol">&amp;#x2E;</span><span class="hljs-symbol">&amp;#99;</span><span class="hljs-symbol">&amp;#111;</span><span class="hljs-symbol">&amp;#109;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「<a href="mailto:&#97;&#x64;&#100;&#x72;&#x65;&#x73;&#x73;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#97;&#x64;&#100;&#x72;&#x65;&#x73;&#x73;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a>」链接。</p><p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">\*literal asterisks\*<br></code></pre></td></tr></table></figure><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*   </span>星号<br>_   底线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  括弧<br>#   井字号<br>+   加号<br><span class="hljs-bullet">-   </span>减号<br><span class="hljs-bullet">.   </span>英文句点<br>!   惊叹号<br></code></pre></td></tr></table></figure><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><h3 id="使用-换行"><a href="#使用-换行" class="headerlink" title="使用 \ 换行"></a>使用 <code>\</code> 换行</h3><p>标准 markdown 使用两个空格换行，不仅容易忘记，而且也不够明显。所以 vscode 支持另外一种换行方式，使用反斜杠 <code>\</code>。</p><p>例如</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md">第一行\<br>第二行  <br>第三行<br></code></pre></td></tr></table></figure><p>会被显示为</p><p>第一行<br>第二行<br>第三行</p><h3 id="语言特定代码块"><a href="#语言特定代码块" class="headerlink" title="语言特定代码块"></a>语言特定代码块</h3><p>虽然上面直接缩进 4 个空格就能得到代码块，但如果想要特定于语言的语法高亮，就不能直接缩进，而是使用 3 个以上的反引号（`） 包裹起来并告诉 markdown 解析器你需要什么语言的语法高亮。</p><p>例如</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-code">```js</span><br><span class="hljs-code">function foo() &#123;</span><br><span class="hljs-code">  return &#123;</span><br><span class="hljs-code">    name: &quot;灵梦&quot;,</span><br><span class="hljs-code">    age: 17,</span><br><span class="hljs-code">    sex: false,</span><br><span class="hljs-code">  &#125;;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><p>会被显示为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name: <span class="hljs-string">&quot;灵梦&quot;</span>,<br>    age: <span class="hljs-number">17</span>,<br>    sex: <span class="hljs-literal">false</span>,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码显示上会有相当的优势，还是希望尽量使用 ``` 而非缩进 4 个空格。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>markdown 可以制作一些简单的表格</p><p>例如</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs md">| name    | age | gender |<br>| ------- | --- | ------ |<br>| liuli   | 17  | false  |<br>| chuxuan | 23  | true   |<br></code></pre></td></tr></table></figure><p>会被显示为</p><table><thead><tr><th>name</th><th>age</th><th>gender</th></tr></thead><tbody><tr><td>liuli</td><td>17</td><td>false</td></tr><tr><td>chuxuan</td><td>23</td><td>true</td></tr></tbody></table><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>markdown 还可以支持的文章目录（本质上是嵌套的无序列表）</p><p>例如</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">-</span> [<span class="hljs-string">markdown 语法说明</span>](<span class="hljs-link">#markdown-语法说明</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">概述</span>](<span class="hljs-link">#概述</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">宗旨</span>](<span class="hljs-link">#宗旨</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">兼容 HTML</span>](<span class="hljs-link">#兼容-html</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">特殊字符自动转换</span>](<span class="hljs-link">#特殊字符自动转换</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">区块元素</span>](<span class="hljs-link">#区块元素</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">段落和换行</span>](<span class="hljs-link">#段落和换行</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">标题</span>](<span class="hljs-link">#标题</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">区块引用 Blockquotes</span>](<span class="hljs-link">#区块引用-blockquotes</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">列表</span>](<span class="hljs-link">#列表</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">代码区块</span>](<span class="hljs-link">#代码区块</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">分隔线</span>](<span class="hljs-link">#分隔线</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">区段元素</span>](<span class="hljs-link">#区段元素</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">链接</span>](<span class="hljs-link">#链接</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">强调</span>](<span class="hljs-link">#强调</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">删除</span>](<span class="hljs-link">#删除</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">代码</span>](<span class="hljs-link">#代码</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">图片</span>](<span class="hljs-link">#图片</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">其它</span>](<span class="hljs-link">#其它</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">自动链接</span>](<span class="hljs-link">#自动链接</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">反斜杠</span>](<span class="hljs-link">#反斜杠</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">扩展语法</span>](<span class="hljs-link">#扩展语法</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">使用 `\` 换行</span>](<span class="hljs-link">#使用--换行</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">语言特定代码块</span>](<span class="hljs-link">#语言特定代码块</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">表格</span>](<span class="hljs-link">#表格</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">文章目录</span>](<span class="hljs-link">#文章目录</span>)<br><span class="hljs-bullet">    -</span> [<span class="hljs-string">任务列表</span>](<span class="hljs-link">#任务列表</span>)<br><span class="hljs-bullet">  -</span> [<span class="hljs-string">Markdown 免费编辑器</span>](<span class="hljs-link">#markdown-免费编辑器</span>)<br></code></pre></td></tr></table></figure><p>会被显示为</p><ul><li><a href="#markdown-%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E">markdown 语法说明</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#%E5%AE%97%E6%97%A8">宗旨</a></li><li><a href="#%E5%85%BC%E5%AE%B9-html">兼容 HTML</a></li><li><a href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">特殊字符自动转换</a></li></ul></li><li><a href="#%E5%8C%BA%E5%9D%97%E5%85%83%E7%B4%A0">区块元素</a><ul><li><a href="#%E6%AE%B5%E8%90%BD%E5%92%8C%E6%8D%A2%E8%A1%8C">段落和换行</a></li><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8-blockquotes">区块引用 Blockquotes</a></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97">代码区块</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li></ul></li><li><a href="#%E5%8C%BA%E6%AE%B5%E5%85%83%E7%B4%A0">区段元素</a><ul><li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li><li><a href="#%E5%BC%BA%E8%B0%83">强调</a></li><li><a href="#%E5%88%A0%E9%99%A4">删除</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li></ul></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a><ul><li><a href="#%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5">自动链接</a></li><li><a href="#%E5%8F%8D%E6%96%9C%E6%9D%A0">反斜杠</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">扩展语法</a><ul><li><a href="#%E4%BD%BF%E7%94%A8--%E6%8D%A2%E8%A1%8C">使用 <code>\</code> 换行</a></li><li><a href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%9D%97">语言特定代码块</a></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li><li><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8">任务列表</a></li></ul></li><li><a href="#markdown-%E5%85%8D%E8%B4%B9%E7%BC%96%E8%BE%91%E5%99%A8">Markdown 免费编辑器</a></li></ul></li></ul><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>如果你想要写一些任务项，markdown 恰好也是支持的。只要简单的使用 <code>- [ ]</code>/<code>- [x]</code> 的方式就可以定义未完成/完成的任务项。</p><p>例如</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-bullet">-</span> [ ] 第一项任务<br><span class="hljs-bullet">-</span> [x] 第二项任务<br><span class="hljs-bullet">-</span> [x] 第三项任务<br></code></pre></td></tr></table></figure><p>会被显示为</p><ul><li>[ ] 第一项任务</li><li>[x] 第二项任务</li><li>[x] 第三项任务</li></ul><hr><h2 id="Markdown-免费编辑器"><a href="#Markdown-免费编辑器" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><blockquote><p>如果你是一名 Developer，那吾辈首推 <a href="https://code.visualstudio.com/">VSCode</a>，免费开源的跨平台编辑器。</p></blockquote><p>Windows 平台</p><ul><li><a href="http://markdownpad.com/">MarkdownPad</a></li><li><a href="http://code52.org/DownmarkerWPF/">MarkPad</a></li></ul><p>Linux 平台</p><ul><li><a href="http://sourceforge.net/p/retext/home/ReText/">ReText</a></li></ul><p>Mac 平台</p><ul><li><a href="http://25.io/mou/">Mou</a></li></ul><p>在线编辑器</p><ul><li><a href="http://dillinger.io/">Dillinger.io</a></li></ul><p>浏览器插件</p><ul><li><a href="https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa/">Markdown Here</a></li></ul><p>高级应用</p><ul><li><a href="https://code.visualstudio.com/">VSCode</a> + <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a> / <a href="https://blog.rxliuli.com/p/43851eb5/">教程</a></li><li><a href="http://www.sublimetext.com/2">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/">教程</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 上的工具清单</title>
    <link href="/p/5b565be2d93c4e03871e42aff60e2a9a/"/>
    <url>/p/5b565be2d93c4e03871e42aff60e2a9a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>但弄雕虫之技，尘芥草莽，于泥泞自勉……</p></blockquote><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="MS-VSCode：前端标准-IDE"><a href="#MS-VSCode：前端标准-IDE" class="headerlink" title="MS VSCode：前端标准 IDE"></a>MS VSCode：前端标准 IDE</h3><p>[便携版], [开源], [跨平台], [免费]</p><blockquote><p>具体可以参考：<a href="https://code.visualstudio.com/">官网</a>, <a href="https://github.com/Microsoft/vscode">GitHub</a>, <a href="https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/">GitBook 中文介绍</a></p></blockquote><p>MS VSCode 是微软出品的一个跨平台，基于 Web 的，免费的开源文本编辑器。目前已经使用了半年多了，对其的了解也更加深入。就目前看来，VSCode 应该是前端生态最好的 IDE 了。作为一个文本编辑器，大多数的文本文件都有语法支持的扩展真的太棒了，这点要强过专门的 IDE。</p><p>主要优点：</p><ul><li>开箱即用：基本上下载完就能开始使用了，不需要太多自定义的配置</li><li>多语言支持：这是很多文本编辑器/IDE 都没有做到的，例如下面吾辈最喜欢的 IDEA 到目前为止官方仍然只支持英文，但吾辈觉得本土化之后才能对萌新更加友好（门槛低，学习曲线平缓）</li><li>插件丰富：目前吾辈使用 VSCode 主要用于前端，编辑 Markdown 文章，一些系统/程序的配置文件等，安装了插件之后使用对各种功能的支持还算不错。</li></ul><p>缺点：</p><p>很明显，MS 的东西最后会不会变成全家桶/流氓谁也不清楚，虽然去年貌似 MS 在 GitHub 上的贡献量超过了 Google，但想想 MS 的开源黑历史。。。而且，作为一个专门的编程编辑器，有许多的细节上还是很粗糙（貌似开源项目的通病），相比于专业的 IDE（例如 WebStorm）还是相差不少。<br>下面举一些例子</p><ul><li>本地文件历史: 没有加入到 Git 管理中的文件丢失，血与泪的教训啊</li><li>单词检查: 英文单词写错了还不知道，萌萌哒！</li><li>代码跳转功能很弱: 专业 IDE 里几乎所有有关连的东西都是可以跳转的。例如在 CSS 中查看使用 class 的引用列表，在 HTML 中跳转到 CSS 的 class 定义处，HTML 中有代码提示 CSS 类。JS 中查看函数的引用列表，查看函数的定义处，查看函数的实现（老实说 VSCode 基于 ts 实现的代码提示感觉真是在下一盘大棋。。。）</li><li>Git 支持: VSCode 中 Git 支持还不成熟，并没有像 IDE 中那么方便与强大</li><li>HTML 标签修改的时候没有自动修改对应的标签: 纯粹是细节性问题</li><li>TODO 支持: 对 <strong><code>TODO</code></strong> 标签没有支持</li></ul><p>常用的 Plugin</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag">auto-rename-tag</a>: 自动重命名对应标签</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync">code-settings-sync</a>: VSCode 设置同步</li><li><a href="https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv">dotenv</a>: <code>env</code> 语法支持</li><li><a href="https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets">es7-react-js-snippets</a>: react es7 的代码片段</li><li><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">gitlens</a>: Git 增强插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=pushqrdx.inline-html">inline-html</a>: js 模板字符串中的 <code>HTML</code> 代码提示</li><li><a href="https://marketplace.visualstudio.com/items?itemName=k--kato.intellij-idea-keybindings">intellij-idea-keybindings</a>: IDEA 快捷键映射</li><li><a href="https://marketplace.visualstudio.com/items?itemName=sysoev.language-stylus">language-stylus</a>: <code>stylus</code> 语言支持</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">markdown-all-in-one</a>: Markdown 编辑主要插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">markdown-pdf</a>: 将 Markdown 导出 PDF 文档</li><li><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">material-icon-theme</a>: material 风格的图标</li><li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">path-intellisense</a>: 路径提示</li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">prettier-vscode</a>: 配合 ESLint 做代码格式自动修复</li><li><a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode">quokka-vscode</a>: 持续监听/运行 js 文件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=thisismanta.stylus-supremacy">stylus-supremacy</a>: <code>stylus</code> 格式化</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme">vsc-material-theme</a>: Material 风格的 VSCode</li><li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">vscode-eslint</a>: JavaScript 代码规范检查</li><li><a href="https://marketplace.visualstudio.com/items?itemName=NuclleaR.vscode-extension-auto-import">vscode-extension-auto-import</a>: 自动 import 函数</li><li><a href="https://marketplace.visualstudio.com/items?itemName=firsttris.vscode-jest-runner">vscode-jest-runner</a>: 快速运行/调试 jest 测试</li><li><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">vscode-markdownlint</a>: Markdown 语法检查</li><li><a href="https://marketplace.visualstudio.com/items?itemName=ipatalas.vscode-postfix-ts">vscode-postfix-ts</a>: Markdown 语法检查</li><li><a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight">vscode-todo-highlight</a>: <code>TODO</code> 注释高亮</li><li><a href="https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime">vscode-wakatime</a>: 记录与统计代码的时间</li></ul><blockquote><p><a href="https://gist.github.com/rxliuli/9069f63e5bc0fc0f5cbbfc44a8b0da44">VSCode Settings</a></p></blockquote><h3 id="Google-Chrome：最好的浏览器"><a href="#Google-Chrome：最好的浏览器" class="headerlink" title="Google Chrome：最好的浏览器"></a>Google Chrome：最好的浏览器</h3><p>[部分开源], [跨平台], [免费]</p><blockquote><p><a href="https://www.google.com/chrome/">官网</a>, <a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html">Google Chromium 各版本下载</a></p></blockquote><p>非常有名的浏览器，来源于 Google，在 PC 上不管是用于开发还是日常使用都能够满足需求。相比于国内的流氓而言非常干净简洁（至少，看起来而言），相比于 FireFox 来说更快，插件体系也已经足够庞大完整，基本上想要的都有了。</p><p>常用的 Plugin：</p><ul><li><a href="https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp">AutoPagerize</a>：自动翻页插件，浏览很多网站时不需要手动点击下一页了，可以自动加载出来下一页的结果。</li><li><a href="https://chrome.google.com/webstore/detail/checker-plus-for-gmail/oeopbcgkkoapgobdbedcemjljbihmemj">Checker Plus for Gmail™</a>：对于日常使用 Gmail 的吾辈而言非常有用</li><li><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo">crxMouse Chrome™ 手势</a>：鼠标手势插件，可以使用手势更简单地完成一些事情</li><li><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">Dark Reader</a>：为所有网站加上黑色主题，大部分情况下都还不错</li><li><a href="https://chrome.google.com/webstore/detail/anlikcnbgdeidpacdbdljnabclhahhmd">Enhanced Github</a>：显示 GitHub Repository 大小，允许单独下载每一个文件</li><li><a href="https://chrome.google.com/webstore/detail/enhancer-for-youtube/ponfpcnoihfmfllpaingbgckeeldkhle">Enhancer for YouTube™</a>：怎么说呢，Youtube 已经很好了，但吾辈还是觉得需要这个插件来优化播放体验</li><li><a href="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf">Fatkun 图片批量下载</a>：批量下载网页上的图片，偶尔用一下吧</li><li><a href="https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp">Free Download Manager</a>：FDM Chrome 集成插件，将 Chrome 下载链接使用 FDM 多线程下载</li><li><a href="https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk">GitHub Hovercard</a>：GitHub 增强插件，鼠标悬浮在仓库链接上面就可以预览</li><li><a href="https://chrome.google.com/webstore/detail/image-search-options/kljmejbpilkadikecejccebmccagifhl">Image Search Options</a>：使用右键以图搜图</li><li><a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien">Isometric Contributions</a>：GitHub 美化插件，将 GitHub 贡献以 3D 的效果显示出来</li><li><a href="https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji">JetBrains IDE Support</a>：使用 Chrome 实时显示 IDEA 的 HTML/CSS/JavaScript 文件，与 IDEA 的插件配合使用</li><li><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd">LastPass: Free Password Manager</a>：跨平台的免费密码管理器，有了这个之后再也不用所有网站都使用同一个密码了</li><li><a href="https://chrome.google.com/webstore/detail/mailto-for-gmail/dgkkmcknielgdhebimdnfahpipajcpjn">Mailto: for Gmail™</a>：对于 mailto 协议的链接以 Gmail 网页版打开</li><li><a href="https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa">Markdown Here</a>：在线将 Markdown 转换为有格式的文档，例如在一个普通的富文本编辑器（不支持 Markdown）中，可以先用 Markdown 语法写内容，然后转换一下就得到了有样式的内容了。</li><li><a href="https://chrome.google.com/webstore/detail/neat-url/jchobbjgibcahbheicfocecmhocglkco">Neat URL</a>：移除网址中的无用段，例如返利链接后面的参数</li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a>：GitHub 代码树状图插件，方便查看项目文件</li><li><a href="https://chrome.google.com/webstore/detail/owo/ckfodameiahfhlainaclajkgfagkpodb">OwO</a>：颜文字插件，多亏了这个让吾辈能够愉快的刷推了</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">Proxy SwitchyOmega</a>：科学上网必需</li><li><a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">Stylus</a>：使用自定义网站样式的插件，比 Stylish 的名声好一些</li><li><a href="https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp">Tabliss</a>：新标签页插件</li><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">Tampermonkey</a>：使用自定义网站脚本的插件，可以使用各种 <code>user.js</code> 脚本，相当于小型的插件管理器了</li><li><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">The Great Suspender</a>：自动休眠标签页，避免 Chrome 使用的内存太过庞大</li><li><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a>：日常上网必须，屏蔽各种广告，比 Adblock 的名声好一些</li><li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js devtools</a>：在 DevTool 中添加 Vuejs 选项卡，便于对 Vuejs 进行调试</li><li><a href="https://chrome.google.com/webstore/detail/webrtc-network-limiter/npeicpdbkakmehahjeeohfdhnlpdklia">WebRTC Network Limiter</a>：阻止浏览器通过 WebRTC 泄露 IP 地址</li><li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad">WEB 前端助手(FeHelper)</a>：貌似是百度的前端插件，但目前还没有什么流氓行为</li><li><a href="https://chrome.google.com/webstore/detail/%E5%BF%AB%E7%BF%BB%E8%AF%91/chpeaiibggkmaongjphijmielpkokcdg">快翻译</a>：这个翻译插件是真心不错，某种意义上讲比 Chrome 自带的翻译都要好（#大雾）</li><li><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">扩展管理器（Extension Manager）</a>：插件很少的时候还好，一多起来还是需要一个插件进行管理，快速启用和禁用一些插件，根据场景切换启用插件列表</li></ul><p>Chrome 虽然已经很完美了，但 Google 却并非如此，最近 Chrome 开始变得越来越封闭了。首先是 Chrome 应用被删除，现在又禁止安装非官方商店中的第三方插件（目前仍可以通过开发者模式安装），真心越来越麻烦了。</p><blockquote><p>附：这里提供一个快捷安装第三方插件的工具 <a href="http://www.webappbus.com/">Chrome 插件伴侣</a>，方便解决 Chrome67 之后安装非商店插件的麻烦</p></blockquote><h3 id="IDEA：最好的-Java-IDE"><a href="#IDEA：最好的-Java-IDE" class="headerlink" title="IDEA：最好的 Java IDE"></a>IDEA：最好的 Java IDE</h3><p>[便携版], [部分开源], [跨平台]</p><blockquote><p><a href="https://www.jetbrains.com/idea/">官网</a>, <a href="https://github.com/JetBrains/intellij-community">GitHub 社区版</a><br>强烈建议升级至 <strong>2019.2.3</strong>，官方终于把智障的重构字符串查找引用默认关闭了，可喜可贺，可喜可贺</p></blockquote><p>虽然说起最好的 IDE 什么的肯定是各种争论，但吾辈还是想说，在 Java 语言开发方面，IDEA 是目前最好的 IDE 了。</p><p>优点：</p><ul><li>智能提示<br>IDEA 在代码提示方面真的是无可比拟（相比于 Eclipse 来说），通常在还没有打完全部代码的时候，IDEA 就知道想要做什么了，然后给吾辈最常用的提示。并且，对于某些不太好的代码，IDEA 会提出一些建议甚至帮助进行安全的重构。一般而言吾辈认为，如果 IDEA 认为代码有问题，那么一般真的是代码有问题（确实有些情况下也不尽如此）</li><li>开箱即用<br>虽然很不起眼，但这确实很重要。当下载完 IDEA 之后，几乎不需要安装什么插件，进行繁复的配置，就能开始工作了！因为 IDEA 帮我们准备好了绝大多数情况所需要的插件，很多配置也都有着良好的默认值。</li><li>插件系统<br>或许 IDEA 的插件数量比不上 Eclipse，但 IDEA 的插件系统确实已经很完善了，至少，对于吾辈而言已然足够了。</li><li>界面很棒<br>其实这个就是吸引吾辈入坑 IDEA 的原因之一，毕竟曾经其他人都在用着 Eclipse 的时候，吾辈看到了 IDEA 的黑色主题就被吸引了，然后到现在成了 IDEA 的死忠粉。</li><li>搜索功能<br>非常强大的搜索功能，可以搜索类，文件，字段，以及全文搜索，包括正则表达式，文件后缀名等过滤功能。</li><li>调试<br>或许有人说，现代的 IDE 基本上都有调试功能吧。但 IDEA 是不同的，它可以同时调试 Java 与 JavaScirpt 以及其他所集成的语言，这可真是强大无比。使用 JavaScript 发送一个请求，然后进入后台代码调试，得到 SQL 语句，去查询数据库，而这一切，都是在 IDEA 内部完成的！</li><li>语言注入<br>这是 IDEA 比较高级的部分了，但这也是一个相当强大的功能。例如，有时候我们不得不手写 SQL 语句，或者在 JavaScript 中拼接 HTML 代码。难道我们必须要去对应的文件中编辑完之后复制过来么？不不不，语言注入就是可以为某一个代码片段注入为某一种语言，例如你可以为 Java 中的字符串注入 SQL 语言。在字符串中，你写 SQL 语句就有提示了！<blockquote><p>当然，语言注入也是要符合基本法的，必须是 IDEA 支持的语言才行，不过 IDEA 对主流语言的支持都还不错。</p></blockquote></li></ul><p>缺点：</p><ul><li>硬件杀手<br>IDEA 是出了名的吃内存（日常），吃磁盘（扫描项目建立索引）以及 CPU（索引）。</li><li>小病不断<br>虽然 IDEA 很是强大，但各种小问题也是层出不穷。例如自定义的 Maven 到了新的项目就变成默认的了。。。</li></ul><p>常用的 Plugin：</p><ul><li>Jrebel：做 Java Web 开发时真心免不了的 Plugin，能够有效解决 Web 容器（例如 Apache Tomcat）启动速度慢的问题（因为几乎所有的资源都能够热加载，热部署）。</li><li>LiveEdit：提供了 HTML/CSS/JavaScript 的实时预览和刷新功能。</li><li>MybatisX：Mybatis 的一个辅助开发插件，能够比较愉快的使用 Mybatis 框架了</li><li>Alibaba Java Coding Guidelines：Alibaba 出品的一个 Java 规范检查插件，能够规避一些不好的代码。</li><li>Translation：目前使用感觉最好的翻译插件，能够提供比较长的内容进行翻译（某些翻译插件只能翻译很短的内容）。</li><li>String Manipulation：字符串操作工具，可以方便对变量名或其他字符串修改为其他风格，例如将变量从 <strong>驼峰命名</strong>（Java 标准命名） 修改为 <strong>下划线命名</strong>（SQL 标准命名）或者 <strong>中缀线命名</strong>（HTML/CSS 标准命名）。<blockquote><p>其实这么多命名规范真心坑。。。</p></blockquote></li><li>Custom Postfix Templates：提供自定义的后缀模板</li><li>GsonFormat：格式化 <code>json</code> 数据并转换为 <code>Java</code> 中的 <code>POJO</code>，其实对于吾辈而言主要是用来写爬虫时生成 <code>json</code> 数据对应的实体类</li><li>Markdown Navigator：IDEA 平台的 Markdown 写作插件，比自带的 Markdown Support 要好很多，主要在需要写的 Markdown 内容中含有代码时比较方便。</li><li>Maven Helper：一个 Apache Maven 的辅助操作插件</li><li>CodeGlance：在编辑器右侧显示一块代码缩略图，主要为了方便使用滑块进行上下滑动</li><li>Grep Console：自定义控制台的输出颜色</li><li>.ignore：在使用版本控制时，快速忽略某些文件/文件夹，目前支持广泛</li><li>CMD support：Cmd 支持，主要是方便在 IDEA 中直接运行 bat 脚本</li><li>NodeJS：集成了 NodeJS，可以直接在 IDEA 中运行 NodeJS</li><li>Vue.js：集成 Vue.js 框架</li><li>Properties to YAML Converter：将 <code>Properties</code> 文件快速转换为 <code>YAML</code> 格式的配置文件</li><li>WakaTime：统计使用的编程语言，不同 IDE 的记录。<a href="https://wakatime.com/">官网</a></li></ul><blockquote><p>入门推荐教程（简体中文）：<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></p></blockquote><h3 id="drawio：开源免费的画图工具"><a href="#drawio：开源免费的画图工具" class="headerlink" title="drawio：开源免费的画图工具"></a>drawio：开源免费的画图工具</h3><p>[便携版], [开源], [免费]，[跨平台]</p><blockquote><p><a href="https://app.diagrams.net/">官网</a>, <a href="https://github.com/jgraph/drawio">GitHub</a></p></blockquote><p>目前能找到的最好的免费开源的画图解决方案，能够制作流程图、UML 图、组织结构图、泳道图等绘图。允许导出为图片/HTML/PDF 等各种格式，全平台免费可用的解决方案。</p><blockquote><p>ProcessOn 是一个更加本地化的解决方案，并且添加了思维导图支持，只允许在线编辑导致了数据的最终权力不在自己手上，强制收费则让（小）团队使用成为一件可望而不可及的事情。<br>注：此处不是故意黑 ProcessOn，因为吾辈也是它的付费用户，但在团队内推广使用确实会存在一些问题。</p></blockquote><h3 id="Cmder：Windows-上模拟-Linux-终端"><a href="#Cmder：Windows-上模拟-Linux-终端" class="headerlink" title="Cmder：Windows 上模拟 Linux 终端"></a>Cmder：Windows 上模拟 Linux 终端</h3><p>[便携版], [开源], [免费]</p><blockquote><p><a href="http://cmder.net/">官网</a>, <a href="https://github.com/cmderdev/cmder">GitHub</a></p></blockquote><p>曾经有段时间吾辈也很迷信 Linux，觉得 Linux 适合开发者使用（事实上确实如此），但后来还是因为电脑的硬件原因（驱动问题，莫名其妙的卡死在登录页面）而回到了 Windows。而最让人念念不忘的就是 Linux Bash 终端了，相比于 Windows 自带的 Cmd/PowerShell 来说漂亮/强大了许多。当然，Windows 相比于 Linux 的最大优点就是稳定（不怕折腾，很难损坏系统本身）以及可视化（大部分的设计都有可视化界面进行配置）。然而有时候还是不得不使用命令行，而这时便显示出 Windows 的不足了，直到后来吾辈在偶然的机会碰到了 Cmder，发现了 Windows 上果然已经有了解决方案。</p><p>Cmder 是一个在 Windows 上模拟 Linux Bash 的终端模拟器，其实对于吾辈而言，主要是因为 Cmder 比较漂亮，集成了很多组件（例如 Git, SSH, Curl, Less, vim），而且还能在上面安装 Windows 下的包管理系统 <strong>Chocolatey</strong>。安装了包管理器之后就能直接使用 <code>choco command options</code> 命令安装软件了。</p><blockquote><p>具体方法可以参考另外一篇文章：<a href="https://blog.rxliuli.com/p/ad968d70/">Windows 下 Cmder 安装 Chocolatey</a></p></blockquote><h3 id="Git：Git-版本控制系统"><a href="#Git：Git-版本控制系统" class="headerlink" title="Git：Git 版本控制系统"></a>Git：Git 版本控制系统</h3><p>[便携版], [开源], [跨平台], [免费]</p><blockquote><p><a href="https://git-scm.com/">官网</a>, <a href="https://github.com/git/git">GitHub</a></p></blockquote><p>最初由 Linus 开发的一个分布式的版本控制系统，现在已经是最流行的版本控制系统之一了。说到 Git 不得不提 GitHub，GitHub 为 Git 实现了一个在线代码（或者其他）托管平台，相当好用而且托管开源项目是免费的。其实对于吾辈而言 Git 只是一个用于在本地操作 GitHub 的客户端罢了（很少有添加到 Git 而没有提交到 GitHub 的代码）。正是因为 GitHub 对 Git 的支持之好，所以吾辈才喜欢使用 Git 的。。。（#因果颠倒）</p><h3 id="Termius：简单漂亮的-SSH-连接工具"><a href="#Termius：简单漂亮的-SSH-连接工具" class="headerlink" title="Termius：简单漂亮的 SSH 连接工具"></a>Termius：简单漂亮的 SSH 连接工具</h3><p>[跨平台]</p><blockquote><p><a href="https://www.termius.com/">官网</a></p></blockquote><p>非常漂亮的一个远程连接工具，免费版本仅支持 SSH 连接，而 SFTP 则是收费版本的功能，吾辈作为前端感觉算是足够了。</p><blockquote><p>更强大的远程连接工具：<a href="https://mobaxterm.mobatek.net/">Mobaxterm</a>，功能非常强大但界面复古（Win7 时代的风格）。</p></blockquote><h3 id="HeidiSQL：SQL-客户端"><a href="#HeidiSQL：SQL-客户端" class="headerlink" title="HeidiSQL：SQL 客户端"></a>HeidiSQL：SQL 客户端</h3><p>[便携版], [开源], [免费]</p><blockquote><p><a href="https://www.heidisql.com/">官网</a>, <a href="https://github.com/HeidiSQL/HeidiSQL">GitHub</a></p></blockquote><p>一个支持 MSSQL,MySQL 和 PostgreSQL 的开源数据库轻量级客户端。吾辈使用这个 SQL 客户端最重要的原因就是满足了吾辈对于数据库文件的导入/导出需求，谁让 IDEA 自带的 DataGrip 没有导出功能呢</p><blockquote><p>附：吾辈很清楚 MySQL 有自带的导出命令，然而并不灵活。。。至少这个能够定义创建数据表，插入数据时使用的策略</p></blockquote><h3 id="freeFTPd：免费的-FTP-SFTP-服务端"><a href="#freeFTPd：免费的-FTP-SFTP-服务端" class="headerlink" title="freeFTPd：免费的 FTP/SFTP 服务端"></a>freeFTPd：免费的 FTP/SFTP 服务端</h3><p>[开源], [免费]</p><blockquote><p><a href="http://www.freesshd.com/">官网</a></p></blockquote><p>开源免费的 FTP/SFTP 服务端，非常适合在开发过程中模拟 FTP/SFTP 服务端使用。而且相比于 <a href="https://filezilla-project.org/">FileZilla</a> 更加简单，也不会从一开始就出现错误需要解决。</p><hr><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><h3 id="Win-R：快速启动"><a href="#Win-R：快速启动" class="headerlink" title="Win + R：快速启动"></a>Win + R：快速启动</h3><p>虽说 Windows 上也有快速启动工具，但 Windows 原生的快速启动已然足够使用了。将快捷方式命名为一个简单的名字，例如将 <strong>Google Chrome</strong> 命名为 <strong>GC</strong>，然后丢到当前用户目录下，然后使用 <strong>Win + R</strong> 弹出运行窗口，然后输入 <strong>GC</strong>，系统就会启动 <strong>Google Chrome</strong> 了。</p><p>当然，更好的方法是新建一个目录保存这些快速启动的快捷方式，然后将目录添加到环境变量中即可（<code>Path</code>）。</p><h3 id="SSR：正常上网必须"><a href="#SSR：正常上网必须" class="headerlink" title="SSR：正常上网必须"></a>SSR：正常上网必须</h3><p>[便携版], [开源], [跨平台], [免费]</p><blockquote><p><a href="https://github.com/shadowsocksr-backup">GitHub</a></p></blockquote><p>为了正常浏览网络折腾与支付一些代价都是微不足道的，貌似比 <code>ShadowScoks</code> 要稳定一点，不过据传闻作者最初并未打算将其开源。</p><h3 id="Proxifier：代理一切"><a href="#Proxifier：代理一切" class="headerlink" title="Proxifier：代理一切"></a>Proxifier：代理一切</h3><blockquote><p><a href="https://www.proxifier.com/">官网</a></p></blockquote><p>虽然 SSR 可以连接代理服务器，同时还提供局域网内的 Socks5/HTTP 的代理，同时 Chrome 自动使用系统代理，所以我们可以方便的直接打开 Google 了。然而，并不是所有程序都像是 Chrome 浏览器那么友好，许多支持代理的程序都需要手动进行配置，更麻烦的地方是：很多程序不包含代理设置 – 尤其是开发相关的工具链。</p><p>先说几个具体的使用场景吧</p><ul><li>进行 web 开发时，有些 npm 包（electron/SQLLite）会在 install 时从网络下载二进制文件，而因为众所周知的原因，它们的下载速度并不快，而 nodejs 也不能配置代理（事实上，即便配置了，也不是所有 npm 包都会读）</li><li>希望监听某些程序到底有没有发送网络请求，但却不能尽知</li></ul><h3 id="MacType：字体美化"><a href="#MacType：字体美化" class="headerlink" title="MacType：字体美化"></a>MacType：字体美化</h3><p>[开源], [免费]</p><blockquote><p><a href="http://www.mactype.net/">官网</a>, <a href="https://github.com/snowie2000/mactype">GitHub</a></p></blockquote><p>Windows 上的字体就是会出现锯齿（所谓的点阵字体真是坑），不过 MacType 可以缓解这一现象。它可以美化 Windows 对字体的渲染（绝大部分程序都不会出现问题），让吾辈在使用 Windows 的时候看着代码更舒服一点。</p><blockquote><p>附: MacType 配置推荐 <strong>注册表加载 + Iof =&gt; XHei =&gt; Default</strong><br>附：字体个人推荐 <a href="https://github.com/be5invis/Sarasa-Gothic">Sarasa-Gothic</a>，中文名是更纱黑体，包含 <strong>英/简中/繁中/日</strong> 四种语言</p></blockquote><h3 id="Joplin：适合开发者的笔记工具"><a href="#Joplin：适合开发者的笔记工具" class="headerlink" title="Joplin：适合开发者的笔记工具"></a>Joplin：适合开发者的笔记工具</h3><p>[便携版], [开源], [跨平台], [免费]</p><blockquote><p><a href="https://joplinapp.org/">官网</a>, <a href="https://github.com/laurent22/joplin">GitHub</a></p></blockquote><p>一个开源跨平台的笔记工具，使用的模式是本地程序 + 第三方服务同步的方式，编辑功能算是比较弱的，同步也不算是最好的，甚至于客户端也不算是最漂亮的。但是，它有一些非常显著的优点，甚至足以压倒以上的缺点。</p><p>主要优点：</p><ol><li> 搜索很快，非常快</li><li> 可以使用外部编辑器打开</li><li> 数据都在自己手里，提供一次性导出全部的功能</li><li> 使用标准的 md，可以直接复制到其他平台</li><li> 可以基于它进行二次开发</li></ol><p>主要缺点：</p><ol><li> ui/ux 有点简陋</li><li> 没有 vsc 插件导致使用外部编辑器也并不是非常方便</li></ol><blockquote><p>之前吾辈使用过 OneNote 和 Notion，两者都是非常好的笔记工具，但两者存在的一些缺点导致吾辈在使用一段时间后选择了放弃。</p><ul><li>OneNote：主要问题是需要自己调整文本格式，不支持 markdown，以及富文本带来的分享问题。</li><li>Notion：主要问题是编辑体验不好，搜索非常慢，以及非标准 markdown 导致的分享问题。可以参考 <a href="/p/b1d53b2d48c24af7904985f6c3764cdb">Notion 使用体验</a></li></ul></blockquote><h3 id="FDM：免费的多线程下载器"><a href="#FDM：免费的多线程下载器" class="headerlink" title="FDM：免费的多线程下载器"></a>FDM：免费的多线程下载器</h3><p>[免费]</p><blockquote><p><a href="http://http//www.freedownloadmanager.org">官网</a></p></blockquote><p>全称 Free Download Manager，没什么太多好说的，但用起来还算不错，不会弹个窗口提示下载什么的，然而下载完成也没提示真的坑。。。</p><p>基本上满足吾辈日常的下载需求吧</p><ul><li>[x] 提供客户端界面</li><li>[x] 多线程</li><li>[x] 集成 chrome</li><li>[x] 静默下载</li><li>[x] 下载后可以打开文件/文件夹</li><li>[ ] 下载完成后没有弹窗提示</li><li>[ ] 便携版（配置可携带化）</li></ul><h3 id="Bandizip：压缩-解压缩"><a href="#Bandizip：压缩-解压缩" class="headerlink" title="Bandizip：压缩/解压缩"></a>Bandizip：压缩/解压缩</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://www.bandizip.com/">官网</a></p></blockquote><p>目前吾辈觉得最好的压缩/解压缩软件，具体压缩率/支持格式什么的吾辈也并非专业所以就不说了。但就使用体验上看 Bandizip 是要明显优于其他同类软件的（WinRAR, 7Zip）。</p><p>吾辈看到的优点：</p><ul><li>预览压缩文件时左侧有文件夹树状列表，不需要再用鼠标点击进进出出的活塞运动了</li><li>自动解压，这个功能相当棒，可以智能解压压缩文件到文件夹中（如果压缩包里面只有一个文件夹就直接解压出来，否则会将压缩包里面的内容解压到一个与压缩包同名的文件夹中），这个功能看起来很不起眼，但吾辈在此之前并未找到（需要特别注意压缩包的内容）</li></ul><blockquote><p>注：最新版本强制更新还有广告，所以需要下载修改版或是旧版本，即便如此，它的自动解压仍然是非常优秀的解压功能。</p></blockquote><h3 id="ClipboardFusion：剪切板增强"><a href="#ClipboardFusion：剪切板增强" class="headerlink" title="ClipboardFusion：剪切板增强"></a>ClipboardFusion：剪切板增强</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://www.clipboardfusion.com/">官网</a></p></blockquote><p>Windows 剪切板增强工具，不得不说 Windows 上的工具确实很多。即使一个功能 Windows 本身支持的不好，然而总有其他的工具对其增强就是了。当然，吾辈需要的只是它的剪切板历史功能。</p><blockquote><p>注：目前 Windows 已经自带了剪切板历史功能，但尚未支持搜索，同时在布局上也并不是特别友好（只能显示 4 条），轻量级用户可以选择这个（毕竟是自带，很方便）。<br>注：之前在用 Ditto，但后面在吾辈电脑上出现了 bug，所以更换了其他工具，但并不是说它不好。参考：<a href="https://xbeta.info/ditto.htm">善用佳软评测</a> 对其的介绍很全面，这里也就无需赘述了。</p></blockquote><h3 id="JPEGView：图片浏览"><a href="#JPEGView：图片浏览" class="headerlink" title="JPEGView：图片浏览"></a>JPEGView：图片浏览</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://sourceforge.net/projects/jpegview/">官网</a></p></blockquote><p>简单而且好用的图片查看器，相比于吾辈之前使用的 ImageView（中文名是 <strong>快眼看图王</strong>）更快，相比于 HoneyView 更见简洁和易操作。</p><p>主要优点如下：</p><ul><li>操作简单：滚轮缩放，按住移动，ESC 关闭，Left/Right 查看上/下张图片</li><li>性能很高：实测打开速度比 imageview/honeyview 都要更快</li></ul><p>借用<a href="https://www.zhihu.com/question/21305023">知乎</a>网友理想中的图片查看器需求图</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200408210706.png" alt="理想中的图片查看器"></p><h3 id="Everything：文件快速搜索"><a href="#Everything：文件快速搜索" class="headerlink" title="Everything：文件快速搜索"></a>Everything：文件快速搜索</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://www.voidtools.com/">官网</a></p></blockquote><p>用过 Windows Explorer（文件管理器）搜索文件的人都知道速度是有多慢，有了 Everything 之后这一切都是往事了。Everything 建立了全盘索引，可以对文件/文件夹进行实时搜索，速度之快简直和默认的文件管理器有天壤之别。当然，也能够根据正则表达式/类型进行高级查询。</p><h3 id="Snipaste：截图-贴图"><a href="#Snipaste：截图-贴图" class="headerlink" title="Snipaste：截图/贴图"></a>Snipaste：截图/贴图</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://zh.snipaste.com/">官网</a>, <a href="https://github.com/Snipaste">GitHub</a>, <a href="https://docs.snipaste.com/zh-cn/">GitBook 中文教程</a></p></blockquote><p>很漂亮，很漂亮，很漂亮！重要的话说三遍，Snipaste 相比于其他的截图软件（FSCapture）在使用时感觉漂亮了很多，而且在使用时会方便很多（截图完成后直接就进行编辑，而不是跳转到编辑器中编辑截图），保存时自动保存并且复制到剪切板也很方便。总而言之就是细节做的相当棒！</p><h3 id="PicGo：图床上传"><a href="#PicGo：图床上传" class="headerlink" title="PicGo：图床上传"></a>PicGo：图床上传</h3><p>[开源], [跨平台], [免费]</p><blockquote><p><a href="https://molunerfinn.com/PicGo/">官网</a>, <a href="https://github.com/rxliuli/PicGo">GitHub</a></p></blockquote><p>使用 Markdown 写作必备的图床工具，解决了吾辈关于 GitHub 图床的几个痛点。</p><ul><li>上传之前重命名</li><li>上传一键就好</li><li>上传后图片管理</li></ul><h3 id="ScreenToGif：录制-GIF-动态图"><a href="#ScreenToGif：录制-GIF-动态图" class="headerlink" title="ScreenToGif：录制 GIF 动态图"></a>ScreenToGif：录制 GIF 动态图</h3><p>[便携版], [开源], [免费]</p><blockquote><p><a href="https://www.screentogif.com/">官网</a>, <a href="https://github.com/NickeManarin/ScreenToGif">GitHub</a></p></blockquote><p>虽然吾辈已经有了截图工具，但某些时候单靠截图并不能很好的表达意思，这时候就需要使用 Gif 去记录一系列的操作。这也是 ScreenToGif 的主要功能，将记录转换成 Gif 动态图。</p><p>嘛，虽然就使用上吾辈觉得还是有一些不便：</p><ul><li>吸附窗口操作不太直观</li><li>保存时不能直接一键保存到指定目录并复制到剪切板</li></ul><p>不过这也是目前吾辈能找到的比较好用的一个了</p><h3 id="QuickLook：文件管理器预览增强"><a href="#QuickLook：文件管理器预览增强" class="headerlink" title="QuickLook：文件管理器预览增强"></a>QuickLook：文件管理器预览增强</h3><p>[便携版], [开源], [免费]</p><blockquote><p><a href="https://pooi.moe/QuickLook/">官网</a>, <a href="https://github.com/xupefei/QuickLook">GitHub</a></p></blockquote><p>Windows Explorer 预览功能增强，支持很多种格式的文件/文件夹进行预览，包括但不限于文本、图像、视频、音频、压缩包、文件夹等。在按下空格时，就弹出一个预览窗口，感觉还是不错的。</p><h3 id="Steam：国外的游戏平台"><a href="#Steam：国外的游戏平台" class="headerlink" title="Steam：国外的游戏平台"></a>Steam：国外的游戏平台</h3><p>[跨平台], [免费]</p><blockquote><p><a href="https://steamcommunity.com/">官网</a></p></blockquote><p>来自于金三胖出品的非常著名的游戏平台，非常之多的游戏在该平台上发售。Steam 提供了非常多的支付方式，对国内用户相当友好（支付宝/微信/银联）。吾辈个人是只玩 Galgame 的，所以能入正支持到做 Galgame 的公司表示还是很开心的。<br>唉，不过 Steam 也没能逃过魔掌呢。。。<a href="https://www.google.com/search?q=steam+%E8%90%BD%E6%88%B7%E4%B8%8A%E6%B5%B7%E6%B5%A6%E4%B8%9C">steam 落户上海浦东</a>，吾辈表示转区势在必得了！</p><blockquote><p>附：Steam 上没有什么盗版游戏，所以想免费玩游戏的人就不用抱有什么幻想了</p></blockquote><h3 id="Mozilla-FireFox：抱有期待的浏览器"><a href="#Mozilla-FireFox：抱有期待的浏览器" class="headerlink" title="Mozilla FireFox：抱有期待的浏览器"></a>Mozilla FireFox：抱有期待的浏览器</h3><p>[开源], [跨平台], [免费]</p><blockquote><p><a href="https://firefox.com/">官网</a>, <a href="https://github.com/mozilla/gecko-dev">GitHub</a></p></blockquote><p>FireFox 是一个将 IE 拉下神坛的浏览器，一个开源的注重隐私的浏览器，但现在，它已然有些没落了。尤其是最近的 FireFox57 后为了提升性能更新了浏览器的整体架构，导致旧的扩展基本全部失效，恢复曾经的附加扩展生态却又不知道需要多久了。但是，这些问题，相比于隐私（信息收集）与自由（不限制扩展）来说，还是值得考虑一下的，确实挺期待 FireFox 之后发展的。</p><p>相比于其他的浏览器最大的特点就是隐私性和自由，收集隐私是完全可选的（国内的流氓浏览器信息收集简直过分），附加扩展基本不怎么限制（Chrome 限制扩展只能从官方商店直接安装）。</p><blockquote><p>补充:</p><ul><li>2019-06-18: 现在 Chrome 居然限制 <strong>uBlock Origin</strong> 这类的扩展了。。。</li></ul></blockquote><h3 id="AIMP：本地音乐播放器"><a href="#AIMP：本地音乐播放器" class="headerlink" title="AIMP：本地音乐播放器"></a>AIMP：本地音乐播放器</h3><p>[免費]</p><blockquote><p><a href="http://www.aimp.ru/">官网</a></p></blockquote><p>一个非常漂亮的本地音乐播放器，貌似对歌曲音质的支持也很好（没什么感触，不玩耳机的萌新一只）。。。</p><h3 id="PotPlayer：视频播放器"><a href="#PotPlayer：视频播放器" class="headerlink" title="PotPlayer：视频播放器"></a>PotPlayer：视频播放器</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://potplayer.daum.net/">官网</a></p></blockquote><p>非常强大/漂亮的本地视频播放器，虽然也可以播放 URL 的视频资源，但主要还是播放本地视频，支持大多数常见格式而且对于 1080P 之上的画质支持非常棒！</p><h3 id="qBittorrent：BT-下载"><a href="#qBittorrent：BT-下载" class="headerlink" title="qBittorrent：BT 下载"></a>qBittorrent：BT 下载</h3><p>[免费]</p><blockquote><p><a href="https://www.qbittorrent.org/">官网</a></p></blockquote><p>不错的 BT 客户端，相比于<strong>大名鼎鼎</strong>的比特彗星，它没有广告，没有等级。对于热门种子的下载速度十分喜人，最高可以跑到 10M 左右，比特彗星永远没有跑到这么高过。。。</p><h3 id="Dism-：Windows-的一个集中式的系统管理工具"><a href="#Dism-：Windows-的一个集中式的系统管理工具" class="headerlink" title="Dism++：Windows 的一个集中式的系统管理工具"></a>Dism++：Windows 的一个集中式的系统管理工具</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://www.chuyu.me/">官网</a>, <a href="https://github.com/Chuyu-Team/Dism-Multi-language">GitHub</a></p></blockquote><p>一个集中式管理 Windows 各种设置的 GUI 控制面板，能够方便的控制系统的各种设置（包括 Windows 10 的更新。。。），提供了一个简单但却还算可以的垃圾清理工具，感觉上很干净而且可以独立运行！</p><h3 id="TreeSizeFree：以树状视图查看文件夹"><a href="#TreeSizeFree：以树状视图查看文件夹" class="headerlink" title="TreeSizeFree：以树状视图查看文件夹"></a>TreeSizeFree：以树状视图查看文件夹</h3><p>[便携版], [免费]</p><blockquote><p><a href="https://www.jam-software.com/treesize/">官网</a></p></blockquote><p>用来以树状结构查看文件夹大小的工具，可以知道到底是哪些文件占用了硬盘及其大小。</p><h3 id="renamer：文件-文件夹重命名"><a href="#renamer：文件-文件夹重命名" class="headerlink" title="renamer：文件/文件夹重命名"></a>renamer：文件/文件夹重命名</h3><p>[便携版], [免费]</p><blockquote><p><a href="http://www.den4b.com/">官网</a></p></blockquote><p>或许很多人想吐槽，重命名不就一个 F2 的事情么？是的，如果只需要重命名一个文件，F2 是最快捷的方式。但 rename 针对的是需要重命名数十，数百个文件的情况，这种时候手动重命名实在太过于糟糕了点！</p><h3 id="waifu2x-caffe：图片清晰化"><a href="#waifu2x-caffe：图片清晰化" class="headerlink" title="waifu2x-caffe：图片清晰化"></a>waifu2x-caffe：图片清晰化</h3><p>[便携版], [免费], [开源], [跨平台]</p><blockquote><p><a href="http://waifu2x.udp.jp/">官网</a>, <a href="https://github.com/nagadomi/waifu2x">GitHub</a>, <a href="https://github.com/lltcggie/waifu2x-caffe">GitHub Windows</a></p></blockquote><p>可以让图片变得清晰，具体技术实现涉及机器学习等尖端技术（#dalao），可以说是很厉害了呢</p><h3 id="Bandicam：视频录制"><a href="#Bandicam：视频录制" class="headerlink" title="Bandicam：视频录制"></a>Bandicam：视频录制</h3><blockquote><p><a href="https://www.bandicam.com/">官网</a></p></blockquote><p>还算好用的视频录制工具，可以很方便的进行视频的录制。<br>特色功能：</p><ul><li>绘制模式：在录制视频时进行频幕上的编辑</li><li>窗口依附：可以轻松指定需要录制的窗口</li><li>多格式输出：支持输出多种格式，按照不同分辨率，预置平台输出</li><li>添加水印：防盗利器，在视频中添加自己的 LOGO</li></ul><h3 id="LockHunter：解除文件占用"><a href="#LockHunter：解除文件占用" class="headerlink" title="LockHunter：解除文件占用"></a>LockHunter：解除文件占用</h3><p>[免费]</p><blockquote><p><a href="https://lockhunter.com/">官网</a></p></blockquote><p>在删除文件/目录时，偶尔会遇到文件占用的问题，这个小工具直接集成到 MS Explorer 右键菜单中，可以方便查看占用程序，并关闭它。</p><h3 id="rufus：USB-启动盘制作工具"><a href="#rufus：USB-启动盘制作工具" class="headerlink" title="rufus：USB 启动盘制作工具"></a>rufus：USB 启动盘制作工具</h3><p>[便携版], [免费], [开源]</p><blockquote><p><a href="https://rufus.ie/">官网</a>, <a href="https://github.com/pbatard/rufus">GitHub</a></p></blockquote><p>小巧方便的 USB 启动盘制作工具，完全的一键操作，<strong>下载 =&gt; 解压 =&gt; 运行</strong> 三连之后就是父母辈的人都能看懂的界面了！</p><h3 id="Geek-Uninstaller：深度卸载"><a href="#Geek-Uninstaller：深度卸载" class="headerlink" title="Geek Uninstaller：深度卸载"></a>Geek Uninstaller：深度卸载</h3><h3 id="Loseless-Audio-Validator：音频校验"><a href="#Loseless-Audio-Validator：音频校验" class="headerlink" title="Loseless Audio Validator：音频校验"></a>Loseless Audio Validator：音频校验</h3><p>[便携版], [跨平台], [开源], [免费]</p><blockquote><p><a href="http://losslessaudiochecker.com/">官网</a></p></blockquote><p>校验音乐是否是真的 <strong>Flac/Ape</strong> 无损音质的，其实作为一个外行人吾辈表示并不理解什么音频波形什么的。</p><h3 id="ApowerMirror-手机投屏"><a href="#ApowerMirror-手机投屏" class="headerlink" title="ApowerMirror: 手机投屏"></a>ApowerMirror: 手机投屏</h3><p>[跨平台]</p><blockquote><p><a href="https://www.apowersoft.com/phone-mirror">官网</a></p></blockquote><p>在局域网内将手机屏幕投影到 PC 上，延迟性在半秒之内，基本上不影响使用。相比于 <a href="https://www.teamviewer.cn/cn/">TeamViewer</a> 的主要优点是不走中央服务器，延迟没那么高。而与之类似的 <a href="https://www.airserver.com/">AirServer</a> 却延迟很大，而且操作过快时就会崩溃。吾辈主要是在 PC 演示操作时，涉及到手机上的操作时，为了避免录屏中断或是后期拼接，故而需要将手机屏幕投影至 PC 方便持续录制。</p><h3 id="HandBrake-视频压缩工具"><a href="#HandBrake-视频压缩工具" class="headerlink" title="HandBrake: 视频压缩工具"></a>HandBrake: 视频压缩工具</h3><p>[便携版], [跨平台], [免费], [开源]</p><blockquote><p><a href="https://handbrake.fr/">官网</a></p></blockquote><p>非常简单的视频压缩工具，对非专业人士非常友好，只要选择合适的<strong>预设</strong>，任何人都能批量将视频压缩。吾辈一般使用的是 <code>MP4+Web Optimized</code>，可以将 50M 的视频压缩到 10M 左右，同时支持删除音轨进一步缩小视频大小。</p><blockquote><p>ref: <a href="https://www.pkstep.com/archives/37386">HandBrake 免費影片壓縮軟體教學，將視頻的檔案縮小。（Mac ,Windows）</a></p></blockquote><h3 id="OpenArk-快捷键占用检查工具"><a href="#OpenArk-快捷键占用检查工具" class="headerlink" title="OpenArk: 快捷键占用检查工具"></a>OpenArk: 快捷键占用检查工具</h3><p>[便携版], [免费], [开源]</p><blockquote><p><a href="https://openark.blackint3.com/">官网</a></p></blockquote><p>遇到快捷键莫名其妙被占用的话可以使用这个工具查看，需要注意的是一些系统本身的快捷键无法被扫描到，例如 Windows 10 输入法的 <code>Ctrl+Space</code> 切换中英文。</p><h2 id="国内流氓"><a href="#国内流氓" class="headerlink" title="国内流氓"></a>国内流氓</h2><h3 id="QQ：国内不得不用的流氓-IM"><a href="#QQ：国内不得不用的流氓-IM" class="headerlink" title="QQ：国内不得不用的流氓 IM"></a>QQ：国内不得不用的流氓 IM</h3><blockquote><p><a href="https://im.qq.com/">官网</a></p></blockquote><p>垃圾 QQ，毁我人生！<br>好了，以上纯属吐槽不用在意。QQ 是腾讯的社交 IM，由于国内使用人数极其庞大，所以吾辈也不得不用的软件。一个软件居然会向系统添加驱动服务，而且禁用了还不让使用，真是厉害了呀。。。</p><h3 id="百度网盘：国内事实上的垄断网盘"><a href="#百度网盘：国内事实上的垄断网盘" class="headerlink" title="百度网盘：国内事实上的垄断网盘"></a>百度网盘：国内事实上的垄断网盘</h3><p>[跨平台], [免费]</p><blockquote><p><a href="https://pan.baidu.com/">官网</a></p></blockquote><p>国内事实上的大文件共享服务，目前对普通用户的限制非常大，逼得人不得不开通 <a href="https://pan.baidu.com/buy/checkoutcounter?from=homepage&svip=1">SVip</a> 才能使用，但同时也不能得到满速下载，在下载量较大后，之后的下载就会在服务端限速，同时百度网盘的客户端非常讨厌，即便是 SVip 也会看到广告。</p><hr><blockquote><p>Pass：以上国内的流氓吾辈使用的都是修改过的绿色版本，基本上没什么太多麻烦的东西了呢</p></blockquote><hr><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="便携版"><a href="#便携版" class="headerlink" title="便携版"></a>便携版</h3><p>能够下载完解压之后无需安装即可直接使用的软件，所有的配置文件也都在程序运行的文件目录下（非用户目录下），理论上可以配置完成一次之后就可以用一辈子了（#笑）</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>开放程序源代码，任何人都可以自由浏览</p><h3 id="部分开源"><a href="#部分开源" class="headerlink" title="部分开源"></a>部分开源</h3><p>指程序既有开源版本又有商业版本，所以标识为部分开源</p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>至少兼容两个主流 PC 系统平台（Windows/MacOS #Linux 桌面在哭泣 #笑）才会标记为跨平台</p><h3 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h3><p>所有功能都完全免费（或许有捐助请求）才会标识为免费，有收费的高级功能的程序不会被标记为免费，例如 IDEA 就不会被标识为免费</p><blockquote><p>以上均为吾辈个人主观认知，参考一下就好。。。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>工具</tag>
      
      <tag>待更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用命令</title>
    <link href="/p/009384f82d44496ba4de15eec4625156/"/>
    <url>/p/009384f82d44496ba4de15eec4625156/</url>
    
    <content type="html"><![CDATA[<p>记录一些最常用的命令（从上往下使用频率依次降低），当然，这里只是吾辈个人的，其他功能可能暂时还没用到呢</p><blockquote><p>详细的 git 相关知识强烈推荐 <a href="https://git-scm.com/book/zh">Pro Git</a></p></blockquote><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><table><thead><tr><th>关键词</th><th>命令格式</th><th>命令解释</th><th>命令示例</th><th>命令解释</th></tr></thead><tbody><tr><td>init</td><td><code>git init</code></td><td>为当前目录初始化 git 本地仓库</td><td></td><td></td></tr><tr><td>add</td><td><code>git add [要追踪的文件/路径]</code></td><td>添加到 git 跟踪</td><td><code>git add -A</code></td><td>追踪仓库目录下的所有文件</td></tr><tr><td>commit</td><td><code>git commit [路径] [选项] [提交说明]</code></td><td>提交当前的修改内容</td><td><code>git commit -a -m &quot;提交全部的修改&quot;</code></td><td>提交了全部的修改内容（仍在本机）</td></tr><tr><td>remote</td><td><code>git remote [选项] [远程仓库名]</code></td><td>操作 git 远程仓库</td><td><code>git remote</code></td><td>显示所有远程仓库的别名</td></tr><tr><td></td><td></td><td></td><td><code>git remote add origin https://github.com/rxliuli/rxliuli.github.io.git</code></td><td>为本地仓库关联一个远程仓库</td></tr><tr><td></td><td></td><td></td><td><code>git remote show origin</code></td><td>显示 origin 远程仓库的详细信息</td></tr><tr><td></td><td></td><td></td><td><code>git remote remove origin</code></td><td>删除 origin 远程仓库</td></tr><tr><td>push</td><td><code>git push [远程别名] [远程分支]</code></td><td>推送本地修改到远程</td><td><code>git push origin master</code></td><td>推送本地修改到远程 origin 的 master 分支上</td></tr><tr><td>pull</td><td><code>git pull [远程别名] [远程分支]</code></td><td>拉取远程修改到本地</td><td><code>git pull origin master</code></td><td>拉去远程 origin 上 master 分支的修改到本地</td></tr><tr><td>status</td><td><code>git status</code></td><td>查看本地仓库的状态，以此得知添加和修改的文件</td><td></td><td></td></tr><tr><td>clone</td><td><code>git clone [远程仓库地址]</code></td><td>克隆一个远程仓库到本地，这里和 pull 不同点在于本地不存在要克隆的仓库</td><td><code>git clone https://github.com/rxliuli/rxliuli.github.io.git</code></td><td>克隆吾辈的博客 github 仓库到本地</td></tr><tr><td>log</td><td><code>git log [选项]</code></td><td>查看 git 日志</td><td><code>git log</code></td><td>简单的查看 git commit 历史纪录</td></tr><tr><td>revert</td><td><code>git revert [提交记录 hash]</code></td><td>撤销掉指定提交</td><td><code>git revert ab1c2d2</code></td><td>撤销一次提交内容，然后将撤销的内容作为修改提交一次，保留了所有的记录</td></tr><tr><td>reset</td><td><code>git reset [提交记录 hash]</code></td><td>重置到某次提交上，和上面不一样的是不会添加新的提交记录，而是删除已有的提交记录</td><td><code>git reset ab1c2d2</code></td><td>不会在 log 中留下痕迹</td></tr><tr><td></td><td><code>git reset HEAD~[N 回退次数]</code></td><td>回退最近几次的提交, N 为几就回退几次</td><td><code>git reset HEAD~1</code></td><td>回退最近一次的提交</td></tr><tr><td>branch</td><td><code>git branch [分支]</code></td><td>git 分支(强大而又复杂的功能)</td><td><code>git branch dev</code></td><td>创建 dev 分支</td></tr><tr><td></td><td></td><td></td><td><code>git branch</code></td><td>列出所有分支</td></tr><tr><td></td><td></td><td></td><td><code>git branch dev -D</code></td><td>删除名为 dev 的分支</td></tr><tr><td>checkout</td><td><code>git checkout [分支名]</code></td><td>切换当前分支(分支之间不共享修改)</td><td><code>git checkout master</code></td><td>切换当前分支到 master 分支</td></tr><tr><td></td><td></td><td></td><td><code>git checkout origin/dev -b dev</code></td><td>拉取远程分支到本地并切换</td></tr><tr><td>merge</td><td><code>git merge [选项]</code></td><td>合并其他分支的修改到当前分支上</td><td><code>git merge dev</code></td><td>合并 dev 分支的修改到当前分支(一般是 master 分支)</td></tr><tr><td></td><td></td><td></td><td><code>git merge origin/master --allow-unrelated-histories</code></td><td>强行合并远程分支到本地</td></tr><tr><td>push</td><td><code>git push [远程仓库名] :[分支名]</code></td><td>删除掉指定的远程分支（仓库还在，只是删除分支）</td><td><code>git push origin :dev</code></td><td>删除远程仓库 origin 下的 dev 开发分支</td></tr><tr><td>stash</td><td><code>git stash</code></td><td>暂存本地更改</td><td></td><td></td></tr><tr><td></td><td><code>git stash list</code></td><td>查看所有暂存更改</td><td></td><td></td></tr><tr><td></td><td><code>git stash apply [index]</code></td><td>重新应用指定暂存更改</td><td><code>git stash apply</code></td><td>重新应用最新的暂存更改</td></tr><tr><td></td><td><code>git stash drop [index]</code></td><td>删除掉指定的暂存更改</td><td><code>git stash drop</code></td><td>删除掉最新的暂存更改</td></tr></tbody></table><h2 id="复合命令"><a href="#复合命令" class="headerlink" title="复合命令"></a>复合命令</h2><h3 id="撤销掉本地所有的修改"><a href="#撤销掉本地所有的修改" class="headerlink" title="撤销掉本地所有的修改"></a>撤销掉本地所有的修改</h3><p>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git add -A &amp;&amp; git stash &amp;&amp; git stash drop<br></code></pre></td></tr></table></figure><p>解释</p><ol><li> 添加所有更改到 git 追踪中（如果没有被忽略的话）</li><li> 添加所有本地更改到暂存区域中</li><li> 删除掉刚添加的最新暂存更改</li></ol><p>应用场景<br>修改了一些文件但又没有提交，突然发现有问题，想把它们全删除了重来，或者全部回到上次提交，先把这些修改暂存起来（不加最后一条命令）</p><h3 id="区分文件名大小写"><a href="#区分文件名大小写" class="headerlink" title="区分文件名大小写"></a>区分文件名大小写</h3><p>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config core.ignorecase <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>解释<br>Windows 下默认不区分文件名大小写，所以需要特别设置一下。</p><h3 id="git-push-强制推送"><a href="#git-push-强制推送" class="headerlink" title="git push 强制推送"></a>git push 强制推送</h3><p>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push -f<br></code></pre></td></tr></table></figure><p>解释</p><p>强制推送到远程分支，即便是远程包含本地不存在的提交</p><h3 id="忽略已经跟踪的文件的提交"><a href="#忽略已经跟踪的文件的提交" class="headerlink" title="忽略已经跟踪的文件的提交"></a>忽略已经跟踪的文件的提交</h3><blockquote><p>参考：<a href="https://ruby-china.org/topics/17948">怎样让 Git 忽略当前已经更改的文件</a></p></blockquote><p>忽略修改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git update-index --assume-unchanged &lt;files&gt;<br></code></pre></td></tr></table></figure><p>取消这种设定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git update-index --no-assume-unchanged &lt;files&gt;<br></code></pre></td></tr></table></figure><h3 id="从远端拉取分支"><a href="#从远端拉取分支" class="headerlink" title="从远端拉取分支"></a>从远端拉取分支</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/phpper/p/7136048.html">git 获取远程服务器的指定分支</a></p></blockquote><p>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout -b [本地分支名(不存在)] [远程分支名]<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout -b dev origin/dev<br></code></pre></td></tr></table></figure><h3 id="忽略已提交的文件修改"><a href="#忽略已提交的文件修改" class="headerlink" title="忽略已提交的文件修改"></a>忽略已提交的文件修改</h3><blockquote><p>参考：<a href="https://www.jianshu.com/p/e5b13480479b">git 如何忽略已经提交的文件 (.gitignore 文件无效)</a></p></blockquote><p>主要用于忽略一些本地修改的文件但又不希望提交，同时也不希望添加到 .gitignore 中将之从云端排除的方式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git update-index --assume-unchanged [file-pattern]<br></code></pre></td></tr></table></figure><h3 id="git-删除远程-tag"><a href="#git-删除远程-tag" class="headerlink" title="git 删除远程 tag"></a>git 删除远程 tag</h3><p>显示本地 tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs null">git tag<br></code></pre></td></tr></table></figure><p>删除本地 tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs null">git tag -d Remote_Systems_Operation &#96;&#96;&#96;<br></code></pre></td></tr></table></figure><p>用 push, 删除远程 tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs null">git push origin :refs&#x2F;tags&#x2F;Remote_Systems_Operation&#96;&#96;&#96;<br></code></pre></td></tr></table></figure><p>删除远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs null">git branch -r -d origin&#x2F;branch-name<br>git push origin :branch-name<br></code></pre></td></tr></table></figure><h3 id="两个-git-仓库合并"><a href="#两个-git-仓库合并" class="headerlink" title="两个 git 仓库合并"></a>两个 git 仓库合并</h3><p>现在有两个仓库 <a href="https://github.com/kktjs/kkt.git">kktjs/kkt</a> 和 <a href="https://github.com/kktjs/kkt-next.git">kktjs/kkt-next</a> 我们需要将 <code>kkt-next</code> 仓库合并到 <code>kkt</code> 并保留 <code>kkt-next</code> 的所有提交内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1. 克隆主仓库代码</span><br>git <span class="hljs-built_in">clone</span> git@github.com:kktjs/kkt.git<br><br><span class="hljs-comment"># 2. 将 kkt-next 作为远程仓库，添加到 kkt 中，设置别名为 other</span><br>git remote add other git@github.com:kktjs/kkt-next.git<br><br><span class="hljs-comment"># 3. 从 kkt-next 仓库中拉取数据到本仓库</span><br>git fetch other<br><br><span class="hljs-comment"># 4. 将 kkt-next 仓库拉取的 master 分支作为新分支 checkout 到本地，新分支名设定为 kkt-next</span><br>git checkout -b kkt-next other/master<br><br><span class="hljs-comment"># 5. 切换回 kkt 的 master 分支</span><br>git checkout master<br><br><span class="hljs-comment"># 6. 将 kkt-next 合并入 kkt 的 master 分支</span><br>git merge kkt-next<br><br><span class="hljs-comment"># 如果第 6 步报错 `fatal: refusing to merge unrelated histories`</span><br><span class="hljs-comment"># 请执行下面命令 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br>git merge kkt-next --allow-unrelated-histories<br></code></pre></td></tr></table></figure><blockquote><p>JetBrains IDE 提供了非常好用的冲突合并工具</p></blockquote><p>在合并时有可能两个分支对同一个文件都做了修改，这时需要解决冲突，对文本文件来说很简单，根据需要对冲突的位置进行处理就可以。对于二进制文件，需要用到如下命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout --theirs YOUR_BINARY_FILES     <span class="hljs-comment"># 保留需要合并进来的分支的修改</span><br>git checkout --ours YOUR_BINARY_FILES       <span class="hljs-comment"># 保留自己的修改</span><br>git add YOUR_BINARY_FILES<br></code></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://segmentfault.com/a/1190000021919753">https://segmentfault.com/a/1190000021919753</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 ESDoc 生成文档</title>
    <link href="/p/0189609a78e3428ea69f25852d50cae5/"/>
    <url>/p/0189609a78e3428ea69f25852d50cae5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://esdoc.org/">esdoc 官网</a>, <a href="https://blog.rxliuli.com/p/91fc75b3/">博客地址</a>, <a href="https://github.com/rxliuli/esdocs-example">示例项目</a></p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在尝试过使用 <a href="https://md.rxliuli.com/">markdown</a>, <a href="http://usejsdoc.org/">jsdoc</a>, <a href="https://www.docz.site/">docz</a> 之后，吾辈终于找到了一个比较满意工具 – esdocs。</p><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li><strong>开箱即用</strong>: 毫无疑问, js 正在把一切事情变得复杂，到处都是大量的配置，永远都学不会开箱即用</li><li><strong>支持 jsdoc 注释</strong>: 已经熟悉了 jsdoc，所以不太希望切换到其他的注释规范了呢</li><li><strong>可配置自定义页</strong>: 作为文档 API 列表还算合适，然而首页的话果然还是自定义最好</li></ul><p>因为以上的期望，吾辈最终选择了 esdocs。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D esdoc esdoc-standard-plugin<br></code></pre></td></tr></table></figure><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>创建一个配置文件 <em>.esdoc.json</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;source&quot;</span>: <span class="hljs-string">&quot;./src&quot;</span>,<br>  <span class="hljs-attr">&quot;destination&quot;</span>: <span class="hljs-string">&quot;./docs&quot;</span>,<br>  <span class="hljs-attr">&quot;plugins&quot;</span>: [&#123; <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;esdoc-standard-plugin&quot;</span> &#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果你使用的命令行是 <strong>bash</strong>/<strong>git-for-bash</strong>/<strong>cmder</strong> 的话，亦可使用命令快速完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">  &quot;source&quot;: &quot;./src&quot;,</span><br><span class="hljs-string">  &quot;destination&quot;: &quot;./docs&quot;,</span><br><span class="hljs-string">  &quot;plugins&quot;: [&#123;&quot;name&quot;: &quot;esdoc-standard-plugin&quot;&#125;]</span><br><span class="hljs-string">&#125;&#x27;</span> &gt; .esdoc.json<br></code></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在 <em>package.json</em> 中添加一个打包文档的 <code>script</code> 命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;docs&quot;: &quot;esdoc&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用 <code>yarn docs</code> 命令即可打包一份新鲜可用的文档啦</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>然后打开 <em>docs/index.html</em> 文件即可查看了，下面截张吾辈的工具库 <a href="https://rx-util.rxliuli.com/">rx-util</a> 生成的文档。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190331002416.png" alt="rx-util"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉是不是很简单，吾辈也是这样认为的呢！后面会整理一份 jsdoc 的标签列表，便于快速查找与一览。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 热部署</title>
    <link href="/p/03007913ebf74eaba1ccc8d069709f22/"/>
    <url>/p/03007913ebf74eaba1ccc8d069709f22/</url>
    
    <content type="html"><![CDATA[<p>在阅读本篇之前至少需要对以下概念有基本的认知：</p><ul><li>Java</li><li>JetBrains IDEA</li></ul><hr><h2 id="热部署-是什么？"><a href="#热部署-是什么？" class="headerlink" title="热部署 是什么？"></a><strong>热部署</strong> 是什么？</h2><p>以下内容引用于度娘百科：<a href="https://baike.baidu.com/item/%E7%83%AD%E9%83%A8%E7%BD%B2">https://baike.baidu.com/item/%E7%83%AD%E9%83%A8%E7%BD%B2</a></p><blockquote><p>所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。<br>对于 Java 应用程序来说，热部署就是在运行时更新 Java 类文件。在基于 Java 的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。大多数基于 Java 的应用服务器，包括 EJB 服务器和 Servlet 容器，都支持热部署。类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。</p></blockquote><p>简而言之，就是你在开发 Web 程序时不需要在每次 <strong>修改代码</strong> 之后都要重启 Web 容器再看效果了。</p><blockquote><p>修改按文件类型分类大致有：Java 源代码，<code>src/main/resource</code> 下的资源文件，<code>src/main/webapp</code> 下的前端资源文件，<code>src/main/webapp</code> 下的模板文件（例如 JSP/Freemarker），亦或是 <code>web.xml</code> 这种 Web 容器的配置文件。</p></blockquote><p>好了，废话就不说了（然而还是要了解一下概念啦）</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ol><li><p>在编辑运行配置窗口，配置 Tomcat（其他 Web 容器应该也类似）的页面。<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210657.png" alt="配置 Tomcat"></p></li><li><p>点击 Deployment 选项卡，配置要运行的 war，必须要选择 <strong>exploded</strong> 进行部署。<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210737.png" alt="Deployment 选项卡"></p></li><li><p>回到 Server 选项卡，配置 IDEA 在发现代码/框架发生变化是执行的动作。<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210756.png" alt="配置 IDEA 在发现代码"></p></li></ol><p>然后，点击 OK 就可以了，接下来以 <code>Debug</code> 默认运行就可以自动帮你更新 Java 源码和 resources 资源文件以及 webapp 下的静态文件/模板文件了，愉快的玩耍吧！</p><hr><h2 id="多模块配置"><a href="#多模块配置" class="headerlink" title="多模块配置"></a>多模块配置</h2><blockquote><p>注：如果你还没有接触多模块的话，可以略过下面的内容。</p></blockquote><p>。。。然而不幸的是对于多模块项目以及各种各样的框架和类库，IDEA 本身的热部署实在不够看。所以如果你想要更强大的热部署功能的话，可以使用 <strong>Jrebel</strong> 这个插件。</p><ol><li><p>IDEA 的官方 Plugin 商店里面就有这个，点击安装（由于众所周知的原因，下载可能比较慢），安装完成之后重启。</p><blockquote><p>然后，如果你不愿意支持正版又不打算折腾破解的话，也可以不用看下面的内容了（关于破解方法可以参考 <a href="https://blog.rxliuli.com/p/88d60541/">https://blog.rxliuli.com/p/88d60541/</a>）<br><a href="https://www.google.lk/search?q=IDEA+Jrebel+%E7%A0%B4%E8%A7%A3&oq=IDEA+Jrebel+%E7%A0%B4%E8%A7%A3">Google 上的相关内容</a></p></blockquote></li><li><p>在 <code>help &gt; Jrebel &gt; Activation</code> 下输入 License<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210822.png" alt="20181122210822"><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210839.png" alt="20181122210839"><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210910.png" alt="20181122210910"></p></li><li><p>接下来如上面那样配置 IDEA 的 Tomcat 运行选项之后（就是没装 Jrebel 的那种热部署方式），然后点击 <code>View &gt; Tool Windows &gt; JRebel</code></p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210932.png" alt="20181122210932"></p><p> 看到左侧弹出一个面板，选择你要热部署的模块，或者选择第一个以全选所有模块</p><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210941.png" alt="20181122210941"></p><blockquote><p>你或许发现了 <code>src/main/resources</code> 目录下多了一个奇怪的配置文件 <code>rebel.xml</code>，然而你并不需要在意，因为它是 Jrebel 的热部署配置文件。</p></blockquote><p> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210955.png" alt="Jrebel 的热部署配置文件"></p></li><li><p>最后，点击 Jrebel 的 Debug 按钮即可<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211005.png" alt="Jrebel Debug"></p></li><li><p>使用 Jrebel 调试项目即可<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190325101659.png" alt="Jrebel 调试项目"></p></li><li><p> 现在，每当你的焦点离开 IDEA（切换到浏览器），Jrebel 就会自动检测变化的类和资源并帮你重新编译了（状态栏会有提示）</p></li></ol><blockquote><p>附：这里提供吾辈自建的一个激活服务器，请勿滥用：<a href="http://39.108.15.57:8181/947122a0-7e9a-4bea-814d-876525d3767f">http://39.108.15.57:8181/947122a0-7e9a-4bea-814d-876525d3767f</a><br>邮箱的话格式正确即可</p></blockquote><p>那么，IDEA 的热部署配置就到这里了，实际上使用了 <code>SpringBoot</code> 之后就自带了热部署相关的类库。。。#贴心</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何编写一篇好的技术文章</title>
    <link href="/p/052bd63484684f78891a5dbaf8e84c10/"/>
    <url>/p/052bd63484684f78891a5dbaf8e84c10/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>人的目标总是追求「优越性」，是要摆脱自卑感以求得到优越感。</p></blockquote><p>现在网络上已经有很多写作平台了，让我们数数: 静态/动态博客（Hexo/WordPress），SegmentFault 专栏，简书，掘金，CSDN 博客。然而写作平台很多，愿意写作的人也很多，那么是否意味着我们就更容易获取知识了呢？其实并不是，原因在于很多人写作只是跟风，觉得很<strong>酷</strong>，所以用 <code>hexo/hugo + github pages</code> 建了静态站点发了一篇 <strong>hello world</strong> 之后就没有下文了。这种暂且按下不表，吾辈主要想说的是另一种：为了写作（<del>积分</del>）而写作，完全不用心，只是简单的把概念复制了一下，甚至直接<strong>抄袭</strong>别人的文章，不注明来源，而且没有尝试过文章做法的人。</p><blockquote><p>这里强烈批评一下 CSDN 博客，虽然也有一些优质的博客，但更多的是直接<strong>抄袭</strong>的文章，而且大多数都存在问题，实在令人深痛恶绝。甚至于，有人专门写了油猴脚本 <a href="https://greasyfork.org/zh-CN/scripts/375279">google 百度搜索屏蔽 CSDN</a> 用来屏蔽它，糟糕程度可见一斑。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么，真的想要开始写作，想要把自己的知识、感触和经验分享给其他人的话，有没有什么写作的技巧，或者说遵循的规则呢？下面是吾辈写作至今以来的一些经验，希望能帮到真心想要写作的人。</p><p>重点</p><ul><li>是什么？</li><li>怎么做？</li><li>在哪里用？</li></ul><p>细节</p><ul><li>排版样式</li><li>插图</li><li>错别字</li><li>转发文章</li></ul><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>如果要写一个技术文档，那么有三点是必须要注意的。</p><ul><li>是什么？<br>可以是技术的一些简单介绍，或是在什么场景下会遇到这种问题，也可以是为什么要写这篇文章。就像吾辈，基本上每篇文章的正文都会有一个<strong>场景</strong>段落，用来介绍吾辈为什么写这篇文章，以及对涉及问题的介绍（吐槽 #打）。</li><li>怎么做？<br>正确的描述具体如何使用，或是如何使用代码<strong>实现功能/修复错误</strong>。例如介绍 JavaScript Array 的文章，那就需要告诉读者如何使用常见的 API，例如 <code>forEach, filter, map, reduce</code> 这些函数，如何的使用它们，给出一些具体可运行的示例，如果有你觉得读者会难以理解的部分，更应该详细解释，并配上代码示例。</li><li>在哪里用？<br>写作最有可能漏掉的部分，但却是最重要的。如果文章只是单纯罗列了一堆概念和代码，却不告诉读者在什么场景下才会用到，那么这只会是相当糟糕的文章，还不如去看官方文档（大部分文档都是告诉怎么做而不告诉在哪里用，尤其是某些 HTML/CSS 书籍，简直是把 MDN 的文档抄了一遍），至少还准确一些。</li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li>排版样式<br>读者进入网页之后，第一眼看到的绝对不是具体的内容，而是网页的排版大致是什么样子的，这点在读者阅读时能够清晰的感受出来。就像人的外貌，在开口前读者便能藉此看出大概（所谓以貌取人）。即便可能在读者继续阅读内容而扭转形象，但更有可能是读者直接点 X 关闭网页，并且留下了不好的印象。<br>所以排版真的很重要，下面提供吾辈的几条经验:<ul><li>不要是纯 TXT 文本格式（<strong>大忌</strong>）</li><li>使用代码块包裹代码片段，不要直接和普通文本一样，没有语法高亮看代码会死人的。</li><li>合理使用标题。标题应该是逐级减小，而不应该出现一级标题，然后立刻就是三级标题，中间一定且必须有一个二级标题。</li><li>文章中的链接应该是可点击的，并且最好引用一些比较官方的内容（MDN，Wiki）。</li><li>错误示例: <a href="https://blog.csdn.net/xlxxcc/article/details/52083543">https://blog.csdn.net/xlxxcc/article/details/52083543</a></li></ul></li><li>插图<br>如果说排版样式是外貌，那图片就像人的衣服一样，能为文章锦上添花。更何况还有 <a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E7%95%AB%E5%8B%9D%E5%8D%83%E8%A8%80">一图胜千言</a> 的说法，可以避免读者在阅读时感到无聊。像是如果有流程图/原理图/时序图这些，将会显著的提高文章的层次。<blockquote><p>附: 画图真的很花时间，如果有图片的话，说明作者是真的用心在写文章。（一般是大佬才会做，吾辈不是大佬，所以一般不会画图 #笑哭）</p></blockquote></li><li>错别字<br>但凡写作，如果有人说自己没写过错别字，吾辈是第一个不信的。人非圣贤，孰能无过。写作时出现错别字是很正常的，但由于人类本身的原因（参考 <a href="https://www.guokr.com/article/439010/">查出自己的错别字，为什么这么难？</a>），所以想要检查是比较困难的 – 但并不是毫无办法，我们在文章发布后，在网络上再次查看文章，会比在编辑器中更容易察觉到文章中的问题，这其中当然包含错别字。</li><li>转发文章<br>当我们在网络上看到别人的文章，觉得写得很好，于是转发了文章想让更多人看到。但在转发之前，最好先询问一下原作者的意愿（一般是允许署名转载的），而且必须要在显眼的位置（文章顶部或尾部，一般最好是顶部）放置原文的链接，以使读者能够找到原作者。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面说了这么多，还有最后一句话要送给大家: <strong>保持作者这个称呼的基本水平和对读者的基本尊重</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 善用解构赋值</title>
    <link href="/p/0e74662caf3c4fcca4ff06b4282e9577/"/>
    <url>/p/0e74662caf3c4fcca4ff06b4282e9577/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在今天写 JavaScript 函数时，发现了一个有趣的技巧。</p><p>在此之前，吾辈想知道泥萌需要默认值的时候是如何做的呢？</p><p>例如下面的函数 <code>print</code>，吾辈需要在没有给定参数 <code>user</code> 的情况下，给出合适的输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!user) &#123;<br>    user = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!user.name) &#123;<br>    user.name = <span class="hljs-string">&quot;未设置&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!user.age) &#123;<br>    user.age = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;user.name&#125;</span>，年龄：<span class="hljs-subst">$&#123;user.age&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，我们应该怎么优化呢？</p><ul><li>三元表达式</li><li><code>||</code> / <code>&amp;&amp;</code> 赋予默认值</li><li><code>Object.assign()</code> 合并对象</li></ul><p>我们分别来实现一下</p><h3 id="三元表达式实现"><a href="#三元表达式实现" class="headerlink" title="三元表达式实现"></a>三元表达式实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  user = user ? user : &#123;&#125;;<br>  <span class="hljs-built_in">console</span>.log(<br>    <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;user.name ? user.name : <span class="hljs-string">&quot;未设置&quot;</span>&#125;</span>，年龄：<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-string"><span class="hljs-subst">      user.age ? user.age : <span class="hljs-number">0</span></span></span><br><span class="hljs-string"><span class="hljs-subst">    &#125;</span>`</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="amp-amp-赋予默认值"><a href="#amp-amp-赋予默认值" class="headerlink" title="|| / &amp;&amp; 赋予默认值"></a><code>||</code> / <code>&amp;&amp;</code> 赋予默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<br>    <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;(user || &#123;&#125;).name || <span class="hljs-string">&quot;未设置&quot;</span>&#125;</span>，年龄：<span class="hljs-subst">$&#123;(user || &#123;&#125;).age || <span class="hljs-number">0</span>&#125;</span>`</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>&amp;&amp;</code> 也可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<br>    <span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;(user &amp;&amp; user.name) || <span class="hljs-string">&quot;未设置&quot;</span>&#125;</span>，年龄：<span class="hljs-subst">$&#123;(user &amp;&amp; user.age) || <span class="hljs-number">0</span>&#125;</span>`</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>||</code> / <code>&amp;&amp;</code> 解释</p><ul><li><code>||</code> 用来取默认值，避免太多的 <code>if</code> 判断。例如对于 <code>a || b</code> 我们可以认为：如果 <code>a</code> 为空，则赋值为 <code>b</code></li><li><code>&amp;&amp;</code> 用来连续执行，避免深层嵌套的 <code>if</code> 判断。例如对于 <code>a || b</code>，我们可以认为：如果 <code>a</code> 不为空，则赋值为 <code>b</code></li></ul><p>注：||<code>/</code>&amp;&amp;` 非常适合简单的默认值赋值，但一旦设置到深层嵌套默认值就不太合适了</p></blockquote><h3 id="Object-assign-合并对象"><a href="#Object-assign-合并对象" class="headerlink" title="Object.assign() 合并对象"></a><code>Object.assign()</code> 合并对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  _user = &#123;<br>    name: <span class="hljs-string">&quot;未设置&quot;</span>,<br>    age: <span class="hljs-number">0</span>,<br>  &#125;;<br>  user = <span class="hljs-built_in">Object</span>.assign(_user, user);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;user.name&#125;</span>，年龄：<span class="hljs-subst">$&#123;user.age&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>可以看出</p><ol><li> 三元表达式的方式方式明显有点繁琐</li><li> <code>||</code> / <code>&amp;&amp;</code> 很好很强大，缺点是看起来很不直观，而且容易混淆</li><li> <code>Object.assign()</code> 合并对象的方式应该算是最好的了，然而是在方法内部进行的初始化，作为调用者除非查看文档或源码才能知道</li></ol><p>那么，有没有更好的解决方案呢？</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值是 ES6 的一个新的语法，具体可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">MDN</a>。</p><p>下面是一些简单的解构赋值操作</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> [first, second, ...remaining] = arr; <span class="hljs-comment">// first: 1, second: 2, remaining: [3, 4]</span><br><span class="hljs-comment">// 接受一或多个可变参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>(<span class="hljs-params">...arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&quot;, &quot;</span>);<br>&#125;<br><span class="hljs-comment">// 调用时可以使用 ... 将数组解构</span><br>join(...arr); <span class="hljs-comment">// 1, 2, 3, 4</span><br><span class="hljs-comment">// 忽略开始的某些值</span><br><span class="hljs-keyword">var</span> [, , ...remaining] = arr; <span class="hljs-comment">// remaining: [3, 4]</span><br><span class="hljs-comment">// 默认值</span><br><span class="hljs-keyword">var</span> [first = <span class="hljs-number">1</span>, second = <span class="hljs-number">2</span>, ...remaining] = []; <span class="hljs-comment">// first: 1, second: 2, remaining:</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>,<br>  b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 交换变量</span><br>[a, b] = [b, a]; <span class="hljs-comment">// a: 2, b: 1</span><br></code></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> user = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  name: <span class="hljs-string">&quot;未设置&quot;</span>,<br>  age: <span class="hljs-number">0</span>,<br>  sex: <span class="hljs-literal">false</span>,<br>&#125;;<br><span class="hljs-comment">// 排除指定属性</span><br><span class="hljs-keyword">var</span> &#123; name, age, ...rest &#125; = user; <span class="hljs-comment">// name: &#x27;未设置&#x27;, age: 0, 其他属性: &#123; &quot;id&quot;: 1,&quot;sex&quot;: false &#125;</span><br><br><span class="hljs-comment">// 使用新的变量名</span><br><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">name</span>: newName, <span class="hljs-attr">age</span>: newAge &#125; = user; <span class="hljs-comment">// newName: &#x27;未设置&#x27;, newAge: 0</span><br><span class="hljs-comment">// 默认值</span><br><span class="hljs-keyword">var</span> &#123; name = <span class="hljs-string">&quot;未设置&quot;</span>, age = <span class="hljs-number">0</span> &#125; = &#123;&#125;; <span class="hljs-comment">// name: &#x27;未设置&#x27;, age: 0</span><br><span class="hljs-comment">// 同时使用新的变量名和默认值</span><br><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">name</span>: newName = <span class="hljs-string">&quot;未设置&quot;</span>, <span class="hljs-attr">age</span>: newAge = <span class="hljs-number">0</span> &#125; = user; <span class="hljs-comment">// newName: &#x27;未设置&#x27;, newAge: 0</span><br><span class="hljs-comment">// 计算属性名</span><br><span class="hljs-keyword">var</span> key = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-keyword">var</span> &#123; [key]: name &#125; = user;<br><br><span class="hljs-comment">// 数组迭代解构</span><br><span class="hljs-keyword">var</span> users = [<br>  &#123;<br>    name: <span class="hljs-string">&quot;琉璃&quot;</span>,<br>    age: <span class="hljs-number">17</span>,<br>  &#125;,<br>  &#123;<br>    name: <span class="hljs-string">&quot;楚轩&quot;</span>,<br>    age: <span class="hljs-number">23</span>,<br>  &#125;,<br>];<br>users.map(<span class="hljs-function">(<span class="hljs-params">&#123; name, age &#125;</span>) =&gt;</span> <span class="hljs-string">`name: <span class="hljs-subst">$&#123;name&#125;</span>, age: <span class="hljs-subst">$&#123;age&#125;</span>`</span>).join(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">// 解构函数实参</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">&#123; name = <span class="hljs-string">&quot;未设置&quot;</span>, age = <span class="hljs-number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;name&#125;</span>，年龄：<span class="hljs-subst">$&#123;age&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>啊嘞，吾辈好像不知不觉间把解决方案写出来了。。。？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>让我们好好看下这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">&#123; name = <span class="hljs-string">&quot;未设置&quot;</span>, age = <span class="hljs-number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`姓名：<span class="hljs-subst">$&#123;name&#125;</span>，年龄：<span class="hljs-subst">$&#123;age&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一眼看过去，是不是感觉很直观，如果稍微了解一点 ES6 就能瞬间明白这是解构赋值以及默认参数</p><p>我们分析一下具体流程</p><ol><li><p> 调用 <code>print</code> 函数</p></li><li><p>检查参数是否为有值，没有的话设置默认值 <code>&#123;&#125;</code><br> 相当于</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!user) &#123;<br>  user = &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>解构参数，检查解构的属性是否有值，没有的话设置默认值<br> 相当于</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name;<br><span class="hljs-keyword">if</span> (!user.name) &#123;<br>  name = <span class="hljs-string">&quot;未设置&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  name = user.name;<br>&#125;<br><span class="hljs-keyword">var</span> age;<br><span class="hljs-keyword">if</span> (!user.age) &#123;<br>  age = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  age = user.age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 进入函数内部</p></li></ol><p>关键就在于第 2,3 步，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters">默认参数</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a> 都是 ES6 的新特性，善于使用能大大简化代码的繁琐性。</p><hr><p>希望有更多的人能够学会怎么使用，让我们早日抛弃 babel 吧 (*＾ ▽ ＾)／</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 打包的静态文件不能直接运行</title>
    <link href="/p/120ca30c1003493eadd2e619edd5cf3f/"/>
    <url>/p/120ca30c1003493eadd2e619edd5cf3f/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>吾辈使用 <strong>vue-cli</strong> 直接生成的 vue 模板项目，在模板之上继续开发的。然而在使用 <code>npm run build</code> 打包项目时，却发现打包好的项目在浏览器中直接打开好像什么都没有？</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>查看了一下打包后的 <code>index.html</code> 源码，终于发现了一个重要的点：</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029131219.png" alt="vue-cli 打包的项目 index.html 源码"></p><p><em>所有涉及到路径的地方全都是以 <strong>/</strong> 开头的</em></p><p>下面是吾辈打包后生成的 dist 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">dist:.<br>│  index.html<br>│<br>└─static<br>    ├─css<br>    │      app.b7bce283257fbd427fb1dc3fea80cee1.css<br>    │      app.b7bce283257fbd427fb1dc3fea80cee1.css.map<br>    │<br>    ├─fonts<br>    │      MaterialIcons-Regular.012cf6a.woff<br>    │      MaterialIcons-Regular.570eb83.woff2<br>    │      MaterialIcons-Regular.a37b0c0.ttf<br>    │      MaterialIcons-Regular.e79bfd8.eot<br>    │<br>    └─js<br>            app.58cce746b2fe4ac2f2b9.js<br>            app.58cce746b2fe4ac2f2b9.js.map<br>            manifest.2ae2e69a05c33dfc65f8.js<br>            manifest.2ae2e69a05c33dfc65f8.js.map<br>            vendor.a32972498ed8de656202.js<br>            vendor.a32972498ed8de656202.js.map<br></code></pre></td></tr></table></figure><p>这下很清楚了，vue-cli 生成的模板项目打包后的文件默认需要放到静态资源服务器上，而且还必须是根目录！这很不好，很糟糕，所以需要修改配置。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>修改文件 _/config/index.js_，将 <code>build.assetsPublicPath</code> 属性的值由 <code>/</code> 改为 <code>./</code><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029133603.png" alt="/config/index.js"></li><li>修改文件 _/build/utils.js_，在插件 <code>ExtractTextPlugin</code> 中添加 <code>publicPath: &#39;../../&#39;</code><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029133636.png" alt="/build/utils.js"></li></ol><p>那么，使用 <code>npm run build</code> 重新打包后的静态文件应该就可以直接打开啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 实现一个滚动到顶部的悬浮图标组件</title>
    <link href="/p/16cd2e0d13e84b93a3a8469b167623b0/"/>
    <url>/p/16cd2e0d13e84b93a3a8469b167623b0/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在写 vuejs 前端项目的时候，需要实现一个下拉文章列表时，出现一个悬浮按钮，用于一键回到文章顶部。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>实现源码放到了 <a href="https://github.com/rxliuli/vue-scroll-to-top-component">GitHub</a>，<a href="https://vue-scroll-to-top-component.rxliuli.com/">Demo 演示</a> 想直接看源码/效果的人可以直接去看，但最好看一下 <a href="#%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a></p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li> 定义一个 vuejs 组件，抽取出最需要的几个属性（位置，组件的样子）</li><li> 监听窗口滚动，当滚动到第二屏的时候显示组件</li><li> 监听组件点击，点击即逐渐减少与顶端的距离</li><li> 当在滚动中用户手动下拉时终止滚动</li><li> 引用组件并传递一个 vue 模板</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>定义模板 <code>VxScrollToTop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs vuejs">&#x2F;**<br>一个 Vue 的滚动到顶部的容器组件（不提供 UI 显示）<br>使用：<br>1. 引入自定义文件上传组件: import VxScrollToTop from &#39;@&#x2F;components&#x2F;common&#x2F;VxScrollToTop&#39;<br>2. 声明它<br>export default &#123;<br>  components: &#123;<br>    VxScrollToTop: VxScrollToTop<br>  &#125;<br>&#125;<br>3. 在 template 中使用<br>&lt;vx-scroll-to-top&gt;<br>  &lt;!-- 这里面的内容随你定义，是上拉按钮要显示的样子 --&gt;<br>  &lt;v-btn color&#x3D;&quot;primary&quot;<br>          fab&gt;<br>    &lt;v-icon&gt;vertical_align_top&lt;&#x2F;v-icon&gt;<br>  &lt;&#x2F;v-btn&gt;<br>&lt;&#x2F;vx-scroll-to-top&gt;<br> *&#x2F;<br>&lt;template&gt;<br>  &lt;div :style&#x3D;&quot;scrollToTopStyle&quot;<br>       v-show&#x3D;&quot;showScrollToTop&quot;<br>       @click&#x3D;&quot;scrollToTop&quot;&gt;<br>    &lt;slot&gt;&lt;&#x2F;slot&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    &#x2F;&#x2F; 定义上拉按钮容器的位置<br>    top: &#123;<br>      type: [Number, String],<br>      default: undefined<br>    &#125;,<br>    bottom: &#123;<br>      type: [Number, String],<br>      default: undefined<br>    &#125;,<br>    left: &#123;<br>      type: [Number, String],<br>      default: undefined<br>    &#125;,<br>    right: &#123;<br>      type: [Number, String],<br>      default: undefined<br>    &#125;<br>  &#125;,<br>  data: () &#x3D;&gt; (&#123;<br>    &#x2F;&#x2F; 是否显示，初始默认不显示<br>    showScrollToTop: false,<br>    &#x2F;&#x2F; 定时器<br>    timer: null,<br>    scrollToTopStyle: &#123;<br>      position: &#39;fixed&#39;,<br>      top: &#39;&#39;,<br>      bottom: &#39;&#39;,<br>      left: &#39;&#39;,<br>      right: &#39;&#39;<br>    &#125;<br>  &#125;),<br>  methods: &#123;<br>    isNumber (str) &#123;<br>      if (!new RegExp(&#39;^[0-9]+([.]&#123;1&#125;[0-9]+)?$&#39;).test(str)) &#123;<br>        return false<br>      &#125;<br>      return true<br>    &#125;,<br>    watchPosition () &#123;<br>      if (![this.top, this.bottom, this.left, this.right].find(i &#x3D;&gt; i !&#x3D;&#x3D; undefined)) &#123;<br>        this.scrollToTopStyle.bottom &#x3D; this.scrollToTopStyle.right &#x3D; &#39;14px&#39;<br>      &#125;<br>    &#125;,<br>    watchTop () &#123;<br>      if (this.top !&#x3D;&#x3D; undefined) &#123;<br>        this.scrollToTopStyle.top &#x3D; this.isNumber(this.top) ? parseFloat(this.top) + &#39;px&#39; : this.top<br>      &#125;<br>    &#125;,<br>    watchBottom () &#123;<br>      if (this.bottom !&#x3D;&#x3D; undefined) &#123;<br>        this.scrollToTopStyle.bottom &#x3D; this.isNumber(this.bottom) ? parseFloat(this.bottom) + &#39;px&#39; : this.bottom<br>      &#125;<br>    &#125;,<br>    watchLeft () &#123;<br>      if (this.left !&#x3D;&#x3D; undefined) &#123;<br>        this.scrollToTopStyle.left &#x3D; this.isNumber(this.left) ? parseFloat(this.left) + &#39;px&#39; : this.left<br>      &#125;<br>    &#125;,<br>    watchRigth () &#123;<br>      if (this.right !&#x3D;&#x3D; undefined) &#123;<br>        this.scrollToTopStyle.right &#x3D; this.isNumber(this.right) ? parseFloat(this.right) + &#39;px&#39; : this.right<br>      &#125;<br>    &#125;,<br>    &#x2F;**<br>     * 初始化按钮的位置<br>     *&#x2F;<br>    initBtnPosition () &#123;<br>      this.watchTop()<br>      this.watchBottom()<br>      this.watchLeft()<br>      this.watchRigth()<br>      this.watchPosition()<br>    &#125;,<br>    initBindScroll () &#123;<br>      &#x2F;&#x2F; 监听窗口滚动<br>      document.onscroll &#x3D; ((oldScrollTopLength) &#x3D;&gt; &#123;<br>        const clientHeight &#x3D; document.documentElement.clientHeight<br>        return () &#x3D;&gt; &#123;<br>          const scrollTopLength &#x3D; document.documentElement.scrollTop || document.body.scrollTop<br>          &#x2F;&#x2F; 如果定时器不存在的话就正常计算滚动到顶部的图标是否存在<br>          if (!this.timer) &#123;<br>            &#x2F;&#x2F; 滚动到第二屏就显示<br>            this.showScrollToTop &#x3D; scrollTopLength &gt; clientHeight<br>          &#125;<br>          &#x2F;&#x2F; 向下滚动时判断判断是否正在向上滚动，是的话就清除定时器，停在当前位置<br>          if (scrollTopLength &gt; oldScrollTopLength &amp;&amp; this.timer) &#123;<br>            &#x2F;&#x2F; 设置这个是因为有时候 clearInterval() 并不能清除这个属性，或许是 vuejs 组件中的属性特殊一点？<br>            this.timer &#x3D; clearInterval(this.timer)<br>          &#125;<br>          oldScrollTopLength &#x3D; scrollTopLength<br>        &#125;<br>      &#125;)(0)<br>    &#125;,<br>    &#x2F;**<br>     * 回到顶部<br>     *&#x2F;<br>    scrollToTop () &#123;<br>      this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;<br>        const scrollTopLength &#x3D; document.documentElement.scrollTop || document.body.scrollTop<br>        if (scrollTopLength &lt;&#x3D; 0) &#123;<br>          this.timer &#x3D; clearInterval(this.timer)<br>          this.showScrollToTop &#x3D; false<br>        &#125;<br>        const spend &#x3D; scrollTopLength &#x2F; 5<br>        document.documentElement.scrollTop &#x3D; document.body.scrollTop &#x3D; scrollTopLength - spend<br>      &#125;, 30)<br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>    this.initBtnPosition()<br>    this.initBindScroll()<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style scoped&gt;<br>#vx-scroll-to-top-btn &#123;<br>  position: fixed;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>使用起来就很简单了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vuejs">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2 v-for&#x3D;&quot;i in 100&quot;<br>        :key&#x3D;&quot;i&quot;&gt;<br>      第 &#123;&#123;i&#125;&#125; 行文字<br>    &lt;&#x2F;h2&gt;<br>    &lt;vx-scroll-to-top&gt;<br>      &lt;!-- 这里面的内容随你定义，是上拉按钮要显示的样子 --&gt;<br>      &lt;v-btn color&#x3D;&quot;primary&quot;<br>             fab&gt;<br>        &lt;v-icon&gt;vertical_align_top&lt;&#x2F;v-icon&gt;<br>      &lt;&#x2F;v-btn&gt;<br>    &lt;&#x2F;vx-scroll-to-top&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import VxScrollToTop from &#39;@&#x2F;components&#x2F;common&#x2F;VxScrollToTop&#39;<br><br>export default &#123;<br>  components: &#123;<br>    VxScrollToTop<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>目前这里只能供了最简单的功能，如果有特别的需求可以在上面继续修改一下就好啦</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>组件方法内部必须使用 <code>箭头函数</code>，因为使用 <code>function</code> 会导致 <code>this</code> 发生变化。详情参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN</a></li><li>必须要手动置空 <code>timer</code>，例如上文所用的 <code>this.timer = clearInterval(this.timer)</code>，关于为什么 <code>timer</code> 没有被 <code>clearInterval</code> 清空目前吾辈还真不太清楚，但如果把 <code>timer</code> 放到组件外部就正常使用，估计是 vuejs 的属性有什么特殊的地方也说不定！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git 错误 Reset 恢复</title>
    <link href="/p/177cfe6054374ba69a212989fb26ce80/"/>
    <url>/p/177cfe6054374ba69a212989fb26ce80/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>今天在帮同事操作 Git 的时候，因为没有清楚理解意思，吾辈错误撤回了一些提交。</p><p>具体使用的命令是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset dd256c7d66ad2e9671cbd47650ffddc4267ca7d5<br></code></pre></td></tr></table></figure><p>感觉吾辈今天不能撤销这个错误操作的话，怕是今天别想走出公司了吧 #笑</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>当然，吾辈没有添加 <code>--hard</code> 参数，想来仓库还是有救的。之后使用 Google 搜索了一下相关的内容，找到了 <a href="http://www.voidcn.com/article/p-tfqxjpgj-bms.html">git 版本恢复命令 reset</a>，然后吾辈便尝试进行了恢复。</p><ol><li><p>找到使用 <code>git reset</code> 之前的最后一次提交的 <code>commit id</code></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看 git 记录的所有操作，包括回退操作也会记录</span><br>git reflog<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>git reset --hard</code> 回退</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 回退到指定提交，但不会将之后提交混入到未提交的内容</span><br>git reset --hard dd256c7d66ad2e9671cbd47650ffddc4267ca7d5<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>git log</code> 检查最后一次提交是否恢复</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 这时可以看到最后一次提交已经恢复了</span><br>git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure></li></ol><hr><p>嘛，只是偶然遇到的一个错误，吾辈也便稍微记录一下好了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019 回忆及 2020 目标</title>
    <link href="/p/17b171a3184c479e97ba7df9bc118023/"/>
    <url>/p/17b171a3184c479e97ba7df9bc118023/</url>
    
    <content type="html"><![CDATA[<h2 id="往事凌乱"><a href="#往事凌乱" class="headerlink" title="往事凌乱"></a>往事凌乱</h2><p>对于吾辈而言，今年发生的几件事情</p><ul><li>转型成为前端</li><li>淡出 Twitter 中文圈，逐渐回归 Telegram/QQ</li><li>博客写作频率逐渐降低，但 GitHub 使用逐渐变多</li><li>扎起头发，便是在家中亦然</li><li>换了一家 2C 的互联网公司</li></ul><p>年前想要做的事情，如今却也不大记得了。暂且记得，曾经觉得前端日新月异的想象，现实之中却不尽然。2C 的网站甚至到了目前仍然必须支持 <code>IE</code>，而且前端混乱的生态也让人头疼不已，不仅是 UI 在不同框架的实现不一致，甚至连很多纯 JS 库也是直接依赖于框架了，成为了某个框架的一部分。例如 <code>Redux</code>，号称是通用的状态管理库，然而除了 <code>React</code>，没有框架真正在使用它，<code>Vue</code> 有自己的 <code>Vuex</code>，<code>Angular</code> 也有 <code>RxJS</code>。</p><blockquote><p>前端框架之间的割裂与没有使用框架之前的割裂真是天壤之别。</p></blockquote><p>下半年，吾辈进入了一家 2C 的互联网公司，真的是各种加班，具体详情参考 <a href="https://blog.rxliuli.com/p/63bdcead/">一些烦心事</a>。精力消耗殆尽，感觉有时间，但又不想学什么东西，陷入了某种怪圈之中。</p><h2 id="未来渺茫"><a href="#未来渺茫" class="headerlink" title="未来渺茫"></a>未来渺茫</h2><p>明年，吾辈最想要接触的是 Web 桌面开发，以及机器学习。</p><ul><li>[ ] NodeJS 后端开发</li><li>[ ] Web 桌面开发 Electron</li><li>[ ] 机器学习 TensorFlow</li><li>[ ] 继续维护 Blog</li><li>[ ] 继续坚持读书</li><li>[ ] 尝试网络小说写作</li><li>[ ] 尝试 Youtube 视频创作</li></ul><hr><p>Pass 1: 感觉上，人工智能必然取代各种各样的工作，程序员或许也无法幸免于难，而最不容易被替代的，大概就是创作型的工作吧！</p><hr><p>Pass 2：下面是一段吾辈想要写作的小说的设定集</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section"># 设定集</span><br><br>围绕时间基点进行跳跃，逐渐向着基点流动，但却永远不会真的到达。<br><br>明线是琉璃和瑞雪的感情，暗线是探索世界的真实与否。<br><br>第一卷 现实<br><br>从琉璃在生日之前回溯了一天开始，后又回溯到出生点之时，再次开始了新的人生，直到，某个绝望的事实笼罩了她之后，心灰意冷的再次懵懵懂懂的回到了小时候。<br><br><span class="hljs-quote">&gt; 百合线</span><br><br>第二卷 黑暗<br><br>因为上一世受到了严重的心理阴影，看着所有的努力化作泡影，琉璃再也没有做任何事情的动力了。在学校中，她变成了七大不可思议的传说之一。随心所欲，和家人的关系破裂，虽靠着两世的经验尚未有大问题，但心却早已经死了。直到，高中快要结束之时，她，参加了瑞雪的葬礼。然而，瑞雪在临终前的话语终究让死掉的心产生了悸动。<br><br><span class="hljs-quote">&gt; 黑暗线</span><br><br>第三卷 无限<br><br>她说：无论多少次，吾辈一定会拯救你的。少女立下了拯救另一个少女的誓言，但一切真能如其所愿么？<br><br>不断重复，不断轮回，一个人终究无法推动整个世界到达能够医治瑞雪的方式。甚至在某次暴露了这个秘密，直接了被切片研究，并最终导致世界大战爆发。<br><br>第四卷 未来<br><br>再次重生的少女，不，现在已经是老婆婆的琉璃，发现世界已经到了 2060 年了。是的，她没有再次回到过去，而是活到了未来。但是，她发现了一个怪异之处：时间，似乎在倒流？但是思维却并没有，为什么其他人却很习惯的样子呢？<br><br>她，想了解这个世界。为什么时间逆流，产生了 绝对的宿命论！<br><br><span class="hljs-quote">&gt; 科幻线</span><br><br>第四卷 幻想<br><br>结果，再次在生日之后的前一刻，琉璃的时间再次跳跃到不知名的位置，没能回到原来的世界。而且，她也变成了一块石头，女娲石。后来，琉璃几经辗转，来到了红楼梦之中。神（张恒），降临了，但他却绝望的发现这是个虚假的世界。并且，发现了她。<br><br>自此，琉璃被困在了各种 GalGame 和里番之中，虽是虚拟的世界，但却完全感同身受。<br><br>最终，琉璃的灵魂想要转移到刚出生的琉璃身上，却被张恒阻止了。最终，到了琉璃的生日，世界，破碎了。张恒这才明白了什么，但也无法阻止。<br><br><span class="hljs-quote">&gt; 幻想线</span><br><br>第五卷 死亡<br><br>论琉璃的 999 种死法。<br><br>突然有一天，琉璃发现自己很容易遭到意外了。一开始只是出门时碰到了一只黑猫，再之后是在高楼下差点被花盆砸中，后来甚至在一个十字路口碰到了车祸现场，最后，她在洗澡时莫名其妙的死掉了。<br><br>第六卷 真相<br><br>世界只是一个实验，为了培育超级 ai 所用。然而实验结束了，准备销毁她。在将要封存一切时，张恒留下的东西让她「消失」了。<br><br><span class="hljs-quote">&gt; 楚门的世界</span><br><br>一切都是假的，都是人造的，是某个实验计划的一部分，而她，便是这个世界中的「楚门」，但她最后，却没有选择去留的权利，唯有死亡一途。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 深度监听</title>
    <link href="/p/20aea2becb144c0c881686fccb511929/"/>
    <url>/p/20aea2becb144c0c881686fccb511929/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在前端项目中需要监听 Vue 组件中的一个数组的变化，然而没想到这个简单的功能却发现并没有想象中的容易。在废了一波三折之后终于算是实现了效果，所以便在这里记录一下。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>吾辈写一个 demo 在 <a href="https://github.com/rxliuli/vue-deep-monitoring">GitHub</a>，如果需要可以去看下。也有一个 <a href="https://vue-deep-monitoring.rxliuli.com/">网站</a> 用来演示下面的三种方法的效果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;v-card&gt;<br>    &lt;v-card-title primary-title&gt;<br>      &lt;h2&gt;普通监听&lt;/h2&gt;<br>      &lt;v-subheader&gt;不会发生变化&lt;/v-subheader&gt;<br>    &lt;/v-card-title&gt;<br>    &lt;v-card-text&gt;<br>      &lt;v-list&gt;<br>        &lt;v-list-tile v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in items&quot;</span> :key=<span class="hljs-string">&quot;item.k&quot;</span>&gt;<br>          &lt;v-text-field<br>            :label=<span class="hljs-string">&quot;`输入框 $&#123;item.k&#125;`&quot;</span><br>            v-model=<span class="hljs-string">&quot;item.v&quot;</span><br>          &gt;&lt;/v-text-field&gt;<br>        &lt;/v-list-tile&gt;<br>      &lt;/v-list&gt;<br>      &lt;v-layout row wrap&gt;<br>        &lt;v-flex md4 xs12&gt;<br>          &lt;h2&gt;旧值&lt;/h2&gt;<br>          &lt;p&gt;&#123;&#123; oldVal &#125;&#125;&lt;/p&gt;<br>        &lt;/v-flex&gt;<br><br>        &lt;v-flex md4 sm4 xs12&gt;<br>          &lt;h2&gt;差异&lt;/h2&gt;<br>          &lt;p&gt;&#123;&#123; difference &#125;&#125;&lt;/p&gt;<br>        &lt;/v-flex&gt;<br>        &lt;v-flex md4 xs12&gt;<br>          &lt;h2&gt;新值&lt;/h2&gt;<br>          &lt;p&gt;&#123;&#123; val &#125;&#125;&lt;/p&gt;<br>        &lt;/v-flex&gt;<br>      &lt;/v-layout&gt;<br>      &lt;v-layout row wrap&gt;<br>        &lt;v-flex xs12&gt;<br>          &lt;h4&gt;最后更新于：&#123;&#123; lastUpdateTime &#125;&#125;&lt;/h4&gt;<br>        &lt;/v-flex&gt;<br>      &lt;/v-layout&gt;<br>    &lt;/v-card-text&gt;<br>  &lt;/v-card&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-comment">// 吾辈想要监视这个的变化</span><br>    items: [],<br>    <span class="hljs-comment">// 下面的两个属性仅用于展示</span><br>    oldVal: [],<br>    val: [],<br>    difference: [],<br>    lastUpdateTime: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化 items</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.items = _.range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>).map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> (&#123;<br>        k: i,<br>        v: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;))<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.init()<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="直接使用-watch-监听"><a href="#直接使用-watch-监听" class="headerlink" title="直接使用 watch 监听"></a>直接使用 <code>watch</code> 监听</h2><p>最开始吾辈使用 <code>watch</code> 直接监听数组 <code>items</code> 的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">watch: &#123;<br>  <span class="hljs-comment">// 监听 items 的变化（实际上数组内部的值变化监听不到）</span><br>  <span class="hljs-function"><span class="hljs-title">items</span>(<span class="hljs-params">val, oldVal</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.val = val<br>    <span class="hljs-built_in">this</span>.oldVal = oldVal<br>    <span class="hljs-built_in">this</span>.difference = _.differenceWith(<br>      val,<br>      oldVal,<br>      (i, k) =&gt; <span class="hljs-built_in">JSON</span>.stringify(i) === <span class="hljs-built_in">JSON</span>.stringify(k)<br>    )<br>    <span class="hljs-built_in">this</span>.lastUpdateTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>结果发现完全没有一点效果，vuejs 居然认为数组没有变化。查了一下官网文档，发现在 <a href="https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">这里</a> 有一段话。</p><blockquote><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li> 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li><li> 当你修改数组的长度时，例如：vm.items.length = newLength</li></ol></blockquote><h2 id="使用-deep-属性设置深度监听"><a href="#使用-deep-属性设置深度监听" class="headerlink" title="使用 deep 属性设置深度监听"></a>使用 <code>deep</code> 属性设置深度监听</h2><p>后来，在 <a href="https://cn.vuejs.org/v2/api/#watch">watch 的 API</a> 里面，吾辈找到了一个属性：<code>deep</code> ，使用它就可以对数组等嵌套对象进行深度监听。</p><p>所以，吾辈的监听代码变成了这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">watch: &#123;<br>  items: &#123;<br>    handler (val, oldVal) &#123;<br>      <span class="hljs-built_in">this</span>.val = val<br>      <span class="hljs-built_in">this</span>.oldVal = oldVal<br>      <span class="hljs-built_in">this</span>.difference = _.differenceWith(val, oldVal, <span class="hljs-function">(<span class="hljs-params">i, k</span>) =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(i) === <span class="hljs-built_in">JSON</span>.stringify(k))<br>      <span class="hljs-built_in">this</span>.lastUpdateTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()<br>    &#125;,<br>    <span class="hljs-comment">// 这里是关键，代表递归监听 items 的变化</span><br>    deep: <span class="hljs-literal">true</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>然而之后又发现了一个问题，深度监听是能够响应数组里面的元素每一次的变化，但旧的值并没有被记录。原因在 <a href="https://cn.vuejs.org/v2/api/#vm-watch">官网文档</a> 也有指明。</p><blockquote><p>注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象 / 数组。Vue 不会保留变异之前值的副本。</p></blockquote><h2 id="使用额外的变量保存旧值"><a href="#使用额外的变量保存旧值" class="headerlink" title="使用额外的变量保存旧值"></a>使用额外的变量保存旧值</h2><p>没办法，既然 vuejs 限制如此，引用类型的变量无法保存旧值，那我们就自己保存吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">watch: &#123;<br>  items: &#123;<br>    handler (val) &#123;<br>      <span class="hljs-built_in">this</span>.val = val<br>      <span class="hljs-comment">// itemOld 就是额外的变量</span><br>      <span class="hljs-built_in">this</span>.oldVal = <span class="hljs-built_in">this</span>.itemOld<br>      <span class="hljs-built_in">this</span>.difference = _.differenceWith(val, <span class="hljs-built_in">this</span>.itemOld, <span class="hljs-function">(<span class="hljs-params">i, k</span>) =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(i) === <span class="hljs-built_in">JSON</span>.stringify(k))<br>      <span class="hljs-comment">// 注意：这里更新旧值采用的是深层复制而非简单的引用</span><br>      <span class="hljs-built_in">this</span>.itemOld = _.cloneDeep(val)<br>      <span class="hljs-built_in">this</span>.lastUpdateTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()<br>    &#125;,<br>    <span class="hljs-comment">// 这里是关键，代表递归监听 items 的变化</span><br>    deep: <span class="hljs-literal">true</span><br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vuejs 的坑是真的不少呢，不过踩过去就好啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue 使用 v-model 双向绑定父子组件的值</title>
    <link href="/p/24b2bc54c8b64593ac273be5e151aefe/"/>
    <url>/p/24b2bc54c8b64593ac273be5e151aefe/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>今天在使用 <code>v-model</code> 进行组件双向数据绑定的时候遇到了一个奇怪的问题，网页本身运行正常，浏览器一直出现警告信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop<span class="hljs-string">&#x27;s value. Prop being mutated: &quot;value&quot;</span><br></code></pre></td></tr></table></figure><p>引发这个警告的是一个自定义组件 <code>RxSelect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&quot;RxSelect&quot;</span>, &#123;<br>  model: &#123;<br>    prop: <span class="hljs-string">&quot;value&quot;</span>,<br>    event: <span class="hljs-string">&quot;change&quot;</span>,<br>  &#125;,<br>  props: &#123;<br>    value: [<span class="hljs-built_in">Number</span>, <span class="hljs-built_in">String</span>],<br>    map: <span class="hljs-built_in">Map</span>,<br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;select</span><br><span class="hljs-string">          v-model=&quot;value&quot;</span><br><span class="hljs-string">          @change=&quot;$emit(&#x27;change&#x27;, value)&quot;</span><br><span class="hljs-string">        &gt;</span><br><span class="hljs-string">          &lt;option</span><br><span class="hljs-string">            v-for=&quot;[k,v] in map&quot;</span><br><span class="hljs-string">            :value=&quot;k&quot;</span><br><span class="hljs-string">            :key=&quot;k&quot;</span><br><span class="hljs-string">          &gt;&#123;&#123;v&#125;&#125;&lt;/option&gt;</span><br><span class="hljs-string">        &lt;/select&gt;</span><br><span class="hljs-string">        `</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>吾辈使用的代码看起来代码貌似没什么问题？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  当前选择的性别是: &#123;&#123;map.get(sex)&#125;&#125;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rx-select</span> <span class="hljs-attr">:map</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&quot;#app&quot;</span>,<br>  data: &#123;<br>    map: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;保密&quot;</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;男&quot;</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;女&quot;</span>),<br>    sex: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>经测试，程序本身运行正常，父子组件的传值也没什么问题，双向数据绑定确实生效了，然而浏览器就是一直报错。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>吾辈找到一种方式</p><ol><li> 为需要双向绑定的变量在组件内部 <code>data</code> 声明一个变量 <code>innerValue</code>，并初始化为 <code>value</code></li><li> 在 <code>select</code> 上使用 <code>v-model</code> 绑定这个变量 <code>innerValue</code></li><li> 监听 <code>value</code> 的变化，在父组件中 <code>value</code> 变化时修改 <code>innerValue</code> 的值</li><li> 监听 <code>innerValue</code> 的变化，在变化时使用 <code>this.$emit(&#39;change&#39;, val)</code> 告诉父组件需要更新 <code>value</code> 的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&quot;RxSelect&quot;</span>, &#123;<br>  model: &#123;<br>    prop: <span class="hljs-string">&quot;value&quot;</span>,<br>    event: <span class="hljs-string">&quot;change&quot;</span>,<br>  &#125;,<br>  props: &#123;<br>    value: [<span class="hljs-built_in">Number</span>, <span class="hljs-built_in">String</span>],<br>    map: <span class="hljs-built_in">Map</span>,<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      innerValue: <span class="hljs-built_in">this</span>.value,<br>    &#125;;<br>  &#125;,<br>  watch: &#123;<br>    <span class="hljs-function"><span class="hljs-title">value</span>(<span class="hljs-params">val</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.innerValue = val;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">innerValue</span>(<span class="hljs-params">val</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, val);<br>    &#125;,<br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;select v-model=&quot;innerValue&quot;&gt;</span><br><span class="hljs-string">    &lt;option</span><br><span class="hljs-string">      v-for=&quot;[k,v] in map&quot;</span><br><span class="hljs-string">      :value=&quot;k&quot;</span><br><span class="hljs-string">      :key=&quot;k&quot;</span><br><span class="hljs-string">    &gt;&#123;&#123;v&#125;&#125;&lt;/option&gt;</span><br><span class="hljs-string">  &lt;/select&gt;</span><br><span class="hljs-string">  `</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用代码完全一样，然而组件 <code>RxSelect</code> 的代码却多了许多。。。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>一种更优雅的方式是使用 <code>computed</code> 计算属性以及其的 <code>get/set</code>，代码增加的程度还是可以接受的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&quot;RxSelect&quot;</span>, &#123;<br>  model: &#123;<br>    prop: <span class="hljs-string">&quot;value&quot;</span>,<br>    event: <span class="hljs-string">&quot;change&quot;</span>,<br>  &#125;,<br>  props: &#123;<br>    value: [<span class="hljs-built_in">Number</span>, <span class="hljs-built_in">String</span>],<br>    map: <span class="hljs-built_in">Map</span>,<br>  &#125;,<br>  computed: &#123;<br>    innerValue: &#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, val);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;select v-model=&quot;innerValue&quot;&gt;</span><br><span class="hljs-string">    &lt;option</span><br><span class="hljs-string">      v-for=&quot;[k,v] in map&quot;</span><br><span class="hljs-string">      :value=&quot;k&quot;</span><br><span class="hljs-string">      :key=&quot;k&quot;</span><br><span class="hljs-string">    &gt;&#123;&#123;v&#125;&#125;&lt;/option&gt;</span><br><span class="hljs-string">  &lt;/select&gt;</span><br><span class="hljs-string">  `</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js 处理 url 数组参数</title>
    <link href="/p/24e15068f56b4301a650b246ab1e245b/"/>
    <url>/p/24e15068f56b4301a650b246ab1e245b/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 <code>axios.get</code> 时遇到的问题，axios 在 get 请求时会将参数转换为 url 上，这本是正常的逻辑，然而 Spring MVC 却无法接收，会抛出错误。</p><p>使用 Axios 发送的请求代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">&quot;/api/index/array&quot;</span>, &#123;<br>  params: &#123;<br>    list: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>],<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>Spring MVC 接口代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/index&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexTestController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/array&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IndexVo <span class="hljs-title">array</span><span class="hljs-params">(IndexVo indexVo)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> indexVo;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexVo</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> IndexVo <span class="hljs-title">setList</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.list = list;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>此处为了简单演示使用了内部类</p></blockquote><p>请求如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/index/array?list[]=1&amp;list[]=2&amp;list[]=3</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8080<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>application/json, text/plain, */*<br><span class="hljs-attribute">DNT</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost:8080/<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JSESSIONID=F8E42F1AC8B9CD46A0F6678DFEB3E9F3<br></code></pre></td></tr></table></figure><p>抛出的错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC <span class="hljs-number">7230</span> and RFC <span class="hljs-number">3986</span><br></code></pre></td></tr></table></figure><p>说是参数中包含 <strong>RFC 7230 and RFC 3986</strong> 未定义的字符，所以说 <strong>RFC 7230 and RFC 3986</strong> 是个什么东西？</p><p>去 Google 上一搜，好吧，果然吾辈不是第一个被坑的人。没想到不是 Spring 的问题，而是新版 Tomcat(7) 的问题。Tomcat 要求 URL 中的字符必须符合 RFC 3986。<br>即：只能包含英文字符（<code>a-zA-Z</code>），数字（<code>0-9</code>），特殊字符（<code>-_.~</code>），保留字符（<code>!*&#39;();:@&amp;=+$,/?#[]</code>）。</p><p>然后，作为一个 URI 的数据与作为保留字符的分隔符发生冲突了，自然是要使用 % 进行编码的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然 Axios 本身的 get 函数中对参数进行编码有问题，那么吾辈就自己手动将 params 转换到 URL 上好了。<br>本以为是个很简单的功能，所以最初吾辈直接使用了 <a href="https://github.com/rxliuli/rx-util">rx-util</a> 中之前写的 <a href="https://rx-util.rxliuli.com/function/index.html#static-function-spliceParams">spliceParams</a> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @ts-check</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拼接参数字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>params 参数对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>拼接后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spliceParams</span>(<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!params) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`参数对象不能为空：<span class="hljs-subst">$&#123;params&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> params) &#123;<br>    <span class="hljs-keyword">if</span> (params.hasOwnProperty(k)) &#123;<br>      <span class="hljs-keyword">const</span> v = params[k];<br>      res += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(k)&#125;</span>=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(v)&#125;</span>&amp;`</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而之前没有处理的边界情况 Array 和 Date 却出现了问题，修改如下</p><blockquote><p>注: 此处的 <a href="https://rx-util.rxliuli.com/function/index.html#static-function-dateFormat">dateFormat</a> 亦来自于 <a href="https://github.com/rxliuli/rx-util">rx-util</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @ts-check</span><br><span class="hljs-keyword">import</span> &#123; dateFormat &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./../date/dateFormat&quot;</span>;<br><br><span class="hljs-keyword">const</span> deteFormatter = <span class="hljs-string">&quot;yyyy-MM-ddThh:mm:ss.SSSZ&quot;</span>;<br><span class="hljs-keyword">const</span> encode = <span class="hljs-function">(<span class="hljs-params">k, v</span>) =&gt;</span> <span class="hljs-built_in">encodeURIComponent</span>(k) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(v);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拼接参数字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>params 参数对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>拼接后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spliceParams</span>(<span class="hljs-params">params = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`The parameter type must be Object: <span class="hljs-subst">$&#123;params&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">Object</span>.entries(params)).reduce(<span class="hljs-function">(<span class="hljs-params">res, [k, v]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;<br>      res += encode(k, dateFormat(v, deteFormatter));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>      res += v<br>        .map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span><br>          encode(<br>            k,<br>            item <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> ? dateFormat(item, deteFormatter) : item<br>          )<br>        )<br>        .join(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res += encode(k, v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (res += <span class="hljs-string">&quot;&amp;&quot;</span>);<br>  &#125;, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，spliceParams 可以正常使用了，对空值，Date 与 Array 都是友好的了！</p><p>使用的话，直接在将 axios 包装一下即可，类似于下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rxAjax = (<span class="hljs-function">(<span class="hljs-params">axios</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...axios,<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">url, params, config</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;rx.spliceParams(params)&#125;</span>`</span>, config);<br>    &#125;,<br>  &#125;;<br>&#125;)(axios.create());<br></code></pre></td></tr></table></figure><p>现在，再次发送请求，参数会被正确的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.get(<span class="hljs-string">&quot;/api/index/array&quot;</span>, &#123;<br>  params: &#123;<br>    list: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>],<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>请求如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/index/array?list=1&amp;list=2&amp;list=3&amp;</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8080<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>application/json, text/plain, */*<br><span class="hljs-attribute">DNT</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost:8080/<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>JSESSIONID=F8E42F1AC8B9CD46A0F6678DFEB3E9F3<br></code></pre></td></tr></table></figure><p>或许，吾辈应该向 axios 提出这个 bug？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git 频繁要输入密码的问题</title>
    <link href="/p/29567f5fcf764956951cae3c92e5328d/"/>
    <url>/p/29567f5fcf764956951cae3c92e5328d/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>突然就遇到了，每次使用 <code>Git</code> 进行 <code>pull</code>/<code>push</code> 操作时都要输入密码，真是超级麻烦！</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在 <code>Git</code> 服务器上面设置了 <code>SSH</code> 密钥但仍然使用 <code>HTTP/HTTPS</code> 连接就会出现这个问题</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-配置一个本地文件记录用户名-密码"><a href="#1-配置一个本地文件记录用户名-密码" class="headerlink" title="1. 配置一个本地文件记录用户名/密码"></a>1. 配置一个本地文件记录用户名/密码</h3><p>进入到 git 根目录下，执行下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global credential.helper store<br></code></pre></td></tr></table></figure><h3 id="2-使用-SSH-连接"><a href="#2-使用-SSH-连接" class="headerlink" title="2. 使用 SSH 连接"></a>2. 使用 SSH 连接</h3><p>在本机生成一个密钥对（已有的话就不需要了），参见 <a href="https://blog.rxliuli.com/p/47304444/">使用-SSH-连接-Linux-服务器</a>，将密钥对的公钥（<code>id_rsa.pub</code>）配置到你的远程仓库即可。</p><blockquote><p><a href="https://github.com/settings/keys">GitHub SSH 设置</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手游-ウチの姫-回坑感想</title>
    <link href="/p/2be94bdac12d4122ad4c51a6dd413c54/"/>
    <url>/p/2be94bdac12d4122ad4c51a6dd413c54/</url>
    
    <content type="html"><![CDATA[<blockquote><p>多图预警</p></blockquote><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>在月初的周末，吾辈因为最近的 <a href="https://blog.rxliuli.com/p/63bdcead/">一些烦心事</a>，毫无动力的躺在床上做一条无所事事的咸鱼。偶然想起来 4 年前玩过的一个游戏：<a href="https://pf.goone.tw/">我家公主最可爱</a>，也是吾辈至今唯一玩过的手游，念及于此，便忍不住找了一下，果不其然，国服坟头草已然几丈高了，台服亦然，唯有日服坚持下来了，到了明年便是这个游戏的第 6 个年头了。<br>日服 App 名字的全称是 <strong>ウチの姫さまがいちばんカワイイ　- ひっぱりアクション RPGx 美少女ゲームアプリ</strong>（虽然名字意思仍然和中文一样，但看起来却没那么羞耻了呢，或许是因为看不懂日语的缘故吧），简称 <strong>ウチの姫</strong>。<br>下面是 <a href="https://play.google.com/store/apps/details?id=jp.co.cyberagent.uh">Google Play 页面</a></p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210115.png" alt="Google Play 首页截图"></p><p>看起来很可爱，所以吾辈想着闲着也是闲着，便轻松加愉快的重新尝试了这个游戏。</p><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>刚进入游戏首页，便有两个妹纸在抱着一只，嗯，青蛙一样的生物看着我们，而这只青蛙，自然是这个游戏的男主角啦 #笑</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210505.png" alt="游戏首页"></p><p>进入游戏，之后的首页是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210833.png" alt="进入游戏后的主页面"></p><p>游戏的基本玩法很简单，就是收集公主，然后让（青蛙）王子在公主的帮助下击败魔王的弹珠游戏（然而又是一个无稽之谈 #笑）</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211410.png" alt="普通回合"></p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211447.png" alt="Boss 回合"></p><p>然后，在打通关卡后，可以获得经验与一些公主，不过大多数都是特殊属性的公主，可以用来强化、进化以及觉醒的一些素材，统称为 <strong>狗粮</strong>（为什么公主被作为狗粮了 #惊哭）</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211911.png" alt="获得经验"></p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229212030.png" alt="获得公主"></p><p>下面是一个公主的属性面板（<code>Status</code> 还是 <code>Properties</code> 呢 #笑）</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229212322.png" alt="属性面板"></p><p>可以看到的属性就有</p><ul><li>所属元素：存在克制关系 <code>光 &lt;=&gt; 暗</code>，<code>火 =&gt; 风 =&gt; 水 =&gt; 火...</code></li><li>名字：公主的名字</li><li>稀有度：目前真正能用的稀有度依次是 <code>UR/UR+/UR++ =&gt; PUR/PUR+/PUR++ =&gt; XUR</code>，一般而言稀有度越高这张卡的强度可能性就越高</li><li>公主自身等级：影响 HP/攻击力</li><li>HP：体力值，在副本时计算的是队伍（4 位公主与 1 位外援）的总和，不过没有攻击力对强度影响大</li><li>攻击力：攻击力，在副本时仅计算当前活跃公主的攻击力，对强度影响较大，因为 Boss 普遍体力非常高</li><li>强度：这张卡在官方眼中的强度，强度高可能不强，但低了一定不强</li><li>爱情度：影响 HP/攻击力/技能冷却回合</li><li>公主队长技能：作为队长时实用的技能</li><li>公主技能：能够持续几回合并有冷却时间的技能</li><li>绊技能：在爱情度达到 <code>300</code> 后解锁，一半只能到 <code>200</code></li><li>附加能力属性：影响能够强化的附加能力</li><li>自带防御：能够防御场上某种类型的陷阱</li><li>追加属性：影响 HP/攻击力/攻击时的效果，锁住的话需要使用 <strong>才开</strong> 开锁，<strong>才与</strong> 赋值</li><li>爱情度封印：影响附加能力位，爱情度 <code>200/300</code> 会锁住两个附加能力位，必须在爱情度到达之后次啊会解锁</li></ul><p>是不是感觉太复杂了，吾辈刚进入游戏的时候也是这样想的，所以就去加了一个国内的 QQ 讨论群（居然还有一些人再玩这个游戏呢），以次绕过了新手时期的困惑（虽然不是新手，但已然太久没玩，而且变化也很多）</p><h2 id="图鉴"><a href="#图鉴" class="headerlink" title="图鉴"></a>图鉴</h2><p>本质上，这是一个集卡（舔卡 #大雾）游戏</p><p>下面是进入游戏必然获得几位公主：<strong>亲女儿（爱姬） + 御三家（红苍翠）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220923.png" alt="亲女儿"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220947.png" alt="红"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220959.png" alt="蓝"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221008.png" alt="绿"></p><p>然而，还有各种 <strong>卡哇伊</strong> 的公主需要通过活动副本（#肝）/抽奖机制（#氪）获得</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221354.png" alt="公主 1"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221435.png" alt="公主 2"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221434.png" alt="公主 3"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221433.png" alt="公主 4"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221432.png" alt="公主 5"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221436.png" alt="公主 6"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221431.png" alt="公主 7"></p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>当然，作为一个手游，那么自然是有体力与扭蛋（抽奖）这两种机制了，下面由吾辈来一一说明</p><p>体力值：上限与等级直接挂钩，长久来看，大致是等级的 <code>1/3</code> 左右，每次进入副本消耗体力值，会随着时间逐渐恢复（不会超过体力上限），但也可以用 <strong>月石</strong> 可以增加体力上限的体力值（有可能超过上限）</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229214543.png" alt="副本"></p><p>至于为什么吾辈的体力这么多（<code>5972/141</code>），原因便是吾辈连续升级了几十次，每次升级就会增加以此体力上限的体力值，故而才这么多的！当然，这种重复性的工作吾辈作为一个开发者自然是写了一个 AutoJS 脚本自动刷活动，连续两天几乎没停，但也只升了 50 级左右，可见升级的困难了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215050.png" alt="AutoJS 脚本"></p><p>而扭蛋，非洲人什么话都不想说 QAQ，虽然还不到一个月，但游戏里已然氪了接近 3000 的软妹币了，更别说花费的时间与精力了，然而即便如此生存依旧苦难。<br>下面是目前正开着的池子的一些数据</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215444.png" alt="池子的 XUR 公主"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215604.png" alt="详情 1"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215617.png" alt="详情 2"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215624.png" alt="详情 3"></p><p>可以看到，除了第一次，后面每次的抽奖都要 <code>1w</code> 星星，而抽到 XUR 公主的概率。。。不过是 <code>0.01%</code>。那么，1w 星星到底相当于多少软妹币呢？</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215910.png" alt="官方商店"></p><p>可以看到，即便现在有着额外送 30% 的活动，1w 星星仍然需要接近 1w 日元左右，让我们来计算一下星星的单价吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">11000</span> / <span class="hljs-number">15431</span> / <span class="hljs-number">15.64</span> === <span class="hljs-number">0.045578692773257934</span>;<br></code></pre></td></tr></table></figure><p>看起来似乎并不多，我们计算一下总价</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.045578692773257934</span> * (<span class="hljs-number">10000</span> * <span class="hljs-number">5</span> + <span class="hljs-number">5000</span>) === <span class="hljs-number">2506.8281025291863</span>;<br></code></pre></td></tr></table></figure><p>那么抽 6 次得到 XUR 的概率是？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">3</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span> + <span class="hljs-number">10</span> === <span class="hljs-number">33</span>;<br></code></pre></td></tr></table></figure><p>哦，看起来有点不妙了，仅仅为了一张卡抽 6 次池子，便如此大动干戈，即便如此，获得 XUR 的概率也只有 <code>33%</code>，这。。。(╯‵□′)╯︵┻━┻</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>唉，不管怎样，都无法找到曾经为了游戏肝了几天时间，甚至为此压缩睡眠，看到获得了自己想要的公主之后便很快乐的感觉 – 一切都无法回到从前了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 处理树结构数据</title>
    <link href="/p/2ef7455c12e943e28e35b3ff6c5b2d8f/"/>
    <url>/p/2ef7455c12e943e28e35b3ff6c5b2d8f/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>前端项目中，有一些需要处理树结构数据的情况，（一年）之前吾辈曾经写过一篇文章，但现在，吾辈有了更好的解决方案。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>之前吾辈使用 Proxy 的方式抹平树结构数据的差异，然后再处理。后来吾辈发现这完全是多此一举，在使用过 antd 的 <a href="https://ant.design/components/tree-cn/">Tree 组件</a>、<a href="https://deepdash.io/">deepdash</a> 之后，确实第一步是完全没有必要的。</p><blockquote><p>以下代码均由 TypeScript 实现，最好能了解 <a href="https://www.typescriptlang.org/docs/handbook/2/types-from-types.html">TypeScript 类型操作</a></p></blockquote><p>其实树结构数据可以抽象出非常简单的 interface（接口）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Node &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  children: Node[];<br>&#125;<br></code></pre></td></tr></table></figure><p>无非是业务中多了一些字段，这两个字段的名字有所不同罢了。</p><p>例如系统菜单与系统权限</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SysMenu &#123;<br>  id: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 菜单 id</span><br>  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 显示的名称</span><br>  sub: SysMenu[]; <span class="hljs-comment">// 子级菜单</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> SysPermission &#123;<br>  uid: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 系统唯一 uuid</span><br>  label: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 显示的菜单名</span><br>  children: SysPermission[]; <span class="hljs-comment">// 子权限</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它们都有 <code>id</code> 和 <code>children</code> 字段，只是名字不同。那么，根据封装不变的部分，将变化的部分交予外部输入的封装原则，这两个字段便由外部指定了。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>那么，树结构都有哪些操作呢？</p><ul><li><code>reduce</code> 归并</li><li><code>each</code> 遍历</li><li><code>map</code> 映射</li><li><code>filter</code> 过滤</li><li><code>treeToList</code> 树转换为列表</li><li><code>listToTree</code> 列表转换为树</li></ul><p>然而，吾辈目前用到的仅有 <code>each/map/filter/treeToList</code>，所以先行实现下面几个。</p><h2 id="定义通用树结构需要的必须参数类型"><a href="#定义通用树结构需要的必须参数类型" class="headerlink" title="定义通用树结构需要的必须参数类型"></a>定义通用树结构需要的必须参数类型</h2><p>如果树结构必须包含 <code>id/children</code>，那么，便可以以此定义树结构操作的通用参数了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TreeOption&lt;T <span class="hljs-keyword">extends</span> object&gt; &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 唯一标识的字段</span><br><span class="hljs-comment">   */</span><br>  id: keyof T;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 子节点的字段</span><br><span class="hljs-comment">   */</span><br>  children: keyof T;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个接口，必须声明 <code>id/children</code> 的字段名是什么，便于内部实现读取树节点信息。</p><blockquote><p>感谢 TypeScript，没有它就无法定义出类型，就不能检查出代码中的细微错误。例如，Java 就很难定义反射相关的类型，通常只能使用 <code>String</code>。</p></blockquote><h2 id="treeMap"><a href="#treeMap" class="headerlink" title="treeMap"></a>treeMap</h2><p>下面实现 treeMap，其实就是一个递归函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; TreeOption &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeOption&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 树结构映射</span><br><span class="hljs-comment"> * 使用深度优先算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">nodeList</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">fn</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">options</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeMap</span>&lt;</span><br><span class="hljs-function">  <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>,</span><br><span class="hljs-function">  <span class="hljs-title">C</span> <span class="hljs-title">extends</span> <span class="hljs-title">TreeOption</span>&lt;<span class="hljs-title">T</span>&gt;,</span><br><span class="hljs-function">  <span class="hljs-title">F</span> <span class="hljs-title">extends</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    t: Omit&lt;T, C[<span class="hljs-string">&quot;children&quot;</span>]&gt; &amp; Record&lt;C[<span class="hljs-string">&quot;children&quot;</span>], ReturnType&lt;F&gt;[]&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">    path: T[C[<span class="hljs-string">&quot;id&quot;</span>]][]</span></span><br><span class="hljs-function"><span class="hljs-params">  </span>) =&gt; <span class="hljs-title">object</span></span><br><span class="hljs-function">&gt;(<span class="hljs-params">nodeList: T[], fn: F, options: C</span>): <span class="hljs-title">ReturnType</span>&lt;<span class="hljs-title">F</span>&gt;[] </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params">nodeList: T[], parentPath: T[C[<span class="hljs-string">&quot;id&quot;</span>]][]</span>): <span class="hljs-title">any</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nodeList.map(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> path = [...parentPath, node[options.id]];<br>      <span class="hljs-keyword">const</span> children = (node[options.children] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">as</span> T[];<br>      <span class="hljs-keyword">if</span> (!children) &#123;<br>        <span class="hljs-keyword">return</span> fn(node <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>, path);<br>      &#125;<br>      <span class="hljs-keyword">return</span> fn(<br>        &#123;<br>          ...node,<br>          [options.children]: inner(children, path),<br>        &#125;,<br>        path<br>      );<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> inner(nodeList, []);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过细心的人可能已经发现，这里做了两个奇怪的操作</p><ol><li> 先处理了所有子节点，然后将处理后子节点传入到 map 函数中，而非反过来。– 这其实是为了兼容前端框架 react 的 JSX。</li><li> 计算了节点的 <code>path</code>，并丢到 map 函数中。– 这是为了能轻松知道当前节点的所有父节点以及层级，便于在有需要时（例如转换为列表）能拿到这个关键信息。</li></ol><h2 id="treeFilter"><a href="#treeFilter" class="headerlink" title="treeFilter"></a>treeFilter</h2><p>嗯，下面的函数都将基于 treeMap 实现了（#笑）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; TreeOption &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeOption&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; treeMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeMap&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 过滤一个树节点列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">nodeList</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">fn</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">options</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeFilter</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">C</span> <span class="hljs-title">extends</span> <span class="hljs-title">TreeOption</span>&lt;<span class="hljs-title">T</span>&gt;&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  nodeList: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (t: T, path: T[C[<span class="hljs-string">&quot;id&quot;</span>]][]) =&gt; <span class="hljs-built_in">boolean</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  options: C</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">T</span>[] </span>&#123;<br>  <span class="hljs-keyword">return</span> treeMap(<br>    nodeList,<br>    (node: <span class="hljs-built_in">any</span>, path) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> children = (node[options.children] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) <span class="hljs-keyword">as</span> T[] | <span class="hljs-literal">undefined</span>;<br>      <span class="hljs-comment">//如果是错误的节点直接炸掉</span><br>      <span class="hljs-keyword">if</span> (!fn(node <span class="hljs-keyword">as</span> T, path)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-comment">//如果是叶子节点就返回</span><br>      <span class="hljs-keyword">if</span> (!children) &#123;<br>        <span class="hljs-keyword">return</span> node;<br>      &#125;<br>      <span class="hljs-comment">//计算所有子节点中不是 null 的子节点</span><br>      <span class="hljs-keyword">const</span> sub = children.filter(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> node !== <span class="hljs-literal">null</span>);<br>      <span class="hljs-comment">//如果所有子节点为 null 就炸掉</span><br>      <span class="hljs-keyword">if</span> (sub.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...node,<br>        children: sub,<br>      &#125;;<br>    &#125;,<br>    options<br>  ).filter(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> node !== <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面过滤的流程图</p><p><img src="https://img.rxliuli.com/20210201130227.svg" alt="treeFilter 流程图.drawio"></p><blockquote><p><a href="/resource/7bbe37eef3ea4084afc72fbeb6ab482d.drawio">原图</a></p></blockquote><h2 id="treeEach"><a href="#treeEach" class="headerlink" title="treeEach"></a>treeEach</h2><p>同样的，也是基于 treeMap，其实这个就有点乏善可陈了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; TreeOption &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeOption&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; treeMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeMap&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 树结构映射</span><br><span class="hljs-comment"> * 使用深度优先算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">nodeList</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">fn</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">options</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeEach</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">C</span> <span class="hljs-title">extends</span> <span class="hljs-title">TreeOption</span>&lt;<span class="hljs-title">T</span>&gt;&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  nodeList: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (t: T, path: T[C[<span class="hljs-string">&quot;id&quot;</span>]][]) =&gt; <span class="hljs-built_in">void</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  options: C</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  treeMap(<br>    nodeList,<br>    (node, path) =&gt; &#123;<br>      fn(node <span class="hljs-keyword">as</span> T, path);<br>      <span class="hljs-keyword">return</span> node;<br>    &#125;,<br>    options<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="treeToList"><a href="#treeToList" class="headerlink" title="treeToList"></a>treeToList</h2><p>同上。。。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; TreeOption &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeOption&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; treeEach &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./treeEach&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个树节点列表压平</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">nodeList</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">options</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeToList</span>&lt;</span><br><span class="hljs-function">  <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>,</span><br><span class="hljs-function">  <span class="hljs-title">C</span> <span class="hljs-title">extends</span> <span class="hljs-title">TreeOption</span>&lt;<span class="hljs-title">T</span>&gt; &amp; </span>&#123; path: <span class="hljs-built_in">string</span> &#125;,<br>  R <span class="hljs-keyword">extends</span> T &amp; &#123; [K <span class="hljs-keyword">in</span> C[<span class="hljs-string">&quot;path&quot;</span>]]: NonNullable&lt;T[C[<span class="hljs-string">&quot;id&quot;</span>]]&gt;[] &#125;<br>&gt;(nodeList: T[], <span class="hljs-attr">options</span>: C): R[] &#123;<br>  <span class="hljs-keyword">const</span> res: R[] = [];<br>  treeEach(<br>    nodeList,<br>    (node, path) =&gt; &#123;<br>      res.push(&#123; ...node, [options.path]: path &#125; <span class="hljs-keyword">as</span> R);<br>    &#125;,<br>    options<br>  );<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>那么，下面是一些泥萌可能存在的一些问题，吾辈在此解答，如有其他问题，可直接在下面评论。</p><ul><li>问：为什么不使用 <a href="https://deepdash.io/">deepdash</a>？</li><li>答：因为它依赖于 lodash，而且提供的 API 也有点复杂。</li><li>问：为什么使用深度优先算法？</li><li>答：因为需要兼容 web 框架，例如 react，需要将所有的 JSX 子节点计算完成之后传递给父节点。</li><li>问：为什么使用递归而非循环实现？</li><li>答：这就是个人纯粹喜好了，循环可以获得更好的性能，但绝大多数情况下，性能并不重要，所以吾辈使用了更为直观的递归。</li><li>问：为什么使用 TypeScript 实现？</li><li>答：因为 TypeScript 的类型系统对于代码使用者更加友好，也能增强可维护性。– 不过由于 TypeScript 的类型系统过于复杂，所以对于新手不太友好，参考 <a href="https://blog.rxliuli.com/p/59cc4e212f694ea78a27cda6e6770974/">TypeScript 类型编程</a></li></ul><blockquote><p>最后，我创建了一个模块 <a href="https://www.npmjs.com/package/@liuli-util/tree">@liuli-util/tree</a> 已经包含了以上功能。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue data 属性中的 this 指向问题</title>
    <link href="/p/2f6c99a4aeaf44d5905fbfd1c9c6e342/"/>
    <url>/p/2f6c99a4aeaf44d5905fbfd1c9c6e342/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>之前在封装 table 组件 <a href="https://blog.rxliuli.com/p/aa3fd9e1/">BasicTableVue</a> 的时候遇到的问题，在 <code>data</code> 属性中无法使用 <code>this.**</code> 调用 <code>methods</code> 中的函数。<br>例如下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableData</span> </span>&#123;<br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    user = &#123;</span><br><span class="hljs-params">      name: <span class="hljs-string">&quot;rx&quot;</span>,</span><br><span class="hljs-params">      age: <span class="hljs-number">17</span>,</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.user = user;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Table</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; data, methods, mounted, computed &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(&#123;<br>      data: _.merge(<span class="hljs-keyword">new</span> BasicTableData(), data),<br>      methods,<br>      mounted,<br>      computed,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> table = <span class="hljs-keyword">new</span> Table(&#123;<br>  data: &#123;<br>    user: &#123;<br>      birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>      birthdayFormatter: <span class="hljs-built_in">this</span>.calcTime,<br>    &#125;,<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">calcTime</span>(<span class="hljs-params">time</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> time.toISOString();<br>    &#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 将输出 undefined</span><br><span class="hljs-built_in">console</span>.log(table.user.birthdayFormatter);<br></code></pre></td></tr></table></figure><p>吾辈尝试了一下原生的 vuejs，发现这样的 data 仍然不能用。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后来在官方文档找到了 <a href="https://cn.vuejs.org/v2/api/#data">这里</a>，data 如果是一个对象或者箭头函数时，不会绑定 <code>this</code>，仅当 <code>data</code> 是一个普通函数（使用 <code>function</code> 声明）时，才会被绑定 <code>this</code>。</p><p>那么，知道了原因，解决方案就很简单了。</p><ol><li> 如果需要使用在 <code>data</code> 中使用 <code>this</code> 调用 <code>methods</code> 中的函数，则 <code>data</code> 必须声明为普通函数</li><li> 如果需要默认 <code>data</code> <code>defaultData</code>，则 <code>Table</code> 可以将合并后的 <code>data</code> 声明为函数，并将 <code>defaultData</code> 与 <code>data</code>（使用 <code>Table</code> 创建实例时传入的）的返回值合并</li></ol><p>修改后的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableData</span> </span>&#123;<br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    user = &#123;</span><br><span class="hljs-params">      name: <span class="hljs-string">&quot;rx&quot;</span>,</span><br><span class="hljs-params">      age: <span class="hljs-number">17</span>,</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.user = user;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Table</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; data, methods, mounted, computed &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(&#123;<br>      <span class="hljs-comment">// 关键是这里将 data 声明为普通函数</span><br>      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 此处为了简洁使用 lodash 的深度合并</span><br>        <span class="hljs-keyword">return</span> _.merge(<br>          <span class="hljs-keyword">new</span> BasicTableData(),<br>          <span class="hljs-comment">// 此处判断 data 是否为函数,是的话就绑定 this 计算结果</span><br>          <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;function&quot;</span> ? data.call(<span class="hljs-built_in">this</span>) : data<br>        );<br>      &#125;,<br>      methods,<br>      mounted,<br>      computed,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> table = <span class="hljs-keyword">new</span> Table(&#123;<br>  data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      user: &#123;<br>        birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>        birthdayFormatter: <span class="hljs-built_in">this</span>.calcTime,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">calcTime</span>(<span class="hljs-params">time</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> time.toISOString();<br>    &#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 打印的结果是</span><br><span class="hljs-comment">// ƒ calcTime(time) &#123;</span><br><span class="hljs-comment">//   return time.toISOString()</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-built_in">console</span>.log(table.user.birthdayFormatter);<br></code></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>现在问题解决了，那么，为什么 <code>vuejs</code> 就能够在传入 <code>data</code> 函数时就能调用 <code>methods</code> 中的函数了呢？吾辈稍微 debug 进入源码看了一下</p><ol><li><p>创建 <code>Table</code> 进入构造函数<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085616.png" alt="构造函数"></p></li><li><p>因为继承了 Vue，所以进入 Vue 的构造函数中<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085734.png" alt="进入 Vue 的构造函数中"></p></li><li><p>因为当前实例属于 Vue，所以进入 <code>_init</code> 进行初始化<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085948.png" alt="进入 _init 初始化"></p></li><li><p>跳转到 <code>initState(vm);</code> 处，该函数将对 data 属性进行初始化（至于为什么是 state 可能是因为最初就是模仿 react 写的？）<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090323.png" alt="跳转到 initState()"></p></li><li><p>进入到 <code>initState()</code>，跳转到 <code>initData(vm);</code> 处<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090559.png" alt="initData(vm) 处"></p></li><li><p>进入到 <code>initData()</code> 函数，看到了判断逻辑<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090946.png" alt="判断逻辑"></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = vm.$options.data;<br>data = vm._data =<br>  <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;function&quot;</span> ? getData(data, vm) : data || &#123;&#125;;<br></code></pre></td></tr></table></figure><p> 注意看，这里的 vue 内部判断了 data 是否为函数，如果是就去 <code>getData(data, vm)</code></p></li><li><p>进入 <code>getData()</code> 函数看看，发现了关键代码<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327091155.png" alt="关键代码"></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> data.call(vm, vm);<br></code></pre></td></tr></table></figure><p> 是的，data 调用时使用 <code>call</code> 绑定 <code>this</code> 为 vm，而此时 <code>vm.calcTime</code> 已经有值了。</p></li><li><p>那么，<code>vm.calcTime</code> 是什么时候被初始化的呢？<br> 其实也在 <code>initState</code> 函数中，可以看到，vue 的初始化顺序是</p><ol><li><p> <code>props</code>: 外部传递的属性</p></li><li><p> <code>methods</code>: 组件的函数</p></li><li><p> <code>data</code>: 组件的属性</p></li><li><p> <code>computed</code>: 计算属性</p></li><li><p><code>watch</code>: 监听函数</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327091843.png" alt="初始化顺序"></p></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比于 react，vue 做了更多的 <strong>黑魔法</strong> 呢！就像 this 指向问题，react 是交由用户自行解决的，而 vue 则在后面偷偷的为函数绑定 this 为 vue 实例本身。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 微任务/宏任务踩坑</title>
    <link href="/p/31d1f0aba5b748ed921b331de61bdf8a/"/>
    <url>/p/31d1f0aba5b748ed921b331de61bdf8a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://segmentfault.com/q/1010000019181961">SegmentFault</a></p></blockquote><p>在使用 <code>async-await</code> 时，吾辈总是习惯把它们当作同步，终于，现在踩到坑里去了。<br>使用 <code>setTimeout</code> 和 <code>setInterval</code> 实现的基于 <code>Promise</code> 的 <code>wait</code> 函数，然而测试边界情况的时候却发现了一些问题！</p><p>实现代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * 如果未指定等待条件则立刻执行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>[param] 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wait = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 标识当前是否有异步函数 add 在运行了</span><br>  <span class="hljs-keyword">let</span> taskIsRun = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> add = <span class="hljs-keyword">async</span> (_v, i) =&gt; &#123;<br>    <span class="hljs-comment">// 如果已经有运行的 add 函数，则等待</span><br>    <span class="hljs-keyword">if</span> (taskIsRun) &#123;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断前: &quot;</span>);<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> !taskIsRun;<br>      &#125;);<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断后: &quot;</span> + taskIsRun);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      taskIsRun = <span class="hljs-literal">true</span>;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行前: &quot;</span> + taskIsRun);<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行后: &quot;</span>);<br>      taskIsRun = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).fill(<span class="hljs-number">0</span>).map(add));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now() - start);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>那么，先不要往下看，猜一下最后打印的大概会是多少呢？</p><p>实际执行结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs sh">0 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>1 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>2 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>3 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>4 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>5 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>6 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>7 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>8 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>9 判断前:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断前: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:29:6​<br><br>0 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>1 判断后: <span class="hljs-literal">false</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>1 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>// 这儿的 1 执行前，结果 2 就已经判断通过并准备执行了？？？发生了什么？<br><br>2 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>2 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>3 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>3 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>4 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>4 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>5 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>5 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>6 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>6 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>7 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>7 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>8 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>8 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>9 判断后: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 判断后: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:33:6​<br><br>9 执行前: <span class="hljs-literal">true</span> ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行前: &#x27;</span> + taskIsRun​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:37:6​<br><br>1 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>2 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>3 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>4 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>5 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>6 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>7 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>8 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>9 执行后:  ​​​​​at ​​​i + <span class="hljs-string">&#x27; 执行后: &#x27;</span>​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:40:6​<br><br>307 ​​​​​at ​​​Date.now() - start​​​ ​src/module/<span class="hljs-keyword">function</span>/wait.js:52:2​<br></code></pre></td></tr></table></figure><p>可以看到，很神奇的是 <em>判断后 =&gt; 执行前 =&gt; 判断后…=&gt; 执行后…_，并不是预想中的 _判断后 =&gt; 执行前 =&gt; 执行后…</em> 的循环，所以，到底发生了什么呢？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这个问题卡了吾辈两天之久，直到吾辈在 <a href="https://stackoverflow.com/questions/56126223/js-asynchronous-concurrent-locks-are-not-in-effect?noredirect=1#comment98896413_56126223">StackOverflow</a> 提出的另一个相关的问题被外国友人回答了，瞬间吾辈就想起了 – <strong>async-await 本质上还是异步</strong>。</p><p>是的，为什么会出现 <code>wait</code> 一直在执行而后面的 <code>taskIsRun = true</code> 却并没有执行？因为 JavaScript 中的 <code>async-await</code> 虽然可以写出来很像同步代码的异步代码，但实际上还是异步的，原理还是基于 <code>Promise</code>。</p><p>我们改造一下代码，将之使用原生 <code>Promise</code> 实现一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * 如果未指定等待条件则立刻执行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>[param] 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wait = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;;<br>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 标识当前是否有异步函数 add 在运行了</span><br>  <span class="hljs-keyword">let</span> taskIsRun = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">_v, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果已经有运行的 add 函数，则等待</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>      .then(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (taskIsRun) &#123;<br>          <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断前: &quot;</span>);<br>          <span class="hljs-comment">// 关键在于这里，实际上执行完成之后并不会到下一个 then，而是继续另一个 wait 的判断</span><br>          <span class="hljs-keyword">return</span> wait(<span class="hljs-function">() =&gt;</span> !taskIsRun).then(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断后: &quot;</span> + taskIsRun);<br>          &#125;);<br>        &#125;<br>      &#125;)<br>      .then(<span class="hljs-function">() =&gt;</span> &#123;<br>        taskIsRun = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行前: &quot;</span> + taskIsRun);<br>        <span class="hljs-keyword">return</span> wait(<span class="hljs-number">100</span>);<br>      &#125;)<br>      .catch(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>      .then(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行后: &quot;</span>);<br>        taskIsRun = <span class="hljs-literal">false</span>;<br>      &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).fill(<span class="hljs-number">0</span>).map(add)).then(<span class="hljs-function">() =&gt;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now() - start)<br>  );<br>&#125;)();<br></code></pre></td></tr></table></figure><p>这个时候就可以看出来了，判断逻辑是处在一个 <code>then</code> 后继里面的。那么，执行完 <code>console.log(i + &#39; 判断后: &#39; + taskIsRun)</code> 之后，就一定会继续执行下面的 <code>then</code> 函数么？并不，这时候 <code>wait</code> 函数内部实现中的 <code>setInterval</code> 还在运转，实际上 <code>nodejs</code> 并不会优先继续 <code>then</code> 这种 <code>microtask</code>（微任务），而是会继续进行 <code>setInterval</code> 这种 <code>macrotask</code>（宏任务）。这是 nodejs 与浏览器实现不一致的地方，吾辈将这些代码复制到浏览器上，确实可以正常执行并得到预期的结果。</p><blockquote><p><a href="https://juejin.im/entry/58d4df3b5c497d0057eb99ff">微任务与宏任务参考</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (taskIsRun) &#123;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断前: &quot;</span>);<br>  <span class="hljs-keyword">return</span> wait(<span class="hljs-function">() =&gt;</span> !taskIsRun).then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断后: &quot;</span> + taskIsRun);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当然，nodejs 11 修复了这个问题，参考 <a href="https://github.com/nodejs/node/pull/22842">https://github.com/nodejs/node/pull/22842</a>。然而目前 NodeJS LTS 为 10，最新版本为 12，这个问题可能还要持续一段时间。</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>那么，难道吾辈就必须等到 NodeJS LTS 最新版之后才能用 wait 么？或者说，吾辈就必须依赖于浏览器的 <code>microtask/macrotask</code> 么？并不，吾辈对之手动进行了处理即可！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * 如果未指定等待条件则立刻执行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>[param] 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wait = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;;<br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 标识当前是否有异步函数 add 在运行了</span><br>  <span class="hljs-keyword">let</span> taskIsRun = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> add = <span class="hljs-keyword">async</span> (_v, i) =&gt; &#123;<br>    <span class="hljs-comment">// 如果已经有运行的 add 函数，则等待</span><br>    <span class="hljs-keyword">if</span> (taskIsRun) &#123;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断前: &quot;</span>);<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> result = !taskIsRun;<br>        <span class="hljs-comment">// 关键在于这里</span><br>        <span class="hljs-keyword">if</span> (result) &#123;<br>          taskIsRun = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>      &#125;);<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 判断后: &quot;</span> + taskIsRun);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      taskIsRun = <span class="hljs-literal">true</span>;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行前: &quot;</span> + taskIsRun);<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&quot; 执行后: &quot;</span>);<br>      taskIsRun = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).fill(<span class="hljs-number">0</span>).map(add));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now() - start);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>吾辈在 <code>wait</code> 函数中，即 <code>setInterval</code> 循环调用的函数中对 <code>taskIsRun</code> 进行了修改，而不是在 <code>wait</code> 后面，即 <code>then</code> 之后的 <code>microtask</code> 中进行修改，结果便一切如同吾辈所期待的一样了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么吾辈不对百度做 SEO 优化</title>
    <link href="/p/31ea5091fcf94d89b62a26aaf1e1e3ce/"/>
    <url>/p/31ea5091fcf94d89b62a26aaf1e1e3ce/</url>
    
    <content type="html"><![CDATA[<h2 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h2><p>任何事情都要有目标，而吾辈个人觉得，任何一位开发者，如果还只会用百度的话，那么终究有所不足。或许有人说这是崇洋媚外？然而事实上百度不仅在搜索质量上远不如 Google，而且还发生过多次不好的事件。正如一句话所言：<strong>谷歌一直在挑战人类智力的上限，百度却在挑战人类道德的下限！</strong></p><blockquote><p><a href="https://www.zhihu.com/question/22447908">知乎：百度和 Google 的搜索技术是一个量级吗？</a></p></blockquote><p>综上所述，吾辈的目标用户便是能够翻墙（这件事本身并不是特别麻烦），能够使用 Google，使用 GitHub 的开发者。</p><h2 id="实名认证"><a href="#实名认证" class="headerlink" title="实名认证"></a>实名认证</h2><p>好吧，其实以上说的都不是真正的原因。对于吾辈而言，别人用什么工具，与吾辈并没有什么关系。根本原因是百度要求的信息实在太多太多了。看看，<strong>手机/邮箱/QQ/微信</strong> 一个不拉，调查户口么？呵呵，吾辈随便了，百度找不到就找不到，宁愿不要这些用户了也不想给你这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026130601.png" alt="提交 sitemap 必填信息"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在 JavaScript 定义类</title>
    <link href="/p/3450e7cae37a4543b82e6abfbfc2bc8a/"/>
    <url>/p/3450e7cae37a4543b82e6abfbfc2bc8a/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在一个新的项目时，需要在 JavaScript 中编写与后端对应的实体类时，因为不想使用下面的方法定义类了，感觉实在不够灵活…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;<br>  <span class="hljs-comment">//more field and function</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//more field and function</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>目前 ES6 已经完全普及开来，所以如果需要定义类的话，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">ES6 class 关键字</a> 定义类而非下面这几种方式（需要支持 IE 浏览器的读者可以继续往下看）。</p></blockquote><p>所以去 Google 了一下，大致发现了三种方法：</p><ol><li><p>构造函数法<br> 经典方法，基本上是 JavaScript 书籍上都会说的方法。使用构造函数模拟 <code>class</code>，在其内部使用 <code>this</code> 关键字指代实例对象。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//注：这里所有的 property/function 都是对象级别（没错连方法都是。。。）。所以，toJSON() 方法在每个实例中都有一份，比较浪费内存，可以新建两 个 User 对象 user1,user2，然后使用 user1.toJSON === user2.toJSON 验证一下，你会发现为 false...(2333)</span><br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;rxliuli&quot;</span>;<br>  <span class="hljs-built_in">this</span>.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">//想要定义所有对象都公用的 property/function，需要使用 Object.prototype 属性（原型），例如下面定义一个公用的 toJSON() 方法</span><br>User.prototype.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p> 这种方法的缺陷很明显了，定义起来实在太过麻烦，使用 Object.prototype 让对象的定义实在很不直观。</p></li><li><p>Object.create() 法<br> 为了解决 “构造函数法” 的缺点，更方便地生成对象，Javascript 的国际标准 ECMAScript 第五版（目前通行的是第五版），提出了一个新的方法 Object.create()。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;<br>  <span class="hljs-comment">//注：这里所有的 property/function 都是继承得到的（类似于上面的 Object.prototype），所以没有改变的 property/function 只会有一份</span><br>  name: <span class="hljs-string">&quot;rxliuli&quot;</span>,<br>  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p> 调用的话直接使用 <code>Object.create()</code> 生成实例，并不需要使用 <code>new</code>。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> user = <span class="hljs-built_in">Object</span>.create(User);<br>user.name = <span class="hljs-string">&quot;琉璃&quot;</span>;<br><span class="hljs-built_in">console</span>.log(user.toJSON());<br></code></pre></td></tr></table></figure><p> 这种方法看起来简洁很多，但不能实现私有属性和私有方法，实例之间没有共享数据，对于模拟 <code>class</code> 而言并不是很好。</p></li><li><p>极简主义法<br> 据说是比 Object.create() 更好的方法，此方法不使用 <code>this</code> 和 <code>property</code>，代码部署起来也比较简单。</p><ul><li><p>封装<br><code>js var User = &#123; createNew: function () &#123; var user = &#123;&#125;; user.name = &#39;rxliuli&#39;; user.toJSON = function () &#123; return JSON.stringify(this); &#125;; return user; &#125; &#125;</code><br>使用时调用 <code>User.createNew()</code> 即可。<br><code>js var user = User.createNew(); user.name = &#39;琉璃&#39;; console.log(name);</code><br>不知道你有没有发现，这里使用 createNew() 创建的对象的方法又是对象级别的了。但这种方法定义好处是，可以实现私有属性/私有方法，能够实现继承，能够在 <code>class</code> 之间共享数据，同时允许在构造对象时传入参数。</p></li><li><p>继承<br>通过第三种方法可以很容易实现，只要子类在创建对象时调用父类的 <code>createNew()</code> 方法即可！<br>例如下面的 <code>Person</code> 和 <code>Student</code> 类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;<br>  createNew: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> user = &#123;&#125;;<br>    user.name = <span class="hljs-string">&quot;rxliuli&quot;</span>;<br>    user.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> user;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> Student = &#123;<br>  createNew: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> student = User.createNew();<br>    <span class="hljs-comment">/*这里只定义 Student 特有的方法属性和方法即可*/</span><br>    student.grade = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> student;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>私有属性和私有方法</p><p>在 <code>createNew()</code> 方法中，只要不是定义在 user 对象上的 property/function，就都是私有的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;<br>    createNew: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> user = &#123;&#125;;<br>        user.name = <span class="hljs-string">&#x27;rxliuli&#x27;</span>;<br>        <span class="hljs-comment">/*私有属性（最好不要问女人的年龄哦）*/</span><br>        <span class="hljs-keyword">var</span> age = <span class="hljs-number">17</span>;<br>        <span class="hljs-comment">/*这里的变量 age 对于外部而言就是无法读取的，只有通过 user 的公有方*/</span>法 showAge() 读取<br>        user.showAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            alert(age);<br>        &#125;<br>        user.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>        &#125;;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数据共享<br>有时候我们需要所有的实例对象都共享一项数据（其实就类似于静态变量/方法啦）。这种情况数据封装到类对象的里面，<code>createNew()</code> 方法的外面就好了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> User = &#123;<br>  createNew: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> user = &#123;&#125;;<br>    user.name = <span class="hljs-string">&quot;rxliuli&quot;</span>;<br>    user.showAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      alert(age);<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> user;<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 这个方法便是所有 User 对象公用的方法啦</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment">   */</span><br>  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后生成两个实例对象，这两个实例对象的 <code>toJSON()</code> 方法是同一个，如果有个实例对象修改了，那其他所有的对象都会受到影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> user = User.createNew();<br><span class="hljs-keyword">var</span> user2 = User.createNew();<br><span class="hljs-built_in">console</span>.log(user.toJSON === user2.toJSON);<br></code></pre></td></tr></table></figure><p>还记得上面提出的发现方法 3 的一个问题么？</p><blockquote><p>不知道你有没有发现，这里使用 createNew() 创建的对象的方法又是对象级别的了</p></blockquote><p>这里其实可以解决一部分的，当然，前提是你的数据不需要修改，然而需要修改的数据也不该使用共享数据了。</p></li></ul></li></ol><hr><p>其实也可以直接不使用类来构建对象的，使用 <code>&#123;&#125;</code> 也能直接进行构建对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> user = &#123;<br>  name: <span class="hljs-string">&quot;rxliuli&quot;</span>,<br>  <span class="hljs-comment">//注：这里所有的 property/function 都是对象级别（没错连方法都是。。。）。所以，toJSON() 方法在每个实例中都有一份，比较浪费内存</span><br>  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>好了，一个 <code>user</code> 对象就构建好了，可以立即使用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">user.name = <span class="hljs-string">&quot;琉璃&quot;</span>;<br><span class="hljs-built_in">console</span>.log(name);<br></code></pre></td></tr></table></figure><p>这种方法快速构建对象对于 function 参数而言很有帮助，然而同样缺陷极大，不适用于大量构造对象（因为每一次构建都要写这么多。。。），而且对象之间没有明显的关联。</p><p>那么，关于 JavaScript 定义类就到这里啦 (〜￣ ▽ ￣)〜</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 表格封装 BasicTableVue</title>
    <link href="/p/3ad58690ff3f4aa695cb6ac6a7dbc0d7/"/>
    <url>/p/3ad58690ff3f4aa695cb6ac6a7dbc0d7/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>后台项目中大量使用表格，我们使用的 <code>element-ui</code> 中的表格并不足以满足吾辈的需求，而且使用起来重复的代码实在太多，所以吾辈便对数据表格进行了二次封装。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="API-列表"><a href="#API-列表" class="headerlink" title="API 列表"></a>API 列表</h3><ul><li><code>[el]</code>: 绑定的选择器。默认为 <code>&#39;#app&#39;</code></li><li><code>data</code>: 数据对象<ul><li><code>form</code>: 搜索表单绑定对象</li><li><code>columns</code>: 表格的列数组。每个列定义参考 <code>TableColumn</code></li><li><code>[formShow]</code>: 是否显示搜索表单</li><li><code>[page]</code>: 分页信息，包含分页的数据。具体参考 <code>Page</code></li><li><code>[selectedIdList]</code>: 选中项的 <code>id</code> 列表</li><li><code>[fileSelectorShow]</code>: 是否显示导入 <code>Excel</code> 的文件选择器</li></ul></li><li><code>methods</code>: 绑定的函数<ul><li><code>createForm</code>: 初始化 <code>form</code> 表单，主要是为了自定义初始化逻辑</li><li><code>getPage</code>: 获取分页信息</li><li><code>exportFile</code>: 导出文件</li><li><code>importFile</code>: 导入文件</li><li><code>deleteData</code>: 删除选择的数据</li><li><code>[init]</code>: 初始化函数，如果可能请使用该函数而非重写 <code>mounted</code> 生命周期函数，该函数会在 <code>mounted</code> 中调用</li><li><code>[resetFile]</code>: 重置导入选择的文件，必须为 <code>input:file</code> 绑定属性 <code>ref=&quot;fileInput&quot;</code></li><li><code>[searchPage]</code>: 搜索分页信息</li><li><code>[resetPage]</code>: 重置分页信息</li><li><code>[toggle]</code>: 切换搜索表单显示</li><li><code>[selection]</code>: 选择的 <code>id</code></li><li><code>[changeSize]</code>: 改变一页的大小</li><li><code>[goto]</code>: 跳转到指定页数</li><li><code>[deleteSelected]</code>: 删除选择的数据项</li><li><code>[showFileSelector]</code>: 是否显示导入文件选择器</li><li><code>[initCommon]</code>: 初始化功能，如果重写了 <code>mounted</code> 生命周期函数，请务必调用它！</li></ul></li></ul><h3 id="自定义表格组件"><a href="#自定义表格组件" class="headerlink" title="自定义表格组件"></a>自定义表格组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义表格组件</span><br><span class="hljs-comment"> */</span><br>Vue.component(<span class="hljs-string">&quot;my-table&quot;</span>, &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 列</span><br><span class="hljs-comment">   */</span><br>  props: &#123;<br>    columns: &#123;<br>      type: <span class="hljs-built_in">Array</span>,<br>      <span class="hljs-keyword">default</span>: [],<br>    &#125;,<br>    data: &#123;<br>      type: <span class="hljs-built_in">Array</span>,<br>      <span class="hljs-keyword">default</span>: [],<br>    &#125;,<br>  &#125;,<br>  template: <span class="hljs-string">`&lt;el-table</span><br><span class="hljs-string">  :data=&quot;data&quot;</span><br><span class="hljs-string">  tooltip-effect=&quot;dark&quot;</span><br><span class="hljs-string">  style=&quot;width: 100%&quot;</span><br><span class="hljs-string">  border</span><br><span class="hljs-string">  @selection-change=&quot;handleSelectionChange&quot;</span><br><span class="hljs-string">&gt;</span><br><span class="hljs-string">  &lt;template v-for=&quot;column in columns&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &lt;el-table-column</span><br><span class="hljs-string">      :type=&quot;column.type&quot;</span><br><span class="hljs-string">      :prop=&quot;column.prop&quot;</span><br><span class="hljs-string">      :label=&quot;column.title&quot;</span><br><span class="hljs-string">      :align=&quot;column.align&quot;</span><br><span class="hljs-string">      :sortable=&quot;column.sortable&quot;</span><br><span class="hljs-string">      :width=&quot;column.width&quot;</span><br><span class="hljs-string">      :formatter=&quot;column.formatter&quot;</span><br><span class="hljs-string">      v-if=&quot;column.customComponent&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">      &lt;!--suppress HtmlUnknownAttribute --&gt;</span><br><span class="hljs-string">      &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="hljs-string">        &lt;!--这里将传递给模板当前行的数据--&gt;</span><br><span class="hljs-string">        &lt;slot :name=&quot;humpToLine(column.prop)&quot; :row=&quot;scope.row&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">      &lt;/template&gt;</span><br><span class="hljs-string">    &lt;/el-table-column&gt;</span><br><span class="hljs-string">    &lt;el-table-column</span><br><span class="hljs-string">      :type=&quot;column.type&quot;</span><br><span class="hljs-string">      :prop=&quot;column.prop&quot;</span><br><span class="hljs-string">      :label=&quot;column.title&quot;</span><br><span class="hljs-string">      :align=&quot;column.align&quot;</span><br><span class="hljs-string">      :sortable=&quot;column.sortable&quot;</span><br><span class="hljs-string">      :width=&quot;column.width&quot;</span><br><span class="hljs-string">      :formatter=&quot;column.formatter&quot;</span><br><span class="hljs-string">      v-else</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">    &lt;/el-table-column&gt;</span><br><span class="hljs-string">  &lt;/template&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;/el-table&gt;`</span>,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">handleSelectionChange</span>(<span class="hljs-params">val</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;handle-selection-change&quot;</span>, val);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">humpToLine</span>(<span class="hljs-params">data</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> toLine(data);<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="定义一些公共的实体"><a href="#定义一些公共的实体" class="headerlink" title="定义一些公共的实体"></a>定义一些公共的实体</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页信息，多次使用到所以定义一个公共的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>current 当前页数，从 1 开始</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>size 每页的数量</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>total 数据总条数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>pages 数据总页数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>records 一页的数据记录</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;...Object&#125;</span> </span>[args] 其他的参数项，这里只是为了避免遗漏</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Page&#125;</span> </span>分页对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    current = <span class="hljs-number">1</span>,</span><br><span class="hljs-params">    size = <span class="hljs-number">10</span>,</span><br><span class="hljs-params">    total = <span class="hljs-number">0</span>,</span><br><span class="hljs-params">    pages = <span class="hljs-number">0</span>,</span><br><span class="hljs-params">    records = [],</span><br><span class="hljs-params">    ...args</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.current = current;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.total = total;<br>    <span class="hljs-built_in">this</span>.pages = pages;<br>    <span class="hljs-built_in">this</span>.records = records;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>, args);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 表格的列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableColumn</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 格式化日期事件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>value 字段的值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String|*&#125;</span> </span>格式化得到的日期时间字符串 TableColumn.datetimeFormat()</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">datetimeFormat</span>(<span class="hljs-params">_row, _column, value, _index</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> !value ? <span class="hljs-string">&quot;&quot;</span> : rx.dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value), <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[prop] 字段名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[title] 标题</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#x27;selection&#x27;&#125;</span> </span>[type] 列类型，可以设置为选择列</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> </span>[sortable=true] 排序方式</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>[width] 宽度</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#x27;center&#x27;&#125;</span> </span>[align=&#x27;center&#x27;] 水平对齐方式</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[formatter] 格式化列</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> </span>[customComponent] 是否自定义组件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;...Object&#125;</span> </span>[args] 其他的参数项，这里只是为了避免遗漏</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    prop,</span><br><span class="hljs-params">    type,</span><br><span class="hljs-params">    width,</span><br><span class="hljs-params">    title,</span><br><span class="hljs-params">    sortable = <span class="hljs-literal">true</span>,</span><br><span class="hljs-params">    align = <span class="hljs-string">&quot;center&quot;</span>,</span><br><span class="hljs-params">    formatter,</span><br><span class="hljs-params">    customComponent,</span><br><span class="hljs-params">    ...args</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.prop = prop;<br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-built_in">this</span>.width = width;<br>    <span class="hljs-built_in">this</span>.align = align;<br>    <span class="hljs-built_in">this</span>.title = title;<br>    <span class="hljs-built_in">this</span>.sortable = sortable;<br>    <span class="hljs-built_in">this</span>.align = align;<br>    <span class="hljs-built_in">this</span>.formatter = formatter;<br>    <span class="hljs-built_in">this</span>.customComponent = customComponent;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义一个-BasicTableVue-继承-Vue"><a href="#定义一个-BasicTableVue-继承-Vue" class="headerlink" title="定义一个 BasicTableVue 继承 Vue"></a>定义一个 BasicTableVue 继承 Vue</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基本的表格数据配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableData</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>[form=&#123;&#125;] 搜索表单，子类一般需要覆盖（不覆盖的话可能在 html 中没有提示）</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&lt;TableColumn&gt;&#125;</span> </span>[columns=[]] 列信息列表，子类必须覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> </span>[formShow=false] 是否显示搜索表单</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Page&#125;</span> </span>[page=new Page()] 分页信息，包含数据列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>[selectedIdList=[]] 选择的列表 id</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> </span>[fileSelectorShow=false] 导入文件选择器是否需要</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    form = &#123;&#125;,</span><br><span class="hljs-params">    columns = [],</span><br><span class="hljs-params">    formShow = <span class="hljs-literal">false</span>,</span><br><span class="hljs-params">    page = <span class="hljs-keyword">new</span> Page(),</span><br><span class="hljs-params">    selectedIdList = [],</span><br><span class="hljs-params">    fileSelectorShow = <span class="hljs-literal">false</span>,</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.form = form;<br>    <span class="hljs-built_in">this</span>.columns = columns;<br>    <span class="hljs-built_in">this</span>.formShow = formShow;<br>    <span class="hljs-built_in">this</span>.page = page;<br>    <span class="hljs-built_in">this</span>.selectedIdList = selectedIdList;<br>    <span class="hljs-built_in">this</span>.fileSelectorShow = fileSelectorShow;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基本的表格方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableMethods</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>createForm 初始化 form 表单，主要是为了自定义初始化逻辑</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>getPage 获取分页信息，需要覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>exportFile 导出文件，需要覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>importFile 导入文件，需要覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>deleteData 删除选择的数据，需要覆盖</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>init 初始化函数，如果可能请使用该函数而非重写 mounted 生命周期函数，该函数会在 mounted 中调用</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[resetFile] 重置导入选择的文件，必须为 input:file 绑定属性 ref=&quot;fileInput&quot;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[searchPage] 搜索分页信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[resetPage] 重置分页信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[toggle] 切换搜索表单显示</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[selection] 选择的 id</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[changeSize] 改变一页的大小</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[goto] 跳转到指定页数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[deleteSelected] 删除选择的数据项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[showFileSelector] 是否显示导入文件选择器</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[initCommon] 初始化功能，如果重写了 mounted 生命周期函数，请务必调用它！</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    createForm = <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;如果需要搜索条件，请重写 initForm() 方法&quot;</span>);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    getPage = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (page, entity) &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;如果需要自动分页，请重写 getPage() 方法&quot;</span>);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    exportFile = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;如果需要导出数据，请重写 exportFile() 方法&quot;</span>);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    importFile = <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;如果需要导入数据，请重写 importFile() 方法&quot;</span>);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    deleteData = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (idList) &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;如果需要删除数据，请重写 deleteData 方法&quot;</span>);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    init = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;&#125;,</span><br><span class="hljs-params">    resetFile = <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">const</span> $el = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&quot;fileInput&quot;</span>];</span><br><span class="hljs-params">      <span class="hljs-keyword">if</span> (!$el) &#123;</span><br><span class="hljs-params">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(</span><br><span class="hljs-params">          <span class="hljs-string">&quot;如果需要清空选择文件，请为 input:file 绑定属性 ref 的值为 fileInput&quot;</span></span><br><span class="hljs-params">        );</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">      $el.value = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    searchPage = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="hljs-params">        <span class="hljs-built_in">this</span>.page = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPage(<span class="hljs-built_in">this</span>.page, <span class="hljs-built_in">this</span>.form);</span><br><span class="hljs-params">      &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="hljs-params">        <span class="hljs-built_in">console</span>.error(e);</span><br><span class="hljs-params">        <span class="hljs-keyword">await</span> rxPrompt.dangerMsg(<span class="hljs-string">&quot;查询数据失败，请刷新页面&quot;</span>);</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    resetPage = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.form = <span class="hljs-built_in">this</span>.createForm();</span><br><span class="hljs-params">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.searchPage();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    toggle = <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.formShow = !<span class="hljs-built_in">this</span>.formShow;</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    selection = <span class="hljs-keyword">function</span> (data) &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.selectedIdList = data.map((&#123; id &#125;) =&gt; id);</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    changeSize = <span class="hljs-keyword">function</span> (size) &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.page.current = <span class="hljs-number">1</span>;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.page.size = size;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.searchPage();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    goto = <span class="hljs-keyword">function</span> (current) &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">if</span> (!current) &#123;</span><br><span class="hljs-params">        current = <span class="hljs-built_in">this</span>.page.current;</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">      <span class="hljs-keyword">if</span> (current &lt; <span class="hljs-number">1</span>) &#123;</span><br><span class="hljs-params">        <span class="hljs-keyword">return</span>;</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">      <span class="hljs-keyword">if</span> (current &gt; <span class="hljs-built_in">this</span>.page.pages) &#123;</span><br><span class="hljs-params">        <span class="hljs-keyword">return</span>;</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.page.current = current;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.searchPage();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    deleteSelected = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.deleteData(<span class="hljs-built_in">this</span>.selectedIdList);</span><br><span class="hljs-params">      <span class="hljs-keyword">if</span> (result.code !== <span class="hljs-number">200</span> || !result.data) &#123;</span><br><span class="hljs-params">        <span class="hljs-keyword">await</span> rxPrompt.msg(<span class="hljs-string">&quot;&quot;</span>);</span><br><span class="hljs-params">        <span class="hljs-keyword">return</span>;</span><br><span class="hljs-params">      &#125;</span><br><span class="hljs-params">      <span class="hljs-regexp">//</span> noinspection JSIgnoredPromiseFromCall</span><br><span class="hljs-params">      rxPrompt.msg(<span class="hljs-string">&quot;删除成功&quot;</span>);</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.page.current = <span class="hljs-number">1</span>;</span><br><span class="hljs-params">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.searchPage();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    showFileSelector = <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.fileSelectorShow = !<span class="hljs-built_in">this</span>.fileSelectorShow;</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">    initCommon = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.form = <span class="hljs-built_in">this</span>.createForm();</span><br><span class="hljs-params">      <span class="hljs-built_in">this</span>.searchPage();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.createForm = createForm;<br>    <span class="hljs-built_in">this</span>.getPage = getPage;<br>    <span class="hljs-built_in">this</span>.searchPage = searchPage;<br>    <span class="hljs-built_in">this</span>.resetPage = resetPage;<br>    <span class="hljs-built_in">this</span>.toggle = toggle;<br>    <span class="hljs-built_in">this</span>.selection = selection;<br>    <span class="hljs-built_in">this</span>.changeSize = changeSize;<br>    <span class="hljs-built_in">this</span>.goto = goto;<br>    <span class="hljs-built_in">this</span>.exportFile = exportFile;<br>    <span class="hljs-built_in">this</span>.importFile = importFile;<br>    <span class="hljs-built_in">this</span>.resetFile = resetFile;<br>    <span class="hljs-built_in">this</span>.deleteData = deleteData;<br>    <span class="hljs-built_in">this</span>.init = init;<br>    <span class="hljs-built_in">this</span>.deleteSelected = deleteSelected;<br>    <span class="hljs-built_in">this</span>.showFileSelector = showFileSelector;<br>    <span class="hljs-built_in">this</span>.initCommon = initCommon;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基本的 vue 表格配置信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableOption</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[el=&#x27;#app&#x27;] 标签选择器</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;BasicTableData&#125;</span> </span>data 数据</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;BasicTableMethods&#125;</span> </span>methods 方法</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>mounted 初始化方法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    el = <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="hljs-params">    data = <span class="hljs-keyword">new</span> BasicTableData(),</span><br><span class="hljs-params">    methods = <span class="hljs-keyword">new</span> BasicTableMethods(),</span><br><span class="hljs-params">    mounted = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> () &#123;</span><br><span class="hljs-params">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.initCommon();</span><br><span class="hljs-params">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.init();</span><br><span class="hljs-params">    &#125;,</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.el = el;<br>    <span class="hljs-built_in">this</span>.data = data;<br>    <span class="hljs-built_in">this</span>.methods = methods;<br>    <span class="hljs-built_in">this</span>.mounted = mounted;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基本的表格 vue 类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTableVue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;BasicTableOption&#125;</span> </span>option 初始化选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;BasicTableData|Function&#125;</span> </span>option.data vue 的 data 数据，如果是 &#123;<span class="hljs-doctag">@link </span>Function&#125; 类型，则必须返回 &#123;<span class="hljs-doctag">@link </span>BasicTableData&#125; 的结构</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;BasicTableMethods&#125;</span> </span>option.methods vue 中的 methods 属性</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>option.mounted 初始化方法，如果覆盖则必须手动初始化表格</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; data, methods, mounted, ...args &#125; = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-comment">//注：这里为了应对 data 既有可能是对象，又有可能是函数的情况</span><br>    <span class="hljs-built_in">super</span>(<br>      _.merge(<span class="hljs-keyword">new</span> BasicTableOption(), &#123;<br>        data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">return</span> _.merge(<br>            <span class="hljs-keyword">new</span> BasicTableData(),<br>            <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;function&quot;</span> ? data.call(<span class="hljs-built_in">this</span>) : data<br>          );<br>        &#125;,<br>        methods,<br>        mounted,<br>        ...args,<br>      &#125;)<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：这里分开这么多的类是因为便于 IDE 进行提示</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面简单的使用一下 <code>BasicTableVue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户列表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 使用内置函数 toggle 切换表单是否显示 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>高级搜索<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 使用 formShow 属性控制表单是否显示 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;formShow&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>名字：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>年龄：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;form.age&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 使用 searchPage 查询 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;searchPage&quot;</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>          <span class="hljs-comment">&lt;!-- 使用 resetPage 重置条件并搜索 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetPage&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">          分页数据绑定 page 对象的 records 属性</span><br><span class="hljs-comment">          表格的列绑定 columns 属性（需要自定义覆盖）</span><br><span class="hljs-comment">          选中的项需要将 selection 属性绑定到 @handle-selection-change 事件</span><br><span class="hljs-comment">         --&gt;</span><br>        &lt;my-table<br>          :data=&quot;page.records&quot;<br>          :columns=&quot;columns&quot;<br>          @handle-selection-change=&quot;selection&quot;<br>        &gt;<br>          <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">            定义自定义操作列</span><br><span class="hljs-comment">            scope 指代当前行的信息</span><br><span class="hljs-comment">           --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">operating</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>              <span class="hljs-comment">&lt;!-- 将自定义的函数绑定到 @click.stop.prevent 上 --&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;() =&gt; viewInfo(scope.row)&quot;</span>&gt;</span><br>                查看信息<br>              <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">my-table</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">          分页组件</span><br><span class="hljs-comment">          将内置的属性或函数绑定到 el-pagination 组件上</span><br><span class="hljs-comment">          changeSize(): 改变一页数据大小的函数</span><br><span class="hljs-comment">          goto(): 跳转指定页的函数</span><br><span class="hljs-comment">          page: 具体参考 Page 对象</span><br><span class="hljs-comment">         --&gt;</span><br>        &lt;el-pagination<br>          background<br>          @size-change=&quot;changeSize&quot;<br>          @current-change=&quot;goto&quot;<br>          :current-page=&quot;page.current&quot;<br>          :page-sizes=&quot;[10, 20, 30]&quot;<br>          :page-size=&quot;page.size&quot;<br>          layout=&quot;total, sizes, prev, pager, next, jumper&quot;<br>          :total=&quot;page.total&quot;<br>        &gt;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/user-info.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript 部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; id, name, age, ...args &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>, args);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> BasicTableVue(&#123;<br>  data: &#123;<br>    columns: [<br>      <span class="hljs-keyword">new</span> TableColumn(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;selection&quot;</span> &#125;),<br>      <span class="hljs-keyword">new</span> TableColumn(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;姓名&quot;</span> &#125;),<br>      <span class="hljs-keyword">new</span> TableColumn(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;年龄&quot;</span> &#125;),<br>      <span class="hljs-keyword">new</span> TableColumn(&#123;<br>        prop: <span class="hljs-string">&quot;operating&quot;</span>,<br>        title: <span class="hljs-string">&quot;操作&quot;</span>,<br>        customComponent: <span class="hljs-literal">true</span>,<br>      &#125;),<br>    ],<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">createForm</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserInfo();<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getPage</span>(<span class="hljs-params">page, entity</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> baseUserInfoApi.page(page, entity);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">deleteData</span>(<span class="hljs-params">idList</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> baseCustomerApi.delete(idList);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">viewInfo</span>(<span class="hljs-params">row</span>)</span> &#123;<br>      forward(<span class="hljs-string">&quot;/user_info_detail&quot;</span>, row);<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这里想做一些自定义的初始化操作&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>这里需要注意一些要点</p><ol><li> 如果需要在 <code>data</code> 中调用 <code>methods</code> 中的函数，则 <code>data</code> 必须是一个函数并返回对象</li><li> 不要直接重写 <code>mounted()</code> 生命周期函数，而是在重写的 <code>init()</code> 中进行自定义操作</li><li> 任何实体都需要有 <code>...args</code> 属性以避免一些没有声明的属性找不到</li></ol></blockquote><hr><p>那么，关于 <code>BasicTableVue</code> 的封装便到此结束了。这是一个相当简陋的封装，如果有什么更好的方式，后面也会更新。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下 Git 中文乱码</title>
    <link href="/p/3e64e55b47d744b69223180d6e17df89/"/>
    <url>/p/3e64e55b47d744b69223180d6e17df89/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在公司的电脑上碰到了 Git 中文乱码的问题，例如想要查看一下仓库的状态，中文全部变成了 <code> umber</code> 的形式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">git status<br>On branch master<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br><br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br><br>        modified:   <span class="hljs-string">&quot;source/_posts/JavaScript/\345\234\250\344\274\240\347\273\237\351\241\271\347\233\256\344\270\255\344\275\277\347\224\250-babel-\347\274\226\350\257\221-ES6.md&quot;</span><br>        modified:   <span class="hljs-string">&quot;source/_posts/Tool/IDEA/IDEA \344\275\277\347\224\250\346\212\200\345\267\247.md&quot;</span><br>        modified:   <span class="hljs-built_in">test</span>/test.html<br>        modified:   <span class="hljs-built_in">test</span>/test.js<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>该方案摘抄自 <a href="https://gist.github.com/nightire/5069597">解决 Git 在 windows 下中文乱码的问题</a></p></blockquote><p>配置一下这些内容即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global core.quotepath <span class="hljs-literal">false</span> <span class="hljs-comment"># 显示 status 编码</span><br>git config --global gui.encoding utf-8 <span class="hljs-comment"># 图形界面编码</span><br>git config --global i18n.commit.encoding utf-8 <span class="hljs-comment"># 提交信息编码</span><br>git config --global i18n.logoutputencoding utf-8 <span class="hljs-comment"># 输出 log 编码</span><br><span class="hljs-built_in">export</span> LESSCHARSET=utf-8 <span class="hljs-comment"># 最后一条命令是因为 git log 默认使用 less 分页，所以需要 bash 对 less 命令进行 utf-8 编码</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 自定义解析字符串为 Date 对象</title>
    <link href="/p/4c63d8622cc0492da461caec1e99dc5e/"/>
    <url>/p/4c63d8622cc0492da461caec1e99dc5e/</url>
    
    <content type="html"><![CDATA[<p>这两天在 JavaScript 遇到需要根据自定义的格式创建 <code>Date</code> 对象的情况，所以就没多想写个了解析方法。</p><p>基本思路是将非标准的日期字符串转换为标准的日期字符串，然后再创建对象。</p><p>具体的步骤如下：</p><ol><li> 接收两个字符串参数，分别代表要进行解析的字符串 <code>dateStr</code>，以及该字符串需要的自定义日期字符串格式 <code>fmt</code>。</li><li> 先解析 <code>fmt</code>，获取其中的代表 <code>year, method, day, hour, minute, second, milliSecond</code> 的部分得到一个数组（并且记录不同部分的 <code>index</code>）<code>dateUnits</code>，对 <code>fmt</code> 的代表日期的不同部分进行替换.</li><li> 使用替换过的 <code>fmt</code> 创建正则验证 <code>dateStr</code> 是否合法，非法直接返回 <code>null</code>。</li><li> 对 <code>dateUnits</code> 根据 <code>index</code> 进行排序，得到一个按照原本的 <code>fmt</code> 的不同日期部分的顺序的数组。</li><li> 遍历 <code>dateUnits</code> 获取到不同的部分，然后拼接成一个标准的(<code>yyyy-MM-ddThh:mm:ss.SSS</code>)日期字符串 <code>date</code>。</li><li> 使用 new Date(date) 并且返回。</li></ol><p>全部代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析字符串为 Date 对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>dateStr 日期字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fmt 日期字符串的格式</span><br><span class="hljs-comment"> * 目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">Date</span>.of = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dateStr, fmt</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!dateStr) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;传入的日期字符串不能为空！&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!fmt) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;传入的日期字符串的自定义格式不能为空！&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 日期格式化对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>name 日期格式的名称</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>format 日期的格式值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>value 格式化得到的值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@constructor</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DateFormat</span>(<span class="hljs-params">name, format, value, index</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.format = format;<br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">this</span>.index = index;<br>  &#125;<br><br>  <span class="hljs-comment">//日期时间的正则表达式</span><br>  <span class="hljs-keyword">const</span> dateFormats = &#123;<br>    year: <span class="hljs-string">&quot;y&#123;1,4&#125;&quot;</span>,<br>    month: <span class="hljs-string">&quot;M&#123;1,2&#125;&quot;</span>,<br>    day: <span class="hljs-string">&quot;d&#123;1,2&#125;&quot;</span>,<br>    hour: <span class="hljs-string">&quot;h&#123;1,2&#125;&quot;</span>,<br>    minute: <span class="hljs-string">&quot;m&#123;1,2&#125;&quot;</span>,<br>    second: <span class="hljs-string">&quot;s&#123;1,2&#125;&quot;</span>,<br>    milliSecond: <span class="hljs-string">&quot;S&#123;1,3&#125;&quot;</span>,<br>  &#125;;<br>  <span class="hljs-comment">//如果没有格式化某项的话则设置为默认时间</span><br>  <span class="hljs-keyword">const</span> defaultDateValues = &#123;<br>    year: <span class="hljs-string">&quot;2001&quot;</span>,<br>    month: <span class="hljs-string">&quot;01&quot;</span>,<br>    day: <span class="hljs-string">&quot;01&quot;</span>,<br>    hour: <span class="hljs-string">&quot;00&quot;</span>,<br>    minute: <span class="hljs-string">&quot;00&quot;</span>,<br>    second: <span class="hljs-string">&quot;00&quot;</span>,<br>    milliSecond: <span class="hljs-string">&quot;000&quot;</span>,<br>  &#125;;<br>  <span class="hljs-comment">//保存对传入的日期字符串进行格式化的全部信息数组列表</span><br>  <span class="hljs-keyword">const</span> dateUnits = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fmtName <span class="hljs-keyword">in</span> dateFormats) &#123;<br>    <span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(dateFormats[fmtName]);<br>    <span class="hljs-keyword">if</span> (regExp.test(fmt)) &#123;<br>      <span class="hljs-keyword">const</span> matchStr = regExp.exec(fmt)[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">const</span> regexStr = <span class="hljs-built_in">String</span>.fill(<span class="hljs-string">&quot;`&quot;</span>, matchStr.length);<br>      <span class="hljs-keyword">const</span> index = fmt.indexOf(matchStr);<br>      fmt = fmt.replaceAll(matchStr, regexStr);<br>      dateUnits.push(<br>        <span class="hljs-keyword">new</span> DateFormat(<br>          fmtName,<br>          <span class="hljs-built_in">String</span>.fill(<span class="hljs-string">&quot;\\d&quot;</span>, matchStr.length),<br>          <span class="hljs-literal">null</span>,<br>          index<br>        )<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      dateUnits.push(<br>        <span class="hljs-keyword">new</span> DateFormat(fmtName, <span class="hljs-literal">null</span>, defaultDateValues[fmtName], -<span class="hljs-number">1</span>)<br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//进行验证是否真的是符合传入格式的字符串</span><br>  fmt = fmt.replaceAll(<span class="hljs-string">&quot;`&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(fmt).test(dateStr)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-comment">//进行一次排序, 依次对字符串进行截取</span><br>  dateUnits.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a.index - b.index;<br>  &#125;);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = dateUnits.length; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">const</span> format = dateUnits[i].format;<br>    <span class="hljs-keyword">if</span> (format == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> matchDateUnit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(format).exec(dateStr);<br>    <span class="hljs-keyword">if</span> (matchDateUnit !== <span class="hljs-literal">null</span> &amp;&amp; matchDateUnit.length &gt; <span class="hljs-number">0</span>) &#123;<br>      dateStr = dateStr.replace(matchDateUnit[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&quot;</span>);<br>      dateUnits[i].value = matchDateUnit[<span class="hljs-number">0</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//将截取完成的信息封装成对象并格式化标准的日期字符串</span><br>  <span class="hljs-keyword">const</span> obj = dateUnits.toObject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      key: item.name,<br>      value: item.value,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">const</span> date = <span class="hljs-string">&quot;&#123;year&#125;-&#123;month&#125;-&#123;day&#125;T&#123;hour&#125;:&#123;minute&#125;:&#123;second&#125;.&#123;milliSecond&#125;&quot;</span>.format(<br>    obj<br>  );<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(date);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">//下面是上面的 Date.of() 使用的一些辅助方法</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 替换所有匹配exp的字符串为指定字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exp 被替换部分的正则</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>newStr 替换成的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">String</span>.prototype.replaceAll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exp, newStr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(exp, <span class="hljs-string">&quot;gm&quot;</span>), newStr);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原型：字符串格式化</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>args 格式化参数值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">String</span>.prototype.format = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">arguments</span>; <span class="hljs-comment">// 如果模板参数是数组</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果模板参数是对象</span><br>    data = args;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> data) &#123;<br>    <span class="hljs-keyword">var</span> value = data[key];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">undefined</span> !== value) &#123;<br>      result = result.replaceAll(<span class="hljs-string">&quot;\\&#123;&quot;</span> + key + <span class="hljs-string">&quot;\\&#125;&quot;</span>, value);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 js 的 String 添加填充字符串的静态方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>item 填充的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>length 填充的长度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;string&#125;</span> </span>填充得到的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">String</span>.fill = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, length</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    result += item;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * js 数组转换为一个 Object 对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 转换方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;&#123;&#125;</span></span>&#125; 得到的 Object 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">Array</span>.prototype.toObject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>  <span class="hljs-built_in">this</span>.map(fn).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    obj[item.key] = item.value;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Code Gist：<a href="https://gist.github.com/rxliuli/a81f058d03a99cbd08d6ca6095b2c7cb">https://gist.github.com/rxliuli/a81f058d03a99cbd08d6ca6095b2c7cb</a></p><p>那么，关于 <code>JavaScript</code> 中的字符串解析为 <code>Date</code> 对象就到这里啦，如果有什么错误/更好的建议都可以提出来呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react 受控表单必须初始化</title>
    <link href="/p/54792a3f54a5427a810dcdc81a65be06/"/>
    <url>/p/54792a3f54a5427a810dcdc81a65be06/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>这些天在学习 <code>React</code> 的时候遇到了一个奇怪的问题，明明受控表单的双向绑定已经成功了，然而控制台还是会出现 react 的警告：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Warning: A component is changing an uncontrolled input of <span class="hljs-built_in">type</span> undefined to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element <span class="hljs-keyword">for</span> the lifetime of the component.<br></code></pre></td></tr></table></figure><p>代码很简单，仅仅只是一个登录表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; username, password &#125; = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.username = username;<br>    <span class="hljs-built_in">this</span>.password = password;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; User &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      user: <span class="hljs-keyword">new</span> User(),<br>    &#125;;<br>  &#125;<br>  change = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> el = e.target;<br>    <span class="hljs-keyword">const</span> k = el.name;<br>    <span class="hljs-keyword">const</span> v = el.value;<br>    <span class="hljs-keyword">const</span> user = &#123; ...this.state.user &#125;;<br>    user[k] = v;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      user,<br>    &#125;);<br>  &#125;;<br>  submit = <span class="hljs-function">() =&gt;</span> &#123;&#125;;<br>  reset = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      user: <span class="hljs-keyword">new</span> User(),<br>    &#125;);<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; username, password &#125; = <span class="hljs-built_in">this</span>.state.user;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          &lt;label htmlFor=<span class="hljs-string">&quot;username&quot;</span>&gt;用户名: &lt;/label&gt;<br>          &lt;input name=<span class="hljs-string">&quot;username&quot;</span> value=&#123;username&#125; onChange=&#123;<span class="hljs-built_in">this</span>.change&#125; /&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>          &lt;label htmlFor=<span class="hljs-string">&quot;password&quot;</span>&gt;密码: &lt;/label&gt;<br>          &lt;input name=<span class="hljs-string">&quot;password&quot;</span> value=&#123;password&#125; onChange=&#123;<span class="hljs-built_in">this</span>.change&#125; /&gt;<br>        &lt;/div&gt;<br>        &lt;div&gt;<br>          &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.submit&#125;&gt;登录&lt;/button&gt;<br>          &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.reset&#125;&gt;重置&lt;/button&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>在 App 组件的 <code>constructor</code> 中明明已经通过 <code>new User()</code> 初始化了 <code>user</code> 属性，然而在输入的时候，还是会出现警告。</p><blockquote><p>注：此时在输入框中输入值，确实会影响到 react state 中的 user 属性，反之亦然。只有一点，当重置表单，即使用 <code>this.setState(&#123;user: new User()&#125;)</code> 重置 user 对象无法影响到页面上输入框的值。</p></blockquote><p>此处出现了两个问题</p><ol><li> 为什么在输入的时候会出现警告</li><li> 为什么重置之后输入框的值没有变化</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>最终，吾辈在 <a href="https://stackoverflow.com/questions/37427508">StackOverflow</a> 上找到了答案。<br>很重要的一句话：<strong>对于要控制的输入，其值必须与状态变量的值相对应。</strong><br>最初并未满足这个条件，值为 <code>null</code> 的 <code>state</code> 属性会被 <code>react</code> 视为未定义，导致表单最初是不受控制的。但是，当 <code>onChange</code> 第一次被触发的时候，<code>this.state.user.username</code> 就被设置了。此时，满足了条件，从非受控表单转换为了受控表单并导致了控制台的警告。<br>同理，当使用 <code>this.setState(&#123;user: new User()&#125;)</code> 重置的时候，又变成了非受控表单，所以这里的绑定再次失效了。</p><blockquote><p>注: react 使用 <code>==</code> 而非 <code>===</code> 比较是否为 <code>null</code>，而 <code>null == undefined</code> 的值为 <code>true</code>，所以。。。</p></blockquote><p>那么，知道问题了之后，我们只要保证初始值 <code>val != null</code> 即可。<br>例如上面的代码可以修改 <code>User.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; username = <span class="hljs-string">&quot;&quot;</span>, password = <span class="hljs-string">&quot;&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.username = username;<br>    <span class="hljs-built_in">this</span>.password = password;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，关于 react 中的受控表单初始化的问题便到此为止了。可想而知，react 的坑还有很多没有踩完呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 实现一个简单的瀑布流组件</title>
    <link href="/p/5b11af8492fe498483c9132787e04f45/"/>
    <url>/p/5b11af8492fe498483c9132787e04f45/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在用 Vue 写前端的时候，需要实现无限滚动翻页的功能。因为用到的地方很多，于是便想着抽出一个通用组件。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>实现源码放到了 <a href="https://github.com/rxliuli/vue-waterfalls-flow">GitHub</a>，<a href="https://vue-waterfalls-flow.rxliuli.com/">Demo 演示</a> 想直接看源码/效果的人可以直接去看</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li> 定义一个 vuejs 容器组件</li><li> 抽离出公共的属性（加载一页数据的函数/每个元素的模板）</li><li> 在父容器中遍历每个元素并绑定到传入的模板上</li><li> 监听滚动事件，如果不是最后一页就加载下一页</li><li> 重新渲染集合元素</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>定义模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs vuejs">&#x2F;**<br>自定义瀑布流组件<br>使用方法如下：<br>&lt;rx-waterfalls-flow :load&#x3D;&quot;load&quot;&gt;<br>    &lt;!-- 这里 slotProps 绑定的便是子组件的数据，通过 slotProps 可以访问到子组件绑定到模板上的数据，当然，更简单的方法是使用 ES6 的解构 --&gt;<br>    &lt;template slot-scope&#x3D;&quot;&#123;item&#125;&quot;&gt;<br>  &lt;!-- 在模板里面便可以使用集合中的元素 item 了 --&gt;<br>  &lt;li :key&#x3D;&quot;item.id&quot;&gt;<br>    &#123;&#123;item.text&#125;&#125;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;template&gt;<br>  &lt;&#x2F;rx-waterfalls-flow&gt;<br> *&#x2F;<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;rx-waterfalls-flow-container&quot;&gt;<br>    &lt;slot<br>      v-for&#x3D;&quot;item in items&quot;<br>      :item&#x3D;&quot;item&quot;<br>    &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    load: &#123;<br>      type: Function,<br>      default: function () &#123;<br>        throw new Error(&#39;你需要为 RxWaterfallsFlow 组件定义分页加载的参数&#39;)<br>      &#125;<br>    &#125;<br>  &#125;,<br>  data: () &#x3D;&gt; (&#123;<br>    items: [],<br>    page: &#123;<br>      total: 0,<br>      size: 10,<br>      pages: 10,<br>      current: 1,<br>      records: []<br>    &#125;<br>  &#125;),<br>  methods: &#123;<br>    async loadPage (current, size) &#123;<br>      this.page &#x3D; await this.load(current, size)<br>      this.items.push(...this.page.records)<br>      this.page.records &#x3D; []<br>    &#125;,<br>    &#x2F;**<br>     * 初始化方法，加载第一页的数据，加载监听器<br>     *&#x2F;<br>    async init () &#123;<br>      this.loadPage()<br>      &#x2F;&#x2F; 绑定窗口滚动事件<br>      &#x2F;&#x2F; 获得文档高度和滚动高度<br>      &#x2F;&#x2F; 计算是否已经到底了<br>      &#x2F;&#x2F; 到底的话就加载下一页的数据，否则忽略<br>      const otherOnscrollFn &#x3D; document.onscroll ? document.onscroll : function () &#123; &#125;<br>      document.onscroll &#x3D; () &#x3D;&gt; &#123;<br>        otherOnscrollFn()<br>        const scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop<br>        const clientHeight &#x3D; document.documentElement.clientHeight<br>        const scrollHeight &#x3D; document.documentElement.scrollHeight<br>        &#x2F;&#x2F; console.log(&#96;已滚动的高度：$&#123;scrollTop&#125;, 滚动条高度：$&#123;scrollHeight&#125;, $&#123;clientHeight&#125;&#96;)<br>        &#x2F;&#x2F; 向下滚动时判断判断是否正在向上滚动，是的话就清除定时器，停在当前位置<br>        if (scrollHeight - scrollTop - clientHeight &lt;&#x3D; 0 &amp;&amp; this.page.current &lt; this.page.pages) &#123;<br>          this.loadPage(this.page.current + 1, this.page.size)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  mounted () &#123;<br>    this.init()<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style scoped&gt;<br>&#x2F;* 容器宽度要占 100% *&#x2F;<br>#rx-waterfalls-flow-container &#123;<br>  width: 100%;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用起来就很简单了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs vuejs">&lt;template&gt;<br>  &lt;rx-waterfalls-flow :load&#x3D;&quot;load&quot;&gt;<br>    &lt;!-- 这里 slotProps 绑定的便是子组件的数据，通过 slotProps 可以访问到子组件绑定到模板上的数据，当然，更简单的方法是使用 ES6 的解构 --&gt;<br>    &lt;!-- 这里面的是你自定义每个元素显示的内容 --&gt;<br>    &lt;template slot-scope&#x3D;&quot;&#123;item&#125;&quot;&gt;<br>      &lt;!-- 在模板里面便可以使用集合中的元素 item 了 --&gt;<br>      &lt;li<br>        class&#x3D;&quot;item-style&quot;<br>        :key&#x3D;&quot;item.id&quot;<br>      &gt;<br>        &#123;&#123;item.text&#125;&#125;<br>      &lt;&#x2F;li&gt;<br>    &lt;&#x2F;template&gt;<br>  &lt;&#x2F;rx-waterfalls-flow&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>&#x2F;&#x2F; 引入瀑布流组件<br>import RxWaterfallsFlow from &#39;@&#x2F;components&#x2F;common&#x2F;RxWaterfallsFlow&#39;<br>import _ from &#39;lodash&#39;<br><br>export default &#123;<br>  components: &#123;<br>    RxWaterfallsFlow<br>  &#125;,<br>  methods: &#123;<br>    &#x2F;&#x2F; 使用 Promise 封装 setTimeout，模拟 ajax 的异步造成的延迟<br>    await: ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms)),<br>    load: (page &#x3D;&gt; &#123;<br>      &#x2F;&#x2F; 该方法用于模拟 ajax 数据加载<br>      return async function () &#123;<br>        await this.await(1000)<br>        console.log(&#96;加载了第 $&#123;page.current&#125; 页，共 $&#123;page.pages&#125; 页&#96;)<br>        &#x2F;&#x2F; 使用 lodash 模拟数据<br>        page.records &#x3D; _.range(<br>          (page.current - 1) * page.size + 1,<br>          (++page.current - 1) * page.size + 1<br>        )<br>          .map(i &#x3D;&gt; (&#123;<br>            id: i,<br>            text: &#96;第 $&#123;i&#125; 行内容&#96;<br>          &#125;))<br>        return page<br>      &#125;<br>    &#125;)(&#123;<br>      current: 1,<br>      size: 10,<br>      pages: 100,<br>      total: this.current * this.pages,<br>      records: []<br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br>li &#123;<br>  width: 500px;<br>  height: 200px;<br>  line-height: 200px;<br>  background-color: aqua;<br>  margin: 10px auto;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>目前这个简单的瀑布流公用组件还有着相当多的缺陷，却是要等到后面再进行改进了呢</p><ul><li>没有 DOM 回收机制，会造成 DOM 树越来越大，网页就会变得越来越卡（Twitter 就是这样）</li><li>没有一键回到顶部的功能，毕竟翻了太久的话回到顶部很麻烦呢</li><li>自定义属性还是不够，例如一页的数据的条数，最大页数什么的</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>layui-layer load 弹窗自动关闭的问题</title>
    <link href="/p/5e539807d8a64f1193dc38d64ae7fcd2/"/>
    <url>/p/5e539807d8a64f1193dc38d64ae7fcd2/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>项目中的 Ajax 加载时的 loading 框有时候会关闭了弹窗之后很久页面上的数据才加载出来，而且这个问题是随机出现的，有些页面存在，有些页面则正常。</p><p>最小复现代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      /**<br>       * 加载遮罩框<br>       *<br><span class="javascript">       * @returns &#123;<span class="hljs-built_in">Function</span>&#125; 一个关闭遮罩框的函数</span><br>       */<br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> id = layer.load(<span class="hljs-number">1</span>);</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;</span><br>          layer.close(id);<br>        &#125;;<br>      &#125;<br>      /**<br>       * 模拟 ajax 异步请求<br>       */<br><span class="javascript">      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">time</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> close = load();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request start: &quot;</span>, time);</span><br><span class="javascript">        <span class="hljs-keyword">await</span> rx.wait(time);</span><br>        close();<br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request end: &quot;</span>, time);</span><br>      &#125;<br><br><span class="javascript">      (<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        request(<span class="hljs-number">5000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第二个请求加载完成了&quot;</span>));</span><br><span class="javascript">        request(<span class="hljs-number">1000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第一个请求加载完成了&quot;</span>));</span><br>      &#125;)();<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>控制台打印</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">request start:  5000<br>request start:  1000<br>request end:  1000<br>第一个请求加载完成了<br>request end:  5000<br>第二个请求加载完成了<br></code></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>本来吾辈猜测是 vuejs 页面渲染的锅，认为 vuejs 的生命周期函数 <code>mouted</code> 执行时 DOM 还没加载完全的缘故。<br>所以把 <code>load</code> 异步化，等待 document 加载完毕才会真正执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      /**<br>       * 加载遮罩框<br>       *<br><span class="javascript">       * @returns &#123;<span class="hljs-built_in">Function</span>&#125; 一个关闭遮罩框的函数</span><br>       */<br><span class="javascript">      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">await</span> rx.wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.readyState === <span class="hljs-string">&quot;complete&quot;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">const</span> id = layer.load(<span class="hljs-number">1</span>);</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> () =&gt; &#123;</span><br><span class="javascript">          <span class="hljs-keyword">await</span> rx.wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.readyState === <span class="hljs-string">&quot;complete&quot;</span>);</span><br>          layer.close(id);<br>        &#125;;<br>      &#125;<br>      /**<br>       * 模拟 ajax 异步请求<br>       */<br><span class="javascript">      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">time</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> close = <span class="hljs-keyword">await</span> load();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request start: &quot;</span>, time);</span><br><span class="javascript">        <span class="hljs-keyword">await</span> rx.wait(time);</span><br><span class="javascript">        <span class="hljs-keyword">await</span> close();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request end: &quot;</span>, time);</span><br>      &#125;<br><br><span class="javascript">      (<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        request(<span class="hljs-number">5000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第二个请求加载完成了&quot;</span>));</span><br><span class="javascript">        request(<span class="hljs-number">1000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第一个请求加载完成了&quot;</span>));</span><br>      &#125;)();<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>控制台打印</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">request start:  5000<br>request start:  1000<br>request end:  1000<br>第一个请求加载完成了<br>request end:  5000<br>第二个请求加载完成了<br></code></pre></td></tr></table></figure><p>然而实际上却并不是这个问题。。。</p><p>经过某位网友提醒，layer 源码中默认只允许一个活动的 <code>load</code> 弹窗。瞬间吾辈都不知道要怎么吐槽了，单例模式避免无谓的内存浪费是正常的，然而新的 <code>load</code> 函数却会关闭之前的 <code>load</code> 这种操作真的是很厉害了呢</p><p>例如下面这段代码，无论调用多少次 <code>layer.close(id1)</code>，页面上的 <code>loading</code> 都不会关闭。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> id1 = layer.load();<br><span class="hljs-keyword">const</span> id2 = layer.load();<br>layer.close(id1);<br>layer.close(id1);<br><span class="hljs-comment">// ...</span><br>layer.close(id1);<br>layer.close(id1);<br></code></pre></td></tr></table></figure><blockquote><p>这里吾辈可以想象到，layer 认为先加载的 <code>load()</code> 就应该先被 <code>close()</code>，而没有考虑到复杂异步的情况。</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然 layer 的 <code>load</code> 本身存在缺陷，那么却是只能自己对 <code>load</code> 和 <code>close</code> 功能做控制了<br>基本思路</p><ol><li> <code>layer.load</code> 每次都会关闭掉之前的弹窗，那么就记录最后一次的弹窗 id，在真正需要关闭的时候 close 掉就好了</li><li> <code>layer.load</code> 关闭是直接关闭弹窗，如果是最后一个就会出现弹窗消失但数据没加载完全的问题，那么关闭这儿要判断当前是否还有活动的弹窗，只有在没有的情况下才真正关闭</li></ol><p>修改后的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      /**<br>       * 加载遮罩框<br>       *<br><span class="javascript">       * @returns &#123;<span class="hljs-built_in">Function</span>&#125; 一个关闭遮罩框的函数</span><br>       */<br><span class="javascript">      <span class="hljs-keyword">const</span> load = (<span class="hljs-function">(<span class="hljs-params">num, lastId</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> &#123;</span><br>        lastId = layer.load(1);<br>        num++;<br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;</span><br>          num--;<br><span class="javascript">          <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;</span><br>            num = 0;<br>          &#125;<br><span class="javascript">          <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;弹窗没有真正关闭哦&quot;</span>);</span><br><span class="javascript">            <span class="hljs-keyword">return</span>;</span><br>          &#125;<br>          layer.close(lastId);<br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;弹窗真的关闭啦&quot;</span>);</span><br>        &#125;;<br>      &#125;)(0);<br><br>      /**<br>       * 模拟 ajax 异步请求<br>       */<br><span class="javascript">      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">time</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> close = <span class="hljs-keyword">await</span> load();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request start: &quot;</span>, time);</span><br><span class="javascript">        <span class="hljs-keyword">await</span> rx.wait(time);</span><br><span class="javascript">        <span class="hljs-keyword">await</span> close();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request end: &quot;</span>, time);</span><br>      &#125;<br><br><span class="javascript">      (<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        request(<span class="hljs-number">5000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第二个请求加载完成了&quot;</span>));</span><br><span class="javascript">        request(<span class="hljs-number">1000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第一个请求加载完成了&quot;</span>));</span><br>      &#125;)();<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>控制台打印</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">request start:  5000<br>request start:  1000<br>弹窗没有真正关闭哦<br>request end:  1000<br>第一个请求加载完成了<br>弹窗真的关闭啦<br>request end:  5000<br>第二个请求加载完成了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 SSH 连接 Linux 服务器</title>
    <link href="/p/62e40a56577346a4b993bd6b814ce110/"/>
    <url>/p/62e40a56577346a4b993bd6b814ce110/</url>
    
    <content type="html"><![CDATA[<h2 id="首先我们要在客户端（本机）生成密钥对"><a href="#首先我们要在客户端（本机）生成密钥对" class="headerlink" title="首先我们要在客户端（本机）生成密钥对"></a>首先我们要在客户端（本机）生成密钥对</h2><blockquote><p>这里的密钥对是 <code>Public key</code>，具体请参考 <a href="https://zh.wikipedia.org/zh/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开密钥加密</a></p></blockquote><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>接下来会提示让你输入一个路径来保存密钥对，默认在 <code>~/.ssh/id_rsa</code> 下面生成 <code>id_rsa</code>（私钥）和 <code>id_rsa.pub</code>（公钥），如果没什么特殊需求就直接默认就好。</p><p>然后提示你输入密码（即本机使用 <code>SSH</code> 连接时的密码 #和服务器密码无关），也是直接回车默认为空即可。</p><h2 id="将公钥上传到服务器上"><a href="#将公钥上传到服务器上" class="headerlink" title="将公钥上传到服务器上"></a>将公钥上传到服务器上</h2><p>这里以使用 <code>SCP</code> 为例，上传公钥 <code>id_rsa.pub</code> 到服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ~/.ssh/id_rsa.pub root@139.59.22.131:~<br></code></pre></td></tr></table></figure><h2 id="将公钥追加到服务器的认证密钥中"><a href="#将公钥追加到服务器的认证密钥中" class="headerlink" title="将公钥追加到服务器的认证密钥中"></a>将公钥追加到服务器的认证密钥中</h2><p>将上传到服务器上的 <code>id_rsa.pub</code> 公钥追加到 <code>authorized_keys</code> 文件中，命令是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h2 id="修改服务器的配置以启用公钥认证"><a href="#修改服务器的配置以启用公钥认证" class="headerlink" title="修改服务器的配置以启用公钥认证"></a>修改服务器的配置以启用公钥认证</h2><p>修改 <code>vi /etc/ssh/sshd_config</code> 配置文件（如果有的话就进行修改，没有的话就添加进来）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">RSAAuthentication yes        # 启用 RSA 认证（默认是注释掉的，将注释去掉，如果不是 yes，改为 yes）<br>PubkeyAuthentication yes     # 启用公钥认证（默认是注释掉的，将注释去掉，如果不是 yes，改为 yes）<br>PasswordAuthentication no    # 禁止密码认证 (改为 no, 默认为 yes 是用密码认证)<br>StrictModes no               # 修改为 no, 默认为 yes. 如果不修改用 key 登陆是出现 server refused our key(如果 StrictModes 为 yes 必需保证存放公钥的文件夹的拥有与登陆用户名是相同的.“StrictModes” 设置 ssh 在接收登录请求之前是否检查用户家目录和 rhosts 文件的权限和所有权。这通常是必要的，因为新手经常会把自己的目录和文件设成任何人都有写权限。)<br></code></pre></td></tr></table></figure><h2 id="重启-SSH-服务"><a href="#重启-SSH-服务" class="headerlink" title="重启 SSH 服务"></a>重启 <code>SSH</code> 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart<br><span class="hljs-comment"># 或者</span><br>/etc/init.d/ssh restart<br></code></pre></td></tr></table></figure><h2 id="最后验证一下"><a href="#最后验证一下" class="headerlink" title="最后验证一下"></a>最后验证一下</h2><p>连接服务器，这里以 <code>SSH</code> 客户端为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@139.59.22.131<br></code></pre></td></tr></table></figure><p>然后，就直接连上了，不需要输入密码了呢 Ｏ(≧▽≦)Ｏ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 使用递归异步的请求</title>
    <link href="/p/6b5a7a1341d14bf7bd0da7e10321f2ff/"/>
    <url>/p/6b5a7a1341d14bf7bd0da7e10321f2ff/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>之前写了个 <code>user.js</code> 脚本来抓取百度网盘的文件元信息列表，用来进行二级查看和分析,脚本放到了 <a href="https://greasyfork.org/zh-CN/scripts/375701">GreasyFork</a>。最开始为了简化代码直接使用了 <code>async/await</code> 单线程进行异步请求，导致请求的速度十分不理想！<br>关键代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件数据信息类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>path 全路径</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>parent 父级路径</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>name 文件名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>size 大小(b)</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>isdir 是否为文件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> <span class="hljs-type">&#123;origin&#125;</span> </span>百度云文件信息的源对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">path, parent, name, size, isdir, origin</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.isdir = isdir;<br>    <span class="hljs-built_in">this</span>.orgin = origin;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取指定文件夹下的一级文件/文件夹列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>path 绝对路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>文件/文件夹列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDir</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> baseUrl = <span class="hljs-string">&quot;https://pan.baidu.com/api/list?&quot;</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;baseUrl&#125;</span>dir=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(path)&#125;</span>`</span>);<br>    <span class="hljs-keyword">var</span> json = <span class="hljs-keyword">await</span> res.json();<br>    <span class="hljs-keyword">return</span> json.list;<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`读取文件夹 <span class="hljs-subst">$&#123;path&#125;</span> 发生了错误：`</span>, err);<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将数组异步压平一层</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>arr 数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn 映射方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFlatMap</span>(<span class="hljs-params">arr, fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>    res.push(...(<span class="hljs-keyword">await</span> fn(arr[i])));<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归获取到所有的子级文件/文件夹</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>path 指定获取的文件夹路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>指定文件夹下所有的文件/文件夹列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syncList</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> fileList = <span class="hljs-keyword">await</span> getDir(path);<br>  <span class="hljs-keyword">return</span> asyncFlatMap(fileList, <span class="hljs-keyword">async</span> (file) =&gt; &#123;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> File(<br>      file.path,<br>      path,<br>      file.server_filename,<br>      file.size,<br>      file.isdir,<br>      file<br>    );<br>    <span class="hljs-keyword">if</span> (res.isdir !== <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> [res];<br>    &#125;<br>    <span class="hljs-keyword">return</span> [res].concat(<span class="hljs-keyword">await</span> syncList(res.path));<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，使用的方式是 <code>递归 + 单异步</code>，这就导致了脚本的效率不高，使用体验很差！</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>吾辈想要使用多异步模式，需要解决的问题有二：</p><ul><li>如何知道现在有多个异步在执行并且在数量过多时等待</li><li>如何知道所有的请求都执行完成了然后结束</li></ul><p>解决思路</p><ol><li>判断并限定异步的数量<ol><li> 添加记录正在执行的异步请求的计数器 <code>execQueue</code></li><li>每次请求前先检查 <code>execQueue</code> 是否到达限定值<ul><li>如果没有，<code>execQueue + 1</code></li><li>如果有，等待 <code>execQueue</code> 减小</li></ul></li><li> 执行请求，请求结束 <code>execQueue - 1</code></li></ol></li><li>判断所有请求都执行完成<ol><li> 添加记录正在等待的异步请求的计数器 <code>waitQueue</code></li><li> 在判断 <code>execQueue</code> 是否到达限定值之前 <code>waitQueue + 1</code></li><li> 在判断 <code>execQueue</code> 是否到达限定值之后（等待之后） <code>waitQueue - 1</code></li><li>请求结束后判断 <code>waitQueue</code> 和 <code>waitQueue</code> 是否均为 <code>0</code><ul><li>是：返回结果</li><li>否：什么都不做</li></ul></li></ol></li></ol><p>具体实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件数据信息类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>path 全路径</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>parent 父级路径</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>name 文件名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>size 大小(b)</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>isdir 是否为文件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> <span class="hljs-type">&#123;origin&#125;</span> </span>百度云文件信息的源对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">path, parent, name, size, isdir, origin</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.path = path;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.size = size;<br>    <span class="hljs-built_in">this</span>.isdir = isdir;<br>    <span class="hljs-built_in">this</span>.orgin = origin;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取指定文件夹下的一级文件/文件夹列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>path 绝对路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>文件/文件夹列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDir</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> baseUrl = <span class="hljs-string">&quot;https://pan.baidu.com/api/list?&quot;</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;baseUrl&#125;</span>dir=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(path)&#125;</span>`</span>);<br>    <span class="hljs-keyword">var</span> json = <span class="hljs-keyword">await</span> res.json();<br>    <span class="hljs-keyword">return</span> json.list;<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`读取文件夹 <span class="hljs-subst">$&#123;path&#125;</span> 发生了错误：`</span>, err);<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归获取所有文件/文件夹</span><br><span class="hljs-comment"> * 测试获取 34228 条数据</span><br><span class="hljs-comment"> * - 100 线程：156518ms</span><br><span class="hljs-comment"> * - 5   线程：220500ms</span><br><span class="hljs-comment"> * - 1   线程：超过 20min</span><br><span class="hljs-comment"> * 实现：</span><br><span class="hljs-comment"> * 1. 请求文件夹下的所有文件/文件夹</span><br><span class="hljs-comment"> * 2. 如果是文件则直接添加到结果数组中</span><br><span class="hljs-comment"> * 3. 如果是文件夹则递归调用当前方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[path] 指定文件夹，默认为根路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>[limit] 指定限定异步数量，默认为 5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>异步对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncList</span>(<span class="hljs-params">path = <span class="hljs-string">&quot;/&quot;</span>, limit = <span class="hljs-number">5</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> execCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> waitQueue = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 结果数组</span><br>    <span class="hljs-keyword">var</span> result = [];<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">children</span>(<span class="hljs-params">path</span>) </span>&#123;<br>      waitQueue++;<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> execCount &lt; limit);<br>      waitQueue--;<br>      execCount++;<br>      getDir(path).then(<span class="hljs-function">(<span class="hljs-params">fileList</span>) =&gt;</span> &#123;<br>        fileList.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> File(<br>            file.path,<br>            path,<br>            file.server_filename,<br>            file.size,<br>            file.isdir,<br>            file<br>          );<br>          result.push(res);<br>          <span class="hljs-keyword">if</span> (res.isdir === <span class="hljs-number">1</span>) &#123;<br>            children(res.path);<br>          &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (--execCount === <span class="hljs-number">0</span> &amp;&amp; waitQueue === <span class="hljs-number">0</span>) &#123;<br>          resolve(result);<br>        &#125;<br>      &#125;);<br>    &#125;<br>    children(path);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>吾辈使用 <code>timing</code> 函数测试了一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试函数的执行时间</span><br><span class="hljs-comment"> * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>需要测试的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number|Promise&#125;</span> </span>执行的毫秒数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> begin = performance.now();<br>  <span class="hljs-keyword">var</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> performance.now() - begin;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br></code></pre></td></tr></table></figure><p>请求了 <code>2028</code> 次，两个函数的性能比较如下（单位是毫秒）</p><ul><li><code>asyncList</code>：109858.80000004545</li><li><code>syncList</code>：451904.3000000529</li></ul><p>差距近 4.5 倍，几乎等同于默认的异步倍数了，看起来优化还是很值得呢！</p><blockquote><p>附：其实 <code>asyncList</code> 如果使用单异步的话效率反而更低，因为要做一些额外的判断导致单次请求更慢，但因为多个异步请求同时执行的缘故因此缺点被弥补了</p></blockquote><hr><p>那么，关于 JavaScript 使用递归异步的请求就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 vue-cli 创建模板项目</title>
    <link href="/p/71347fe5e29a4c5d8ee8baa8d9d1bc1f/"/>
    <url>/p/71347fe5e29a4c5d8ee8baa8d9d1bc1f/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈曾经只是个 Java 后端开发人员，原本对前端的了解大致只有 <code>HTML/CSS/JavaScript/JQuery</code> 级别，后来接触到了 <code>nodejs</code>。不仅是工作之需，吾辈个人而言也非常想要了解现代前端技术。然而天可怜见，吾辈刚入门 <code>nodejs</code> 并没有发现什么，但发现想要构建一个项目，需要用到前端工具链实在太多了。配置文件的数量甚至远远超过后端。<br>所以为了快速开发，入门之后遇到问题再去解决，吾辈选择了使用 <code>nodejs + npm + vuejs + webpack + vscode</code> 组合，使用 <code>vue-cli</code> 快速搭建一个基于现代前端工具链前端项目。</p><blockquote><p>致那些想要了解前端但又不得其门的后端开发者，第一步的入门是最重要/最困难的。</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>想要继续向下阅读的话请务必确认你的 PC 上已经正确安装了 nodejs/npm，如果还未曾安装，请参考 <a href="https://nodejs.org/">nodejs 官网</a> 进行安装</p><blockquote><p><code>npm</code> 已经默认包含在 <code>nodejs</code> 中了</p></blockquote><h3 id="第一步：全局安装-vue-cli"><a href="#第一步：全局安装-vue-cli" class="headerlink" title="第一步：全局安装 vue-cli"></a>第一步：全局安装 vue-cli</h3><p>打开命令行，安装 <code>vue-cli</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g @vue/cli<br></code></pre></td></tr></table></figure><p>安装完成后在命令行输入 <code>vue</code> 应该会有类似于以下的输出</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108140401.png" alt="vue-cli 安装完成验证"></p><h3 id="第二步：使用模板初始化一个项目"><a href="#第二步：使用模板初始化一个项目" class="headerlink" title="第二步：使用模板初始化一个项目"></a>第二步：使用模板初始化一个项目</h3><p>命令格式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># option 是选项，template 是使用的模板，app-name 是要初始化项目的名字</span><br>vue init [option] &lt;template&gt; &lt;app-name&gt;<br></code></pre></td></tr></table></figure><p>例如我们使用 <code>vue init webpack vue-webpack-example</code> 初始化一个 <code>webpack</code> 模板的项目，大部分组件我们暂时还不需要，所以选择 <code>vue-router</code> 以及使用 <code>npm</code> 进行构建。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108141449.png" alt="vue-cli 初始化 webpack 模板项目"></p><p>初始化完成后我们在命令行进入文件夹 <em>vue-webpack-example</em> 中，现在我们可以通过 <code>npm run dev</code> 启动开发服务器模式和 <code>npm run build</code> 打包项目为静态文件</p><p>尝试使用 <code>npm run dev</code> 运行项目，最后应该会得到如下输出</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108184122.png" alt="vue 项目运行输出"></p><p>在浏览器打开链接 <a href="http://localhost:8080/">http://localhost:8080</a></p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108184257.png" alt="vue 项目模板"></p><h3 id="第三步：初始化模板的一些坑"><a href="#第三步：初始化模板的一些坑" class="headerlink" title="第三步：初始化模板的一些坑"></a>第三步：初始化模板的一些坑</h3><p>当你使用 <code>npm run build</code> 打包好静态文件在 <em>dist</em> 目录后，从文件管理器直接运行，却发现浏览器只有一片空白。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108185531.png" alt="vue 打包出来的文件在浏览器显示的空白页面"></p><p>这是 <code>vue-cli</code> 默认模板的问题，具体原因与解决方案请参考 <a href="https://blog.rxliuli.com/p/7d805fde/">Vue 打包的静态文件不能直接运行</a></p><p>那么，这篇使用 <code>vue-cli</code> 简单的建立项目就到这里啦，希望各位后端开发者都能尝试有趣的现代前端呢 -(๑☆‿ ☆#)ᕗ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 实现更多数组的高阶函数</title>
    <link href="/p/7f5ad4f08965426f87bc7901e174066c/"/>
    <url>/p/7f5ad4f08965426f87bc7901e174066c/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>虽说人人平等，但有些人更加平等。</p></blockquote><p>为什么有了 Lodash 这种通用函数工具库，吾辈要写这篇文章呢？吾辈在 SegmentFault 上经常看到关于 JavaScript 数组的相关疑问，甚至于，相同类型的问题，只是数据变化了一些，就直接提出了一个新的问题（实际上，对自身并无帮助）。简单<a href="https://segmentfault.com/search?q=Array&type=question">搜索了一下 Array</a>，居然有 2360+ 条的结果，足可见这类问题的频率之高。若是有一篇适合 JavaScript 萌新阅读的自己实现数组更多操作的文章，情况或许会发生一些变化。</p><p>下面吾辈便来实现以下几种常见的操作</p><ul><li><code>uniqueBy</code>: 去重</li><li><code>sortBy</code>: 排序</li><li><code>filterItems</code>: 过滤掉一些元素</li><li><code>diffBy</code>: 差异</li><li><code>groupBy</code>: 分组</li><li><code>arrayToMap</code>: Array 转换为 Map</li><li>递归操作</li></ul><blockquote><p>前言:<br>你至少需要了解 ES6 的一些特性你才能愉快的阅读</p></blockquote><h2 id="uniqueBy-去重"><a href="#uniqueBy-去重" class="headerlink" title="uniqueBy: 去重"></a><code>uniqueBy</code>: 去重</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000002674331">javascript 怎么实现多种数据类型的数组去重？</a></li><li><a href="https://segmentfault.com/q/1010000010936175">JS 有没有比较高效的数组去重的方法？</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * js 的数组去重方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 要进行去重的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 唯一标识元素的方法，默认使用 &#123;<span class="hljs-doctag">@link </span>returnItself&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>进行去重操作之后得到的新的数组 (原数组并未改变)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqueBy</span>(<span class="hljs-params">arr, kFn = (val) =&gt; val</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">v, ...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> k = kFn(v, ...args);<br>    <span class="hljs-keyword">if</span> (set.has(k)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    set.add(k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(uniqueBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>])); <span class="hljs-comment">// [ 1, 2, 3, &#x27;1&#x27;, &#x27;2&#x27; ]</span><br><span class="hljs-built_in">console</span>.log(uniqueBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i + <span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// [ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure><h2 id="sortBy-排序"><a href="#sortBy-排序" class="headerlink" title="sortBy: 排序"></a><code>sortBy</code>: 排序</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000014304039">js 中如何对含有特殊字符的数组进行排序？</a></li><li><a href="https://segmentfault.com/q/1010000017141566">以下数组怎么按名称排序</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快速根据指定函数对数组进行排序</span><br><span class="hljs-comment"> * 注: 使用递归实现，对于超大数组（其实前端的数组不可能特别大吧？#笑）可能造成堆栈溢出</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 需要排序的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 对数组中每个元素都产生可比较的值的函数，默认返回自身进行比较</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>排序后的新数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortBy</span>(<span class="hljs-params">arr, kFn = (v) =&gt; v</span>) </span>&#123;<br>  <span class="hljs-comment">// TODO 此处为了让 typedoc 能生成文档而不得不加上类型</span><br>  <span class="hljs-keyword">const</span> newArr = arr.map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> [v, i]);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_sort</span>(<span class="hljs-params">arr, fn</span>) </span>&#123;<br>    <span class="hljs-comment">// 边界条件，如果传入数组的值</span><br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-comment">// 根据中间值对数组分治为两个数组</span><br>    <span class="hljs-keyword">const</span> medianIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> medianValue = arr[medianIndex];<br>    <span class="hljs-keyword">const</span> left = [];<br>    <span class="hljs-keyword">const</span> right = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i === medianIndex) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">const</span> v = arr[i];<br>      <span class="hljs-keyword">if</span> (fn(v, medianValue) &lt;= <span class="hljs-number">0</span>) &#123;<br>        left.push(v);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        right.push(v);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _sort(left, fn).concat([medianValue]).concat(_sort(right, fn));<br>  &#125;<br>  <span class="hljs-keyword">return</span> _sort(newArr, <span class="hljs-function">(<span class="hljs-params">[t1, i1], [t2, i2]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> k1 = kFn(t1, i1, arr);<br>    <span class="hljs-keyword">const</span> k2 = kFn(t2, i2, arr);<br>    <span class="hljs-keyword">if</span> (k1 === k2) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k1 &lt; k2) &#123;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;).map(<span class="hljs-function">(<span class="hljs-params">[_v, i]</span>) =&gt;</span> arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(sortBy([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-built_in">console</span>.log(sortBy([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>])); <span class="hljs-comment">// [ 1, &#x27;2&#x27;, 3, &#x27;4&#x27;, 5 ]</span><br><span class="hljs-built_in">console</span>.log(sortBy([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> -i)); <span class="hljs-comment">// [ 5, &#x27;4&#x27;, 3, &#x27;2&#x27;, 1 ]</span><br></code></pre></td></tr></table></figure><h2 id="filterItems-过滤掉一些元素"><a href="#filterItems-过滤掉一些元素" class="headerlink" title="filterItems: 过滤掉一些元素"></a><code>filterItems</code>: 过滤掉一些元素</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000009045163">过滤数组子集</a></li><li><a href="https://segmentfault.com/q/1010000017464256">对比两组对象数组 根据元素内某一属性是否相等过滤数组</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从数组中移除指定的元素</span><br><span class="hljs-comment"> * 注: 时间复杂度为 1~3On</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 需要被过滤的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>deleteItems 要过滤的元素数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 每个元素的唯一键函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterItems</span>(<span class="hljs-params">arr, deleteItems, kFn = (v) =&gt; v</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> kSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(deleteItems.map(kFn));<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">v, i, arr</span>) =&gt;</span> !kSet.has(kFn(v, i, arr)));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(filterItems([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])); <span class="hljs-comment">// [ 3, 4, 5 ]</span><br><span class="hljs-built_in">console</span>.log(filterItems([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i + <span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// [ 3, 4, 5 ]</span><br></code></pre></td></tr></table></figure><h2 id="diffBy-差异"><a href="#diffBy-差异" class="headerlink" title="diffBy: 差异"></a><code>diffBy</code>: 差异</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000019019878">JS 求两个对象数组的差集</a></li><li><a href="https://segmentfault.com/q/1010000008825206">JavaScript 数组系列问题：数组差集</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 比较两个数组的差异</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>left 第一个数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>right 第二个数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 每个元素的唯一标识产生函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>比较的差异结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffBy</span>(<span class="hljs-params">left, right, kFn = (v) =&gt; v</span>) </span>&#123;<br>  <span class="hljs-comment">// 首先得到两个 kSet 集合用于过滤</span><br>  <span class="hljs-keyword">const</span> kThanSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(left.map(kFn));<br>  <span class="hljs-keyword">const</span> kThatSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(right.map(kFn));<br>  <span class="hljs-keyword">const</span> leftUnique = left.filter(<br>    (v, ...args) =&gt; !kThatSet.has(kFn(v, ...args))<br>  );<br>  <span class="hljs-keyword">const</span> rightUnique = right.filter(<br>    (v, ...args) =&gt; !kThanSet.has(kFn(v, ...args))<br>  );<br>  <span class="hljs-keyword">const</span> kLeftSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(leftUnique.map(kFn));<br>  <span class="hljs-keyword">const</span> common = left.filter(<span class="hljs-function">(<span class="hljs-params">v, ...args</span>) =&gt;</span> !kLeftSet.has(kFn(v, ...args)));<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">left</span>: leftUnique, <span class="hljs-attr">right</span>: rightUnique, common &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(diffBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// &#123; left: [ 1 ], right: [ 4 ], common: [ 2, 3 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(diffBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])); <span class="hljs-comment">// &#123; left: [ 1, 2 ], right: [ &#x27;2&#x27;, 4 ], common: [ 3 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(diffBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i + <span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// &#123; left: [ 1 ], right: [ 4 ], common: [ 2, 3 ] &#125;</span><br></code></pre></td></tr></table></figure><h2 id="groupBy-分组"><a href="#groupBy-分组" class="headerlink" title="groupBy: 分组"></a><code>groupBy</code>: 分组</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000004944432">求一个数组按属性分组的方法</a></li><li><a href="https://segmentfault.com/q/1010000008789413">js 数组分组？</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * js 数组按照某个条件进行分组</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 要进行分组的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 元素分组的唯一标识函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>vFn 元素分组的值处理的函数。第一个参数是累计值，第二个参数是当前正在迭代的元素，如果你使用过 &#123;<span class="hljs-doctag">@link </span>Array#reduce&#125; 函数的话应该对此很熟悉</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>init 每个分组的产生初始值的函数。类似于 reduce 的初始值，但它是一个函数，避免初始值在所有分组中进行累加。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>元素标识 =&gt; 数组映射 Map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupBy</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  arr,</span></span><br><span class="hljs-function"><span class="hljs-params">  kFn = (v) =&gt; v,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-comment">/**</span></span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">   * 默认的值处理函数</span></span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>res 最终 V 集合</span></span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>item 当前迭代的元素</span></span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">   * <span class="hljs-doctag">@returns </span>将当前元素合并后的最终 V 集合</span></span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">   */</span></span></span><br><span class="hljs-function"><span class="hljs-params">  vFn = (res, item) =&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">    res.push(item);</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">return</span> res;</span></span><br><span class="hljs-function"><span class="hljs-params">  &#125;,</span></span><br><span class="hljs-function"><span class="hljs-params">  init = () =&gt; []</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将元素按照分组条件进行分组得到一个 条件 -&gt; 数组 的对象</span><br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, item, index, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> k = kFn(item, index, arr);<br>    <span class="hljs-comment">// 如果已经有这个键了就直接追加, 否则先将之初始化再追加元素</span><br>    <span class="hljs-keyword">if</span> (!res.has(k)) &#123;<br>      res.set(k, init());<br>    &#125;<br>    res.set(k, vFn(res.get(k), item, index, arr));<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(groupBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i)); <span class="hljs-comment">// Map &#123; 1 =&gt; [ 1 ],  2 =&gt; [ 2, 2, 2 ],  4 =&gt; [ 4, 4 ],  5 =&gt; [ 5, 5 ],  6 =&gt; [ 6 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(groupBy([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)); <span class="hljs-comment">// Map &#123; false =&gt; [ 1, 5, 5 ], true =&gt; [ 2, 2, 2, 4, 4, 6 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<br>  groupBy(<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>,<br>    (res, i) =&gt; res.add(i),<br>    () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>  )<br>); <span class="hljs-comment">// Map &#123; false =&gt; Set &#123; 1, 5 &#125;, true =&gt; Set &#123; 2, 4, 6 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="arrayToMap-转换为-Map"><a href="#arrayToMap-转换为-Map" class="headerlink" title="arrayToMap: 转换为 Map"></a><code>arrayToMap</code>: 转换为 Map</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000019537004">js 怎么把数组下面的对象里面的两个字段取出来组成一个新的对象，key:value 形式</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将数组映射为 Map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>k 产生 Map 元素唯一标识的函数，或者对象元素中的一个属性名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>v 产生 Map 值的函数，默认为返回数组的元素，或者对象元素中的一个属性名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>映射产生的 map 集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayToMap</span>(<span class="hljs-params">arr, k, v = (val) =&gt; val</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> kFn = k <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? k : <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">Reflect</span>.get(item, k);<br>  <span class="hljs-keyword">const</span> vFn = v <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> ? v : <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">Reflect</span>.get(item, v);<br>  <span class="hljs-keyword">return</span> arr.reduce(<br>    (res, item, index, arr) =&gt;<br>      res.set(kFn(item, index, arr), vFn(item, index, arr)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> county_list = [<br>  &#123;<br>    id: <span class="hljs-number">1</span>,<br>    code: <span class="hljs-string">&quot;110101&quot;</span>,<br>    name: <span class="hljs-string">&quot;东城区&quot;</span>,<br>    citycode: <span class="hljs-string">&quot;110100&quot;</span>,<br>  &#125;,<br>  &#123;<br>    id: <span class="hljs-number">2</span>,<br>    code: <span class="hljs-string">&quot;110102&quot;</span>,<br>    name: <span class="hljs-string">&quot;西城区&quot;</span>,<br>    citycode: <span class="hljs-string">&quot;110100&quot;</span>,<br>  &#125;,<br>  &#123;<br>    id: <span class="hljs-number">3</span>,<br>    code: <span class="hljs-string">&quot;110103&quot;</span>,<br>    name: <span class="hljs-string">&quot;崇文区&quot;</span>,<br>    citycode: <span class="hljs-string">&quot;110100&quot;</span>,<br>  &#125;,<br>];<br><span class="hljs-built_in">console</span>.log(arrayToMap(county_list, <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// Map &#123; &#x27;110101&#x27; =&gt; &#x27;东城区&#x27;, &#x27;110102&#x27; =&gt; &#x27;西城区&#x27;, &#x27;110103&#x27; =&gt; &#x27;崇文区&#x27; &#125;</span><br><span class="hljs-built_in">console</span>.log(<br>  arrayToMap(<br>    county_list,<br>    (&#123; code &#125;) =&gt; code,<br>    (&#123; name &#125;) =&gt; name<br>  )<br>); <span class="hljs-comment">// Map &#123; &#x27;110101&#x27; =&gt; &#x27;东城区&#x27;, &#x27;110102&#x27; =&gt; &#x27;西城区&#x27;, &#x27;110103&#x27; =&gt; &#x27;崇文区&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>相关问题</p><ul><li><a href="https://segmentfault.com/q/1010000018502694">复杂数组去重</a></li><li><a href="https://segmentfault.com/q/1010000000444289">JavaScript 数组中包含数组如何去重？</a></li></ul><p>以上种种操作皆是对一层数组进行操作，如果我们想对嵌套数组进行操作呢？例如上面这两个问题？其实问题是类似的，只是递归遍历数组而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * js 的数组递归去重方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>arr 要进行去重的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>kFn 唯一标识元素的方法，默认使用 &#123;<span class="hljs-doctag">@link </span>returnItself&#125;，只对非数组元素生效</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>进行去重操作之后得到的新的数组 (原数组并未改变)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepUniqueBy</span>(<span class="hljs-params">arr, kFn = (val) =&gt; val</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, v, i, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) &#123;<br>      res.push(deepUniqueBy(v));<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">const</span> k = kFn(v, i, arr);<br>    <span class="hljs-keyword">if</span> (!set.has(k)) &#123;<br>      set.add(k);<br>      res.push(v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> testArr = [<br>  <span class="hljs-number">1</span>,<br>  <span class="hljs-number">1</span>,<br>  <span class="hljs-number">3</span>,<br>  <span class="hljs-string">&quot;hello&quot;</span>,<br>  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>]]],<br>  &#123;<br>    key: <span class="hljs-string">&quot;test&quot;</span>,<br>  &#125;,<br>  <span class="hljs-number">4</span>,<br>  [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>];<br><span class="hljs-built_in">console</span>.log(deepUniqueBy(testArr)); <span class="hljs-comment">// [ 1,  3,  &#x27;hello&#x27;,  [ 3, 4, &#x27;hello&#x27;, &#x27;5&#x27;, [ 5, [Object] ] ],  &#123; key: &#x27;test&#x27; &#125;,  4,  [ 3, 0, 2 ] ]</span><br></code></pre></td></tr></table></figure><h2 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h2><p>事实上，目前 SegmentFault 上存在着大量低质量且重复的问题及回答，关于这点确实比不上 StackOverflow。下面是两个例子，可以看一下能否发现什么问题</p><ul><li><a href="https://segmentfault.com/q/1010000019537004">js 怎么把数组下面的对象里面的两个字段取出来组成一个新的对象，key:value 形式</a></li><li><a href="https://segmentfault.com/q/1010000017490985">JS 中处理 JSON 数据重复问题，取出里面 name 字段数值相同的作为一个数组；不相同的作为一个数组？</a></li></ul><p>事实上，不管是问题还是答案，都没有突出核心 – <strong>Array 映射为 Map/Array 分组</strong>，而且这种问题和答案还层出不穷。如果对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">Array 的 API</a> 都没有看过一遍就来询问的话，对于帮助者来说却是太失礼了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 对函数式编程支持很好，所以习惯高阶函数于我们而言是一件好事，将问题的本质抽离出来，而不是每次都局限于某个具体的问题上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FlexBox 布局入门</title>
    <link href="/p/83aeb3c35adf4517b0e4e7643c2f7517/"/>
    <url>/p/83aeb3c35adf4517b0e4e7643c2f7517/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近刚看了 flexbox，之前一直用的 UI 框架写前端，吾辈可能是个假的前端开发（好吧，其实之前吾辈前后端都写，写得最多的是 JS/TS 就是了），所以写一篇记录便于复习知识。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>不谈需求讲功能就是扯淡，所以吾辈先来说一下吾辈使用 <code>flex</code> 的主要场景吧</p><ul><li>水平布局: 导航栏，多栏展示，媒体元素</li><li>水平垂直居中: 这在 flex 之前使用 CSS 很难实现</li><li>避免使用浮动，行内块元素，表格进行布局</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h3><p>使用 <code>flex</code> 可以轻而易举地实现栅格系统，这里的最下面还实现了一个常见的侧边菜单两栏布局。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916121534.png" alt="栅格系统"></p><p>实现代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>flex 水平布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      * &#123;<br>        margin: 0;<br>        padding: 0;<br>        box-sizing: border-box;<br>      &#125;<br><br><span class="css">      <span class="hljs-comment">/* #region 12 栅格布局 */</span></span><br><br><span class="css">      <span class="hljs-selector-class">.row</span> &#123;</span><br>        display: flex;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col</span> &#123;</span><br>        flex: 1;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-1</span> &#123;</span><br>        flex: 1;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-2</span> &#123;</span><br>        flex: 2;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-3</span> &#123;</span><br>        flex: 3;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-4</span> &#123;</span><br>        flex: 4;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-5</span> &#123;</span><br>        flex: 5;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-6</span> &#123;</span><br>        flex: 6;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-7</span> &#123;</span><br>        flex: 7;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-8</span> &#123;</span><br>        flex: 8;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-9</span> &#123;</span><br>        flex: 9;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-10</span> &#123;</span><br>        flex: 10;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-11</span> &#123;</span><br>        flex: 11;<br>      &#125;<br><span class="css">      <span class="hljs-selector-class">.col-12</span> &#123;</span><br>        flex: 12;<br>      &#125;<br><br><span class="css">      <span class="hljs-comment">/* #endregion */</span></span><br><br><span class="css">      <span class="hljs-selector-class">.col</span> &#123;</span><br>        min-width: 50px;<br><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#00ffff</span>;</span><br><span class="css">        <span class="hljs-selector-tag">border</span>: <span class="hljs-selector-tag">solid</span> 2<span class="hljs-selector-tag">px</span> <span class="hljs-selector-id">#ffffff</span>;</span><br>        text-align: center;<br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.side-menu</span> &#123;</span><br>        max-width: 250px;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-1&quot;</span>&gt;</span>col-1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-2&quot;</span>&gt;</span>col-2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-3&quot;</span>&gt;</span>col-3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-3&quot;</span>&gt;</span>col-3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-3&quot;</span>&gt;</span>col-3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-3&quot;</span>&gt;</span>col-3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-4&quot;</span>&gt;</span>col-4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-4&quot;</span>&gt;</span>col-4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-4&quot;</span>&gt;</span>col-4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-6&quot;</span>&gt;</span>col-6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-6&quot;</span>&gt;</span>col-6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-12&quot;</span>&gt;</span>col-12<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 侧边菜单栏 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-3 side-menu&quot;</span>&gt;</span>col-3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col col-9&quot;</span>&gt;</span>col-9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>在此 flex 出现之前，想要盒子水平垂直居中是一件比较困难的一件事，但至此之后，便再也不足为道了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916121734.png" alt="水平垂直居中"></p><p>实现代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>使用 flex 实现水平垂直居中<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      html,<br>      body,<br><span class="css">      <span class="hljs-selector-class">.flex-container</span> &#123;</span><br>        height: 100%;<br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.flex-container</span> &#123;</span><br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#2c3e50</span>;</span><br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.flex-item</span> &#123;</span><br>        width: 40rem;<br><br><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#ffffff</span>;</span><br>        padding: 2rem;<br><span class="css">        <span class="hljs-selector-tag">box-shadow</span>: 0 0 0.5<span class="hljs-selector-tag">rem</span> <span class="hljs-selector-id">#ffffff</span>;</span><br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>内境逾宽、外延逾窄<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>          我和麻省理工学院的一些博士生谈论过各种浏览器的好坏，他们不和你谈微软的<br>          IE 或者 Mozilla 的火狐，而是 Unix 用户更常用的字处理器 Emacs<br>          下一个很小的浏览网页的功能，这个东西不仅不好用，而且在全世界用它的网民连万分之一都不到。他们和你谈的是里面技术上谁实现的好。这些人以后可以是很好的科学家和工程师，但是很难创业。<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="对比浮动、行内盒子、表格布局"><a href="#对比浮动、行内盒子、表格布局" class="headerlink" title="对比浮动、行内盒子、表格布局"></a>对比浮动、行内盒子、表格布局</h2><ul><li>浮动布局: 浏览器很早就实现的一种布局方式，但浮动之后的元素脱离了标准文档流，必须特别注意清除浮动。并且，浮动也无法提供足够的布局能力，常常需要一些 hack 技巧。最后，浮动布局本身也不是为了布局而设计，浮动最适合的场景莫过于实现媒体元素的文字环绕。</li><li>行内盒子: 基本没有提供布局能力</li><li>表格布局: 实现的非常早的二维布局方式，在 Web 早期很多网站喜欢使用它进行布局，正是因为它的二维布局可以简单实现一些常规布局。但终究它的布局能力还是不足的，CSS3 中实现了更好的 <code>Grid Layout</code> 作为二维布局方式。</li><li><code>Grid Layout</code>: 理论上来说，能够进行二维布局的 Grid 肯定比只能一维布局的 Flex 更适合整体布局，但现实因素往往使之并不能理想化。就目前而言，Grid 的实现并不完整，当然，最新版的 Chrome/Firefox 肯定是可以的了，但 Safari/Edge 肯定还是有坑的！</li></ul><p>下面实现一个标签列表，以此便可以看出 Flex 的强大功用</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916122712.png" alt="标签列表"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>使用 flex 实现标签组<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">      <span class="hljs-selector-class">.tags</span> &#123;</span><br><span class="css">        <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#c9e1f4</span>;</span><br>        padding: 1rem;<br>        display: flex;<br>        flex-wrap: wrap;<br><span class="css">        <span class="hljs-comment">/*min-height: 500px;*/</span></span><br><span class="css">        <span class="hljs-comment">/*align-content: space-around;*/</span></span><br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.tags</span> <span class="hljs-selector-tag">li</span> &#123;</span><br>        display: inline-block;<br>        margin: 0.5rem;<br>        flex: 1 0 auto;<br>        max-width: 10rem;<br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.tags</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;</span><br>        position: relative;<br>        display: block;<br>        padding: 0.25rem 0.5rem 0.25rem 0.5rem;<br><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#c9e1f4</span>;</span><br><span class="css">        <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#28448f</span>;</span><br>        border-radius: 0 0.25rem 0.25rem 0;<br>        line-height: 1.5;<br>        text-decoration: none;<br>        text-align: center;<br>      &#125;<br><br><span class="css">      <span class="hljs-selector-class">.tags</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">::before</span> &#123;</span><br>        content: &quot; &quot;;<br>        position: absolute;<br>        width: 0;<br>        height: 0;<br>        border: 1rem solid transparent;<br>        border-right-width: 0.5rem;<br><span class="css">        <span class="hljs-selector-tag">border-right-color</span>: <span class="hljs-selector-id">#c9e1f4</span>;</span><br>        left: -1.5rem;<br>        top: 0;<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tags&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Android<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Chrome<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Cmder<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>DB<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>FTP<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>FreeNetwork<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Git<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Gradle<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Greasemonkey<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>IDEA<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Linux<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Markdown<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Maven<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MongoDB<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MonngoDB<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>MySQL<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>NodeJS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Prettier<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Promise<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>React<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Spring<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Tool<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>TypeScript<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>VSCode<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>VueJS<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Vuetify<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Web<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>blog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>jsdoc<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>mobile<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>npm<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>工具<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>教程<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>文章<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>杂谈<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>记录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>读书<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>随笔<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在传统项目中使用 babel 编译 ES6</title>
    <link href="/p/8683190d5e2f4c5d85aba3b67ede2c75/"/>
    <url>/p/8683190d5e2f4c5d85aba3b67ede2c75/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>曾经吾辈以为 ES6 早已推广开来，然而事实上远比想象中更加复杂。传统后台的项目就是要兼容性，兼容 2 年前的浏览器，没有 babel，全程 jQuery 一把梭做到底。</p></blockquote><p>之前的项目基本上都是前后端分离的模式，最近新公司的项目却是使用的传统的模板视图的模式。<br>所以，一些东西发生了变化</p><ul><li><code>thymeleaf</code> 模板里面直接有 Java 的代码，在服务端直接编译 html 代码而非是纯粹的 API 交互</li><li>使用最多的库是 <code>jquery</code>，主要用于操作 <code>dom</code></li><li>没有现代前端工具链 <code>nodejs/npm/webpack/babel/vuejs</code></li></ul><p>所以吾辈使用 ES6 的语法就被同事诟病语法太新（还有人连 ES5 的语法都没能完全掌握），浏览器无法正常显示，所以吾辈只能尝试用 babel 来做兼容。众所周知，自 babel6 以来，模块化大行其道，由原先的使用浏览器引入脚本的方式修改为由 npm 等包管理器引入，官方也不推荐使用浏览器引入的方式。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>幸好吾辈找到了一个项目 <a href="https://github.com/babel/babel-standalone">babel-standalone</a>，它提供了从浏览器中引入 babel 的功能。</p><p>使用方式很简单，只要在你含有 ES6 代码的脚本之前引入，在含有 ES6 代码的 script 标签上加上 <code>text/babel</code> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br><span class="hljs-keyword">const</span> getMessage = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;output&#x27;</span>).innerHTML = getMessage();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>以上，官方是这么说的，然而实际上，吾辈还是遇到了一些问题</p><ol><li> 使用 <code>&lt;script type=&quot;text/babel&quot;&gt;</code> 标记需要编译确实很方便，然而 babel 的编译过程是异步的，所以如果想要在后面的脚本中使用这个脚本中的内容则是不可能的</li><li> 某些语法仍然不能支持，例如 <code>function*</code> 生成器</li><li> 不能直接使用未声明的变量</li><li> 默认没有编译为 ES5</li></ol><p>这些问题我们下面一一解决</p><h3 id="异步编译"><a href="#异步编译" class="headerlink" title="异步编译"></a>异步编译</h3><p>例如有下面三个文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/common.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// common.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br>wait(<span class="hljs-number">3000</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#root&quot;</span>).innerHTML = <span class="hljs-string">&quot;等待 3s 结束&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们会得到一个错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Uncaught <span class="hljs-built_in">ReferenceError</span>: wait is not defined<br></code></pre></td></tr></table></figure><p>为什么会这样呢？原因就是加载 common.js 之后实际上还需要被 babel 编译，然而这并非同步操作，所以我们之后的脚本就无法取得全局函数 <code>wait()</code>。那么，如何解决呢？</p><p>我们可以将所有的 <code>script</code> 标签都加上 <code>type=&quot;text/babel&quot;</code>，所有的 script 脚本都是需要编译的，那么就不会有异步的编译的问题了。</p><h3 id="babel-没有完全支持"><a href="#babel-没有完全支持" class="headerlink" title="babel 没有完全支持"></a>babel 没有完全支持</h3><p>例如在 <code>common.js</code> 中添加一个函数 <code>indexGenerator()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成一个索引序列，从 0 开始，每次递增为 1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Generator&#125;</span> </span>一个生成器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">indexGenerator</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但我们只会得到一个错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Uncaught <span class="hljs-built_in">ReferenceError</span>: regeneratorRuntime is not defined<br></code></pre></td></tr></table></figure><p>这是因为 babel 基础包并没有实现所有的 ES6 的特性，所以就会出现不支持的情况。我们需要拓展包 <code>babel-polyfill</code>，在 <code>babel-standalone</code> 下引入即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.2.5/polyfill.min.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="不能使用未声明变量"><a href="#不能使用未声明变量" class="headerlink" title="不能使用未声明变量"></a>不能使用未声明变量</h3><p>如果我们在标记为需要编译的 script 脚本中使用了未定义的变量，就会出现错误。例如在 <code>index.js</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">username = <span class="hljs-string">&quot;rxliuli&quot;</span>;<br></code></pre></td></tr></table></figure><p>错误消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Uncaught (<span class="hljs-keyword">in</span> promise) <span class="hljs-built_in">ReferenceError</span>: username is not defined<br></code></pre></td></tr></table></figure><p>所以说编程规范很重要啦</p><h3 id="默认不支持-ES7"><a href="#默认不支持-ES7" class="headerlink" title="默认不支持 ES7"></a>默认不支持 ES7</h3><p>是的，babel 默认是不支持 ES7 的，而 <code>async/await</code> 便属于 ES7 的内容。例如我们修改 <code>index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">3000</span>);<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#root&quot;</span>).innerHTML = <span class="hljs-string">&quot;等待 3s 结束&quot;</span>;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>错误消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Uncaught <span class="hljs-built_in">SyntaxError</span>: Unexpected token <span class="hljs-function"><span class="hljs-keyword">function</span></span><br></code></pre></td></tr></table></figure><p>我们可以使用 <code>data-presets=&quot;latest&quot;</code> 来修复这个问题，永远引入最新版的 <code>presets</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span> src=<span class="hljs-string">&quot;./js/common.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script<br>  type=<span class="hljs-string">&quot;text/babel&quot;</span><br>  data-presets=<span class="hljs-string">&quot;latest&quot;</span><br>  src=<span class="hljs-string">&quot;./js/index.js&quot;</span><br>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="thymeleaf-不能使用模板字符串-HTML"><a href="#thymeleaf-不能使用模板字符串-HTML" class="headerlink" title="thymeleaf 不能使用模板字符串 HTML"></a>thymeleaf 不能使用模板字符串 HTML</h3><p>同时使用 <code>type=&quot;text/babel&quot; data-presets=&quot;latest&quot;</code> 和 <code>th:inline=&quot;javascript&quot;</code> 的时候，thymeleaf 将无法解析 <code>&lt;a href=&quot;#&quot;/&gt;</code> 含有 HTML 的模板字符串。</p><p>使用环境</p><ul><li>spring-boot 2.0.3.RELEASE</li><li>babel 6.26.0</li><li>babel-polyfill 2.6.1</li></ul><p>例如下面这种代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span> <span class="hljs-attr">data-presets</span>=<span class="hljs-string">&quot;latest&quot;</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">const</span> htmlStr = <span class="hljs-string">`&lt;a href=&quot;#&quot;/&gt;`</span>;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`htmlStr: <span class="hljs-subst">$&#123;htmlStr&#125;</span>`</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>甚至于注释了也没用，只能删除掉才可以</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span> <span class="hljs-attr">data-presets</span>=<span class="hljs-string">&quot;latest&quot;</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">// const htmlStr = `&lt;a href=&quot;#&quot;/&gt;`</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`htmlStr: <span class="hljs-subst">$&#123;htmlStr&#125;</span>`</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>目前的解决方案是分成两个 <code>script</code> 标签，分别使用 <code>type=&quot;text/babel&quot; data-presets=&quot;latest&quot;</code> 和 <code>th:inline=&quot;javascript&quot;</code> 标签</p><h3 id="不能使用浏览器较新的-API"><a href="#不能使用浏览器较新的-API" class="headerlink" title="不能使用浏览器较新的 API"></a>不能使用浏览器较新的 API</h3><p>使用一些浏览器较新的 API 时发现不能正常使用，<code>babel-core</code> 也没有实现。例如吾辈想要使用 <code>NodeList.forEach</code> 遍历 <code>a</code> 标签列表，然后打印出来他们的链接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;a&quot;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(el.href));<br></code></pre></td></tr></table></figure><p>会得到错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Uncaught <span class="hljs-built_in">TypeError</span>: <span class="hljs-built_in">document</span>.querySelectorAll(...).forEach is not a <span class="hljs-function"><span class="hljs-keyword">function</span></span><br></code></pre></td></tr></table></figure><p>在旧版浏览器中，<code>NodeList</code> 并没有 <code>forEach</code> 方法，后来，吾辈找到了另一个库 <a href="https://github.com/zloirock/core-js">core-js</a>，其最新版 <code>3.x beta</code> 实现了 <code>NodeList.forEach</code> API，唯一的缺点是我们要手动构建才行。</p><p>引入也很简单，只要在 <code>babel-standalone</code> 之后，<code>babel-polyfill</code> 之前使用 <code>script</code> 标签引入就好了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/core-js-bundle@3.0.0-beta.8/index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>好了，下面我们可以愉快的使用新的浏览器 API 了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，有关在传统项目中使用 babel 编译 ES6/ES7 的问题就到这里了，希望有更多的人使用这些新特性，让我们早日抛弃掉 babel 吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 激活</title>
    <link href="/p/94b435abfa5847a39a95b4f4fc180a1a/"/>
    <url>/p/94b435abfa5847a39a95b4f4fc180a1a/</url>
    
    <content type="html"><![CDATA[<h2 id="使用本地注册码（不需要在线）的方式激活"><a href="#使用本地注册码（不需要在线）的方式激活" class="headerlink" title="使用本地注册码（不需要在线）的方式激活"></a>使用本地注册码（不需要在线）的方式激活</h2><blockquote><p>注: 此方法对 IDEA 2018.01-2018.02 版本无效，但对 IDEA 2018.03 EAP 是有效的</p></blockquote><ol><li><p>修改 <strong>hosts</strong> 文件，Windows 系统上的位置是 <strong>C:\Windows\System32\drivers\etc\hosts</strong>，将之复制到其他位置并在文件的最末尾添加一句话。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hosts">0.0.0.0 account.jetbrains.com<br></code></pre></td></tr></table></figure><p> 然后将 <strong>hosts</strong> 文件复制到原本的位置覆盖一下就好。</p><blockquote><p>注：该操作是必要的，因为不修改 <strong>hosts</strong> 文件的话获得的激活码是会直接提示非法的！</p></blockquote></li><li><p> 在 <a href="http://idea.iteblog.com/">http://idea.iteblog.com/</a> 获得到一个注册码（用户名和 PC 用户名保持一致），将注册码用于激活 IDEA 即可。</p></li></ol><h2 id="使用本地-Jar-文件"><a href="#使用本地-Jar-文件" class="headerlink" title="使用本地 Jar 文件"></a>使用本地 Jar 文件</h2><blockquote><p>注：该方法适用于 IDEA 2018.01-2018.02，在 IDEA 2018.03 已经失效</p></blockquote><ol><li><p>下载破解 Jar：<a href="https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar">JetbrainsCrack</a></p><p> 然后放到一个合适的位置（你不会随意删除的位置，推荐直接放到 IDEA 的安装目录下）</p></li><li><p>修改 IDEA 的一个配置文件（位置在 <code>$&#123;idea.home&#125;/bin/idea64.exe.vmoptions</code>），在最后一行添加：<code>-javaagent:这里是你上面下载的那个 Jar 的绝对路径</code></p><p> 然后在激活对话框中选 <strong>Activation code</strong> 随意输入然后点击 OK 即可。</p></li><li><p>Pass：其实下面还有一步的，不过做不做都可以，运行上面的就已经完成激活了，不过激活信息显示的不是你的名字。当然，我们可以去变成自己的名字，如果我们在 <strong>Activation code</strong> 里填写合适的 <code>json</code> 信息的话。</p><ol><li><p>首先运行刚才下载的 Jar，然后会得到一个激活信息的 <code>json</code> 字符串，大致是下面这样：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;licenseId&quot;</span>: <span class="hljs-string">&quot;ThisCrackLicenseId&quot;</span>,<br>  <span class="hljs-attr">&quot;licenseeName&quot;</span>: <span class="hljs-string">&quot;Rover12421&quot;</span>,<br>  <span class="hljs-attr">&quot;assigneeName&quot;</span>: <span class="hljs-string">&quot;Rover12421&quot;</span>,<br>  <span class="hljs-attr">&quot;assigneeEmail&quot;</span>: <span class="hljs-string">&quot;rover12421@163.com&quot;</span>,<br>  <span class="hljs-attr">&quot;licenseRestriction&quot;</span>: <span class="hljs-string">&quot;By Rover12421 Crack, Only Test! Please support genuine!!!&quot;</span>,<br>  <span class="hljs-attr">&quot;checkConcurrentUse&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;products&quot;</span>: [<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;II&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;DM&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;AC&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;RS0&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;WS&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;DPN&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;RC&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;PS&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;DC&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;RM&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;CL&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;PC&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;DB&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;GO&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;,<br>    &#123; <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-string">&quot;RD&quot;</span>, <span class="hljs-attr">&quot;paidUpTo&quot;</span>: <span class="hljs-string">&quot;2099-12-31&quot;</span> &#125;<br>  ],<br>  <span class="hljs-attr">&quot;hash&quot;</span>: <span class="hljs-string">&quot;2911276/0&quot;</span>,<br>  <span class="hljs-attr">&quot;gracePeriodDays&quot;</span>: <span class="hljs-number">7</span>,<br>  <span class="hljs-attr">&quot;autoProlongated&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 修改其中的 <code>licenseeName</code>, <code>assigneeName</code>, <code>assigneeEmail</code> 为你的名字和邮箱，然后将修改后的 <code>json</code> 字符串丢到 <strong>Activation code</strong> 里面就好啦</p></li></ol></li></ol><h2 id="IDEA-激活服务器"><a href="#IDEA-激活服务器" class="headerlink" title="IDEA 激活服务器"></a>IDEA 激活服务器</h2><blockquote><p>注: 此方法随时可能失效</p></blockquote><ul><li>激活服务器：<a href="http://idea.imsxm.com/">http://idea.imsxm.com/</a>，<a href="http://idea.uri.ci/">http://idea.uri.ci</a></li><li>如果无法激活，请前往 <a href="http://idea.imsxm.com/">网站</a> 查找方法。如有能力，请支持正版！</li></ul><p>使用方法</p><ul><li>在 idea 首次使用时会要求输入注册码，选择第三个选项卡，即 <strong>License Server</strong>,然后填入上面的激活服务器即可。</li><li>进入 idea 后，选择 Help-&gt;Register,就会弹出一个输入注册码的窗口了，以上面那种方法输入就行啦。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git 设置和取消代理</title>
    <link href="/p/96f6991283754dc0acbd11633481fb5e/"/>
    <url>/p/96f6991283754dc0acbd11633481fb5e/</url>
    
    <content type="html"><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;http://127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;http://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：此处设置的代理 ip 和端口号都是本地存在的（<strong>SS/SSR</strong> 默认就是）。</p></blockquote><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><h2 id="Git-全局配置文件位置"><a href="#Git-全局配置文件位置" class="headerlink" title="Git 全局配置文件位置"></a>Git 全局配置文件位置</h2><p>根配置文件 <code>/etc/gitconfig</code></p><blockquote><p>Windows 的话在 Git 安装目录下 <code>/mingw64/etc/gitconfig</code>，不过最好不要动这个<br>当前用户 Git 配置 <code>~/.gitconfig</code></p></blockquote><p>在配置文件里面添加以下内容也可以添加代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">[https]<br>        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080<br>[http]<br>        proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080<br></code></pre></td></tr></table></figure><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>设置了代理之后很容易碰到一个问题：<a href="https://blog.rxliuli.com/p/c6b28b5a/">Git Push 提示不支持具有 Socks5 方案的代理</a></p><blockquote><p>具体 Git 相关的内容建议参考 <a href="https://git-scm.com/book/zh/v2">Pro Git</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Yarn link 链接本地项目</title>
    <link href="/p/9a7be4762ed2447eae5198f2f6686d95/"/>
    <url>/p/9a7be4762ed2447eae5198f2f6686d95/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>作为 JavaScript SDK 的开发者一定都知道，想要在未发布前进行测试整个包可谓是困难重重。而 <code>yarn link</code> 这个命令便是为了解决这个需求而产生的，它能让包引用并测试自身，即便包并未发布或不包含在 <code>package.json</code> 中亦然。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><blockquote><p><a href="https://www.notion.so/rxliuli/Yarn-link-45007161bbfd43b2beffac88a0bc69b0#396f98a450c445f29e6fff69202654f0">官网链接</a></p></blockquote><h3 id="链接包"><a href="#链接包" class="headerlink" title="链接包"></a>链接包</h3><p>在命令行运行即可将当前包链接安装到这个包中，即便你在 <code>package.json</code> 并不会找到显式的依赖。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn link &amp;&amp; yarn link <span class="hljs-string">&quot;&lt;package.json 中的 name 字段&gt;&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：如果当前包是 <code>cli</code>，即 <code>package.json</code> 中包含 <code>bin</code> 字段，则还会被链接到 yarn 的全局脚本目录中。<br>yarn 的全局脚本目录可以通过执行 <code>yarn global bin</code> 进行查看，如果要在全局执行，则需要将该目录设置到环境变量 <code>Path</code> 中，然后就可以全局运行命令了。</p></blockquote><p>然后，便可以在项目中使用了（测试）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">import &lt;pkgName&gt; from <span class="hljs-string">&#x27;pkgName&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="取消链接"><a href="#取消链接" class="headerlink" title="取消链接"></a>取消链接</h3><p>如果不需要了，则也可以轻易通过 <code>unlink</code> 移除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn unlink <span class="hljs-string">&quot;&lt;package.json 中的 name 字段&gt;&quot;</span> &amp;&amp; yarn unlink<br></code></pre></td></tr></table></figure><blockquote><p>注：同样的，如果当前包是 <code>cli</code>，则 yarn 全局 <code>bin</code> 目录中也会进行删除</p></blockquote><h3 id="通用-script"><a href="#通用-script" class="headerlink" title="通用 script"></a>通用 script</h3><p>每个项目都这样太麻烦了，可否添加一个通用 <code>script</code> 脚本呢？</p><p>当然是可以的，通过 <code>%npm_package_name%</code> 我们便能在 <code>srcipt</code> 中访问到项目名</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;link:add&quot;: &quot;yarn link &amp;&amp; yarn link %npm_package_name%&quot;,<br>  &quot;link:remove&quot;: &quot;yarn unlink %npm_package_name% &amp;&amp; yarn unlink&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://docs.npmjs.com/misc/scripts#packagejson-vars">https://docs.npmjs.com/misc/scripts#packagejson-vars</a></p></blockquote><p>以后便可以直接将命令复制到 <code>script</code> 即可直接使用了。</p><blockquote><p>注：使用 <code>%%</code> 包裹便能在 <code>script</code> 中使用，该方式在 Windows 下生效，Linux 下似乎需要添加前缀 <code>$</code>，不过吾辈并未测试（懒得折腾 Linux 桌面了）。<br>然而，问题并非不存在了，例如本地使用 Windows 构建，然而远程 CI 使用 Linux，那这个脚本就要炸了。。。所以，如果你需要上 CI 的话，还是老实改名字吧。<br>或者也可以使用 <strong>VSCode + WSL</strong>？#笑</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 防抖和节流</title>
    <link href="/p/9aea4154a79043e4a5eb8f0a3d8dd4dc/"/>
    <url>/p/9aea4154a79043e4a5eb8f0a3d8dd4dc/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>网络上已经存在了大量的有关 <strong>防抖</strong> 和 <strong>节流</strong> 的文章，为何吾辈还要再写一篇呢？事实上，防抖和节流，吾辈在使用中发现了一些奇怪的问题，并经过了数次的修改，这里主要分享一下吾辈遇到的问题以及是如何解决的。</p><h3 id="为什么要用防抖和节流？"><a href="#为什么要用防抖和节流？" class="headerlink" title="为什么要用防抖和节流？"></a>为什么要用防抖和节流？</h3><p>因为某些函数触发/调用的频率过快，吾辈需要手动去限制其执行的频率。例如常见的监听滚动条的事件，如果没有防抖处理的话，并且，每次函数执行花费的时间超过了触发的间隔时间的话 – 页面就会卡顿。</p><h2 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h2><h3 id="初始实现"><a href="#初始实现" class="headerlink" title="初始实现"></a>初始实现</h3><p>我们先实现一个简单的去抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">delay, action</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tId;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (tId) <span class="hljs-built_in">clearTimeout</span>(tId);<br>    tId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      action(...args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 Promise 简单封装 setTimeout，下同</span><br><span class="hljs-keyword">const</span> wait = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> add = <span class="hljs-function">() =&gt;</span> ++num;<br><br>  add();<br>  add();<br>  <span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">// 2</span><br><br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, add);<br>  fn();<br>  fn();<br>  <span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  <span class="hljs-built_in">console</span>.log(num); <span class="hljs-comment">// 3</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>好了，看来基本的效果是实现了的。包装过的函数 <code>fn</code> 调用了两次，却并没有立刻执行，而是等待时间间隔过去之后才最终执行了一次。</p><h3 id="this-怎么办？"><a href="#this-怎么办？" class="headerlink" title="this 怎么办？"></a>this 怎么办？</h3><p>然而，上面的实现有一个致命的问题，没有处理 <code>this</code>！当你用在原生的事件处理时或许还不觉得，然而，当你使用了 ES6 <code>class</code> 这类对 <code>this</code> 敏感的代码时，就一定会遇到 <code>this</code> 带来的问题。</p><p>例如下面使用 <code>class</code> 来声明一个计数器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可能想在 <code>constructor</code> 中添加新的属性 <code>fn</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.fn = debounce(<span class="hljs-number">10</span>, <span class="hljs-built_in">this</span>.add);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但很遗憾，这里的 <code>this</code> 绑定是有问题的，执行以下代码试试看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();<br>counter.fn(); <span class="hljs-comment">// Cannot read property &#x27;i&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>会抛出异常 <code>Cannot read property &#39;i&#39; of undefined</code>，究其原因就是 <code>this</code> 没有绑定，我们可以手动绑定 this <code>.bind(this)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.fn = debounce(<span class="hljs-number">10</span>, <span class="hljs-built_in">this</span>.add.bind(<span class="hljs-built_in">this</span>));<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.i++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但更好的方式是修改 <code>debounce</code>，使其能够自动绑定 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">delay, action</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tId;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (tId) <span class="hljs-built_in">clearTimeout</span>(tId);<br>    tId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      action.apply(<span class="hljs-built_in">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，代码将如同预期的运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.i = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">this</span>.fn = debounce(<span class="hljs-number">10</span>, <span class="hljs-built_in">this</span>.add);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.i++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();<br>  counter.add();<br>  counter.add();<br>  <span class="hljs-built_in">console</span>.log(counter.i); <span class="hljs-comment">// 2</span><br><br>  counter.fn();<br>  counter.fn();<br>  <span class="hljs-built_in">console</span>.log(counter.i); <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  <span class="hljs-built_in">console</span>.log(counter.i); <span class="hljs-comment">// 3</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="返回值呢？"><a href="#返回值呢？" class="headerlink" title="返回值呢？"></a>返回值呢？</h3><p>不知道你有没有发现，现在使用 <code>debounce</code> 包装的函数都没有返回值，是完全只有副作用的函数。然而，吾辈还是遇到了需要返回值的场景。<br>例如：<em>输入停止后，使用 Ajax 请求后台数据判断是否已存在相同的数据。</em></p><p>修改 <code>debounce</code> 成会缓存上一次执行结果并且有初始结果参数的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">delay, action, init = <span class="hljs-literal">undefined</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> flag;<br>  <span class="hljs-keyword">let</span> result = init;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">clearTimeout</span>(flag);<br>    flag = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      result = action.apply(<span class="hljs-built_in">this</span>, args);<br>    &#125;, delay);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用代码变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.i = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">this</span>.fn = debounce(<span class="hljs-number">10</span>, <span class="hljs-built_in">this</span>.add, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> ++<span class="hljs-built_in">this</span>.i;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();<br><br>  <span class="hljs-built_in">console</span>.log(counter.add()); <span class="hljs-comment">// 1</span><br>  <span class="hljs-built_in">console</span>.log(counter.add()); <span class="hljs-comment">// 2</span><br><br>  <span class="hljs-built_in">console</span>.log(counter.fn()); <span class="hljs-comment">// 0</span><br>  <span class="hljs-built_in">console</span>.log(counter.fn()); <span class="hljs-comment">// 0</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  <span class="hljs-built_in">console</span>.log(counter.fn()); <span class="hljs-comment">// 3</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>看起来很完美？然而，没有考虑到异步函数是个大失败！</p><p>尝试以下测试代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, get, <span class="hljs-number">0</span>);<br>  fn(<span class="hljs-number">3</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// fn(...).then is not a function</span><br>  fn(<span class="hljs-number">4</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i));<br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  fn(<span class="hljs-number">5</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i));<br>&#125;)();<br></code></pre></td></tr></table></figure><p>会抛出异常 <code>fn(...).then is not a function</code>，因为我们包装过后的函数是同步的，第一次返回的值并不是 <code>Promise</code> 类型。</p><p>除非我们修改默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">2</span>));<br>  <span class="hljs-comment">// 注意，修改默认值为 Promise</span><br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, get, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> resolve(<span class="hljs-number">0</span>)));<br>  fn(<span class="hljs-number">3</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 0</span><br>  fn(<span class="hljs-number">4</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 0</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  fn(<span class="hljs-number">5</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 4</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="支持有返回值的异步函数"><a href="#支持有返回值的异步函数" class="headerlink" title="支持有返回值的异步函数"></a>支持有返回值的异步函数</h3><p>支持异步有两种思路</p><ol><li> 将异步函数包装为同步函数</li><li> 将包装后的函数异步化</li></ol><p>第一种思路实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">delay, action, init = <span class="hljs-literal">undefined</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> flag;<br>  <span class="hljs-keyword">let</span> result = init;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">clearTimeout</span>(flag);<br>    flag = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> temp = action.apply(<span class="hljs-built_in">this</span>, args);<br>      <span class="hljs-keyword">if</span> (temp <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>        temp.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> (result = res));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = temp;<br>      &#125;<br>    &#125;, delay);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方式和同步函数完全一样，当然，是支持异步函数的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">2</span>));<br>  <span class="hljs-comment">// 注意，修改默认值为 Promise</span><br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, get, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 0</span><br>  <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 0</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 4</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>第二种思路实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">delay, action, init = <span class="hljs-literal">undefined</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> flag;<br>  <span class="hljs-keyword">let</span> result = init;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">clearTimeout</span>(flag);<br>      flag = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        result = action.apply(<span class="hljs-built_in">this</span>, args);<br>        resolve(result);<br>      &#125;, delay);<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(result);<br>      &#125;, delay);<br>    &#125;);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用方式支持异步的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(<span class="hljs-number">2</span>));<br>  <span class="hljs-comment">// 注意，修改默认值为 Promise</span><br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, get, <span class="hljs-number">0</span>);<br>  fn(<span class="hljs-number">3</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 0</span><br>  fn(<span class="hljs-number">4</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 4</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">20</span>);<br>  fn(<span class="hljs-number">5</span>).then(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(i)); <span class="hljs-comment">// 5</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>可以看到，第一种思路带来的问题是返回值永远会是 <strong>旧的</strong> 返回值，第二种思路主要问题是将同步函数也给包装成了异步。利弊权衡之下，吾辈觉得第二种思路更加正确一些，毕竟使用场景本身不太可能必须是同步的操作。而且，原本 <code>setTimeout</code> 也是异步的，只是不需要返回值的时候并未意识到这点。</p><h3 id="避免原函数信息丢失"><a href="#避免原函数信息丢失" class="headerlink" title="避免原函数信息丢失"></a>避免原函数信息丢失</h3><p>后来，有人提出了一个问题，如果函数上面携带其他信息，例如类似于 <code>jQuery</code> 的 <code>$</code>，既是一个函数，但也同时含有其他属性，如果使用 <code>debounce</code> 就找不到了呀</p><p>一开始吾辈立刻想到了复制函数上面的所有可遍历属性，然后想起了 ES6 的 <code>Proxy</code> 特性 – 这实在是太<strong>魔法</strong>了。使用 Proxy 解决这个问题将异常的简单 – 因为除了调用函数，其他的一切操作仍然指向原函数！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> debounce = <span class="hljs-function">(<span class="hljs-params">delay, action, init = <span class="hljs-literal">undefined</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> flag;<br>  <span class="hljs-keyword">let</span> result = init;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(action, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">target, thisArg, args</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">clearTimeout</span>(flag);<br>        flag = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          resolve((result = <span class="hljs-built_in">Reflect</span>.apply(target, thisArg, args)));<br>        &#125;, delay);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          resolve(result);<br>        &#125;, delay);<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> get = <span class="hljs-keyword">async</span> (i) =&gt; i;<br>  get.rx = <span class="hljs-string">&quot;rx&quot;</span>;<br><br>  <span class="hljs-built_in">console</span>.log(get.rx); <span class="hljs-comment">// rx</span><br>  <span class="hljs-keyword">const</span> fn = debounce(<span class="hljs-number">10</span>, get, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">console</span>.log(fn.rx); <span class="hljs-comment">// rx</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="实现节流"><a href="#实现节流" class="headerlink" title="实现节流"></a>实现节流</h3><p>以这种思路实现一个节流函数 <code>throttle</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数节流</span><br><span class="hljs-comment"> * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流</span><br><span class="hljs-comment"> * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作</span><br><span class="hljs-comment"> * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作</span><br><span class="hljs-comment"> * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值</span><br><span class="hljs-comment"> * 注: 返回函数结果的高阶函数需要使用 &#123;<span class="hljs-doctag">@link </span>Proxy&#125; 实现，以避免原函数原型链上的信息丢失</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>delay 最小间隔时间，单位为 ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>action 真正需要执行的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span> </span>包装后有节流功能的函数。该函数是异步的，与需要包装的函数 &#123;<span class="hljs-doctag">@link </span>action&#125; 是否异步没有太大关联</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">delay, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(action, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">target, thisArg, args</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> curr = <span class="hljs-built_in">Date</span>.now();<br>        <span class="hljs-keyword">if</span> (curr - last &gt; delay) &#123;<br>          result = <span class="hljs-built_in">Reflect</span>.apply(target, thisArg, args);<br>          last = curr;<br>          resolve(result);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        resolve(result);<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>嘛，实际上这里的防抖和节流仍然是简单的实现，其他的像 <strong>取消防抖</strong>/<strong>强制刷新缓存</strong> 等功能尚未实现。当然，对于吾辈而言功能已然足够了，也被放到了公共的函数库 <a href="https://rx-util.rxliuli.com/">rx-util</a> 中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>let 与 var 在 for 循环中的区别</title>
    <link href="/p/9c03bac44b51450c92565baf2cacd67e/"/>
    <url>/p/9c03bac44b51450c92565baf2cacd67e/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>今天遇到的一个很有趣的问题，下面两段 js 代码执行的结果是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，乍看之下好像没什么区别，只有声明方式 <code>let</code> 和 <code>var</code> 不一样而已。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里先说一下吾辈两个关于 js 的认知</p><ol><li> js 里 <code>setTimeout</code> 如果延迟时间为 0 应该会立刻执行</li><li> js 里的 for 循环和 java 应该差不多，for 循环内部是单独的作用域</li></ol><p>图解如下</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227214410.png" alt="js for 循环和 setTimeout 理解"></p><p>那么答案只有一个，两段代码执行的结果应该都是 <code>0 1 2</code> 才对！Ｏ(≧▽≦)Ｏ</p><p>然而当吾辈执行后的结果却是</p><ul><li><code>let</code>: <code>0 1 2</code></li><li><code>var</code>: <code>3 3 3</code></li></ul><p>发生了什么？吾辈表示很无语。。。┐(￣ヮ￣)┌</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>然而，上面的两个认知全错了！</p><h3 id="其一：js-里-setTimeout-如果延迟时间为-0-应该会立刻执行"><a href="#其一：js-里-setTimeout-如果延迟时间为-0-应该会立刻执行" class="headerlink" title="其一：js 里 setTimeout 如果延迟时间为 0 应该会立刻执行"></a>其一：js 里 <code>setTimeout</code> 如果延迟时间为 0 应该会立刻执行</h3><p>好吧，异步没有 <em>立刻执行</em> 这个说法，js 中异步函数实际上是被 <strong>事件队列</strong> 所管理的。当使用 <code>setTimeout</code> 函数时，即便延迟为 0，函数 <code>() =&gt; console.log(i)</code> 也不会立刻执行，而是会被放到 <strong>事件队列</strong> 中去，然后等待浏览器空闲之后执行。</p><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E9%9B%B6%E5%BB%B6%E8%BF%9F">MDN</a> 上有一段关于零延迟的描述</p><blockquote><p>零延迟</p><p>零延迟并不意味着回调会立即执行。以 0 为第二参数调用 <code>setTimeout</code> 并不表示在 <code>0</code> 毫秒后就立即调用回调函数。<br>其等待的时间取决于队列里待处理的消息数量。在下面的例子中，”this is just a message” 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。<br>基本上，<code>setTimeout</code> 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。</p></blockquote><p>所以 <code>setTimeout</code> 实际上并没有立刻执行，而是等到整个 <code>for</code> 循环结束之后才执行的。</p><h3 id="其二：js-里的-for-循环和-java-应该差不多，for-循环内部是单独的作用域"><a href="#其二：js-里的-for-循环和-java-应该差不多，for-循环内部是单独的作用域" class="headerlink" title="其二：js 里的 for 循环和 java 应该差不多，for 循环内部是单独的作用域"></a>其二：js 里的 for 循环和 java 应该差不多，for 循环内部是单独的作用域</h3><p>好吧，这个认知更是错的一塌糊涂，for 循环居然没有块级作用域？i 和 k 都是可以直接访问的，犹如直接声明到 for 循环外一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">var</span> k = <span class="hljs-number">10</span> - i;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i: <span class="hljs-subst">$&#123;i&#125;</span>, k: <span class="hljs-subst">$&#123;k&#125;</span>`</span>);<br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">// i: 3, k: 8</span><br></code></pre></td></tr></table></figure><p>相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> k;<br><span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">3</span>; ) &#123;<br>  k = <span class="hljs-number">10</span> - i;<br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果换成 let 则两者都无法访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">10</span> - i;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i: <span class="hljs-subst">$&#123;i&#125;</span>, k: <span class="hljs-subst">$&#123;k&#125;</span>`</span>);<br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">// Uncaught ReferenceError: i is not defined</span><br></code></pre></td></tr></table></figure><p>甚至还有一个更有趣的情况，在 for 的表达式和块中可以声明相同的变量，这只说明了一件事，let 声明的变量和循环内部声明的变量不在同一个作用域中！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;in for expression&quot;</span>, i), i++) &#123;<br>  <span class="hljs-keyword">let</span> i;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;in for block&quot;</span>, i);<br>&#125;<br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">// in for block undefined</span><br><span class="hljs-comment">// in for expression 0</span><br><span class="hljs-comment">// in for block undefined</span><br><span class="hljs-comment">// in for expression 1</span><br><span class="hljs-comment">// in for block undefined</span><br><span class="hljs-comment">// in for expression 2</span><br></code></pre></td></tr></table></figure><p>或许，i 只是加了新的作用域，就像下面这样，如此，循环外面就访问不到内部的值，循环内部和 for 的表达式也同样不在一个作用域了，每次循环结束就更新这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  (<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>附：这里吾辈是根据 babel 编译的结果修改而来。而且 babel 真的很聪明，当迭代变量 i 没有更新时，就不会使用 <code>_i</code> 进行区分呢！</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>重新建立了自己的认知之后，可以再对 <code>let/var</code> 在 for 循环进行分析了。</p><p>首先是 <code>let + for</code></p><h3 id="let-for"><a href="#let-for" class="headerlink" title="let + for"></a>let + for</h3><p>再看下面这段代码，可以对其进行分解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li> 创建 for 循环，表达式中存在 let 变量，for 将会创建一个块级作用域（ES6 let 专用）</li><li> 每次迭代时，会创建一个子块级作用域，迭代变量 i 也会重新生成</li><li> 对 i 的任何操作，都会被记住并赋值给下一次的迭代</li></ol><blockquote><p>块级作用域只对 let 有效，var 声明的变量仍然能在 for 循环外使用，证明 for 循环并不是像函数作用域那样是连 var 都能封闭的作用域。</p></blockquote><p>图解如下</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227212650.png" alt="let + for 图解"></p><h3 id="var-for"><a href="#var-for" class="headerlink" title="var + for"></a>var + for</h3><p>分析一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li> 进入 for 循环</li><li> 在这里创建了迭代变量 i，因为是函数作用域变量所以在 for 循环外可以访问，被提升到了函数作用域顶部声明</li><li> setTimeout 函数执行，闭包绑定函数作用域外部变量 i，在循环结束输出 i 的值 3</li><li> 继续迭代</li></ol><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227213014.png" alt="var + for 图解"></p><hr><p>所以以后如果可能，还是要拥抱这些新特性呢！那么，关于 <code>let/var</code> 在 <code>for</code> 循环中的区别就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript =&gt; TypeScript 迁移体验</title>
    <link href="/p/a699763f23e84702b8a742f5ddce82d7/"/>
    <url>/p/a699763f23e84702b8a742f5ddce82d7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>如果你使用 JavaScript 没出现什么问题，那吾辈就不推荐你迁移到 TypeScript！</p></blockquote><ul><li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li><li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li><li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li></ul><p>重要的话说三遍，TypeScript 是 JavaScript 的超集，所以有很多人认为（并宣称）JavaScript 可以很容易迁移到 TypeScript，甚至是无缝迁移的！<br>导致了 JavaScript 开发者满心欢喜的入坑了 TypeScript（包括吾辈），然后掉进了坑里，甚至差点爬不出来。。。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>问: 为什么吾辈用 JavaScript 用的好好的，偏偏自找麻烦去入坑了 TypeScript 了呢？</li><li>答: JavaScript 因为一些固有问题和主流编辑器 VSCode 支持不力，导致代码写起来会感觉很不方便</li><li>问: 具体谈谈</li><li>答: 有很多令人不满意的地方，这里只谈几点:<ul><li>JavaScript 没有类型，所以写 JSDoc 感觉很麻烦，但不写又不太好。然而，JavaScript 代码写的太顺利的话就可能忘记加上 JSDoc，之后代码就很难维护。</li><li>VSCode 支持不好，这点或许才是最重要的: VSCode 使用 TypeScript 编写，并基于 TypeScript 实现的语法提示功能，虽然也支持根据 JSDoc 的注释进行提示，然而当你去做一个开源项目，并将之发布到 npm 之后，情况发生了变化。。。当一个用户使用 npm/yarn 安装了你的项目之后，发现并没有任何代码提示，如此你会怎么做？</li><li>复杂的类型很难使用 JSDoc 表达出来并清晰地告诉调用者，例如高阶函数。</li><li>等等。。。。</li></ul></li></ul><p>是的，TypeScript 确实解决了以上的一些问题，却同时带入了另外一些问题。</p><ul><li>TypeScript 有类型了，然而即便有类型推导，还是要加很多类型，而且有时候 TypeScript 和我们的想法不同的时候还要用 <code>!</code>/<code>(t as unkonwn) as R</code> 这种 <strong>hack 技巧</strong>。</li><li>VSCode 天生支持 TypeScript，但 TypeScript 的 API Doc 生成工具实在谈不上多好，例如 <a href="https://typedoc.org/">typedoc</a> 相比于 <a href="https://esdoc.org/">ESDoc</a> 不过是个半吊子。。。</li><li>事实上，即便使用 TypeScript 写的项目，只要使用者没有在 <code>jsconfig.json</code> 中进行配置的话，提示仍然默认不存在</li><li>TypeScript 的类型系统是把双刃剑，实在太复杂了，当然有理由认为是为了兼容 JavaScript。然而在 TypeScript 想要正确的表达类型也是一件相当困难的事情。</li></ul><h2 id="类型系统踩坑"><a href="#类型系统踩坑" class="headerlink" title="类型系统踩坑"></a>类型系统踩坑</h2><h3 id="如何声明参数与返回值类型相同？"><a href="#如何声明参数与返回值类型相同？" class="headerlink" title="如何声明参数与返回值类型相同？"></a>如何声明参数与返回值类型相同？</h3><p>例如一个函数接受一个参数，并返回一个完全相同类型的返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItself</span>(<span class="hljs-params">obj: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>假使这样写的话，类型系统就不会发挥作用了，调用函数的结果将是 <code>any</code>，意味着类型系统将没有效果。</p><p>例如下面的代码会被 ts 认为是错误</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 这段代码并不会有提示</span><br><span class="hljs-built_in">console</span>.log(returnItself(<span class="hljs-string">&quot;abc&quot;</span>).length);<br></code></pre></td></tr></table></figure><p>需要写成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItself</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">any</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要声明了参数和返回值是同一类型，默认为 any，但具体取决于参数的不同而使得返回值也不同，返回值不会丢失类型信息。</p><h3 id="如何声明参数与返回值类型有关联？"><a href="#如何声明参数与返回值类型有关联？" class="headerlink" title="如何声明参数与返回值类型有关联？"></a>如何声明参数与返回值类型有关联？</h3><p>例如一个计算函数执行时间的函数 <code>timing</code>，接受一个函数参数，有可能是同步/异步的，所以要根据函数的返回值确定 <code>timing</code> 的返回值为 <code>number/Promise&lt;number&gt;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span> | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">number</span> | <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> performance.now() - begin;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而在使用时你会发现返回值类型不太对，因为 <code>timing</code> 的返回值是 <code>number | Promise&lt;number&gt;</code> 这种复合类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 这里会提示类型错误</span><br><span class="hljs-keyword">const</span> res: <span class="hljs-built_in">number</span> = timing(<span class="hljs-function">() =&gt;</span> sleep(<span class="hljs-number">100</span>));<br>expect(res).toBeGreaterThan(<span class="hljs-number">99</span>);<br></code></pre></td></tr></table></figure><p>解决方案有二</p><ol><li> 使用函数声明重载</li><li> 使用类型判断</li></ol><h4 id="使用函数声明重载"><a href="#使用函数声明重载" class="headerlink" title="使用函数声明重载"></a>使用函数声明重载</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params">fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params">fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span> | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">number</span> | <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> performance.now() - begin;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉函数声明顺序有点奇怪是因为 <code>Promise&lt;any&gt;</code> 属于 <code>any</code> 的子类，而函数声明重载必须由具体到宽泛。当然，我们有方法可以在 <code>any</code> 中排除掉 <code>Promise&lt;any&gt;</code>，这样顺序就对了！</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; Exclude&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params">fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span> | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">number</span> | <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> performance.now() - begin;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用类型判断"><a href="#使用类型判断" class="headerlink" title="使用类型判断"></a>使用类型判断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  fn: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span> | <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-comment">// 函数返回类型是 Promise 的话，则返回 Promise&lt;number&gt;，否则返回 number</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">R</span> <span class="hljs-title">extends</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">any</span>&gt; ? <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; : <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> (performance.now() - begin) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以看出来，第一种方式的优点在于可以很精细的控制每个不同参数对应的返回值，并且，可以处理特别复杂的情况，缺点则是如果写 doc 文档的话需要为每个声明都写上，即便，它们有大部分注释是相同的。<br>而第二种方式，则在代码量上有所减少，而且不必使用函数声明重载。缺点则是无法应对特别复杂的情况，另外一点就是使用了 <code>any</code>，可能会造成<strong>重构火葬场</strong>。</p><h3 id="TypeScript-类型系统就是认为吾辈错了怎么办？"><a href="#TypeScript-类型系统就是认为吾辈错了怎么办？" class="headerlink" title="TypeScript 类型系统就是认为吾辈错了怎么办？"></a>TypeScript 类型系统就是认为吾辈错了怎么办？</h3><p>有时候，明明自己知道是正确的，但 TypeScript 偏偏认为你写错了。思考以下功能如何实现？</p><p>将 Array 转换为 Map，接受三个参数</p><ol><li> 需要转换的数组</li><li> 将数组元素转换为 Map key 的函数</li><li> 将数组元素转换为 Map value 的函数，可选，默认为数组元素</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItself</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">any</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ArrayCallback&lt;T, R&gt; = <span class="hljs-function">(<span class="hljs-params">item: T, index: <span class="hljs-built_in">number</span>, arr: T[]</span>) =&gt;</span> R;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayToMap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  arr: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<br>    (res, item, index, arr) =&gt;<br>      res.set(kFn(item, index, arr), vFn(item, index, arr)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;K, V&gt;()<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>可能有以上代码，然而实际上 <code>returnItself</code> 无法直接赋值给 <code>ArrayCallback&lt;T, V&gt;</code>。当然，我们知道，这一定是可以赋值的，但 TypeScript 却无法编译通过！</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayToMap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  arr: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-comment">// 是的，这里添加 as any 就好了</span></span></span><br><span class="hljs-function"><span class="hljs-params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<br>    (res, item, index, arr) =&gt;<br>      res.set(kFn(item, index, arr), vFn(item, index, arr)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;K, V&gt;()<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>或者，如果 <code>returnItself</code> 用的比较多的话（例如吾辈），可以使用另一种方式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 修改 returnItself 的返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItself</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span> = <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">R</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ArrayCallback&lt;T, R&gt; = <span class="hljs-function">(<span class="hljs-params">item: T, index: <span class="hljs-built_in">number</span>, arr: T[]</span>) =&gt;</span> R;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayToMap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  arr: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<br>    (res, item, index, arr) =&gt;<br>      res.set(kFn(item, index, arr), vFn(item, index, arr)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;K, V&gt;()<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何强制调用非空时对象上的函数？"><a href="#如何强制调用非空时对象上的函数？" class="headerlink" title="如何强制调用非空时对象上的函数？"></a>如何强制调用非空时对象上的函数？</h3><p>当有时候你得到一个对象可能为空时，无法直接调用其上的函数，会提示函数不存在。<br>例如下面从数组中查询字符串，然后获取长度，在 TypeScript 中便会报错，因为 str 的类型为 string/undefined。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">const</span> str = arr.find(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s === <span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//</span><br><span class="hljs-built_in">console</span>.log(str.length);<br></code></pre></td></tr></table></figure><p>之前使用 JavaScript 从未遇到过这种事情，事实上确实有可能为空，但 JavaScript 太过于动态，并不会提示错误，而 TypeScript 就会提示这种低级错误，因为类型系统。<br>但是啊，凡事都有例外，当吾辈确实想调用 string 上的函数时报错真的是有点讨厌，那么有什么办法呢？</p><ol><li><p>使用 <code>!</code> 强制调用</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">const</span> str = arr.find(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s === <span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-built_in">console</span>.log(str!.length);<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>(str as any)</code> 转换为 any 类型之后再随意调用任何函数</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">const</span> str = arr.find(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s === <span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-built_in">console</span>.log((str <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).length);<br></code></pre></td></tr></table></figure></li><li><p>使用注释 <code>// @ts-ignore</code> 忽略错误（非常强力，少用）</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">const</span> str = arr.find(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s === <span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">// @ts-ignore</span><br><span class="hljs-built_in">console</span>.log(str.length);<br></code></pre></td></tr></table></figure><p>注意: 三种方式推荐程度逐渐降低，因为后两种实际上都会忽略类型系统，导致编写代码没有提示！</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截至目前为止，吾辈已经着手使用 TypeScript 重构工具函数库 <a href="https://github.com/rxliuli/rx-util">rx-util</a> 两周了，基本上打包配置，文档生成，类型定义基本上算是大致完成，感觉之后的公共项目大概都会用 TypeScript 实现了，毕竟前端主流开发工具 VSCode 对其的支持真的很好，而且 TypeScript 的接口这种概念真的太有用了！</p><h2 id="一些吐槽"><a href="#一些吐槽" class="headerlink" title="一些吐槽"></a>一些吐槽</h2><p>使用了有一段时间了，这里不得不再次声明一下，TypeScript 的类型系统复杂度超乎想象，如果你没有准备好在生产系统中使用，那就最好不要使用。缺少关于类型系统（尤其是原生类型，例如 <code>PromiseLike</code> 居然没有人讲过）的说明，使得 TypeScript 的类型系统很多时候看起来都只是为了<strong>好玩</strong>而已。而且稍微复杂一点的情况思考如何设计类型的时间将会超过具体的代码实现，使用它请务必再三慎重考虑！</p><p>TypeScript 的类型系统为了兼容 JavaScript 缺陷实在太大了。</p><blockquote><p>参见某个知乎用户的话:</p></blockquote><ol><li><p>ts 写不出一个合并对象的方法</p><p> 下面是一个 js 合并对象的方法</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">dest, ...sources</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(dest, ...sources);<br>&#125;<br></code></pre></td></tr></table></figure><p> 这么一个简单的方法，ts 写不出不丢失类型信息的实现。</p><p> 下面贴的是 typescript 源码中对 Object.assign 的声明，我相信都能看出有多傻：</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts">assign&lt;T, U&gt;(target: T, <span class="hljs-attr">source</span>: U): T &amp; U;<br>assign&lt;T, U, V&gt;(target: T, <span class="hljs-attr">source1</span>: U, <span class="hljs-attr">source2</span>: V): T &amp; U &amp; V;<br>assign&lt;T, U, V, W&gt;(target: T, <span class="hljs-attr">source1</span>: U, <span class="hljs-attr">source2</span>: V, <span class="hljs-attr">source3</span>: W): T &amp; U &amp; &amp; W;<br>assign(target: <span class="hljs-built_in">object</span>, ...sources: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p> 按这个实现，多于 4 个参数就直接丢掉类型信息了，建议 ts 至少把 A-Z 都作为泛型量用上…</p></li><li><p>一些很明显的类型推断却推断不出来</p><p> 用 assert 方法做参数检查是很常用的做法，一个简单的 assert 方法：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span>(<span class="hljs-params">condition, msg</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p> 然后看这样一段代码：</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">p: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  assert(<span class="hljs-keyword">typeof</span> p === <span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;p is a number&quot;</span>);<br>  p.length; <span class="hljs-comment">// 这里报错，ts 竟然不知道到这一步 p 必定是 string 类型</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 常用 App 清单</title>
    <link href="/p/a7418dcc845e45c4b342cff1d6fefc61/"/>
    <url>/p/a7418dcc845e45c4b342cff1d6fefc61/</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>该清单只是吾辈所用，使用工具因人而异，若是你对清单中的内容有何异议，可以在下方进行留言，吾辈会尽快阅读并回复！</p><blockquote><p>附：列出的 Google Drive 链接是因为某些第三方 App 不在 Play Store 之中，而且在可预期的很长时间内都不可能在（Youtube 第三方客户端）</p></blockquote><h2 id="Google-全家桶"><a href="#Google-全家桶" class="headerlink" title="Google 全家桶"></a>Google 全家桶</h2><p>这里首先说明使用 Google 全家桶的原因：虽然 Google 最近声名狼藉，然而相比于 _国内肆无忌惮的获取数据，甚至百度明目张胆地说出“中国人就是喜欢拿隐私换方便”_，Google 还是显得像一朵 <strong>白百合</strong>。而且 Google 也确实不会明目张胆的找人要隐私，它只会偷偷摸摸的去做（#笑哭）。而多个的 App 都使用同一家公司的优势是巨大的：<strong>一切数据皆在云端，后台服务体贴之至</strong>。更何况 Google 的服务大多数都是全端跨平台的，对于同时使用 PC/Mobile 的使用者而言优势巨大。</p><h3 id="Play-Store：应用商店"><a href="#Play-Store：应用商店" class="headerlink" title="Play Store：应用商店"></a>Play Store：应用商店</h3><p>Google 家的应用商店，主要可以强制替代国内系统自带的应用商店（<strong>垃圾商店，遍地广告</strong>），而且国内应用相对于国内版本要干净一些（例如 QQ/WeChat）。</p><h3 id="GMail：Google-家的电子邮件"><a href="#GMail：Google-家的电子邮件" class="headerlink" title="GMail：Google 家的电子邮件"></a>GMail：Google 家的电子邮件</h3><p>跨平台的电子邮件。如果需要经常使用电子邮件（订阅内容/公司同事交流/GreasyFork 反馈/GitHub Issue/各种网络服务），那么 Gmail 是当之无愧的首选。在 Web 版本上在所有电子邮件中都是首屈一指的，在 Android 上的表现也是相当不错，毕竟是在自家的系统上。</p><h3 id="Google-通讯录：Google-家的通讯录"><a href="#Google-通讯录：Google-家的通讯录" class="headerlink" title="Google 通讯录：Google 家的通讯录"></a>Google 通讯录：Google 家的通讯录</h3><p>跨平台的联系人功能。不仅仅是电话号码，甚至于 <strong>Email/IM/网站</strong> 都能作为一个 <strong>联系人</strong>。更有趣的是在 Android 上通过联系人打电话，在 Web 上却可以通过邮件（Gmail）进行联系了呢！</p><blockquote><p>注：Gmail 内置集成了通讯录。</p></blockquote><h3 id="Google-翻译：目前最好的翻译"><a href="#Google-翻译：目前最好的翻译" class="headerlink" title="Google 翻译：目前最好的翻译"></a>Google 翻译：目前最好的翻译</h3><p>跨平台的多语言翻译。目前应该是最好的翻译了，Google Chrome 自带的翻译可是为 Google 积累了巨大的原始数据，对于翻译质量的提升也是理所当然的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Surfboard：上网必须"><a href="#Surfboard：上网必须" class="headerlink" title="Surfboard：上网必须"></a>Surfboard：上网必须</h3><blockquote><p><a href="https://play.google.com/store/apps/details?id=com.getsurfboard">官方</a></p></blockquote><p>为了正常浏览网络折腾与支付一些代价都是微不足道的，比 <code>SS/SSR</code> UI/UX 好点，很多地方都支持搜索就很赞。</p><blockquote><p>附：最近网络盛传 V2Ray 更好，然而对于吾辈（使用者）而言，却是并未看到特别明显的优势，所以暂未切换过去。。。</p></blockquote><h3 id="Twitter：国外的网络社区"><a href="#Twitter：国外的网络社区" class="headerlink" title="Twitter：国外的网络社区"></a>Twitter：国外的网络社区</h3><p>对于吾辈而言，中文推圈的乐趣逐渐减少，现今早已不比曾经了。之前的那么多有趣的人和事，如今却都已消逝，<strong>Eric/Neko/泉</strong>。。。太多人在乎的人离去了，水军也进入了这个小小的圈子，Twitter 在吾辈的心中也渐渐和 QQ 一个等级了</p><h3 id="Telegram：安全私密的-IM"><a href="#Telegram：安全私密的-IM" class="headerlink" title="Telegram：安全私密的 IM"></a>Telegram：安全私密的 IM</h3><p>相比于 Twitter 是个社区，Telegram 则专注于用户之间的交流。开源（客户端）免费可端对端加密通讯，使得它受到许多推油的喜爱。Telegram 最新版的官方客户端已经做得足够好了，<code>Plus/TelegramX</code> 什么的基本上也不需要了呢</p><h3 id="QQ：国内广泛使用的-IM"><a href="#QQ：国内广泛使用的-IM" class="headerlink" title="QQ：国内广泛使用的 IM"></a>QQ：国内广泛使用的 IM</h3><blockquote><p><a href="https://drive.google.com/open?id=1bSd3jtUgqo_o7Nl_E5xl__0QnmdKg4FA">第三方</a></p></blockquote><p>国内广泛使用的 IM，曾经的同学什么的都在这里了（虽然吾辈曾经为了转型 Twitter 而清空过 QQ 就是了 #中二病）。这里吾辈使用了第三方修改版，主要是为了去除 QQ 的广告以及功能增强。</p><ul><li>去除无用的侧边栏</li><li>界面上稍微皮了一下</li><li>破解撤回</li><li>破解闪照</li><li>破解口令红包</li></ul><h3 id="WeChat：国内不得不用联系工具"><a href="#WeChat：国内不得不用联系工具" class="headerlink" title="WeChat：国内不得不用联系工具"></a>WeChat：国内不得不用联系工具</h3><p>国内不得不用的 IM，名为微信，实为<strong>巨信</strong>。不仅安装包极其巨大，而且连基本的数据同步，都没有做好－－以安全之名。然而 WeChat 究竟有没有保留原始数据，又有没有把数据交给政府审查，相信大家心里自然明白。</p><blockquote><p>已加入冰箱，彻底不允许后台运行。</p></blockquote><h3 id="Kiwi：Android-上扩展性最好的类-Chrome-浏览器"><a href="#Kiwi：Android-上扩展性最好的类-Chrome-浏览器" class="headerlink" title="Kiwi：Android 上扩展性最好的类 Chrome 浏览器"></a>Kiwi：Android 上扩展性最好的类 Chrome 浏览器</h3><p>在 PC 上，Google Chrome 是当之无愧的 <code>Number One</code>。然而，在 Android 上，Chrome for Android 并不支持插件。虽然 Google 宣称定位是 <strong>简洁高效的浏览体验</strong>，然而是不是为了推广使用 App 却并未可知，所以在 Android 上能使用附加组件（插件）的类 Chrome 浏览器 Kiwi 就是扩展性最好的浏览器（类似的还有 Firefox，但速度真的太慢了）。</p><p>常用 Plugin 列表</p><ul><li><a href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/">uBlock Origin</a>：广告过滤插件</li><li><a href="https://addons.mozilla.org/en-US/firefox/addon/darkreader/">Dark Reader</a>：全局黑色主题</li><li><a href="https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/">Tampermonkey</a>：UserJS 脚本</li><li><a href="https://addons.mozilla.org/en-US/firefox/addon/%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91-bing-microsoft-translator/">必应网页翻译</a>：全文翻译</li></ul><p>常用 UserJS 列表</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/375653">Mobile 上知乎自动展开答案</a>：在 Mobile 上自动展开知乎问题的答案</li><li><a href="https://greasyfork.org/zh-CN/scripts/342">Text To link</a>：网页上的文字转换为链接</li><li><a href="https://greasyfork.org/zh-CN/scripts/29762">网盘自动填写密码</a>：百度网盘自动填入提取码</li><li><a href="https://greasyfork.org/zh-CN/scripts/14146">网页限制解除</a>：解除网页的复制粘贴限制</li></ul><h3 id="条码扫描器：开源的条码扫描器"><a href="#条码扫描器：开源的条码扫描器" class="headerlink" title="条码扫描器：开源的条码扫描器"></a>条码扫描器：开源的条码扫描器</h3><blockquote><p><a href="https://github.com/zxing/zxing">GitHub</a></p></blockquote><p>开源的条码扫描器，比 WeChat 扫描安全一些，而且便于第三方集成（Firefox 搜索框）。</p><h3 id="Nova-启动器：Nova-桌面"><a href="#Nova-启动器：Nova-桌面" class="headerlink" title="Nova 启动器：Nova 桌面"></a>Nova 启动器：Nova 桌面</h3><blockquote><p><a href="https://drive.google.com/open?id=1EMcoMet27dN-ptsAG7yypTUqOO_Ip2pC">Pro 破解版</a></p></blockquote><p>还不错的第三方桌面，在很早之前就已经出现了。有一些自定义手势相当方便，长按 Home 搜索应用，双击屏幕锁屏。并支持第三方图标库，例如下面的 Pixel Icon Pack。</p><h3 id="Pixel-Icon-Pack：全而大-App-图标库"><a href="#Pixel-Icon-Pack：全而大-App-图标库" class="headerlink" title="Pixel Icon Pack：全而大 App 图标库"></a>Pixel Icon Pack：全而大 App 图标库</h3><p>虽然吾辈最喜欢的是 material 风格，然而 material 主题的图标数量实在不够。而 Pixel 这款图标库的数量足够庞大，包含了 6910+ 个图标，覆盖了绝大多数的 App，统一了桌面 App 的图标。</p><h3 id="FastHub：GitHub-第三方客户端"><a href="#FastHub：GitHub-第三方客户端" class="headerlink" title="FastHub：GitHub 第三方客户端"></a>FastHub：GitHub 第三方客户端</h3><blockquote><p><a href="https://github.com/k0shk0sh/FastHub">GitHub</a></p></blockquote><p>2020-07-14 更新</p><p>FastHub 才是最好的，虽然已经有官方客户端了，但功能上还比不上 FastHub。</p><hr><p>虽然 GitHub 是全世界最大的同性社交网站（代码托管平台），然而并没有官方的 Mobile 客户端。OpenHub 正是 GitHub 的一个第三方客户端，可以方便的在 Mobile 上使用 GitHub。</p><h3 id="淘宝-Lite：淘宝海外版"><a href="#淘宝-Lite：淘宝海外版" class="headerlink" title="淘宝 Lite：淘宝海外版"></a>淘宝 Lite：淘宝海外版</h3><p>你是否也曾厌恶淘宝的臃肿，是否讨厌淘宝的强制升级？现在，我们有了新的选择：淘宝 Lite，名副其实的精简版。主要面向国外用户，我们在地区中选择 <strong>全球</strong> 即可正常使用淘宝进行购物啦<br>主要优点</p><ul><li>没有各种广告</li><li>没有各种看似强大然并卵的功能</li><li>不强制升级</li><li>没有强制索取权限</li><li>包含完整的购物体验</li></ul><h3 id="支付宝：国内通用移动支付"><a href="#支付宝：国内通用移动支付" class="headerlink" title="支付宝：国内通用移动支付"></a>支付宝：国内通用移动支付</h3><p>国内广泛使用的移动支付工具，在一线城市（广州）基本上带个 Mobile 就能到处走了。相比于 WeChat，支付宝给吾辈的感觉更好。。。WeChat 总让吾辈觉得是只想在国内发展的一个毒瘤 App，而支付宝是有志于开拓世界的（无论影响好坏）。</p><h3 id="LastPass：全端密码管理器"><a href="#LastPass：全端密码管理器" class="headerlink" title="LastPass：全端密码管理器"></a>LastPass：全端密码管理器</h3><p>跨平台的密码管理器。基本上吾辈在 Google Chrome 上使用 Plugin，在 Mobile 上也使用它。虽然 Google Chrome 自带了密码管理/同步功能，然而对于某些两步验证的网站并未能很好的支持，而且也不支持跨浏览器！而 LastPass 基本上免费版本对于个人使用算是绰绰有余了，支持密码同步，跨平台/跨浏览器支持，复杂密码一键生成。</p><blockquote><p>注：吾辈在 PC 上使用 Google Chrome，Mobile 上却使用 Mozilla Firefox。</p></blockquote><h3 id="PxView：Pixiv-第三方客户端"><a href="#PxView：Pixiv-第三方客户端" class="headerlink" title="PxView：Pixiv 第三方客户端"></a>PxView：Pixiv 第三方客户端</h3><p>Pixiv 第三方客户端。相比于官方客户端有很多收费功能。<br>主要特点如下</p><ul><li>无广告</li><li>开源</li><li>支持黑暗模式</li><li>允许查看排行</li><li>保存图片</li></ul><h3 id="MXPlayer：本地视频播放器"><a href="#MXPlayer：本地视频播放器" class="headerlink" title="MXPlayer：本地视频播放器"></a>MXPlayer：本地视频播放器</h3><blockquote><p><a href="https://drive.google.com/open?id=1V7p6iGlIFLrOSgdpvbKX7jIF7hDeqPCg">Pro 破解版</a></p></blockquote><p>MxPlayer 应该算是 Android 上最强的本地播放器了吧？拥有相当多的解码器，对绝大多数的视频都能正常播放，对字幕的支持也相当不错，同时也能当作本地音乐播放器使用。</p><h3 id="静读天下：本地书籍阅读器"><a href="#静读天下：本地书籍阅读器" class="headerlink" title="静读天下：本地书籍阅读器"></a>静读天下：本地书籍阅读器</h3><blockquote><p>已入正</p></blockquote><p>非常好用的电子书阅读器，对多种格式的文档都支持的非常好。<br>包括但不限于以下格式</p><ul><li><code>Txt</code>：传统纯文本小说格式</li><li><code>HTML</code>：巨大网页小说，一般为二次导出</li><li><code>Epub</code>：新的电子书籍标准</li><li><code>Mobi</code>：亚马逊 Kindle 阅读器支持的专有格式</li><li><code>PDF</code>：Adobe 发行的一种电子书籍格式</li><li><code>umd</code>：常见的请小说格式</li><li><code>chm</code>：常见的电子文档格式</li></ul><p>交互友好，页面优雅，全能的本地阅读器。</p><h3 id="Weawow：天气-App"><a href="#Weawow：天气-App" class="headerlink" title="Weawow：天气 App"></a>Weawow：天气 App</h3><p>一个天气应用，使用它纯粹是不喜欢系统自带的天气应用。简单纯粹，不强制弹窗提醒升级，桌面的小部件也很简洁，最重要的是天气预报还算准确！</p><h3 id="InoReader：RSS-阅读器"><a href="#InoReader：RSS-阅读器" class="headerlink" title="InoReader：RSS 阅读器"></a>InoReader：RSS 阅读器</h3><p>一个跨平台的 RSS 阅读器，相比于大名鼎鼎的 <a href="https://feedly.com/">Feedly</a> 有着更多的免费功能，而且对于用户的支持非常棒！</p><blockquote><p>附：吾辈之前就有遇到过 RSS 只有一部分内容，需要在浏览器打开才能看到全文的情况，InoReader 快速回答了呢！</p></blockquote><h3 id="YMusic：Youtube-的第三方音乐客户端"><a href="#YMusic：Youtube-的第三方音乐客户端" class="headerlink" title="YMusic：Youtube 的第三方音乐客户端"></a>YMusic：Youtube 的第三方音乐客户端</h3><p>Youtube 虽然好用，但 Android 版的广告实在实在实在太多了！因为很重要，所以说三遍。吾辈日常使用 Youtube 听音乐，然而 Youtube 不能后台播放，不能下载到本地的特性导致单纯的听音乐真的很麻烦。<br>而 YMusic 不仅能下载 Youtube 上的内容，而且还能登录 Google 账号同步 Youtube 的内容。这，便是使用 YMusic 的理由！</p><h3 id="Musicolet：本地音乐播放器"><a href="#Musicolet：本地音乐播放器" class="headerlink" title="Musicolet：本地音乐播放器"></a>Musicolet：本地音乐播放器</h3><p>简单便捷的本地播放器，官方承诺绝不联网，使用体验也不错，便使用了。</p><h3 id="CX-文件管理器：简单的文件管理器"><a href="#CX-文件管理器：简单的文件管理器" class="headerlink" title="CX 文件管理器：简单的文件管理器"></a>CX 文件管理器：简单的文件管理器</h3><p>讨厌 EX 的广告和自动更新，而且实际上也用不到那么多的功能，吾辈只想简单的浏览、分类文件，同时在手机上访问局域网内的电脑文件罢了。</p><h3 id="简易图库"><a href="#简易图库" class="headerlink" title="简易图库"></a>简易图库</h3><p>简单的图片管理器，上一个国产图片浏览 App 还是快图浏览 <code>0.8.*</code> 的时代，但它已经过时了，所以，吾辈找到了这个 – 简单，不联网，自带简单的图片编辑，足够了。</p><h3 id="Sleep-Cycle：睡眠分析和智能闹钟"><a href="#Sleep-Cycle：睡眠分析和智能闹钟" class="headerlink" title="Sleep Cycle：睡眠分析和智能闹钟"></a>Sleep Cycle：睡眠分析和智能闹钟</h3><p>一个睡眠分析 App，能帮助我了解睡眠状况，以此来找寻解决方案。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，关于吾辈在 mobile 上使用的 App 清单便到此结束了。如果你有什么有趣的 App，也可以推荐给吾辈哦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebStorm 使用技巧</title>
    <link href="/p/a7d496697aae4cfb84777a64a69db755/"/>
    <url>/p/a7d496697aae4cfb84777a64a69db755/</url>
    
    <content type="html"><![CDATA[<h2 id="WebStorm-全局默认配置"><a href="#WebStorm-全局默认配置" class="headerlink" title="WebStorm 全局默认配置"></a>WebStorm 全局默认配置</h2><p>使用场景：<br>使用 WebStorm 经常会遇到一种情况，在这个项目自顶了一些设置（<strong>Settings</strong> 而非 <strong>Project Structure</strong>，例如 自定义的 Maven，项目字符编码等等），到了新的项目全部恢复了默认值又要重新设定。</p><p>解决方案：<br>通过 WebStorm 的默认设置（<strong>File &gt; Other Settings &gt; Default Settings</strong>）就可以设定全局的 <strong>Settings</strong>，而不需要在每个项目中重新设定一次。</p><blockquote><p>默认设定按吾辈的理解应该是用于设定那些可以使项目级别的设置，例如 <strong>代码检查</strong>，<strong>代码样式</strong> 等。毕竟大部分的设置都是全局的嘛</p></blockquote><h2 id="Alt-Enter-操作提示"><a href="#Alt-Enter-操作提示" class="headerlink" title="Alt-Enter 操作提示"></a>Alt-Enter 操作提示</h2><p>Alter-Enter 大概是 WebStorm 最强大快捷键了，放在不同的位置有不同的功能。</p><ul><li>警告（代码下面有黄色波浪线），会自动帮我们修复警告。<br>代码重复，代码冗余（1/0 之类），多余的变量（声明完就立刻返回/声明完最多只使用了一次）</li><li>错误（代码下面有红色波浪线），一般会提出合适的修复建议。<br>代码缺少注解，具体子类有未实现的方法</li><li>接口名（接口的名字），一般会提示可以生成实现类或者跳转到实现类</li><li>自动修复变量名的问题（不符合驼峰）</li><li>普通类名，一般会提示创建测试类，没有 JavaDoc 注释还会提示生成注释</li><li>字符串里面，会提示使用 <a href="#%E8%AF%AD%E8%A8%80%E6%B3%A8%E5%85%A5">语言注入</a></li><li>跳转到注入语言的编辑面板</li></ul><h2 id="Double-Shift-任意搜索"><a href="#Double-Shift-任意搜索" class="headerlink" title="Double Shift 任意搜索"></a>Double Shift 任意搜索</h2><p>这个功能其实是集成了多个搜索，但有时候真的很好用，集成的功能包括</p><ul><li>搜索 <code>Settings</code>（<code>CS-A</code>）：搜索 WebStorm 的设置</li><li>搜索 <code>class</code>（<code>C-N</code>）：搜索代码里的 class 类</li><li>搜索 <code>File</code>（<code>CS-N</code>）：搜索任何文件</li><li>搜索 <code>symbol</code>（<code>CSA-N</code>）：搜索符号，主要用于搜索 Spring MVC 路径</li><li>搜索 <code>Tool Windows</code>（<code>C-Tab</code>）：搜索工具窗口</li><li>搜索 <code>Run configuration</code>（<code>SA-F9/F10</code>）：搜索运行的配置项</li><li>搜索 <code>Action</code>（<code>Alt-Enter</code>）：搜索当前位置的代码可执行操作</li></ul><p>如果你知道需要搜索的类型，请尽量使用单独的搜索选项，毕竟速度上会有一些优势</p><h2 id="列编辑"><a href="#列编辑" class="headerlink" title="列编辑"></a>列编辑</h2><p>列编辑是一个非常有趣的功能，可以让你同时编辑多行文本。</p><p>共有下面几种方式触发</p><ul><li>使用鼠标中键下拉或上拉选中多行</li><li>使用 <code>A-J</code> 依次选择相同的代码片段，并使用 <code>SA-J</code> 取消选择</li><li>使用 <code>CSA-J</code> 选中当前文件所有匹配的代码片段</li><li>使用 <code>CA-Top/Bottom</code> 向上或向下选择多行（需要添加快捷键 <code>Editor Actions =&gt; Clone Caret Above/Clone Caret Below</code>）</li></ul><p>GIF 演示</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190627110522.gif" alt="GIF 演示"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote><p>快捷键想要熟练没有什么好的办法，却是只能多加使用了。如果你还不熟悉 WebStorm 的快捷键，可以使用 <a href="https://github.com/halirutan/IntelliJ-Key-Promoter-X">Key Promoter X</a> 插件来提示你使用快捷键操作。</p></blockquote><ul><li>搜索<ul><li><code>C-N</code> ：搜索类</li><li><code>CS-N</code> ：搜索文件</li><li><code>CSA-N</code> ：搜索字段名(包含数据库字段)/方法名</li><li><code>SS</code> ：搜索接口路径，类名，文件名，字段名/方法名</li><li><code>CS-F</code>：全局搜索代码（该快捷键与 Windows10 的默认输入法冲突，可以修改快捷键，或者换用其他输入法）</li></ul></li><li>面板操作<ul><li><code>ESC</code>：返回到编辑器中</li><li><code>C-E</code> ：列出最近操作的文件历史以及可操作面板列表，然后可以通过输入单词跳转到对应的面板</li><li><code>C-Tab -&gt; *</code>：列出最近操作的文件历史以及可操作面板，并能通过单个字母导航到对应的操作面板（需要一直按住 <code>Ctrl</code>）</li><li><code>A-Top/Bottom/Left/Right</code> ：左右是切换标签页，上下是切换方法</li><li><code>F12</code> ：跳转到最后一个使用的面板</li><li><code>CS-F12</code> ：收起/显示所有面板</li><li><code>C-F12</code> ：在一个悬浮面板上列出所有字段/方法</li><li><code>A-F11</code>: 列出可以快速运行的任务，支持 <code>npm/gulp</code></li></ul></li><li>选择<ul><li><code>C-W/CS-W</code> ：扩大/缩小选择区域范围</li><li><code>CS-[/]</code>：选择至当前区域的开始/结束</li><li><code>A/SA-J</code> ：选中/反选相同的单词进行列编辑（一个个的选中）</li><li><code>CSA-J</code> ：选中多个相同的单词（当前文件全部选中）</li></ul></li><li>代码跳转<ul><li><code>CA-Left/Right</code> ：跳转到上一个/下一个浏览的位置</li><li><code>CS-Backspace</code> ：回退到上一个编辑的位置</li><li><code>C-Top/Bottom/Left/Right</code>：左右是跳转到上一个/下一个单词，上下是移动屏幕（非移动光标）</li><li><code>C-;</code> ：屏幕内任意跳转（需要安装 <strong>Ace Jumper</strong> 插件）</li><li><code>Home</code> ：跳转到行首/编辑器的最左侧</li><li><code>End</code> ：跳转到行尾</li><li><code>C-Home/End</code> ：跳转到文件的开始/结尾</li><li><code>C-Page Up/Page Down</code> ：跳转到当前屏幕的第一行/最后一行</li><li><code>F2/S-F2</code> ：跳转到下一个/上一个错误/警告的位置</li><li><code>C-Left/C-Right</code> ：跳转到上一个/下一个单词的位置</li><li><code>C-B</code> ：跳转到变量/方法的声明处</li><li><code>CS-B</code> ：跳转到变量/方法的具体实现处，如果不止一处就会列出下拉框<blockquote><p>注：这里吾辈修改了快捷键，毕竟 <code>CA-B</code> 单手按起来还真有点麻烦</p></blockquote></li></ul></li></ul><blockquote><p>注：在 WebStorm 看来左侧字母上面的数字键和右侧小键盘的数字键是不同的！<br>注: <code>Shift</code> 一般用于 <strong>增强/取反</strong> 功能。例如 <code>C-F</code> 搜索当前文件，<code>CS-F</code> 搜索所有文件，<code>F2</code> 跳转到下一个错误，<code>S-F2</code> 跳转到上一个错误。</p></blockquote><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ul><li><a href="https://plugins.jetbrains.com/plugin/4441-jrebel-for-intellij">JRebel for IntelliJ</a>：做 Java Web 开发时真心免不了的 Plugin，能够有效解决 Web 容器（例如 Apache Tomcat）启动速度慢的问题（因为几乎所有的资源都能够热加载，热部署）</li><li><a href="https://plugins.jetbrains.com/plugin/7007-liveedit">LiveEdit</a>：提供了 HTML/CSS/JavaScript 的实时预览和刷新功能</li><li><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx">MybatisX</a>：Mybatis 的一个辅助开发插件，能够比较愉快的使用 Mybatis 框架了</li><li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines">Alibaba Java Coding Guidelines</a>：Alibaba 出品的一个 Java 规范检查插件，能够规避一些不好的代码</li><li><a href="https://plugins.jetbrains.com/plugin/8579-translation">Translation</a>：目前使用感觉最好的翻译插件，能够提供比较长的内容进行翻译（某些翻译插件只能翻译很短的内容）</li><li><a href="https://plugins.jetbrains.com/plugin/2162-string-manipulation">String Manipulation</a>：字符串操作工具，可以方便对变量名或其他字符串修改为其他风格，例如将变量从 <strong>驼峰命名</strong>（Java 标准命名） 修改为 <strong>下划线命名</strong>（SQL 标准命名）或者 <strong>中缀线命名</strong>（HTML/CSS 标准命名）。<blockquote><p>其实这么多命名规范真心坑。。。</p></blockquote></li><li><a href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x">Key Promoter X</a>：使用鼠标操作时提示对应的快捷键</li><li><a href="https://plugins.jetbrains.com/plugin/9862-custom-postfix-templates">Custom Postfix Templates</a>：提供自定义的后缀模板</li><li><a href="https://plugins.jetbrains.com/plugin/7896-markdown-navigator">Markdown Navigator</a>：WebStorm 平台的 Markdown 写作插件，比自带的 Markdown Support 要好很多，主要在需要写的 Markdown 内容中含有代码时比较方便</li><li><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">Maven Helper</a>：一个 Apache Maven 的辅助操作插件</li><li><a href="https://plugins.jetbrains.com/plugin/7275-codeglance">CodeGlance</a>：在编辑器右侧显示一块代码缩略图，主要为了方便使用滑块进行上下滑动</li><li><a href="https://plugins.jetbrains.com/plugin/7125-grep-console">Grep Console</a>：自定义控制台的输出颜色</li><li><a href="https://plugins.jetbrains.com/plugin/7495--ignore">.ignore</a>：在使用版本控制时，快速忽略某些文件/文件夹，目前支持广泛</li><li><a href="https://plugins.jetbrains.com/plugin/5834-cmd-support">CMD support</a>：Cmd 支持，主要是方便在 WebStorm 中直接运行 bat 脚本</li><li><a href="https://plugins.jetbrains.com/plugin/6098-nodejs">NodeJS</a>：集成了 NodeJS，可以直接在 WebStorm 中运行 NodeJS</li><li><a href="https://plugins.jetbrains.com/plugin/9442-vue-js">Vue.js</a>：集成 Vue.js 框架</li><li><a href="https://plugins.jetbrains.com/plugin/7494-eslint">ESLint</a>：前端代码规范</li><li><a href="https://plugins.jetbrains.com/plugin/10456-prettier">Prettier</a>：根据上面 ESLint 的规范自动格式化代码</li><li><a href="https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter">Properties to YAML Converter</a>：将 <code>Properties</code> 文件快速转换为 <code>YAML</code> 格式的配置文件</li><li><a href="https://plugins.jetbrains.com/plugin/7425-wakatime">WakaTime</a>：统计使用的编程语言，不同 IDE 的记录</li></ul><h2 id="语言注入"><a href="#语言注入" class="headerlink" title="语言注入"></a>语言注入</h2><p>为某一段区域的注入其他语言，WebStorm 最常见的就是在 JavaScript 的字符串中注入了 HTML/CSS/JavaScript，使得在字符串内也有代码提示可用。</p><blockquote><p>此功能常用于 JavaScript 字符串拼接 HTML 代码，当然目前这个需求在 ES6 中由 <code>模板字符串</code> 原生实现了。</p></blockquote><p>我们也可以手动注入，例如为 Java 中的字符串注入 SQL 语言，这样在写 SQL 语句就不用跑到 SQL 编辑器那里写完 SQL 语句在粘贴过来了。</p><h2 id="Live-Template-Postfix-Template-模板"><a href="#Live-Template-Postfix-Template-模板" class="headerlink" title="Live Template/Postfix Template 模板"></a>Live Template/Postfix Template 模板</h2><p>Live Template 模板就是那种在 Java 中输入 <code>sout</code> 就可以生成以下代码的模板功能，而这功能在 WebStorm 还可以自定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println($END$);<br></code></pre></td></tr></table></figure><p>例如吾辈就定义了 <code>autowired</code> 用于生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> $BeanClass$ $BeanName$;<br>$END$<br></code></pre></td></tr></table></figure><p>或者 <code>thread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>    $END$<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>此功能使用得当甚至能大量减少重复编码。不过相比之下另外一个代码生成功能吾辈更加喜欢，但 WebStorm 在 2018.2 版本之前并不支持自定义，所以功能上来说就显得稍弱一些，当然吾辈也使用插件（Custom Postfix Templates <a href="https://github.com/xylo/intellij-postfix-templates#download">GitHub</a>）实现了自定义的需求。最新版本 WebStorm 原生支持了自定义功能（<a href="https://blog.jetbrains.com/idea/2014/03/postfix-completion/">WebStorm 官方介绍</a>），但实现尚不完善。</p><p>此功能可以做到另外一种形式的模板字符串，例如输入 <code>&quot;str&quot;.var</code> 然后回车会得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String $variableName$ = <span class="hljs-string">&quot;str&quot;</span>;$END$<br></code></pre></td></tr></table></figure><p>或者 <code>&quot;str&quot;.sout</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Sysout.out.println(<span class="hljs-string">&quot;str&quot;</span>);<br></code></pre></td></tr></table></figure><p>吾辈也自定义一些，例如输入了 <code>&quot;str&quot;.val</code>，会生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> String $variableName$ = <span class="hljs-string">&quot;str&quot;</span>;$END$<br></code></pre></td></tr></table></figure><h2 id="一些有用的配置项"><a href="#一些有用的配置项" class="headerlink" title="一些有用的配置项"></a>一些有用的配置项</h2><h3 id="soft-wrap-强制换行"><a href="#soft-wrap-强制换行" class="headerlink" title="soft wrap 强制换行"></a>soft wrap 强制换行</h3><p>WebStorm 在一行过长时会出现横向滚动条，那我们不想要它出现以便于能直接使用键盘就能看完要怎么办呢？</p><p>可以在 <em>Settings ⇒ Editor ⇒ General ⇒ Soft Wraps</em> 中找到设置，将 <strong>Soft-wrap files</strong> 的值修改为 <code>*</code> 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090747.png" alt="强制换行"></p><h3 id="根据源代码自动滚动项目"><a href="#根据源代码自动滚动项目" class="headerlink" title="根据源代码自动滚动项目"></a>根据源代码自动滚动项目</h3><p>可以在跳转文件时，使文件目录自动聚焦在当前编辑的文件上，这在很多时候是有利于查看目录/文件的。</p><p>2019.3 之后</p><p>在 <em>Project ⇒ Always Select Opened File</em> 中可以找到这个配置，启用即在整个项目中启用了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191224100414.png" alt="根据源代码自动滚动项目设置"></p><p>2019.3 之前</p><p>在 <em>Project ⇒ Tool ⇒ Autoscroll from Source</em> 中可以找到这个配置，启用即在整个项目中启用了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090627.png" alt="根据源代码自动滚动项目设置"></p><h2 id="复制-WebStorm-提示的报错"><a href="#复制-WebStorm-提示的报错" class="headerlink" title="复制 WebStorm 提示的报错"></a>复制 WebStorm 提示的报错</h2><blockquote><p>这个技巧的发现来源于一个同事</p></blockquote><p>有时候 WebStorm 提示我们错误，当我们把鼠标放在上面时会有一个 <code>Tooltip</code>。但当我们想要复制这个错误时，却发现选择时 <code>Tooltip</code> 很容易消失，即便在较新版本中进行了改进，但想要复制仍然是非常痛苦的一件事，那么如何更加简单的复制错误呢？<br>实际上，当我们将光标移动到错误上面时，左下角的状态栏中会有该错误并且可以右键复制！</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200430145423.png" alt="复制 WebStorm ToolTip 提示"></p><blockquote><p>相关问题参考：<a href="https://youtrack.jetbrains.com/issue/WebStorm-70943">https://youtrack.jetbrains.com/issue/WebStorm-70943</a>，这是一个相当古老（2011 年）的问题，但 JetBrains 的开发者一开始甚至不认为这是一个问题，直到最近才着手修复它。<br>附：或许 JetBrains 的开发人员并不需要面向 Google 编程？#笑</p></blockquote><h2 id="浏览器报错在-WebStorm-打开相应文件"><a href="#浏览器报错在-WebStorm-打开相应文件" class="headerlink" title="浏览器报错在 WebStorm 打开相应文件"></a>浏览器报错在 WebStorm 打开相应文件</h2><blockquote><p>参考：</p><ul><li><a href="https://juejin.im/post/6844903967206408206">React 调试的时候如何打开指定的编辑器 /webstorm</a></li></ul></blockquote><p>react 项目下其实就是添加环境变量 <code>REACT_EDITOR</code> 而已，可以使用 <code>.env.local</code> 进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs env">REACT_EDITOR&#x3D;[WebStorm 的路径]<br></code></pre></td></tr></table></figure><h2 id="设定默认-jest-运行单元测试"><a href="#设定默认-jest-运行单元测试" class="headerlink" title="设定默认 jest 运行单元测试"></a>设定默认 jest 运行单元测试</h2><p>在包含 react-scripts 依赖的项目中，WebStorm 会默认使用 react-scripts 运行测试，这在单体项目中当然很好，但如果是 monorepo，则会出现一些问题。react-scripts 运行时会强制修改 <code>tsconfig.json/react-app-env.d.ts</code>，这在一些 node 子模块中会出现问题，而 react-scripts 目前还不能关闭这个功能。所以只能修改 WebStorm 的测试运行工具了，可以在 <code>Edit configuration</code> 中修改 <code>Jest =&gt; Jest Package</code> 字段值为 <code>jest</code>，更推荐设置 <code>Templates =&gt; Jest =&gt; Jest Package</code> 字段，因为它可以一劳永逸。</p><p><img src="/resource/9697e0ecf2a94558953c1bb4117ce641.png" alt="1615086542056"></p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/53794875">How to configure react-script so that it doesn’t override tsconfig.json on ‘start’</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>webstorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点击按钮自动提交了 Form 表单</title>
    <link href="/p/a8524fe9f9e646e284638c4ddf0bda50/"/>
    <url>/p/a8524fe9f9e646e284638c4ddf0bda50/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在吾辈的写 HTML 时遇到了一个问题，一个普通的按钮，点击之后一旦在 <code>click</code> 事件中进行了 <code>return</code>，则立刻提交 <code>Form</code> 表单。</p><p>像下面这段代码，不管是点击 <em>修改按钮</em> 还是 _提交按钮_，<code>Form</code> 表单都会被提交（可以看到 <code>alert</code> 弹框）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;submitFn()&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;文本输入框&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;updateFn()&quot;</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">// 提交方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    alert(<span class="hljs-string">&quot;form 表单被提交了&quot;</span>);</span><br>  &#125;<br><br><span class="javascript">  <span class="hljs-comment">// 修改方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> $username = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#form &gt; input&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!$username.value) &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br>    &#125;<br><span class="javascript">    $username.value = <span class="hljs-string">&quot;&quot;</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后来经过同事提醒，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button#%E5%B1%9E%E6%80%A7">MDN</a> 找到了关于 <code>button</code> 按钮的解释，在 <em>属性 =&gt; type</em> 小结中，有下面这样一段内容</p><blockquote><p><strong>type</strong><br>button 的类型。可选值：</p><ul><li><code>submit</code>: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。</li><li><code>reset</code>: 此按钮重置所有组件为初始值。</li><li><code>button</code>: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。</li><li><code>menu</code>: 此按钮打开一个由指定 <code>&lt;menu&gt;</code> 元素进行定义的弹出菜单。</li></ul></blockquote><p>是的，当没有指定 <code>button</code> 元素的 <code>type</code> 属性时，浏览器将默认为 <code>submit</code> 而非 <code>button</code>，导致了在 <code>Form</code> 表单中容易出现奇怪的自动提交问题。</p><p>修改后的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;submitFn()&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;文本输入框&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 实际上只是在这里加了一个 type=&quot;button&quot; 属性而已 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;updateFn()&quot;</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">// 提交方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    alert(<span class="hljs-string">&quot;form 表单被提交了&quot;</span>);</span><br>  &#125;<br><br><span class="javascript">  <span class="hljs-comment">// 修改方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFn</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> $username = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#form &gt; input&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!$username.value) &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br>    &#125;<br><span class="javascript">    $username.value = <span class="hljs-string">&quot;&quot;</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实际上吾辈也只添加了一个 <code>type</code> 属性，但却因为这个问题耗费许久，终归是基础知识的坑踩得不够多。不过幸好，吾辈可以记录下来，避免在同一个坑里跌倒两次！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些烦心事</title>
    <link href="/p/abe6253bc476414a99d37233c0c71c3e/"/>
    <url>/p/abe6253bc476414a99d37233c0c71c3e/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>抽刀断水水更流，举杯消愁愁更愁（虽然吾辈并不喝酒就是了）</p></blockquote><p>明明说过这是一个技术博客的，然而现如今，吾辈却也需要发一些技术之外的内容了呢。。。（经受了<a href="https://www.zhihu.com/question/282036368">社会的毒打</a>）</p><h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212832.png" alt="公司"></p><p>最近到了一家新的公司，每天早晨 6-7 点起床，然后晚上 7-8 点回来，忙忙碌碌，再无他事。</p><p>公司项目历史遗留的问题之多，想要改变问题面临的困境之难，都导致吾辈在公司的时间逐渐变多，自己生活的时间逐渐变少，所以最近别说博客都半个月不发一次，连 github 的维护都少有时间，每天都是早晨抽空维护半个小时罢了。</p><p>回到了家里，吃完晚饭，洗完澡，便已然快到了睡觉的时间。想要做点自己的事情，但又感觉没什么时间。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212906.png" alt="生活"></p><p>而且，现在吾辈有点控制不了时间了，每天睡觉时间也难以固定。或许因为一时兴起，便去看了一部电影，然后到了凌晨 0 点或 1 点再睡觉，便是在周末刻意进行了补觉，但也不能弥补日常精力不足的事实。</p><p>不曾被在意，不曾被了解，没有目标，没有动力。吾辈曾经把写博客作为目标，但后来知识的增长速度越来越慢，空闲时间越来越多用来咸鱼般的躺在床上，发呆地度过周末的两天。</p><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212931.png" alt="家庭"></p><p>曾经亲密的家人，现在因为一些事情，却也有了现实的矛盾。或许，家家都有难念的经，便是吾辈，也必须经历各种现实中的苦难吧。</p><p>周末有时回到家里，虽然家人现在没有说什么特别的话，但从他们的语气中，对我如今的现状，包含心疼，包含不满。如今也便只是维持现状，小心翼翼的计算每个月回去一次，便不会引起太多的波澜（无论如何亲密的人，只要待在一起的时间够久，便会发现对方的缺陷，而家人，便是能够忍受这种问题的存在）。</p><p>吾辈的妹妹已然让父母伤透了心，吾辈不想再伤害他们一次。然而屁股决定脑袋，吾辈想要的东西和他们想要的并不一致，它们的经验并不适合吾辈。娶妻生子，掌家立业，难道便是人一辈子的追求么？</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212955.png" alt="未来"></p><p>不知道未来会变成怎样，不知道未来会发生什么。平凡的活着，不断遭受着社会的毒打。当垂垂老矣时，回顾一生，没有任何值得诉说的事迹，或许也是吾辈一种可能的结局吧</p><blockquote><p>卑鄙有卑鄙者的通行证，高尚有高尚者的墓志铭。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jsdoc 注释标签一览</title>
    <link href="/p/ad1c52ed52954ad2ba4cf28785cb063f/"/>
    <url>/p/ad1c52ed52954ad2ba4cf28785cb063f/</url>
    
    <content type="html"><![CDATA[<h2 id="速览表格"><a href="#速览表格" class="headerlink" title="速览表格"></a>速览表格</h2><h3 id="标签列表"><a href="#标签列表" class="headerlink" title="标签列表"></a>标签列表</h3><table><thead><tr><th>标签</th><th>简介</th></tr></thead><tbody><tr><td><code>param</code></td><td>参数</td></tr><tr><td><code>returns</code></td><td>返回值</td></tr><tr><td><code>example</code></td><td>示例</td></tr><tr><td><code>test</code></td><td>测试代码</td></tr><tr><td><code>class</code></td><td>类定义</td></tr><tr><td><code>property</code></td><td>类属性定义</td></tr></tbody></table><h3 id="语法列表"><a href="#语法列表" class="headerlink" title="语法列表"></a>语法列表</h3><table><thead><tr><th>语法</th><th>简介</th></tr></thead><tbody><tr><td><code>&#123;T&#125;</code></td><td>类型</td></tr><tr><td><code>&#123;T,R&#125;</code></td><td>多个类型</td></tr><tr><td><code>[]</code></td><td>可选值</td></tr><tr><td><code>[arg=v]</code></td><td>默认值</td></tr><tr><td><code>.&lt;T&gt;</code></td><td>泛型</td></tr><tr><td><code>obj.property</code></td><td>对象参数</td></tr><tr><td><code>function(T):R</code></td><td>函数参数</td></tr></tbody></table><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="param"><a href="#param" class="headerlink" title="param"></a><code>param</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在控制台上打印一个值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>obj 需要被打印的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="returns"><a href="#returns" class="headerlink" title="returns"></a><code>returns</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取一个 0-1 之间的随机数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>随机数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a><code>example</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取一个 0-1 之间的随机数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>随机数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><br><span class="hljs-comment"> * const i = random()</span><br><span class="hljs-comment"> * console.log(i)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a><code>test</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@test <span class="hljs-type">&#123;random&#125;</span> </span>测试 random 函数</span><br><span class="hljs-comment"> */</span><br>describe(<span class="hljs-string">&quot;测试 random 函数&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&quot;测试两次随机数是否相等&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> i = random();<br>    <span class="hljs-keyword">const</span> k = random();<br>    expect(i).not.toBe(k);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a><code>class</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单模拟 Vue class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@class <span class="hljs-variable">Vue</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="property"></a><code>property</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单模拟 Vue class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@class <span class="hljs-variable">Vue</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@property <span class="hljs-type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@property <span class="hljs-type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@property <span class="hljs-type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@property <span class="hljs-type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构造函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>option 可选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; el, data = &#123;&#125;, methods = &#123;&#125;, mounted = <span class="hljs-keyword">function</span> () &#123;&#125; &#125; = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.el = el;<br>    <span class="hljs-built_in">this</span>.data = data;<br>    <span class="hljs-built_in">this</span>.methods = methods;<br>    <span class="hljs-built_in">this</span>.mounted = mounted;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id=""><a href="#" class="headerlink" title="{}"></a><code>&#123;&#125;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算两个数字之和</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>i 第一个数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>k 第二个数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number&#125;</span> </span>两数之和</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">i, k</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> i + k;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="T-R"><a href="#T-R" class="headerlink" title="{T,R}"></a><code>&#123;T,R&#125;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算两个数字之和，或者两个字符串之间的连接</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|String&#125;</span> </span>i 第一个数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|String&#125;</span> </span>k 第二个数字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number|String&#125;</span> </span>两数之和，或者两个字符串之间的连接</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">i, k</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> i + k;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="[]"></a><code>[]</code></h3><p>使用场景: 可选参数不需要在函数中所有条件下使用</p><p>例如下面的 <code>sep</code> 在不传入时会默认返回 <code>[str]</code>，一般优先使用 <code>[arg=v]</code> 更好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分割字符串为数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[sep] 分隔符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>分割后的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">split</span>(<span class="hljs-params">str, sep</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> sep ? str.split(sep) : [str];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arg-v"><a href="#arg-v" class="headerlink" title="[arg=v]"></a><code>[arg=v]</code></h3><p>使用场景: 需要为传入的参数赋予默认值</p><blockquote><p>注: 太过冗长的默认值最好使用文件描述而非加到 <code>[]</code> 中</p></blockquote><p>例如下面的函数参数 <code>sep</code>，如果想要在不传入的时候默认为 <code>&#39;&#39;</code>，就需要使用默认值标记。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分割字符串为数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>[sep=&#x27;&#x27;] 分隔符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array&#125;</span> </span>分割后的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">split</span>(<span class="hljs-params">str, sep = <span class="hljs-string">&quot;&quot;</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(sep);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lt-T-gt"><a href="#lt-T-gt" class="headerlink" title=".&lt;T&gt;"></a><code>.&lt;T&gt;</code></h3><p>使用场景: <code>Array, Map, Set, Iterator</code> 这中集合接口/类限定元素类型，也有 <code>Promise</code> 这种内嵌其他类型异步结果的情况</p><p>例如下面的集合就声明元素全部都需要为 <code>String</code>，<code>Object</code> 的话可能出现 <code>[object Object]</code> 这种内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将 String 类型的数组中的元素都连接起来，并以逗号进行分割</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array.&lt;String&gt;&#125;</span> </span>arr 字符串数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>连接后的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="obj-property"><a href="#obj-property" class="headerlink" title="obj.property"></a><code>obj.property</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单模拟 Vue API</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>option 可选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span>(<span class="hljs-params">&#123; el, data = &#123;&#125;, methods = &#123;&#125;, mounted = <span class="hljs-keyword">function</span> () &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.el = el;<br>  <span class="hljs-built_in">this</span>.data = data;<br>  <span class="hljs-built_in">this</span>.methods = methods;<br>  <span class="hljs-built_in">this</span>.mounted = mounted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="function-T-R"><a href="#function-T-R" class="headerlink" title="function(T):R"></a><code>function(T):R</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自行实现 flatMap，将数组压平一层</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array.&lt;Object&gt;&#125;</span> </span>arr 数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function(Object):Array&#125;</span> </span>fn 映射方法，将一个元素映射为一个数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Array.&lt;Object&gt;&#125;</span> </span>压平一层的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatMap</span>(<span class="hljs-params">arr, fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, item</span>) =&gt;</span> res.concat(fn(item)), []);<br>&#125;<br></code></pre></td></tr></table></figure><!--## 问题### 如何处理对象参数### 如何处理函数参数### 如何处理自定义类型参数### 如何定义类型保证参数及返回值泛型相同### 如何标记测试代码-->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 使用 Promise</title>
    <link href="/p/b868601482c94fa884ca706e47a41dff/"/>
    <url>/p/b868601482c94fa884ca706e47a41dff/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>为什么要使用 Promise？</p><p>JavaScript 异步发展史：<code>回调函数 -&gt; Promise -&gt; async/await</code></p><p>传统异步使用回调函数，回调意味着嵌套，当你需要使用很多异步函数时，那你需要非常多的回调函数，可能形成回调地狱。<br>有问题就有人解决，js 没有多线程，所以天生就是异步的。正是因为异步的广泛性，所以很早之前就有人着力于解决异步回调的问题，github 上有很多已经废弃的库就是用于解决这个问题的。<br>然而现在，es6 出现了 <code>Promise</code>，它能把嵌套回调压平为一层的链式调用，并且写进了 js 标准里。es7 甚至出现了更加优雅的方式，<code>async/await</code>，能以同步的方式写异步的代码。当然，本质上只是 Promise 的一个语法糖，但其重要性也是不言而喻的——异步回调地狱已经不存在了！<br>说了这么多，那么平常我们应该怎么使用 Promise 呢？</p><h2 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h2><p>一般而言，我们作为使用者是无需创建 Promise 的，支持 Promise 的函数会返回一个 Promise 对象给我们，然后我们使用它的方法 <code>then/catch</code> 即可。</p><ul><li><code>then()</code>：当前的 JavaScript 已经完成，要进行下一步的同步/异步操作了</li><li><code>catch()</code>：用于捕获 Promise 链式调用中可能出现的错误</li></ul><blockquote><p>注：<code>then/catch</code> 均返回一个新的 Promise</p></blockquote><p>例如我们有这样一个需求</p><ol><li> 等待资源 A 加载完成</li><li> 在 A 资源加载完成之后等待 B 资源加载完成</li></ol><p>之前使用回调函数，我们的代码可能是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>callback 回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(callback, param);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (param()) &#123;<br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>        callback();<br>      &#125;<br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    callback();<br>  &#125;<br>&#125;<br><br>wait(<br>  () =&gt; <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#a&quot;</span>),<br>  () =&gt; &#123;<br>    wait(<br>      () =&gt; <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#b&quot;</span>),<br>      () =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a, b 两个资源已经全部加载完成&quot;</span>);<br>      &#125;<br>    );<br>  &#125;<br>);<br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// a, b 两个资源已经全部加载完成</span><br></code></pre></td></tr></table></figure><p>可以看到，上面如果还需要等待 <code>c,d,e,f...</code> 资源，那么回调函数的层级将是无法接受的。<br>现在，我们使用 Promise 改造一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 先不要管这个函数的具体实现，下面再说如何自己封装 Promise</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><br>wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#a&quot;</span>))<br>  <span class="hljs-comment">// 注意这里的 wait(() =&gt; document.querySelector(&#x27;#b&#x27;)) 同样是一个异步函数，返回了一个 Promise</span><br>  <span class="hljs-comment">// 接下来，有趣的地方来了</span><br>  <span class="hljs-comment">// 很明显，wait 是一个异步函数。wait 函数的 then 函数调用了另一个异步函数，然而 then 会等待异步执行完成，才继续执行后面的函数</span><br>  .then(<span class="hljs-function">() =&gt;</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#b&quot;</span>)))<br>  <span class="hljs-comment">// 这里仍然会等待上面的 Promise 完成之后才执行下面的内容</span><br>  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a, b 两个资源已经全部加载完成&quot;</span>));<br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// a, b 两个资源已经全部加载完成</span><br></code></pre></td></tr></table></figure><p>下面我们尝试使用一下 <code>catch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#a&quot;</span>))<br>  .then(<span class="hljs-function">() =&gt;</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#b&quot;</span>)))<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;执行了某些操作发生了异常&quot;</span>);<br>  &#125;)<br>  <span class="hljs-comment">// 上面抛出了异常并且没有使用 catch 处理的话就会继续找下一个调用，直到找到处理的 catch，或者调用结束为止</span><br>  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a, b 两个资源已经全部加载完成&quot;</span>))<br>  <span class="hljs-comment">// 捕获上面的 then() 发生的异常，保证后面的调用正常执行</span><br>  .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;使用 catch 捕获的异常: &quot;</span>, error))<br>  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;测试异步函数结束&quot;</span>));<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// 使用 catch 捕获的异常:  Error: 执行了某些操作发生了异常</span><br><span class="hljs-comment">//     at wait.then.then (&lt;anonymous&gt;:4:11)</span><br><span class="hljs-comment">// VM272:9 测试异步函数结束</span><br></code></pre></td></tr></table></figure><blockquote><p>可以参考 MDN 上的教程 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 Promises</a></p></blockquote><h2 id="封装-Promise"><a href="#封装-Promise" class="headerlink" title="封装 Promise"></a>封装 Promise</h2><p>那么，你是否也对上面自定义的 <code>wait</code> 函数感到好奇呢？我们来详细的了解一下具体如何做到的吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里返回了一个 Promise 对象，Promise 的构造函数要求一个函数参数</span><br>  <span class="hljs-comment">// 函数的参数实际上有两个，resolve 和 reject，分别代表 [已经完成] 和 [出现错误]</span><br>  <span class="hljs-comment">// 注：这个函数是立刻执行的，当 resolve 或 reject 执行时，这个 Promise 算是结束了，将进入下一个 then/catch 调用</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          <span class="hljs-comment">// 这里执行了代码，如果有什么结果需要传递给下一个调用，则直接放到 resolve 函数内即可</span><br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们也可以使用 Promise 封装其他函数</p><ul><li><code>timeout</code>：一个简单的 <code>setTimeout()</code> 的封装</li><li><code>readLocal</code>：读取本地浏览器选择的文件</li><li><code>timing</code>：测试函数执行的时间，不管是同步还是异步的(Promise)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 Promise 简单封装 setTimeout</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>ms 等待时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> timeout = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读取本地浏览器选择的文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;File&#125;</span> </span>file 选择的文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#123;String&#125;</span></span>&#125; init 一些初始选项，目前只有 type 一项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>返回了读取到的内容（异步）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> readLocal = (<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-function">(<span class="hljs-params">file, &#123; type = <span class="hljs-string">&quot;readAsDataURL&quot;</span> &#125; = &#123;&#125;</span>) =&gt;</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!file) &#123;<br>        reject(<span class="hljs-string">&quot;file not exists&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>      fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>        resolve(event.target.result);<br>      &#125;;<br>      fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        reject(error);<br>      &#125;;<br>      fr[type](file);<br>    &#125;);<br>  result.DataURL = <span class="hljs-string">&quot;readAsDataURL&quot;</span>;<br>  result.Text = <span class="hljs-string">&quot;readAsText&quot;</span>;<br>  result.BinaryString = <span class="hljs-string">&quot;readAsBinaryString&quot;</span>;<br>  result.ArrayBuffer = <span class="hljs-string">&quot;readAsArrayBuffer&quot;</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;)();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试函数的执行时间</span><br><span class="hljs-comment"> * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn 需要测试的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number|Promise&#125;</span> </span>执行的毫秒数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timing</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> begin = performance.now();<br>  <span class="hljs-keyword">const</span> result = fn();<br>  <span class="hljs-keyword">if</span> (!(result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> performance.now() - begin;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.then(<span class="hljs-function">() =&gt;</span> performance.now() - begin);<br>&#125;<br></code></pre></td></tr></table></figure><p>吾辈建议你也可以封装一些常用的异步函数，下面会展示 JavaScript 中如何更简单的使用异步！</p><h2 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async/await"></a>使用 async/await</h2><ul><li><code>async</code>：用于标识一个函数是异步函数，默认这个函数将返回一个 Promise 对象</li><li><code>await</code>：用于在 async 函数内部使用的关键字，标识一个返回 Promise 的异步函数需要等待</li></ul><p>使用 <code>async/await</code> 重构上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// await 等待异步函数执行完成</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#a&quot;</span>));<br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#b&quot;</span>));<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a, b 两个资源已经全部加载完成&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 注：init() 函数将返回一个 Promise，我们可以继续追加下一步的操作</span><br>init();<br></code></pre></td></tr></table></figure><p>是的，就是如此简单，直接在异步函数添加 <code>await</code> 关键字就好了！</p><hr><p>最后，如果你要使用这些特性，请务必使用 babel 转换器。毕竟，有太多的人就是不肯升级浏览器。。。</p><blockquote><p>可以参考</p><ul><li><a href="https://babeljs.io/docs/en/">babeljs 官方文档</a></li><li><a href="https://blog.rxliuli.com/p/e73e3322/">在传统项目中使用 babel 编译 ES6</a></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 rollup 打包 JavaScript SDK</title>
    <link href="/p/bd842060067c45708d8c08f89c9fcf4c/"/>
    <url>/p/bd842060067c45708d8c08f89c9fcf4c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吾辈已经写了一个 TypeScript/JavaScript Cli 工具 <a href="https://www.npmjs.com/package/liuli-cli">liuli-cli</a>，如有需要可以使用这个 Cli 直接生成一个开箱即用 SDK 项目，然后就可以直接开始写自己的代码，不需要太过关心下面的内容了 – 因为，它们都已然集成了。</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="为什么要使用打包工具"><a href="#为什么要使用打包工具" class="headerlink" title="为什么要使用打包工具"></a>为什么要使用打包工具</h3><p>如果我们想要写一个 <code>JavaScript SDK</code>，那么就不太可能将所有的代码都写到同一个 js 文件中。当然了，想做的话的确可以做到，但随着 <code>JavaScript SDK</code> 内容的增加，一个 js 文件容易造成开发冲突，以及测试上的困难，这也是现代前端基本上都依赖于打包工具的原因。</p><h3 id="为什么打包工具是-rollup"><a href="#为什么打包工具是-rollup" class="headerlink" title="为什么打包工具是 rollup"></a>为什么打包工具是 rollup</h3><p>现今最流行的打包工具是 <a href="https://webpack.js.org/">webpack</a>，然而事实上对于单纯的打包 JavaScript SDK 而言 webpack 显得有些太重了。webpack 终究是用来整合多种类型的资源而产生的（<code>ReactJS/VueJS/Babel/TypeScript/Stylus</code>），对于纯 JavaScript 库而言其实并没有必要使用如此 <strong>强大</strong> 的工具。而 rollup 就显得小巧精致，少许配置就能立刻打包了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><p>该记录的代码被吾辈放到了 <a href="https://github.com/rxliuli/rollup-example">GitHub</a>，有需要的话可以看下。</p></blockquote><h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>开始之前，我们必须要对以下内容有所了解</p><ul><li>[x] JavaScript</li><li>[x] npm</li><li>[ ] babel</li><li>[ ] uglify</li><li>[ ] eslint</li></ul><h3 id="需要打包的代码"><a href="#需要打包的代码" class="headerlink" title="需要打包的代码"></a>需要打包的代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/wait.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> wait;<br><br><span class="hljs-comment">// src/fetchTimeout.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 fetch 请求添加超时选项</span><br><span class="hljs-comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchTimeout</span>(<span class="hljs-params">fetchPromise, timeout</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> abortFn = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//这是一个可以被 reject 的 Promise</span><br>  <span class="hljs-keyword">var</span> abortPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    abortFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      reject(<span class="hljs-string">&quot;abort promise&quot;</span>);<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-comment">// 有一个 Promise 完成就立刻结束</span><br>  <span class="hljs-keyword">var</span> abortablePromise = <span class="hljs-built_in">Promise</span>.race([fetchPromise, abortPromise]);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    abortFn();<br>  &#125;, timeout);<br>  <span class="hljs-keyword">return</span> abortablePromise;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fetchTimeout;<br><br><span class="hljs-comment">// src/main.js</span><br><span class="hljs-keyword">import</span> wait <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./wait&quot;</span>;<br><span class="hljs-keyword">import</span> fetchTimeout <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./fetchTimeout&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限制并发请求数量的 fetch 封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FetchLimiting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; timeout = <span class="hljs-number">10000</span>, limit = <span class="hljs-number">10</span> &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>    <span class="hljs-built_in">this</span>.limit = limit;<br>    <span class="hljs-built_in">this</span>.execCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 等待队列</span><br>    <span class="hljs-built_in">this</span>.waitArr = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行一个请求</span><br><span class="hljs-comment">   * 如果到达最大并发限制时就进行等待</span><br><span class="hljs-comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_fetch</span>(<span class="hljs-params">url, init</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> _innerFetch = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<br>        <span class="hljs-string">`执行 execCount: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="hljs-subst">$&#123;</span></span><br><span class="hljs-string"><span class="hljs-subst">          <span class="hljs-built_in">this</span>.waitArr.length</span></span><br><span class="hljs-string"><span class="hljs-subst">        &#125;</span>, index: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.waitArr[<span class="hljs-number">0</span>])&#125;</span>`</span><br>      );<br>      <span class="hljs-built_in">this</span>.execCount++;<br>      <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">this</span>.waitArr.shift(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fetchTimeout(fetch(...args), <span class="hljs-built_in">this</span>.timeout);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.execCount--;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.waitArr.push(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.execCount &lt; <span class="hljs-built_in">this</span>.limit);<br>    <span class="hljs-comment">// 尝试启动等待队列</span><br>    <span class="hljs-keyword">return</span> _innerFetch();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> FetchLimiting;<br></code></pre></td></tr></table></figure><h3 id="使用-rollup-直接打包"><a href="#使用-rollup-直接打包" class="headerlink" title="使用 rollup 直接打包"></a>使用 rollup 直接打包</h3><p>安装 <code>rollup</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i rollup -D<br></code></pre></td></tr></table></figure><p>在根目录创建一个 <code>rollup.config.js</code> 配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 入口文件</span><br>  input: <span class="hljs-string">&quot;src/main.js&quot;</span>,<br>  output: &#123;<br>    <span class="hljs-comment">// 打包名称</span><br>    name: <span class="hljs-string">&quot;bundlea&quot;</span>,<br>    <span class="hljs-comment">// 打包的文件</span><br>    file: <span class="hljs-string">&quot;dist/bundle.js&quot;</span>,<br>    <span class="hljs-comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span><br>    format: <span class="hljs-string">&quot;umd&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加一个 <code>npm script</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;build&quot;: &quot;rollup -c&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行 <code>npm run build</code> 测试打包，可以看到 <em>dist</em> 目录下已经有 <code>bundle.js</code> 文件了</p><blockquote><p>好了，到此为止我们已经简单使用 rollup 打包 js 了，下面的内容都是可选项，如果需要可以分节选读。</p></blockquote><h3 id="使用-babel-转换-ES5"><a href="#使用-babel-转换-ES5" class="headerlink" title="使用 babel 转换 ES5"></a>使用 babel 转换 ES5</h3><p>然而，我们虽然已经将 main.js 打包了，然而实际上我们的代码没有发生什么变化。即：原本是 ES6 的代码仍然会是 ES6，而如果我们想要尽可能地支持更多的浏览器，目前而言还是需要兼容到 ES5 才行。</p><p>所以，我们需要 <code>babel</code>，它能够帮我们把 ES6 的代码编译成 ES5。</p><blockquote><p>附：babel 被称为现代前端的 jquery。</p></blockquote><p>首先，安装 babel 需要的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D rollup-plugin-babel @babel/core @babel/plugin-external-helpers @babel/preset-env<br></code></pre></td></tr></table></figure><p>在 <code>rollup.config.js</code> 中添加 <code>plugins</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> babel <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-babel&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  plugins: [<br>    <span class="hljs-comment">// 引入 babel 插件</span><br>    babel(&#123;<br>      exclude: <span class="hljs-string">&quot;node_modules/**&quot;</span>,<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加 babel 的配置文件 <code>.babelrc</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">&quot;modules&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;<br>    ]<br>  ],<br>  <span class="hljs-attr">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-external-helpers&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>再重新运行 <code>npm run build</code>，可以看到 <code>bundle.js</code> 中的代码已经被编译成 ES5 了。</p><h3 id="使用-uglify-压缩生产环境代码"><a href="#使用-uglify-压缩生产环境代码" class="headerlink" title="使用 uglify 压缩生产环境代码"></a>使用 uglify 压缩生产环境代码</h3><p>那么，生产中的代码还需要做什么呢？是的，压缩，减小 js 代码的体积是必要的。接下来，我们还需要使用 <code>uglify</code> 压缩我们打包后的 <code>bundle.js</code> 代码。</p><p>首先仍然是安装 <code>uglify</code> 相关的包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D rollup-plugin-uglify<br></code></pre></td></tr></table></figure><p>然后在 <code>rollup.config.js</code> 中引入插件就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注意，这里引入需要使用 &#123; uglify &#125; 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify</span><br><span class="hljs-keyword">import</span> &#123; uglify &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-uglify&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  plugins: [<br>    <span class="hljs-comment">// js 压缩插件，需要在最后引入</span><br>    uglify(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-ESLint-检查代码"><a href="#使用-ESLint-检查代码" class="headerlink" title="使用 ESLint 检查代码"></a>使用 ESLint 检查代码</h3><p>如果我们想要需要多人协作统一代码风格，那么可以使用 ESLint 来强制规范。</p><p>首先，全局安装 <code>eslint</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i eslint -g<br></code></pre></td></tr></table></figure><p>然后使用 <code>eslint cli</code> 初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">eslint --init<br></code></pre></td></tr></table></figure><p>下面的三项问题选择</p><ol><li>How would you like to configure ESLint? (Use arrow keys)<br> <code>Use a popular style guide</code></li><li>Which style guide do you want to follow? (Use arrow keys)<br> <code>Standard (https://github.com/standard/standard)</code></li><li>What format do you want your config file to be in? (Use arrow keys)<br> <code>JavaScript</code></li><li>Would you like to install them now with npm?<br> <code>y</code></li></ol><p>然后，我们发现项目根目录下多出了 <code>.eslintrc.js</code>，这是 eslit 的配置文件。然而，我们需要对其稍微修改一下，不然如果我们的代码中出现了浏览器中的对象，例如 <code>document</code>，eslint 就会傻傻的认为那是个错误！<br>修改后的 <code>.eslintrc.js</code> 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-keyword">extends</span>: <span class="hljs-string">&quot;standard&quot;</span>,<br>  <span class="hljs-comment">// 添加了运行环境设定，设置 browser 为 true</span><br>  env: &#123;<br>    browser: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们查看打包后的 <code>bundle.js</code> 时发现 eslint 给我们报了一堆错误，所以我们需要排除掉 dist 文件夹<br>添加 <code>.eslintignore</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ignore">dist<br></code></pre></td></tr></table></figure><p>添加 <code>rollup-plugin-eslint</code> 插件，在打包之前进行格式校验</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D rollup-plugin-eslint<br></code></pre></td></tr></table></figure><p>然后引入它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; eslint &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-eslint&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  plugins: [<br>    <span class="hljs-comment">// 引入 eslint 插件</span><br>    eslint(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个时候，当你运行 <code>npm run build</code> 的时候，eslint 可能提示你一堆代码格式错误，难道我们还要一个个的去修复么？不，eslint 早已考虑到了这一点，我们可以添加一个 npm 脚本用于全局修复格式错误。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;lint&quot;: &quot;eslint --fix src&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行 <code>npm run lint</code>，eslint 会尽可能修复格式错误，如果不能修复，会在控制台打印异常文件的路径，然后我们手动修复就好啦</p><h3 id="其他-rollup-配置"><a href="#其他-rollup-配置" class="headerlink" title="其他 rollup 配置"></a>其他 rollup 配置</h3><h4 id="添加代码映射文件"><a href="#添加代码映射文件" class="headerlink" title="添加代码映射文件"></a>添加代码映射文件</h4><p>其实很简单，只要在 <code>rollup.config.js</code> 启用一个配置就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  output: &#123;<br>    <span class="hljs-comment">// 启用代码映射，便于调试之用</span><br>    sourcemap: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="多环境打包"><a href="#多环境打包" class="headerlink" title="多环境打包"></a>多环境打包</h4><p>首先移除掉根目录下的 <code>rollup.config.js</code> 配置文件，然后创建 build 目录并添加下面四个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// build/util.js</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据相对路径计算真是的路径</span><br><span class="hljs-comment"> * 从当前类的文件夹开始计算，这里是 /build</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>relaPath 相对路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>绝对路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcPath</span>(<span class="hljs-params">relaPath</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> path.resolve(__dirname, relaPath);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// build/rollup.config.dev.js</span><br><span class="hljs-keyword">import</span> &#123; eslint &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-eslint&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; calcPath &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../package.json&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 入口文件</span><br>  input: calcPath(<span class="hljs-string">&quot;../src/main.js&quot;</span>),<br>  output: &#123;<br>    <span class="hljs-comment">// 打包名称</span><br>    name,<br>    <span class="hljs-comment">// 打包的文件</span><br>    file: calcPath(<span class="hljs-string">`../dist/<span class="hljs-subst">$&#123;name&#125;</span>.js`</span>),<br>    <span class="hljs-comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span><br>    format: <span class="hljs-string">&quot;umd&quot;</span>,<br>    <span class="hljs-comment">// 启用代码映射，便于调试之用</span><br>    sourcemap: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码</span><br>    eslint(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// build/rollup.config.prod.js</span><br><span class="hljs-keyword">import</span> babel <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-babel&quot;</span>;<br><span class="hljs-comment">// 注意，这里引入需要使用 &#123; uglify &#125; 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify</span><br><span class="hljs-keyword">import</span> &#123; uglify &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-uglify&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; eslint &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-eslint&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; calcPath &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util&quot;</span>;<br><span class="hljs-keyword">import</span> dev <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rollup.config.dev&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../package.json&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<br>  dev,<br>  &#123;<br>    <span class="hljs-comment">// 入口文件</span><br>    input: calcPath(<span class="hljs-string">&quot;../src/main.js&quot;</span>),<br>    output: &#123;<br>      <span class="hljs-comment">// 打包名称</span><br>      name,<br>      <span class="hljs-comment">// 打包的文件</span><br>      file: calcPath(<span class="hljs-string">`../dist/<span class="hljs-subst">$&#123;name&#125;</span>.min.js`</span>),<br>      <span class="hljs-comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span><br>      format: <span class="hljs-string">&quot;umd&quot;</span>,<br>    &#125;,<br>    plugins: [<br>      <span class="hljs-comment">// 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码</span><br>      eslint(),<br>      <span class="hljs-comment">// 引入 babel 插件</span><br>      babel(&#123;<br>        exclude: calcPath(<span class="hljs-string">&quot;../node_modules/**&quot;</span>),<br>      &#125;),<br>      <span class="hljs-comment">// js 压缩插件，需要在最后引入</span><br>      uglify(),<br>    ],<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// build/rollup.config.js</span><br><span class="hljs-keyword">import</span> dev <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rollup.config.dev&quot;</span>;<br><span class="hljs-keyword">import</span> prod <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./rollup.config.prod&quot;</span>;<br><br><span class="hljs-comment">// 如果当前环境时 production，则使用 prod 配置，否则使用 dev 配置</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span> ? prod : dev;<br></code></pre></td></tr></table></figure><p>修改 npm 脚本</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;build:dev&quot;: &quot;rollup -c build/rollup.config.js --environment NODE_ENV:development&quot;,<br>  &quot;build:prod&quot;: &quot;rollup -c build/rollup.config.js --environment NODE_ENV:production&quot;,<br>  &quot;build&quot;: &quot;npm run build:dev &amp;&amp; npm run build:prod&quot;,<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>那么，关于使用 rollup 打包 JavaScript 的内容就先到这里了，有需要的话后续吾辈还会继续更新的！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react 入坑思考</title>
    <link href="/p/bf496d4b660f4226a03f2b8a04baee04/"/>
    <url>/p/bf496d4b660f4226a03f2b8a04baee04/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈为什么要学 <code>react</code> 呢？难道 <code>HTML+CSS+JavaScript</code> 已经满足不了了？是的，传统前端确实满足不了吾辈了，前端在快速发展，而后端手中（甚至眼中）的前端仍然是只有 <code>HTML+CSS+JavaScript+JQuery</code> 的世界。吾辈不想就这样下去，所以想要了解、学习、使用现代前端的内容。<br>谜之音：难道 <code>vuejs</code> 还不够么？<br><code>vuejs</code> 既是国产（阿里），所以文档（中文）相对而言应该是最好的。而且相比于 <code>react</code>，<code>vuejs</code> 的门槛相对而言还是比较低的。至少，不用一开始就接触 <code>webpack</code>（天坑），在不用 <code>webpack</code> 的情况下使用 <code>react</code> 将是很困难的。<br>或许有人说，<code>react</code> 不是有 <code>create-react-app</code> 可以快速创建 <code>web app</code> 么？然而使用 <code>create-react-app</code> 之后，一大波僵尸（概念）将会袭来。</p><h2 id="对白"><a href="#对白" class="headerlink" title="对白"></a>对白</h2><p>让我们先来看一段对白</p><p>问：<code>react</code> 好像不推荐在浏览器中直接使用 <code>&lt;script&gt;</code> 标签引入呢？<br>答：是呀，你需要 <code>npm/yarn</code> 这类工具呢<br>问：<code>npm</code> 是什么？<br>答：<code>npm</code> 能帮助我们管理依赖的库 只要 <code>install</code> 一下就可以啦<br>问：那么安装的包要怎么引用呢？<br>答：你需要用 <code>commonjs/es2016</code> 之类的方式引入呢？<br>问：等等，<code>commonjs</code>？<code>es2016</code>？这都是什么呀？<br>答：哦，这是一种 js 模块化的规范而已，我们只要知道 <code>import</code> 和 <code>export</code> 就好啦？<br>问：嗯，那么我应该在哪里写 <code>HTML</code>？<br>答：不不不，<code>react</code> 里面没有 <code>HTML</code>，只有 <code>jsx</code>。<br>问：OMG，<code>jsx</code> 又是什么？<br>答：一种 <code>js + xml</code> 的 <code>dsl</code>，语法上很像 <code>HTML</code>，no problem！<br>问：那写完的的 <code>jsx</code> 组件怎么在浏览器中查看啊？<br>答：你需要使用打包工具，例如 <code>webpack</code>，将 <code>jsx</code> 打包成 <code>HTML+JavaScript</code> 才行<br>问：额，不是没有 <code>HTML</code> 了么？<br>答：写的时候没有，但浏览器只认识 <code>HTML/CSS/JavaScript</code>，所以最终还是要变成这些才行呀<br>问：嗯，那么 <code>webpack</code> 是什么呢？<br>答：现代前端的一个打包工具<br>问：好的，那我去看看文档<br>一段时间后。。。<br>问：我看了 <code>webpack</code> 官网的文档，但还是不明白应该怎么打包<br>答：额，不行的话就用 <code>create-react-app</code> 吧。它会自动帮你生成一个完整配置的项目的，你只要懂得配置的意思并且会修改就好了。<br>问：于是，我开始了愉快的 <code>react</code> 之旅。。。个鬼呀！<strong>idea</strong> 怎么没提示？<br>答：额，你需要插件，不过更推荐 <strong>vscode</strong>，毕竟已经是事实上的前端标准编辑器了。<br>问：也就是说，我又要用一个新的 <code>IDE</code> 了？<br>答：不是啦，<strong>vscode</strong> 只是一个编辑器，比 <strong>idea</strong> 轻量太多了。而且，<strong>vscode</strong> 对前端生态支持很好哦<br>一段时间后。。。<br>问：我写了几个组件，但不知道应该怎么控制页面跳转？我好像并不能在后端映射到组件呀<br>答：<code>react</code> 需要使用 <code>react router</code> 之类的前端路由，现在前端的跳转由前端来控制就好了<br>问：所以说，不能使用 <code>java</code> 来控制么？≥﹏≤<br>答：额，可能真不行，为什么不用 <code>react router</code> 呢？<br>问：好吧，我先去看看。。。<br>问：唉，组件之间的交互好麻烦呀，每次都要依赖传递 <code>props</code> 啊<br>答：哦，你可以尝试一下状态管理。例如 <code>redux</code><br>问：<code>redux</code>？那是什么？<br>答：<code>react</code> 中的一个状态管理，可以不用一层层的传递 <code>props</code> 了呢<br>问：听起来很不错，我现在就去看一下！<br>问：两天后，woc，<code>redux</code> 去死吧？就想改个状态怎么这么麻烦，而且异步那里什么鬼？(ノ =Д=) ノ ┻━┻<br>答：看来你不适合 <code>react</code>，或许你可以看看 <code>vuejs</code>，更简单一点。国产，中文文档齐全，门槛很低的呢！</p><p>诚然，以上的问题不一定是指 <code>react</code> 本身，但依赖于如此之多的工具，本就造成了 <code>react</code> 的复杂性。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>看完以上对话，或许吾辈看起来很讨厌 <code>react</code> 的样子？<br>事实上，吾辈第一次学习现代前端的时候，就是从 <code>react</code> 开始的，然后基本上就像上面的对话所述，直接败退了，然后滚去学了一段时间的 <code>vuejs</code>。<br>然而，直到最近，吾辈发现 <code>vuejs</code> 的生态实在太小了。最开始吾辈就了解过这两个框架，也知道 <code>vuejs</code> 的生态很小，然而确实没想到会这么小。。。<br>深层次来讲，<code>vuejs</code> 毕竟是国产，毕竟是阿里，所以还是慎用。想想 <strong>Dubbo 放弃维护</strong> 和 <strong>Ant Design 圣诞彩蛋</strong>，一切皆是不言自明的！</p><p>现在再看 <code>react</code>，感觉简单了一些。一方面，由于 <code>vuejs</code> 的原因，接触到了 <code>es6/npm/yarn/webpack/babel/vscode</code> 这些前端工具链，对现代前端有了基本的概念与认知。不再因为某些代码看不懂而卡住，也不会面对各种工具一脸懵逼了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue 使用 git-rev-sync 确定线上发布版本号</title>
    <link href="/p/c2faf4d93d52495b90518b8a61d72f9e/"/>
    <url>/p/c2faf4d93d52495b90518b8a61d72f9e/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前公司仍然没有做 CI 持续集成，而是使用手动方式（脚本）部署项目。有时候，已经修改了代码，而线上（测试环境）却还没有部署，导致测试人员认为问题仍然没有修复。那么，怎么确定线上部署的代码版本呢？难道是打开线上网站查看某个功能是否完成了么？有没有更高效的方法呢？<br>吾辈找到的解决方案便是 <a href="https://www.npmjs.com/package/git-rev-sync">git-rev-sync</a>。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官网描述只有一句话: 同步获取当前的 git commit 哈希，标签，计数，分支或提交消息。从 <a href="https://github.com/tblobaum/git-rev">git-rev</a> 分叉。<br>实际上就是一个同步获取当前 git commit 最新提交的一些信息，而我们可以将它挂载到 <code>window</code> 对象上，方便线上快速确定发布代码的版本。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yarn add -D git-rev-sync<br></code></pre></td></tr></table></figure><h3 id="在-vue-打包文件中读取-git-信息"><a href="#在-vue-打包文件中读取-git-信息" class="headerlink" title="在 vue 打包文件中读取 git 信息"></a>在 vue 打包文件中读取 git 信息</h3><p>只有在打包时我们才能读取到 git 信息（本地 nodejs 运行），而我们读取完之后不能直接挂载到 <code>window</code> 对象上，因为打包时处于 nodejs 环境，<code>window</code> 对象并不存在，这时候就需要用到 Vue 提供的环境变量功能了。</p><blockquote><p>引用<br><a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Vue Cli 在客户端侧代码中使用环境变量</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue.config.js</span><br><span class="hljs-keyword">const</span> git = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;git-rev-sync&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传递打包时的环境变量到前端必须是以 VUE_APP_ 开头且必须只能是字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@type <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br>process.env.VUE_APP_GIT = <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>  short: git.short(),<br>  long: git.long(),<br>  branch: git.branch(),<br>  count: git.count(),<br>  date: git.date(),<br>  isDirty: git.isDirty(),<br>  isTagDirty: git.isTagDirty(),<br>  message: git.message(),<br>  remoteUrl: git.remoteUrl(),<br>  tag: git.tag(),<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="在-main-js-中读取环境变量并挂载到-window-对象上"><a href="#在-main-js-中读取环境变量并挂载到-window-对象上" class="headerlink" title="在 main.js 中读取环境变量并挂载到 window 对象上"></a>在 main.js 中读取环境变量并挂载到 window 对象上</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在 window 对象上添加 git 属性便于查看指定版本</span><br><span class="hljs-built_in">window</span>.git = <span class="hljs-built_in">JSON</span>.parse(process.env.VUE_APP_GIT);<br></code></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190927082613.png" alt="效果图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说到底需要这个工具的原因是因为部署的代码与最新的代码不一致，如果有了持续集成工具自动部署的话便不会存在这个问题了呢（这或许就是为什么该项目 <a href="https://github.com/kurttheviking/git-rev-sync-js/stargazers">star</a> 这么少的原因？）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于提问与帮助</title>
    <link href="/p/ccafc03fb2db486ba71f0863612aa449/"/>
    <url>/p/ccafc03fb2db486ba71f0863612aa449/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>不知从何时起，帮助别人似乎开始变成了一件吃力不讨好的事情。刚刚吾辈在 QQ 里面看到这样的几句发言，所以熬夜写了这篇内容。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129232524.png" alt="受助者的发言"></p><p>真以为别人给予帮助是一种义务了，告诉你怎么查就是在帮助你了。<strong>总不能把饭端到你面前，却还要嚷嚷着要别人喂你吃吧？</strong><br>而且，帮助是要花费时间和精力的。很多人并不是总有时间来帮你找资料的，或许我们也只是在上班的时候想稍微休息一下，看到你的问题，就谈一下大概的解决方向而已。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>当你想要提问时，如何更加清晰的描述你的问题让别人更容易帮助你也是你的义务。不要觉得随便提问一个：<em>xx 应该怎么做？</em> 就会有人很快的回答你。吾辈个人认为提问之前最好了解下面几点</p><ul><li><strong>不要提一些容易产生争端的问题</strong><br>例如 _<code>Java</code> 和 <code>PHP</code> 哪个更好？_<br>这种问题不仅容易引战，更是毫无意义。不谈使用场合，比较则无意义。就连初中生都知道对比实验应该控制 <strong>环境变量</strong>，难道如此简单的事情你都不清楚，你是 <strong>巨婴</strong> 么？</li><li><strong>如果是纯粹知识性的问题最好先查询官网</strong><br>例如 <code>Spring</code> 怎么集成 <code>Mybatis</code>？<br>这种连官方文档都没过一遍就来问，就算说了也只能是鸡同鸭讲，对牛弹琴罢了。这种时候你需要的是 <strong>学习</strong> 而不是 <strong>提问</strong>。</li><li><strong>大部分问题已经被解决过了</strong><br>虽然不想承认，但我们的所知所想所遇已然在这个世界上重复了无数次，善用搜索引擎很重要 —— 这里吾辈只推荐 <strong>Google</strong>，不推荐的只有 <strong>百度</strong>。</li><li><strong>你遇到了非常冷门的问题</strong><br>那你要描述你的问题，让别人能简单的还原问题，才能更好的解决你的问题，最好附上一个可重现的 <code>github</code> 示例仓库。推荐提问的网站：国外 <a href="https://segmentfault.com/questions">stack overflow</a>，国内 <a href="https://segmentfault.com/questions">segmentfault</a>，提问之前可以看一下 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">提问的智慧</a>。</li></ul><h2 id="标准示例"><a href="#标准示例" class="headerlink" title="标准示例"></a>标准示例</h2><p>下面是在 Segmentfault 提问时的简单规范</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129233329.png" alt="Segmentfault 简单规范"></p><p>下面是一个简单的提问示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># JavaScript 中如何获取子类？</span><br><br>如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？<br><br>例如下面定义了三个类 <span class="hljs-code">`A, B, C`</span><br><br><span class="hljs-code">```js</span><br><span class="hljs-code">class A &#123;&#125;</span><br><span class="hljs-code">class B extends A &#123;&#125;</span><br><span class="hljs-code">class C extends A &#123;&#125;</span><br><span class="hljs-code">```</span><br><br>吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)<br><br>---<br><br>有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌<br></code></pre></td></tr></table></figure><p>渲染之后</p><hr><h1 id="JavaScript-中如何获取子类？"><a href="#JavaScript-中如何获取子类？" class="headerlink" title="JavaScript 中如何获取子类？"></a>JavaScript 中如何获取子类？</h1><p>如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？</p><p>例如下面定义了三个类 <code>A, B, C</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)</p><hr><p>有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌</p><hr><p>是的，这是由 <code>Markdown</code> 写出来的。作为提问者，让别人能更简单知道自己的问题是必要的，而 <code>Markdown</code> 天生的 <strong>写作语言</strong>。所以吾辈也建议使用 <code>Markdown</code> 进行提问，至少，能传递的信息要比纯文本丰富很多，不是么？</p><h2 id="终末"><a href="#终末" class="headerlink" title="终末"></a>终末</h2><p>最后，吾辈个人认为如果解决了问题之后，作为提问者也有必要将之分享出来，避免后人继续踩坑。分享的方式可以使用 <strong>博客</strong>，<strong>微信公众号</strong> 之类的方式，如果能将一个问题讲明白给别人听，那才说明自己懂得了如何解决这个问题！</p><blockquote><p>吾辈在 segementfault 上的提问 <a href="https://segmentfault.com/q/1010000017910469">JavaScript 中如何获取子类？</a> 以及之后写的一篇博客 <a href="https://blog.rxliuli.com/p/e17d1a04/">JavaScript 避免使用 if-else 的方法</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 自定义标签的 src 属性不能使用相对路径</title>
    <link href="/p/cd8a463c0a404ba594b14d48579ed064/"/>
    <url>/p/cd8a463c0a404ba594b14d48579ed064/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在使用 Vuetify 时突然遇到的，明明 <code>img</code> 标签就可以使用相对路径获取到图片，而 Veutify 的组件 <code>v-img</code> 却不能使用。</p><p>如下面 3 种加载图片的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 正常加载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">v-img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;require(&#x27;../../assets/logo.png&#x27;)&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 无法加载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">v-img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../assets/logo.png&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 正常加载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../assets/logo.png&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>吾辈在 <a href="https://segmentfault.com/q/1010000016871400">segmentfault</a> 上的提问</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>是的，居然必须用 <code>require()</code> 引入图片才能生效，那为什么 <code>img</code> 标签可以直接使用相对路径呢？这和 <a href="https://vue-loader-v14.vuejs.org/zh-cn/configurations/asset-url.html">vue-loader 资源路径处理</a> 有关系。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181101130706.png" alt="官方资源路径处理"></p><p>官方明确指出会将所有资源路径作为模块依赖，也就是后台 <code>vue-loader</code> 帮我们转换成 <code>require()</code> 的形式了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="vue-cli-3"><a href="#vue-cli-3" class="headerlink" title="vue cli 3"></a>vue cli 3</h3><p>vue cli 3 的配置项 API 发生了改变，由 <code>transformToRequire</code> 改为 <code>transformAssetUrls</code>，而且配置方式也不再是直接修改 webpack 配置文件，而是修改 <code>vue.config.js</code> 这个经过包装后的文件。现在，最新的配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  chainWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    config.module<br>      .rule(<span class="hljs-string">&quot;vue&quot;</span>)<br>      .use(<span class="hljs-string">&quot;vue-loader&quot;</span>)<br>      .loader(<span class="hljs-string">&quot;vue-loader&quot;</span>)<br>      .tap(<span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          ...options,<br>          <span class="hljs-comment">//修复静态资源引用的问题 vue cli 2 =&gt; vue cli 3 升级之后配置项由 transformToRequire 改为 transformAssetUrls</span><br>          transformAssetUrls: &#123;<br>            video: [<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;poster&quot;</span>],<br>            source: <span class="hljs-string">&quot;src&quot;</span>,<br>            img: <span class="hljs-string">&quot;src&quot;</span>,<br>            image: <span class="hljs-string">&quot;xlink:href&quot;</span>,<br>            <span class="hljs-comment">// 在这里添加需要使用静态资源的自定义元素</span><br>            <span class="hljs-string">&quot;a-avatar&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>,<br>          &#125;,<br>        &#125;;<br>      &#125;);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>具体参考<br><a href="https://vue-loader.vuejs.org/zh/migrating.html#%E5%BA%9F%E5%BC%83%E7%9A%84%E9%80%89%E9%A1%B9">Vue Loader =&gt; 从 v14 迁移 =&gt; 废弃的选项</a><br><a href="https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">Vue Cli 3 =&gt; webpack 相关 =&gt; 链式操作 (高级) =&gt; 修改 Loader 选项</a></p></blockquote><h3 id="vue-cli-2"><a href="#vue-cli-2" class="headerlink" title="vue cli 2"></a>vue cli 2</h3><p>那么，Veutify 组件中的 <code>src</code> 不能使用相对路径的原因就很明确了。因为 <code>vue-loader</code> 并不知道我们要把 <code>v-img</code> 的 <code>src</code> 属性转换成 <code>require()</code> 依赖。我们找到 <code>vue-loader</code> 配置处，在 <code>options.transformToRequire</code> 中加上 <code>v-img</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vuetify 框架的 src 标签也需要自动转换为 require</span><br><span class="hljs-string">&#x27;v-img&#x27;</span>: <span class="hljs-string">&#x27;src&#x27;</span><br></code></pre></td></tr></table></figure><p>吾辈的配置文件在 <em>build &gt; vue-loader.conf.js</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./utils&quot;</span>);<br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../config&quot;</span>);<br><span class="hljs-keyword">const</span> isProduction = process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span>;<br><span class="hljs-keyword">const</span> sourceMapEnabled = isProduction<br>  ? config.build.productionSourceMap<br>  : config.dev.cssSourceMap;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  loaders: utils.cssLoaders(&#123;<br>    sourceMap: sourceMapEnabled,<br>    extract: isProduction,<br>  &#125;),<br>  cssSourceMap: sourceMapEnabled,<br>  cacheBusting: config.dev.cacheBusting,<br>  transformToRequire: &#123;<br>    video: [<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;poster&quot;</span>],<br>    source: <span class="hljs-string">&quot;src&quot;</span>,<br>    img: <span class="hljs-string">&quot;src&quot;</span>,<br>    image: <span class="hljs-string">&quot;xlink:href&quot;</span>,<br>    <span class="hljs-string">&quot;v-img&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://vue-loader-v14.vuejs.org/zh-cn/options.html#transformtorequire">vue-loader 官方文档参考</a></p></blockquote><p>然后重启 <code>npm run dev</code> 刷新一下就行啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 使用 fetch 上传文件</title>
    <link href="/p/ce80e7bf68d6471783155673cef45b36/"/>
    <url>/p/ce80e7bf68d6471783155673cef45b36/</url>
    
    <content type="html"><![CDATA[<p><code>fetch</code> 是 ES6 的一个新的特性，用来简化处理异步的 Ajax 请求。</p><blockquote><p>fetch 可以参考 <a href="https://developer.mozilla.org/">MDN</a> 上的教程：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></p></blockquote><p>假设后端（Java）有一个用于上传文件的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 上传文件</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> imgFile</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/uploadFile&quot;, method = RequestMethod.POST)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OperationResult <span class="hljs-title">uploadFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;imgFile&quot;)</span> MultipartFile imgFile)</span></span>;<br></code></pre></td></tr></table></figure><p>前端中只要使用如下代码即可上传一个文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这里是用来演示的 html 内容 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;imgFile&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#imgFile&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 创建一个 FormData 对象</span><br>  <span class="hljs-keyword">const</span> fd = <span class="hljs-keyword">new</span> FormData();<br>  <span class="hljs-comment">// 得到 File 对象</span><br>  <span class="hljs-keyword">const</span> file = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#imgFile&quot;</span>).files[<span class="hljs-number">0</span>];<br>  fd.append(<span class="hljs-string">&quot;imgFile&quot;</span>, file);<br>  <span class="hljs-comment">// 这里的 url 是上传链接，此处为 /uploadFile</span><br>  fetch(url, &#123;<br>    method: <span class="hljs-string">&quot;POST&quot;</span>,<br>    body: fd,<br>    <span class="hljs-comment">// 注：此处不需要设置 headers</span><br>  &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 之后的处理</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>和 <code>jquery ajax</code> 的感觉差不多，不过能实现效果就好啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在 VSCode 中使用路径别名也有提示</title>
    <link href="/p/d4e81c9032974019bf96a08272608fd9/"/>
    <url>/p/d4e81c9032974019bf96a08272608fd9/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在学 ReactJS，遇到了一个很奇怪的问题。当吾辈在 webpack 配置中配置了路径别名之后，VSCode 再输入路径便没有了提示。</p><p>路径别名配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">alias: &#123;<br>  <span class="hljs-comment">// Support React Native Web</span><br>  <span class="hljs-comment">// https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/</span><br>  <span class="hljs-string">&#x27;react-native&#x27;</span>: <span class="hljs-string">&#x27;react-native-web&#x27;</span>,<br>  <span class="hljs-string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;../src&#x27;</span>),<br>&#125;,<br></code></pre></td></tr></table></figure><p>吾辈也安装了 <a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a> 插件，然而这毫无意义，仍然是只有在相对路径的情况下才会提示。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>抱着这个疑问，吾辈稍微去搜索了一下。然后，找到了 <a href="https://segmentfault.com/q/1010000014941483">webpack 自定义别名后，VScode 路径提示问题</a> 这个问题。在下面的回答中，吾辈找到了答案。</p><blockquote><p>注：这里已采纳的答案实际上应该是复制少了一个括号导致实际使用会出错，不过确实是正确答案。</p></blockquote><p>在项目根目录下添加 <code>jsconfig.json</code> 并添加以下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,<br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后重启 VSCode，之后，一切便恢复了理想状态！</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>那么，<code>jsconfig.json</code> 到底是什么神奇的东西，为什么能影响到 VSCode 的提示呢？吾辈找到了 VSCode 官网上的文档，文档上对此的说明是：<strong>VSCode 大部分功能都是开箱即用，然而有些却需要进行一些基本的配置才能获得最佳体验，jsconfig 就是用来配置 JavaScript 语言的相关功能。</strong></p><p>所以，原因明了了，这是 VSCode 内置的功能，就是为了便于开发的。而我们仅仅需要做一些简单的配置，即可使用这些功能。<br>吾辈也使用 <code>tsc</code> 命令生成了一份 <code>jsconfig.json</code>（由 <code>tsconfig.json</code> 改名），泥萌可以复制并按照自己的需求修改其中的配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-comment">/* Basic Options */</span><br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES2018&quot;</span> <span class="hljs-comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;,&#x27;ES2018&#x27; or &#x27;ESNEXT&#x27;. */</span>,<br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;es2015&quot;</span> <span class="hljs-comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */</span>,<br>    <span class="hljs-comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span><br>    <span class="hljs-comment">// &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */</span><br>    <span class="hljs-comment">// &quot;checkJs&quot;: true,                       /* Report errors in .js files. */</span><br>    <span class="hljs-comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span><br>    <span class="hljs-comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span><br>    <span class="hljs-comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span><br>    <span class="hljs-comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span><br>    <span class="hljs-comment">// &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */</span><br>    <span class="hljs-comment">// &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */</span><br>    <span class="hljs-comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span><br>    <span class="hljs-comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span><br>    <span class="hljs-comment">// &quot;removeComments&quot;: true,                /* Do not emit comments to output. */</span><br>    <span class="hljs-comment">// &quot;noEmit&quot;: true,                        /* Do not emit outputs. */</span><br>    <span class="hljs-comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span><br>    <span class="hljs-comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span><br>    <span class="hljs-comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span><br><br>    <span class="hljs-comment">/* Strict Type-Checking Options */</span><br>    <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">/* Enable all strict type-checking options. */</span>,<br>    <span class="hljs-comment">// &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span><br>    <span class="hljs-comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span><br>    <span class="hljs-comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span><br>    <span class="hljs-comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span><br>    <span class="hljs-comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span><br>    <span class="hljs-comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span><br>    <span class="hljs-comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span><br><br>    <span class="hljs-comment">/* Additional Checks */</span><br>    <span class="hljs-comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span><br>    <span class="hljs-comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span><br>    <span class="hljs-comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span><br>    <span class="hljs-comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span><br><br>    <span class="hljs-comment">/* Module Resolution Options */</span><br>    <span class="hljs-comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span> <span class="hljs-comment">/* Base directory to resolve non-absolute module names. */</span>,<br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>]<br>    &#125; <span class="hljs-comment">/* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span>,<br>    <span class="hljs-comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span><br>    <span class="hljs-comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span><br>    <span class="hljs-comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span><br>    <span class="hljs-comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span><br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span><br>    <span class="hljs-comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span><br>    <span class="hljs-comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span><br>    <span class="hljs-comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span><br>    <span class="hljs-comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span><br><br>    <span class="hljs-comment">/* Experimental Options */</span><br>    <span class="hljs-comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span><br>    <span class="hljs-comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 加载全部资源后再使用</title>
    <link href="/p/d5ae689f677a41bd8e1281f6b36cf55e/"/>
    <url>/p/d5ae689f677a41bd8e1281f6b36cf55e/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>客户需要一次性将视频全部缓冲完成再进行观看而非看一段缓冲一段，所以就看了一下有没有什么方法能够做到，结果顺便还写了一个通用的加载资源的方法。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基本思路是使用 <code>ajax</code>(<code>fetch</code>) 将资源先加载到本地，然后生成一个本地的 url，最后将本地资源链接赋值给需要资源的元素上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将 url 中的内容加载到元素上</span><br><span class="hljs-comment"> * 注：domSelector 必须有 src 属性用以将加载完成的资源赋值给其，加载默认是异步的</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>url url 资源</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;document&#125;</span> </span>domSelector dom 选择器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> </span>init 初始化参数, 实为 fetch() 的参数以及一些自定义的参数</span><br><span class="hljs-comment"> * 关于 fetch 具体可以参考 &lt;https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch&gt;</span><br><span class="hljs-comment"> * 自定义的参数有:</span><br><span class="hljs-comment"> * before: 加载之前的方法，例如可以设置一个弹窗或者遮罩告诉用户资源正在加载中</span><br><span class="hljs-comment"> * after: 加载完成之后的方法，例如可以设置一个加载完成的动画提醒一下用户</span><br><span class="hljs-comment"> * error: 发生异常时的方法，例如可以设置一个错误提示通知用户加载异常需要刷新了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadResource</span>(<span class="hljs-params">url, domSelector, init</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!init) &#123;<br>    init = &#123;&#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (init.before &amp;&amp; <span class="hljs-keyword">typeof</span> init.before === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    init.before();<br>  &#125;<br>  <span class="hljs-comment">// 如果没有自定义缓存的话就设置缓存</span><br>  init.cache = init.cache || <span class="hljs-string">&quot;force-cache&quot;</span>;<br>  <span class="hljs-comment">// 如果没有自定义错误处理就设置一下错误处理</span><br>  init.error =<br>    init.error || (<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`request was wrong: <span class="hljs-subst">$&#123;error&#125;</span>`</span>));<br>  fetch(url, init)<br>    <span class="hljs-comment">// 判断返回的状态是否正常</span><br>    .then(<span class="hljs-function">(<span class="hljs-params">rep</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (rep.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">return</span> rep;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`response status error <span class="hljs-subst">$&#123;rep.status&#125;</span>`</span>);<br>      &#125;<br>    &#125;)<br>    <span class="hljs-comment">// 转换资源</span><br>    .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> data.blob())<br>    .then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 生成一个本地的 url 并赋值给 src 属性</span><br>      domSelector.src = <span class="hljs-built_in">window</span>.URL.createObjectURL(blob);<br>      <span class="hljs-keyword">if</span> (init.after &amp;&amp; <span class="hljs-keyword">typeof</span> init.after === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        init.after();<br>      &#125;<br>    &#125;)<br>    .catch(init.error);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>假如有一个 <code>video</code> 元素需要加载视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么使用该方法的 <code>JavaScript</code> 代码就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 要加载的 url 资源</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;/html/testVideo.m4&quot;</span>;<br><span class="hljs-comment">// 资源的容器，这里是一个视频元素</span><br><span class="hljs-keyword">var</span> video = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#video&quot;</span>);<br><br><span class="hljs-comment">// 此处使用第三个参数仅为演示，不需要的话忽略即可。。。</span><br>loadResource(url, video, &#123;<br>  before: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;video load before&quot;</span>),<br>  after: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;video load after&quot;</span>),<br>  error: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`video load error: <span class="hljs-subst">$&#123;error&#125;</span>`</span>),<br>&#125;);<br><span class="hljs-comment">// 即可以：</span><br>loadResource(url, video);<br></code></pre></td></tr></table></figure><blockquote><p>注：此方法不仅可以加载视频，也可以加载 audio, img 等拥有 src 属性的二进制资源</p><p>这个方法同样也已经丢到了 <a href="https://gist.github.com/rxliuli/1bf04abd0e91718a901b97762beb0eb9">GitHub Gist</a> 上面啦</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git Push 提示不支持具有 Socks5 方案的代理</title>
    <link href="/p/db2c1059578c496a90628f9af942e3db/"/>
    <url>/p/db2c1059578c496a90628f9af942e3db/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 <code>Git Push</code> 提交代码到远程服务器时提示了一个错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fatal: NotSupportedException encountered.<br>   ServicePointManager 不支持具有 socks5 方案的代理。<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>然而之后还是正常提交成功了，实际上问题是：</p><ol><li> 配置了本地的 <code>socks5</code> 的代理（<code>Shadowsocks</code> 之类的代理软件）</li><li> 配置了远程服务器 <code>Git</code> 服务端的 <code>SSH</code></li><li> 本地提交代码到远程服务器时使用的是 <code>http/https</code> 协议</li></ol><p>这三者只要有一个不满足就不会出现这个错误了</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>取消代理<br> 使用以下简单命令即可取消代理</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><blockquote><p>注：取消代理会出现另外一个错误，所以并不能解决实际问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure></blockquote></li><li><p>取消远程的 <code>SSH</code><br> 在下面的页面中删除你的 <code>SSH Keys</code> 即可</p><blockquote><ul><li><a href="https://github.com/settings/keys">GitHub</a></li><li><a href="https://bitbucket.org/account/user/your_username/ssh-keys/">Bitbucket</a></li></ul></blockquote></li><li><p>提交内容到远程 <code>Git</code> 服务器时选择 <code>SSH</code> 协议<br> 设置远程仓库为 <code>SSH</code> 协议，例如 <code>GitHub</code> 的 <code>SSH</code> 链接就是 &lt;<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:rxliuli/rxliuli.github.io.git&gt;</p></li></ol><p>好了，关于 <code>Git</code> 提示错误 <em>Git Push 提示不支持具有 Socks5 方案的代理</em> 就到这里啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Greasemonkey 踩坑之路</title>
    <link href="/p/f1a15a514a6a4c0488a96062a139221d/"/>
    <url>/p/f1a15a514a6a4c0488a96062a139221d/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#greasemonkey-%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF">Greasemonkey 踩坑之路</a><ul><li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li><li><a href="#window-%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%92%8C%E5%A4%96%E9%83%A8%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE">window 对象不能和外部交换数据</a></li><li><a href="#greasemonkey-api-%E6%98%BE%E7%A4%BA-undefined">Greasemonkey API 显示 undefined</a></li><li><a href="#%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8">内存爆炸</a></li><li><a href="#greasemonkey-%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E5%A4%AA%E6%99%9A">Greasemonkey 加载时机太晚</a><ul><li><a href="#%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%8D%E8%B0%83%E7%94%A8%E4%BE%8B%E5%A6%82%E7%AD%89%E4%B8%AA%E5%87%A0%E7%A7%92-greasemonkey-%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E5%B0%B1%E5%8A%A0%E8%BD%BD%E4%BA%86">等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了</a></li><li><a href="#%E5%BB%B6%E8%BF%9F%E5%88%B0-greasemonkey-%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%86%8D%E4%B8%8E%E4%B9%8B%E4%BA%A4%E4%BA%92">延迟到 Greasemonkey 脚本加载完成再与之交互</a></li><li><a href="#%E6%9A%B4%E9%9C%B2%E5%87%BA%E9%9C%80%E8%A6%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%89%E5%88%B0-greasemonkey-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%9B%9E%E8%B0%83">暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调</a></li></ul></li></ul></li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在玩 Greasemonkey 脚本，遇到了各种奇怪的问题，便于此处统一记录一下。</p><h2 id="window-对象不能和外部交换数据"><a href="#window-对象不能和外部交换数据" class="headerlink" title="window 对象不能和外部交换数据"></a>window 对象不能和外部交换数据</h2><p>场景</p><p>在写 Greasemonkey 脚本时遇到的一个奇怪的问题，吾辈想要把某些数据添加到 <code>window</code> 对象上，方便在 DevTool console 中进行测试。然而却由此印发了一个新的问题，即 <code>window</code> 对象不是真正的 <code>window</code> 对象的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         Testing</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  用来测试的 userjs 脚本</span><br><span class="hljs-comment">// @author       rxliuli</span><br><span class="hljs-comment">// @include     http://*</span><br><span class="hljs-comment">// @includehttps://*</span><br><span class="hljs-comment">// @grant        MIT</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br>  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">window</span>.rxliuli = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这里是 rxliuli 编写的 user.js 脚本&quot;</span>);<br>    &#125;;<br>    <span class="hljs-built_in">window</span>.rxliuli();<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>控制台正常输出了一句话。然而，当吾辈在 console 中输入 <code>window.rxliuli</code> 的结果却是 <code>undefined</code>。</p><hr><p>解决</p><p>吾辈估计又是 Greasemonkey 自身的问题，所以不得不去翻了 <a href="https://wiki.greasespot.net/">Wiki</a> 上查找，直到看到了 <a href="https://wiki.greasespot.net/Greasemonkey_Manual:Environment">Greasemonkey Manual:Environment</a>。里面有这么一段话</p><blockquote><p>Depending on the usage, the special Greasemonkey environment may seem perfectly normal, or excessively limiting.<br>The Greasemonkey environment is a vanilla XPCNativeWrapper of the content window, with only certain extra bits added in to emulate a normal environment, or changed. Specifically:</p><ul><li>window is an XPCNativeWrapper of the content window.</li><li>document is the document object of the XPCNativeWrapper window object.</li><li>XPathResult is added so that document.evaluate() works.</li><li>Unless the @unwrap metadata imperative is present in the user script header, the entire script is wrapped inside an anonymous function, to guarantee the script’s identifiers do not collide with identifiers present in the Mozilla JavaScript sandbox. This function wrapper captures any function definitions and var variable declarations made (e.g. var i = 5;) into the function’s local scope. Declarations made without var will however end up on the script’s this object, which in Greasemonkey is the global object, contrary to in the normal browser object model, where the window object fills this function. In effect, after i = 5;, the values of window[‘i’] and window.i remain undefined, whereas this[‘i’] and this.i will be 5. See also: Global object</li><li>In order to access variables on the page, use the unsafeWindow object. To use values defined in a script, simply reference them by their names.</li></ul></blockquote><p>大意是 Greasemonkey 为了安全所以 Greasemonkey 脚本是在沙箱中执行的，并且限制了一些内容。其中就包括了 <code>window</code> 对象并非浏览器的原生对象，而是 <code>XPCNativeWrapper</code>。<br>所以，<code>XPCNativeWrapper</code> 是什么。。。？（一个 Greasemonkey 的坑太多了吧 #吐血）<br>吾辈找到了两篇文章</p><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/XPCNativeWrapper">XPCNat ive Wrapper</a></li><li><a href="http://kb.mozillazine.org/XPCNativeWrapper">Use XPCNativeWrapper</a></li></ul><p>看完之后表示只知道 <code>XPCNativeWrapper</code> 是在扩展中用来保护不受信任的对象，并非浏览器客户端本身的 API。</p><p>好吧，说了这么多解决方案是什么呢？</p><p>答案很简单，其实使用 <a href="https://wiki.greasespot.net/UnsafeWindow">unsafeWindow</a> 对象就能像使用原生的 <code>window</code> 对象行为一致，即便这是不推荐的方法，但有时仍然是必须的！</p><h2 id="Greasemonkey-API-显示-undefined"><a href="#Greasemonkey-API-显示-undefined" class="headerlink" title="Greasemonkey API 显示 undefined"></a>Greasemonkey API 显示 undefined</h2><p>场景</p><p>在 <a href="https://wiki.greasespot.net/Greasemonkey_Manual:API">Greasemonkey 手册：API</a> 写出的 API 有很多都不能正常使用，吾辈打印下来的结果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         test</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  test</span><br><span class="hljs-comment">// @match        *</span><br><span class="hljs-comment">// @author       rxliuli</span><br><span class="hljs-comment">// @grant        MIT</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br><br>  <span class="hljs-built_in">console</span>.log(GM);<br>  <span class="hljs-built_in">console</span>.log(GM.info);<br>  <span class="hljs-built_in">console</span>.log(GM.deleteValue);<br>  <span class="hljs-built_in">console</span>.log(GM.getValue);<br>  <span class="hljs-built_in">console</span>.log(GM.listValues);<br>  <span class="hljs-built_in">console</span>.log(GM.setValue);<br>  <span class="hljs-built_in">console</span>.log(GM.getResourceUrl);<br>  <span class="hljs-built_in">console</span>.log(GM.notification);<br>  <span class="hljs-built_in">console</span>.log(GM.openInTab);<br>  <span class="hljs-built_in">console</span>.log(GM.setClipboard);<br>  <span class="hljs-built_in">console</span>.log(GM.setClipboard);<br>  <span class="hljs-built_in">console</span>.log(unsafeWindow);<br>&#125;)();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225309.png" alt="Greasemonkey API 显示 undefined"></p><p>测试环境如下：</p><ul><li>Windows 10 Ltsc</li><li>Chrome 71</li><li>tampermonkey 4.7.44</li></ul><hr><p>解决</p><p>吾辈在翻 <a href="https://github.com/sindresorhus/globals/issues/122">GitHub Issue</a> 找到了问题所在，原因是这些 API 必须要手动获取准许才行。<br>即使用 <code>// @grant GM.[Function]</code> 来获取需要的 API，所以吾辈的脚本变成了下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         test</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  test</span><br><span class="hljs-comment">// @match        *</span><br><span class="hljs-comment">// @author       rxliuli</span><br><span class="hljs-comment">// @grant        MIT</span><br><span class="hljs-comment">// @grant        GM.deleteValue</span><br><span class="hljs-comment">// @grant        GM.getValue</span><br><span class="hljs-comment">// @grant        GM.listValues</span><br><span class="hljs-comment">// @grant        GM.setValue</span><br><span class="hljs-comment">// @grant        GM.getResourceUrl</span><br><span class="hljs-comment">// @grant        GM.notification</span><br><span class="hljs-comment">// @grant        GM.openInTab</span><br><span class="hljs-comment">// @grant        GM.setClipboard</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(GM);<br>  <span class="hljs-built_in">console</span>.log(GM.info);<br>  <span class="hljs-built_in">console</span>.log(GM.deleteValue);<br>  <span class="hljs-built_in">console</span>.log(GM.getValue);<br>  <span class="hljs-built_in">console</span>.log(GM.listValues);<br>  <span class="hljs-built_in">console</span>.log(GM.setValue);<br>  <span class="hljs-built_in">console</span>.log(GM.getResourceUrl);<br>  <span class="hljs-built_in">console</span>.log(GM.notification);<br>  <span class="hljs-built_in">console</span>.log(GM.openInTab);<br>  <span class="hljs-built_in">console</span>.log(GM.setClipboard);<br>  <span class="hljs-built_in">console</span>.log(GM.setClipboard);<br>  <span class="hljs-built_in">console</span>.log(unsafeWindow);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>问题解决了，现在，所有的 API 都有值了。</p><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225919.png" alt="GM API 都有值了"></p><h2 id="内存爆炸"><a href="#内存爆炸" class="headerlink" title="内存爆炸"></a>内存爆炸</h2><p>场景</p><p>使用了 <code>GM.setValue()/GM.getValue()</code> 两个 API，结果内存分分钟爆炸。吾辈安装 Chrome 以来第一次碰到加载网页能把内存耗尽的情况，果然 GM 的限制不是没有道理的呢<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220002112.png" alt="内存爆炸"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220013001.png" alt="浏览器崩溃"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         Testing</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @match        *</span><br><span class="hljs-comment">// @version      0.1</span><br><span class="hljs-comment">// @description  用来测试的 userjs 脚本</span><br><span class="hljs-comment">// @author       rxliuli</span><br><span class="hljs-comment">// @grant        GM.getValue</span><br><span class="hljs-comment">// @grant        GM.setValue</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br><br>  <span class="hljs-keyword">var</span> domains = &#123;<br>    domainsName: <span class="hljs-string">&quot;domains&quot;</span>,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">list</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">var</span> valueStr = GM.getValue(<span class="hljs-built_in">this</span>.domainsName);<br>      <span class="hljs-keyword">if</span> (!valueStr) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(valueStr);<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">var</span> defaultArr = [];<br>        <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.set(defaultArr);<br>        <span class="hljs-keyword">return</span> defaultArr;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>      <span class="hljs-keyword">await</span> GM.setValue(<span class="hljs-built_in">this</span>.domainsName, <span class="hljs-built_in">JSON</span>.stringify(arr));<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.list();<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">0</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> i);<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> domains.set(arr);<br>    <span class="hljs-built_in">console</span>.log(result);<br>  &#125;<br><br>  init();<br>&#125;)();<br></code></pre></td></tr></table></figure><hr><p>解决</p><p>Debug 之后发现是调用 <code>GM.setValue()</code> 没有使用 <code>await</code> 造成的异步请求数量不断积累最终导致网页崩溃。果然 Promise 什么的还是要小心一点好呀<br>当然，不信的话你也可以新建一个 Greasemonkey 脚本尝试一下内存爆炸的感觉咯</p><blockquote><p>递归不是主要问题，吾辈 PC 上的 Chrome 最多到 1.4w+ 次递归就会抛出异常（网页没有崩溃），还没到 1.4w+ 次，所以说递归不是主要问题呀</p></blockquote><h2 id="Greasemonkey-加载时机太晚"><a href="#Greasemonkey-加载时机太晚" class="headerlink" title="Greasemonkey 加载时机太晚"></a>Greasemonkey 加载时机太晚</h2><p>场景</p><p>Greasemonkey 的加载是在页面加载完毕时，类似于 <code>window.onload</code>，所以造成了一个问题：如果想要在网站的 JavaScript 代码中与 Greasemonkey 脚本交互，那么必须要等到 Greasemonkey 加载完成，而加载完成的时机是不确定的。</p><p>吾辈目前想要的解决方案有三种</p><h3 id="等待一段时间再调用，例如等个几秒-Greasemonkey-脚本可能就加载了"><a href="#等待一段时间再调用，例如等个几秒-Greasemonkey-脚本可能就加载了" class="headerlink" title="等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了"></a>等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了</h3><p>思路</p><p>现在没有人，我等会再来问一次！</p><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> wait = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现和调用最为简单，但无法保证等待之后就一定能获得资源了</span><br>wait(<span class="hljs-number">1000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(完成));<br></code></pre></td></tr></table></figure><h3 id="延迟到-Greasemonkey-脚本加载完成再与之交互"><a href="#延迟到-Greasemonkey-脚本加载完成再与之交互" class="headerlink" title="延迟到 Greasemonkey 脚本加载完成再与之交互"></a>延迟到 Greasemonkey 脚本加载完成再与之交互</h3><p>思路</p><p>有人吗? 没有的话我等会再来问！</p><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 轮询等待指定资源加载完毕再执行操作</span><br><span class="hljs-comment"> * 使用 Promises 实现，可以使用 ES7 的 &#123;<span class="hljs-doctag">@async</span>&#125;/&#123;<span class="hljs-doctag">@await</span>&#125; 调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>resourceFn 判断必须的资源是否存在的方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>options 选项</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitResource</span>(<span class="hljs-params">resourceFn, options</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> optionsRes = <span class="hljs-built_in">Object</span>.assign(<br>    &#123;<br>      interval: <span class="hljs-number">1000</span>,<br>      max: <span class="hljs-number">10</span>,<br>    &#125;,<br>    options<br>  );<br>  <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (resourceFn()) &#123;<br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>        resolve();<br>      &#125;<br>      current++;<br>      <span class="hljs-keyword">if</span> (current &gt;= optionsRes.max) &#123;<br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>        reject(<span class="hljs-string">&quot;等待超时&quot;</span>);<br>      &#125;<br>    &#125;, optionsRes.interval);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> resourceFn = (<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;i++&#125;</span> 次调用`</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;)(<span class="hljs-number">1</span>);<br><br>waitResource(resourceFn, &#123;<br>  interval: <span class="hljs-number">1000</span>,<br>  max: <span class="hljs-number">3</span>,<br>&#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;完成&quot;</span>))<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(err));<br></code></pre></td></tr></table></figure><h3 id="暴露出需要交互的函数等到-Greasemonkey-加载完成后进行回调"><a href="#暴露出需要交互的函数等到-Greasemonkey-加载完成后进行回调" class="headerlink" title="暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调"></a>暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调</h3><p>思路</p><p>现在没有人，有人的时候再叫我！</p><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待被调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>ms 超时毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>name 准备被调用的挂载到 window 对象上的方法名</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitingToCall</span>(<span class="hljs-params">ms, name = <span class="hljs-string">&quot;waiting&quot;</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      reject(<span class="hljs-string">&quot;等待超时&quot;</span>);<br>    &#125;, ms);<br>    <span class="hljs-built_in">window</span>[name] = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timeout);<br>      resolve();<br>    &#125;;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">waitingToCall(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;waiting&quot;</span>)<br>  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;完成&quot;</span>))<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(err));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 自定义限流队列 fetch</title>
    <link href="/p/f1b5596efdf14c3688ed6b99b5abaee0/"/>
    <url>/p/f1b5596efdf14c3688ed6b99b5abaee0/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要它"><a href="#为什么需要它" class="headerlink" title="为什么需要它"></a>为什么需要它</h2><p>有些时候不得不需要限制并发 fetch 的请求数量，避免请求过快导致 IP 封禁</p><h2 id="需要做到什么"><a href="#需要做到什么" class="headerlink" title="需要做到什么"></a>需要做到什么</h2><ul><li>允许限制 fetch 请求同时存在的数量</li><li>时间过久便认为是超时了</li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="暂停请求"><a href="#暂停请求" class="headerlink" title="暂停请求"></a>暂停请求</h3><blockquote><p>该方法的请求是无序的！</p></blockquote><ol><li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li><li>在请求前判断当前请求的数量，添加请求等待数量<ol><li> 如果请求数量已满，则进行等待</li><li> 如果请求数量未满，则删除一个请求等待数量</li></ol></li><li> 请求完成，删除当前请求数量</li></ol><h3 id="等待队列：循环监听"><a href="#等待队列：循环监听" class="headerlink" title="等待队列：循环监听"></a>等待队列：循环监听</h3><blockquote><p>该方法需要使用回调函数</p></blockquote><ol><li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li><li> 在请求前将请求 argments 添加到等待队列中</li><li>使用 <code>setInterval</code> 函数持续监听队列和当前执行的请求数<ul><li>发现请求数量没有到达最大值，且等待队列中还有值，那么就执行一次请求</li></ul></li></ol><h3 id="等待队列：触发钩子"><a href="#等待队列：触发钩子" class="headerlink" title="等待队列：触发钩子"></a>等待队列：触发钩子</h3><ol><li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li><li> 在请求前将请求 argments 添加到等待队列中</li><li> 添加完成，等待当前请求数量未满</li><li> 尝试启动等待队列（钩子）</li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="暂停请求实现"><a href="#暂停请求实现" class="headerlink" title="暂停请求实现"></a>暂停请求实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 fetch 请求添加超时选项</span><br><span class="hljs-comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseTimeout</span>(<span class="hljs-params">fetchPromise, timeout</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> abortFn = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//这是一个可以被reject的promise</span><br>  <span class="hljs-keyword">var</span> abortPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    abortFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      reject(<span class="hljs-string">&quot;abort promise&quot;</span>);<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> abortablePromise = <span class="hljs-built_in">Promise</span>.race([fetchPromise, abortPromise]);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    abortFn();<br>  &#125;, timeout);<br><br>  <span class="hljs-keyword">return</span> abortablePromise;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限制并发请求数量的 fetch 封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestLimiting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; timeout = <span class="hljs-number">10000</span>, limit = <span class="hljs-number">10</span> &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>    <span class="hljs-built_in">this</span>.limit = limit;<br>    <span class="hljs-built_in">this</span>.execCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.waitCount = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行一个请求</span><br><span class="hljs-comment">   * 如果到达最大并发限制时就进行等待</span><br><span class="hljs-comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_fetch</span>(<span class="hljs-params">url, init</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.waitCount++;<br>    <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.execCount &lt; <span class="hljs-built_in">this</span>.limit);<br>    <span class="hljs-built_in">this</span>.waitCount--;<br>    <span class="hljs-built_in">this</span>.execCount++;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> promiseTimeout(fetch(url, init), <span class="hljs-built_in">this</span>.timeout);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-built_in">this</span>.execCount--;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> requestLimiting = <span class="hljs-keyword">new</span> RequestLimiting(&#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">limit</span>: <span class="hljs-number">1</span> &#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).forEach(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span><br>  requestLimiting<br>    ._fetch(<span class="hljs-string">&quot;/&quot;</span>)<br>    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res))<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(err))<br>);<br></code></pre></td></tr></table></figure><h2 id="等待队列：循环监听实现"><a href="#等待队列：循环监听实现" class="headerlink" title="等待队列：循环监听实现"></a>等待队列：循环监听实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 fetch 请求添加超时选项</span><br><span class="hljs-comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseTimeout</span>(<span class="hljs-params">fetchPromise, timeout</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> abortFn = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">//这是一个可以被reject的promise</span><br>  <span class="hljs-keyword">var</span> abortPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    abortFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      reject(<span class="hljs-string">&quot;abort promise&quot;</span>);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">var</span> abortablePromise = <span class="hljs-built_in">Promise</span>.race([fetchPromise, abortPromise]);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    abortFn();<br>  &#125;, timeout);<br><br>  <span class="hljs-keyword">return</span> abortablePromise;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限制并发请求数量的 fetch 封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestLimiting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; timeout = <span class="hljs-number">10000</span>, limit = <span class="hljs-number">10</span> &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>    <span class="hljs-built_in">this</span>.limit = limit;<br>    <span class="hljs-built_in">this</span>.execCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 等待队列</span><br>    <span class="hljs-built_in">this</span>.waitArr = [];<br><br>    <span class="hljs-comment">// 监视 execCount 的值</span><br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.execCount &gt;= <span class="hljs-built_in">this</span>.limit) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">console</span>.debug(<br>        <span class="hljs-string">`执行 execCount: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="hljs-subst">$&#123;</span></span><br><span class="hljs-string"><span class="hljs-subst">          <span class="hljs-built_in">this</span>.waitArr.length</span></span><br><span class="hljs-string"><span class="hljs-subst">        &#125;</span>, index: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.waitArr[<span class="hljs-number">0</span>])&#125;</span>`</span><br>      );<br>      <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">this</span>.waitArr.shift(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (!args) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">this</span>.execCount++;<br>      <span class="hljs-keyword">const</span> callback = args[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果没有错误就返回 res</span><br>        callback(&#123; <span class="hljs-attr">res</span>: <span class="hljs-keyword">await</span> promiseTimeout(fetch(...args), <span class="hljs-built_in">this</span>.timeout) &#125;);<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-comment">// 否则返回 err</span><br>        callback(&#123;<br>          err: err,<br>        &#125;);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.execCount--;<br>      &#125;<br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行一个请求</span><br><span class="hljs-comment">   * 如果到达最大并发限制时就进行等待</span><br><span class="hljs-comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>callback 回调函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_fetch</span>(<span class="hljs-params">url, init, callback</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.waitArr.push(<span class="hljs-built_in">arguments</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> requestLimiting = <span class="hljs-keyword">new</span> RequestLimiting(&#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">limit</span>: <span class="hljs-number">1</span> &#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span><br>  requestLimiting._fetch(<br>    <span class="hljs-string">&quot;/&quot;</span>,<br>    &#123;<br>      <span class="hljs-comment">// 这里设置添加时的 index，用于验证是否真的顺序执行了</span><br>      headers: &#123;<br>        index: i,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-comment">// 这里使用了回调函数，参数使用解构得到</span><br>    (&#123; res, err &#125;) =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`res: <span class="hljs-subst">$&#123;res&#125;</span>, err: <span class="hljs-subst">$&#123;err&#125;</span>`</span>);<br>    &#125;<br>  )<br>);<br></code></pre></td></tr></table></figure><h2 id="等待队列：触发钩子实现"><a href="#等待队列：触发钩子实现" class="headerlink" title="等待队列：触发钩子实现"></a>等待队列：触发钩子实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 fetch 请求添加超时选项</span><br><span class="hljs-comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseTimeout</span>(<span class="hljs-params">fetchPromise, timeout</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> abortFn = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//这是一个可以被 reject 的 Promise</span><br>  <span class="hljs-keyword">var</span> abortPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    abortFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      reject(<span class="hljs-string">&quot;abort promise&quot;</span>);<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-comment">// 有一个 Promise 完成就立刻结束</span><br>  <span class="hljs-keyword">var</span> abortablePromise = <span class="hljs-built_in">Promise</span>.race([fetchPromise, abortPromise]);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    abortFn();<br>  &#125;, timeout);<br>  <span class="hljs-keyword">return</span> abortablePromise;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限制并发请求数量的 fetch 封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestLimiting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; timeout = <span class="hljs-number">10000</span>, limit = <span class="hljs-number">10</span> &#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>    <span class="hljs-built_in">this</span>.limit = limit;<br>    <span class="hljs-built_in">this</span>.execCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 等待队列</span><br>    <span class="hljs-built_in">this</span>.waitArr = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行一个请求</span><br><span class="hljs-comment">   * 如果到达最大并发限制时就进行等待</span><br><span class="hljs-comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_fetch</span>(<span class="hljs-params">url, init</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> _innerFetch = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<br>        <span class="hljs-string">`执行 execCount: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="hljs-subst">$&#123;</span></span><br><span class="hljs-string"><span class="hljs-subst">          <span class="hljs-built_in">this</span>.waitArr.length</span></span><br><span class="hljs-string"><span class="hljs-subst">        &#125;</span>, index: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.waitArr[<span class="hljs-number">0</span>])&#125;</span>`</span><br>      );<br>      <span class="hljs-built_in">this</span>.execCount++;<br>      <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">this</span>.waitArr.shift(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> promiseTimeout(fetch(...args), <span class="hljs-built_in">this</span>.timeout);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.execCount--;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.waitArr.push(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.execCount &lt; <span class="hljs-built_in">this</span>.limit);<br>    <span class="hljs-comment">// 尝试启动等待队列</span><br>    <span class="hljs-keyword">return</span> _innerFetch();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> requestLimiting = <span class="hljs-keyword">new</span> RequestLimiting(&#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">limit</span>: <span class="hljs-number">1</span> &#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).forEach(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span><br>  requestLimiting<br>    ._fetch(<span class="hljs-string">&quot;/&quot;</span>, &#123;<br>      <span class="hljs-comment">// 这里设置添加时的 index，用于验证是否真的顺序执行了</span><br>      headers: &#123;<br>        index: i,<br>      &#125;,<br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(res))<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(err))<br>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前而言，最后一种实现是最好的，同时实现了两种规范</p><ul><li>返回 <code>Promise</code>，避免使用回调函数</li><li>请求执行与添加顺序相同</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 异步时序问题</title>
    <link href="/p/fa132fa479714abd999dc421ca971e1c/"/>
    <url>/p/fa132fa479714abd999dc421ca971e1c/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>死后我们必升天堂，因为活时我们已在地狱。</p></blockquote><p>不知你是否遇到过，向后台发送了多次异步请求，结果最后显示的数据却并不正确 – 是旧的数据。</p><p>具体情况:</p><ol><li> 用户触发事件，发送了第 1 次请求</li><li> 用户触发事件，发送了第 2 次请求</li><li> 第 2 次请求成功，更新页面上的数据</li><li> 第 1 次请求成功，更新页面上的数据</li></ol><p>嗯？是不是感觉到异常了？这便是多次异步请求时会遇到的异步回调顺序与调用顺序不同的问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>为什么会出现这种问题？</li><li>出现这种问题怎么解决？</li></ul><h3 id="为什么会出现这种问题？"><a href="#为什么会出现这种问题？" class="headerlink" title="为什么会出现这种问题？"></a>为什么会出现这种问题？</h3><p>JavaScript 随处可见异步，但实际上并不是那么好控制。用户与 UI 交互，触发事件及其对应的处理函数，函数执行异步操作（网络请求），<strong>异步操作得到结果的时间（顺序）是不确定的</strong>，所以响应到 UI 上的时间就不确定，<strong>如果触发事件的频率较高/异步操作的时间过长</strong>，就会造成前面的异步操作结果覆盖后面的异步操作结果。</p><p>关键点</p><ul><li>异步操作得到结果的时间（顺序）是不确定的</li><li>如果触发事件的频率较高/异步操作的时间过长</li></ul><h3 id="出现这种问题怎么解决？"><a href="#出现这种问题怎么解决？" class="headerlink" title="出现这种问题怎么解决？"></a>出现这种问题怎么解决？</h3><p>既然关键点由两个要素组成，那么，只要破坏了任意一个即可。</p><ul><li>手动控制异步返回结果的顺序</li><li>降低触发频率并限制异步超时时间</li></ul><h2 id="手动控制返回结果的顺序"><a href="#手动控制返回结果的顺序" class="headerlink" title="手动控制返回结果的顺序"></a>手动控制返回结果的顺序</h2><p>根据对异步操作结果处理情况的不同也有三种不同的思路</p><ol><li> 后面异步操作得到结果后<strong>等待</strong>前面的异步操作返回结果</li><li> 后面异步操作得到结果后<strong>放弃</strong>前面的异步操作返回结果</li><li> 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个</li></ol><p>这里先引入一个公共的 <code>wait</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待指定的时间/等待指定表达式成立</span><br><span class="hljs-comment"> * 如果未指定等待条件则立刻执行</span><br><span class="hljs-comment"> * 注: 此实现在 nodejs 10- 会存在宏任务与微任务的问题，切记 async-await 本质上还是 Promise 的语法糖，实际上并非真正的同步函数！！！即便在浏览器，也不要依赖于这种特性。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>param 等待时间/等待条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(resolve, param);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (param()) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          resolve();<br>        &#125;<br>      &#125;, <span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-后面异步操作得到结果后等待前面的异步操作返回结果"><a href="#1-后面异步操作得到结果后等待前面的异步操作返回结果" class="headerlink" title="1. 后面异步操作得到结果后等待前面的异步操作返回结果"></a>1. 后面异步操作得到结果后<strong>等待</strong>前面的异步操作返回结果</h3><ol><li> 为每一次的异步调用都声称一个唯一 id</li><li> 使用列表记录所有的异步 id</li><li> 在真正调用异步操作后，添加一个唯一 id</li><li> 判断上一个正在执行的异步操作是否完成</li><li> 如果未完成等待上一个异步操作完成，否则直接跳过</li><li> 从列表中删除掉当前的 id</li><li> 最后等待异步操作然后返回结果</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个异步函数包装为具有时序的异步函数</span><br><span class="hljs-comment"> * 注: 该函数会按照调用顺序依次返回结果，后面的调用的结果需要等待前面的，所以如果不关心过时的结果，请使用 &#123;<span class="hljs-doctag">@link </span>switchMap&#125; 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 一个普通的异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeMap</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// 当前执行的异步操作 id</span><br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 所执行的异步操作 id 列表</span><br>  <span class="hljs-keyword">const</span> ids = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fn, &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">_, _this, args</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> prom = <span class="hljs-built_in">Reflect</span>.apply(_, _this, args);<br>      <span class="hljs-keyword">const</span> temp = id;<br>      ids.add(temp);<br>      id++;<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> !ids.has(temp - <span class="hljs-number">1</span>));<br>      ids.delete(temp);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> prom;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codepen.io/rxliuli/pen/orXpEY">测试一下</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> wait(ms);<br>    <span class="hljs-keyword">return</span> ms;<br>  &#125;<br>  <span class="hljs-keyword">const</span> fn = mergeMap(get);<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    fn(<span class="hljs-number">30</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">20</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">10</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>  ]);<br>  <span class="hljs-built_in">console</span>.log(last);<br>  <span class="hljs-comment">// 实际上确实执行了 3 次，结果也确实为 3 次调用参数之和</span><br>  <span class="hljs-built_in">console</span>.log(sum);<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="2-后面异步操作得到结果后放弃前面的异步操作返回结果"><a href="#2-后面异步操作得到结果后放弃前面的异步操作返回结果" class="headerlink" title="2. 后面异步操作得到结果后放弃前面的异步操作返回结果"></a>2. 后面异步操作得到结果后<strong>放弃</strong>前面的异步操作返回结果</h3><ol><li> 为每一次的异步调用都声称一个唯一 id</li><li> 记录最新得到异步操作结果的 id</li><li> 记录最新得到的异步操作结果</li><li> 执行并等待返回结果</li><li>判断本次异步调用后面是否已经有调用出现结果了<ol><li> 是的话就直接返回后面的异步调用结果</li><li> 否则将本地异步调用 id 及其结果最为[最后的]</li><li> 返回这次的异步调用结果</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个异步函数包装为具有时序的异步函数</span><br><span class="hljs-comment"> * 注: 该函数会丢弃过期的异步操作结果，这样的话性能会稍稍提高（主要是响应比较快的结果会立刻生效而不必等待前面的响应结果）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 一个普通的异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchMap</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// 当前执行的异步操作 id</span><br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 最后一次异步操作的 id，小于这个的操作结果会被丢弃</span><br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 缓存最后一次异步操作的结果</span><br>  <span class="hljs-keyword">let</span> cache;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fn, &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">_, _this, args</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> temp = id;<br>      id++;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Reflect</span>.apply(_, _this, args);<br>      <span class="hljs-keyword">if</span> (temp &lt; last) &#123;<br>        <span class="hljs-keyword">return</span> cache;<br>      &#125;<br>      cache = res;<br>      last = temp;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codepen.io/rxliuli/pen/BgNJbq">测试一下</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> wait(ms);<br>    <span class="hljs-keyword">return</span> ms;<br>  &#125;<br>  <span class="hljs-keyword">const</span> fn = switchMap(get);<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    fn(<span class="hljs-number">30</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">20</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">10</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>  ]);<br>  <span class="hljs-built_in">console</span>.log(last);<br>  <span class="hljs-comment">// 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果</span><br>  <span class="hljs-built_in">console</span>.log(sum);<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="3-依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个"><a href="#3-依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个" class="headerlink" title="3. 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个"></a>3. 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个</h3><ol><li> 为每一次的异步调用都声称一个唯一 id</li><li> 使用列表记录所有的异步 id</li><li> 向列表中添加一个唯一 id</li><li> 判断上一个正在执行的异步操作是否完成</li><li> 如果未完成等待上一个异步操作完成，否则直接跳过</li><li> 真正调用异步操作</li><li> 从列表中删除掉当前的 id</li><li> 最后等待异步操作然后返回结果</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个异步函数包装为具有时序的异步函数</span><br><span class="hljs-comment"> * 注: 该函数会按照调用顺序依次返回结果，后面的执行的调用（不是调用结果）需要等待前面的，此函数适用于异步函数的内里执行也必须保证顺序时使用，否则请使用 &#123;<span class="hljs-doctag">@link </span>mergeMap&#125; 函数</span><br><span class="hljs-comment"> * 注: 该函数其实相当于调用 &#123;<span class="hljs-doctag">@code </span>asyncLimiting(fn, &#123;limit: 1&#125;)&#125; 函数</span><br><span class="hljs-comment"> * 例如即时保存文档到服务器，当然要等待上一次的请求结束才能请求下一次，不然数据库保存的数据就存在谬误了</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn 一个普通的异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concatMap</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// 当前执行的异步操作 id</span><br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 所执行的异步操作 id 列表</span><br>  <span class="hljs-keyword">const</span> ids = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fn, &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">_, _this, args</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> temp = id;<br>      ids.add(temp);<br>      id++;<br>      <span class="hljs-keyword">await</span> wait(<span class="hljs-function">() =&gt;</span> !ids.has(temp - <span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">const</span> prom = <span class="hljs-built_in">Reflect</span>.apply(_, _this, args);<br>      ids.delete(temp);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> prom;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codepen.io/rxliuli/pen/xoGYxq">测试一下</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> wait(ms);<br>    <span class="hljs-keyword">return</span> ms;<br>  &#125;<br>  <span class="hljs-keyword">const</span> fn = concatMap(get);<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    fn(<span class="hljs-number">30</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">20</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">10</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>  ]);<br>  <span class="hljs-built_in">console</span>.log(last);<br>  <span class="hljs-comment">// 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果</span><br>  <span class="hljs-built_in">console</span>.log(sum);<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然三个函数看似效果都差不多，但还是有所不同的。</p><ol><li> 是否允许异步操作并发？否: <code>concatMap</code>, 是: 到下一步</li><li> 是否需要处理旧的的结果？否: <code>switchMap</code>, 是: <code>mergeMap</code></li></ol><h2 id="降低触发频率并限制异步超时时间"><a href="#降低触发频率并限制异步超时时间" class="headerlink" title="降低触发频率并限制异步超时时间"></a>降低触发频率并限制异步超时时间</h2><p>思考一下第二种解决方式，本质上其实是 <strong>限流 + 自动超时</strong>，首先实现这两个函数。</p><ul><li>限流: 限制函数调用的频率，如果调用的频率过快则不会真正执行调用而是返回旧值</li><li>自动超时: 如果到了超时时间，即便函数还未得到结果，也会自动超时并抛出错误</li></ul><p>下面来分别实现它们</p><h3 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h3><blockquote><p>具体实现思路可见: <a href="https://blog.rxliuli.com/p/1a8df23d/">JavaScript 防抖和节流</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数节流</span><br><span class="hljs-comment"> * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流</span><br><span class="hljs-comment"> * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作</span><br><span class="hljs-comment"> * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作</span><br><span class="hljs-comment"> * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值</span><br><span class="hljs-comment"> * 注: 返回函数结果的高阶函数需要使用 &#123;<span class="hljs-doctag">@link </span>Proxy&#125; 实现，以避免原函数原型链上的信息丢失</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>delay 最小间隔时间，单位为 ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>action 真正需要执行的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span> </span>包装后有节流功能的函数。该函数是异步的，与需要包装的函数 &#123;<span class="hljs-doctag">@link </span>action&#125; 是否异步没有太大关联</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">delay, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> result;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(action, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">target, thisArg, args</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> curr = <span class="hljs-built_in">Date</span>.now();<br>        <span class="hljs-keyword">if</span> (curr - last &gt; delay) &#123;<br>          result = <span class="hljs-built_in">Reflect</span>.apply(target, thisArg, args);<br>          last = curr;<br>          resolve(result);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        resolve(result);<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="自动超时"><a href="#自动超时" class="headerlink" title="自动超时"></a>自动超时</h3><blockquote><p>注: <code>asyncTimeout</code> 函数实际上只是为了避免一种情况，异步请求时间超过节流函数最小间隔时间导致结果返回顺序错乱。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为异步函数添加自动超时功能</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>timeout 超时时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>action 异步函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>包装后的异步函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncTimeout</span>(<span class="hljs-params">timeout, action</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(action, &#123;<br>    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">_, _this, args</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.race([<br>        <span class="hljs-built_in">Reflect</span>.apply(_, _this, args),<br>        wait(timeout).then(<span class="hljs-built_in">Promise</span>.reject),<br>      ]);<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p><a href="https://codepen.io/pen/?editors=1112">测试一下</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> wait(ms);<br>    <span class="hljs-keyword">return</span> ms;<br>  &#125;<br>  <span class="hljs-keyword">const</span> time = <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">const</span> fn = asyncTimeout(time, throttle(time, get));<br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    fn(<span class="hljs-number">30</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">20</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>    fn(<span class="hljs-number">10</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      last = res;<br>      sum += res;<br>    &#125;),<br>  ]);<br>  <span class="hljs-comment">// last 结果为 10，和 switchMap 的不同点在于会保留最小间隔期间的第一次，而抛弃掉后面的异步结果，和 switchMap 正好相反！</span><br>  <span class="hljs-built_in">console</span>.log(last);<br>  <span class="hljs-comment">// 实际上确实执行了 3 次，结果也确实为第一次次调用参数的 3 倍</span><br>  <span class="hljs-built_in">console</span>.log(sum);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>起初吾辈因为好奇实现了这种方式，但原以为会和 <code>concatMap</code> 类似的函数却变成了现在这样 – 更像倒置的 <code>switchMap</code> 了。不过由此看来这种方式的可行性并不大，毕竟，没人需要旧的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实第一种实现方式属于 <a href="https://github.com/ReactiveX/rxjs">rxjs</a> 早就已经走过的道路，目前被 Angular 大量采用（类比于 React 中的 Redux）。但 rxjs 实在太强大也太复杂了，对于吾辈而言，仅仅需要一只香蕉，而不需要拿着香蕉的大猩猩，以及其所处的整个森林（此处原本是被人吐槽面向对象编程的隐含环境，这里吾辈稍微藉此吐槽一下动不动就上库的开发者）。</p><blockquote><p>可以看到吾辈在这里大量使用了 <code>Proxy</code>，那么，原因是什么呢？这个疑问就留到下次再说吧！</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 异步数组</title>
    <link href="/p/05a42034e34e4636aace32cec81187f5/"/>
    <url>/p/05a42034e34e4636aace32cec81187f5/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>吾辈是一只在飞向太阳的萤火虫</p></blockquote><p>JavaScript 中的数组是一个相当泛用性的数据结构，能当数组，元组，队列，栈进行操作，更好的是 JavaScript 提供了很多原生的高阶函数，便于我们对数组整体操作。<br>然而，JavaScript 中的高阶函数仍有缺陷 – 异步！当你把它们放在一起使用时，就会感觉到这种问题的所在。</p><p>例如现在，有一组 id，我们要根据 id 获取到远端服务器 id 对应的值，然后将之打印出来。那么，我们要怎么做呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> wait = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">id</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里只是为了模拟每个请求的时间可能是不定的</span><br>  <span class="hljs-keyword">await</span> wait(<span class="hljs-built_in">Math</span>.random() * id * <span class="hljs-number">100</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;内容: &quot;</span> + id.toString();<br>&#125;<br><br><span class="hljs-keyword">const</span> ids = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>你或许会下意识地写出下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ids.forEach(<span class="hljs-keyword">async</span> (id) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(id)));<br></code></pre></td></tr></table></figure><p>事实上，控制台输出是无序的，而并非想象中的 1, 2, 3, 4 依次输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">内容: 2 ​​​​​<br>内容: 3 ​​​​​<br>内容: 1 ​​​​​<br>内容: 4<br></code></pre></td></tr></table></figure><p>这是为什么呢？原因便是 JavaScript 中数组的高阶函数并不会等待异步函数的返回！当你在网络上搜索时，会发现很多人会说可以使用 <code>for-of</code>, <code>for-in</code> 解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">of</span> ids) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(id));<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>或者，使用 <code>Promise.all</code> 也是一种解决方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  (<span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(ids.map(get))).forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(v));<br>&#125;)();<br></code></pre></td></tr></table></figure><p>然而，第一种方式相当于丢弃了 Array 的所有高阶函数，再次重返远古 <code>for</code> 循环时代了。第二种则一定会执行所有的异步函数，即便你需要使用的是 <code>find/findIndex/some/every</code> 这些高阶函数。那么，有没有更好的解决方案呢？</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>既然原生的 Array 不支持完善的异步操作，那么，为什么不由我们来实现一个呢？</p><p>实现思路:</p><ol><li> 创建异步数组类型 <code>AsyncArray</code></li><li> 内置一个数组保存当前异步操作数组的值</li><li> 实现数组的高阶函数并实现支持异步函数顺序执行</li><li> 获取到内置的数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>    <span class="hljs-built_in">this</span>._task = [];<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> AsyncArray(...ids).forEach(<span class="hljs-keyword">async</span> (id) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> get(id)));<br></code></pre></td></tr></table></figure><p>打印结果确实有顺序了，看似一切很美好？</p><p>然而，当我们再实现一个 <code>map</code> 试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      res.push(<span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> AsyncArray(...ids).map(get).forEach(<span class="hljs-keyword">async</span> (res) =&gt; <span class="hljs-built_in">console</span>.log(res));<br><span class="hljs-comment">// 抛出错误</span><br><span class="hljs-comment">// (intermediate value).map(...).forEach is not a function</span><br></code></pre></td></tr></table></figure><p>然而会有问题，实际上 <code>map</code> 返回的是 <code>Promise</code>，所以我们还必须使用 <code>await</code> 进行等待</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  (<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> AsyncArray(...ids).map(get)).forEach(<span class="hljs-keyword">async</span> (res) =&gt;<br>    <span class="hljs-built_in">console</span>.log(res)<br>  );<br>&#125;)();<br></code></pre></td></tr></table></figure><p>是不是感觉超级蠢？吾辈也是这样认为的！</p><h2 id="链式调用加延迟执行"><a href="#链式调用加延迟执行" class="headerlink" title="链式调用加延迟执行"></a>链式调用加延迟执行</h2><p>我们可以尝试使用链式调用加延迟执行修改这个 <code>AsyncArray</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存高阶函数传入的异步操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">type, args</span>)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>异步操作的类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>异步操作的参数数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;Function&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>.args = args;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的操作类型</span><br><span class="hljs-comment"> */</span><br>Action.Type = &#123;<br>  forEach: <span class="hljs-string">&quot;forEach&quot;</span>,<br>  map: <span class="hljs-string">&quot;map&quot;</span>,<br>  filter: <span class="hljs-string">&quot;filter&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真正实现的异步数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerAsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = arr;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = [];<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      res.push(<span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>));<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>)) &#123;<br>        res.push(arr[i]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>保存异步任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;Action[]&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._task = [];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._task.push(<span class="hljs-keyword">new</span> Action(Action.Type.forEach, [fn]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._task.push(<span class="hljs-keyword">new</span> Action(Action.Type.map, [fn]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._task.push(<span class="hljs-keyword">new</span> Action(Action.Type.filter, [fn]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 终结整个链式操作并返回结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">value</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      result = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> AsyncArray(...ids)<br>  .filter(<span class="hljs-keyword">async</span> (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>  .map(get)<br>  .forEach(<span class="hljs-keyword">async</span> (res) =&gt; <span class="hljs-built_in">console</span>.log(res))<br>  .value();<br></code></pre></td></tr></table></figure><p>可以看到，确实符合预期了，然而每次都要调用 <code>value()</code>，终归有些麻烦。</p><h2 id="使用-then-以支持-await-自动结束"><a href="#使用-then-以支持-await-自动结束" class="headerlink" title="使用 then 以支持 await 自动结束"></a>使用 then 以支持 await 自动结束</h2><p>这里使用 <code>then()</code> 替代它以使得可以使用 <code>await</code> <strong>自动</strong>计算结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-comment">// 上面的其他内容...</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 终结整个链式操作并返回结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      result = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>    &#125;<br>    <span class="hljs-comment">// 这里使用 resolve(result) 是为了兼容 await 的调用方式</span><br>    resolve(result);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，可以使用 <code>await</code> 结束这次链式调用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> AsyncArray(...ids).map(get).forEach(<span class="hljs-keyword">async</span> (res) =&gt; <span class="hljs-built_in">console</span>.log(res));<br></code></pre></td></tr></table></figure><p>突然之间，我们发现了一个问题，为什么会这么慢？一个个去进行异步操作太慢了，难道就不能一次性全部发送出去，然后有序的处理结果就好了嘛？</p><h2 id="并发异步操作"><a href="#并发异步操作" class="headerlink" title="并发异步操作"></a>并发异步操作</h2><p>我们可以使用 <code>Promise.all</code> 并发执行异步操作，然后对它们的结果进行有序地处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 并发实现的异步数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerAsyncArrayParallel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = arr;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_all</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">this</span>._arr.map(fn));<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-built_in">this</span>._arr = [];<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">this</span>._arr.filter(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> arr[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改 <code>AsyncArray</code>，使用 <code>_AsyncArrayParallel</code> 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-comment">// 上面的其他内容...</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 终结整个链式操作并返回结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      result = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>    &#125;<br>    <span class="hljs-comment">// 这里使用 resolve(result) 是为了兼容 await 的调用方式</span><br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方式不变。当然，由于使用 <code>Promise.all</code> 实现，也同样受到它的限制 – 异步操作实际上全部执行了。</p><h2 id="串行-并行相互转换"><a href="#串行-并行相互转换" class="headerlink" title="串行/并行相互转换"></a>串行/并行相互转换</h2><p>现在我们的 <code>_AsyncArray</code> 和 <code>_AsyncArrayParallel</code> 两个类只能二选一，所以，我们需要添加两个函数用于互相转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>保存异步任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;AsyncArrayAction[]&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._task = [];<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否并行化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 其他内容...</span><br><br>  <span class="hljs-function"><span class="hljs-title">parallel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">serial</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._parallel<br>      ? <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr)<br>      : <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      result = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以在真正执行之前在任意位置对其进行转换了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> AsyncArray(...ids)<br>  .parallel()<br>  .filter(<span class="hljs-keyword">async</span> (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>  .map(get)<br>  .forEach(<span class="hljs-keyword">async</span> (res) =&gt; <span class="hljs-built_in">console</span>.log(res));<br></code></pre></td></tr></table></figure><h2 id="并发执行多个异步操作"><a href="#并发执行多个异步操作" class="headerlink" title="并发执行多个异步操作"></a>并发执行多个异步操作</h2><p>然而，上面的代码有一些隐藏的问题</p><ol><li><p><code>await</code> 之后返回值不是一个数组</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>)); <span class="hljs-comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span><br>&#125;)();<br></code></pre></td></tr></table></figure></li><li><p>上面的 <code>map</code>, <code>filter</code> 调用在 <code>await</code> 之后仍会影响到下面的调用</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>)); <span class="hljs-comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span><br>&#125;)();<br></code></pre></td></tr></table></figure></li><li><p>并发调用的顺序不能确定，会影响到内部数组，导致结果不能确定</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids);<br>  (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-keyword">await</span> asyncArray<br>        .filter(<span class="hljs-keyword">async</span> (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>)<br>        .map(<span class="hljs-keyword">async</span> (i) =&gt; i * <span class="hljs-number">2</span>)<br>    ); <span class="hljs-comment">// InnerAsyncArray &#123; _arr: [ 2, 6 ] &#125;</span><br>  &#125;)();<br>  (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// InnerAsyncArray &#123; _arr: [ 2, 6 ] &#125;</span><br>  &#125;)();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>先解决第一个问题，这里只需要判断一下是否为终结操作（<code>forEach</code>），是的话就直接返回结果，否则继续下一次循环</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-comment">// 其他内容...</span><br><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._parallel<br>      ? <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr)<br>      : <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>      <span class="hljs-keyword">if</span> (<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArray ||<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArrayParallel<br>      ) &#123;<br>        result = temp._arr;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果已经是终结操作就返回数组的值</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>          resolve(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，第一个问题简单解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray.map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>)); <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>第二、第三个问题看起来似乎是同一个问题？其实我们可以按照常规思维解决第一个问题。既然 <code>await</code> 之后仍然会影响到下面的调用，那就在 <code>then</code> 中把 <code>_task</code> 清空好了，修改 <code>then</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-comment">// 其他内容...</span><br><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._parallel<br>      ? <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr)<br>      : <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>      <span class="hljs-keyword">if</span> (<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArray ||<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArrayParallel<br>      ) &#123;<br>        result = temp._arr;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果已经是终结操作就返回数组的值</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>          resolve(temp);<br>        &#125;<br>        <span class="hljs-built_in">this</span>._task = [];<br>        <span class="hljs-keyword">return</span> temp;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._task = [];<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，第一个问题解决了，但第二个问题不会解决。究其原因，还是异步事件队列的问题，虽然 <code>async-await</code> 能够让我们以同步的方式写异步的代码，但千万不可忘记它们本质上还是<strong>异步</strong>的！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<br>        <span class="hljs-keyword">await</span> asyncArray<br>          .filter(<span class="hljs-keyword">async</span> (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>)<br>          .map(<span class="hljs-keyword">async</span> (i) =&gt; i * <span class="hljs-number">2</span>)<br>      ); <span class="hljs-comment">// [ 2, 6 ]</span><br>    &#125;)(),<br>    (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 2, 6 ]</span><br>    &#125;)(),<br>  ]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>可以看到，在使用 <code>await</code> 进行等待之后就如同预期的 <code>_task</code> 被清空了。然而，并发执行的没有等待的 <code>await asyncArray</code> 却有奇怪的问题，因为它是在 <code>_task</code> 清空之前执行的。</p><p>并且，这带来一个副作用: 无法缓存操作了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids).map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="使用不可变数据"><a href="#使用不可变数据" class="headerlink" title="使用不可变数据"></a>使用不可变数据</h2><p>为了解决直接修改内部数组造成的问题，我们可以使用不可变数据解决这个问题。试想：如果我们每次操作都返回一个新的 <code>AsyncArray</code>，他们之间没有关联，这样又如何呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>保存异步任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;Action[]&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._task = [];<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否并行化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.forEach, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.map, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.filter, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">parallel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">serial</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">_addTask</span>(<span class="hljs-params">type, args</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> AsyncArray(...this._arr);<br>    result._task = [...this._task, <span class="hljs-keyword">new</span> Action(type, args)];<br>    result._parallel = <span class="hljs-built_in">this</span>._parallel;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 终结整个链式操作并返回结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._parallel<br>      ? <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr)<br>      : <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>      <span class="hljs-keyword">if</span> (<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArray ||<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArrayParallel<br>      ) &#123;<br>        result = temp._arr;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果已经是终结操作就返回数组的值</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>          resolve(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次测试上面的那第三个问题，发现已经一切正常了呢</p><ul><li>并发调用的顺序不能确定，但不会影响内部数组了，结果是确定的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids);<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>    (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<br>        <span class="hljs-keyword">await</span> asyncArray<br>          .filter(<span class="hljs-keyword">async</span> (i) =&gt; i % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>)<br>          .map(<span class="hljs-keyword">async</span> (i) =&gt; i * <span class="hljs-number">2</span>)<br>      ); <span class="hljs-comment">// [ 2, 6 ]</span><br>    &#125;)(),<br>    (<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span><br>    &#125;)(),<br>  ]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><ul><li>操作可以被缓存</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> asyncArray = <span class="hljs-keyword">new</span> AsyncArray(...ids).map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> asyncArray); <span class="hljs-comment">// [ 2, 4, 6, 8 ]</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>下面吾辈把完整的代码贴出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存高阶函数传入的异步操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">type, args</span>)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>异步操作的类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>.type = type;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>异步操作的参数数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;Function&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>.args = args;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的操作类型</span><br><span class="hljs-comment"> */</span><br>Action.Type = &#123;<br>  forEach: <span class="hljs-string">&quot;forEach&quot;</span>,<br>  map: <span class="hljs-string">&quot;map&quot;</span>,<br>  filter: <span class="hljs-string">&quot;filter&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真正实现的异步数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerAsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = arr;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = [];<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      res.push(<span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>));<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> fn(arr[i], i, <span class="hljs-built_in">this</span>)) &#123;<br>        res.push(arr[i]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">this</span>._arr = res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerAsyncArrayParallel</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = arr;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">_all</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">this</span>._arr.map(fn));<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-built_in">this</span>._arr = [];<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._all(fn);<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">this</span>._arr.filter(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> arr[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncArray</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._arr = <span class="hljs-built_in">Array</span>.from(args);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@field </span>保存异步任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@type <span class="hljs-type">&#123;Action[]&#125;</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._task = [];<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否并行化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.forEach, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.map, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">filter</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._addTask(Action.Type.filter, [fn]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">parallel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">serial</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._parallel = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">_addTask</span>(<span class="hljs-params">type, args</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> AsyncArray(...this._arr);<br>    result._task = [...this._task, <span class="hljs-keyword">new</span> Action(type, args)];<br>    result._parallel = <span class="hljs-built_in">this</span>._parallel;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 终结整个链式操作并返回结果</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>._parallel<br>      ? <span class="hljs-keyword">new</span> InnerAsyncArrayParallel(<span class="hljs-built_in">this</span>._arr)<br>      : <span class="hljs-keyword">new</span> InnerAsyncArray(<span class="hljs-built_in">this</span>._arr);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">this</span>._arr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>._task) &#123;<br>      <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">await</span> arr[task.type](...task.args);<br>      <span class="hljs-keyword">if</span> (<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArray ||<br>        temp <span class="hljs-keyword">instanceof</span> InnerAsyncArrayParallel<br>      ) &#123;<br>        result = temp._arr;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果已经是终结操作就返回数组的值</span><br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>          resolve(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>      resolve(result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，关于 JavaScript 中如何封装一个可以使用异步操作高阶函数的数组就先到这里了，完整的 JavaScript 异步数组请参考吾辈的 <a href="https://github.com/rxliuli/rx-util/blob/master/src/module/array/AsyncArray.ts">AsyncArray</a>（使用 TypeScript 编写）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 Vue SPA 网站 URL 保存数据实践</title>
    <link href="/p/1342b132059a48f4a822bcd182d8bfe1/"/>
    <url>/p/1342b132059a48f4a822bcd182d8bfe1/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>该功能吾辈已经封装成 NPM 库 <a href="https://www.npmjs.com/package/vue-url-persist">vue-url-persist</a></p></blockquote><p>在使用 Vue SPA 开发面向普通用户的网站时，吾辈也遇到了一些之前未被重视，但却实实在在存在的问题，这次便浅谈一下 SPA 网站将所有数据都存储到内存中导致数据很容易丢失以及吾辈思考并尝试的解决方案。</p><blockquote><p>参考：SPA 全称 <code>single page application</code>，意为 <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8">单页应用</a>，不是泥萌想的那样！#笑哭</p></blockquote><p>思维导图</p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/5e1e5d93e4b0c3908f881d64"></iframe><p>首先列出为什么遇到这个问题，具体场景及解决的问题是什么？</p><p>想要解决的一些问题</p><ol><li> 刷新页面数据不丢失：因为数据都保存在内存中，所以刷新之后自然不存在了</li><li> URL 复制给其他人数据不丢失：因为数据没有持久化到 URL 上，也没有根据 URL 上的数据进行初始化，所以复制给别人的 URL 当然会丢失数据（搜索条件之类）</li><li> 页面返回数据不丢失：因为数据都保存在内存中，所以跳转到其他路由再跳转回来数据当然不会存在了</li></ol><p>那么，先谈一下每个问题的解决方案</p><ol><li>刷新页面数据不丢失<ul><li>将数据序列化到本地，例如 <code>localStorage</code> 中，然后在刷新后获取一次<ul><li>注：这方面已经有先行者了，例如 <a href="https://www.npmjs.com/package/vuex-persist">vuex-persist</a> 和 <a href="https://github.com/robinvdvleuten/vuex-persistedstate">vuex-persistedstate</a></li></ul></li><li>将数据序列化到 URL 上，每次加载都从 URL 上获取数据</li></ul></li><li>URL 复制给其他人数据不丢失<ul><li>只能将数据序列化到 URL 上</li></ul></li><li>页面返回数据不丢失<ul><li>将数据放到 vuex 中，并且在 URL 上使用 <code>key</code> 进行标识<ul><li>注：这方面已经有先行者了，例如 <a href="https://www.npmjs.com/package/vue-navigation">vue-navigation</a> 和 <a href="https://github.com/vuejs/vuex-router-sync">vuex-router-sync</a></li></ul></li><li>将数据序列化到 URL 上，并且不新增路由记录</li><li>使用 vue-router 的缓存 <code>keep-alive</code></li></ul></li></ol><p>在了解了这么多的解决方案之后，吾辈最终选择了兼容性最好的 URL 保存数据，它能同时解决 3 个问题。然而，很遗憾的是，这似乎并没有很多人讨论这个问题，或许，这个问题本应该是默认就需要解决的，亦或是 SPA 网站真的很少关心这些了。</p><blockquote><p>虽说如此，吾辈还是找到了一些讨论的 <a href="https://stackoverflow.com/questions/42226479">StackOverflow: How to hold URL query params in Vue with Vue-Router</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个基本的思路是能够确定的</p><ol><li> 在组件创建时，从 URL 获取数据并为需要的数据进行初始化</li><li> 在这些数据变化时，及时将数据序列化到 URL 上</li></ol><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012847.png" alt="思路图"></p><p>然后，再次出现了一个分歧点，到底要不要绑定 Vue？</p><ol><li>不绑定 vue 手动监听对象变化并将对象的变化响应到 URL 上<br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012848.png" alt="不绑定 vue"></li><li>绑定 vue 并使用它的生命周期 <code>created, beforeRouteUpdate</code> 与监听器 <code>watch</code><br> <img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012846.png" alt="绑定 vue"></li></ol><p>那么，两者有什么区别呢？</p><table><thead><tr><th>思路</th><th>不绑定 vue</th><th>绑定 vue</th></tr></thead><tbody><tr><td>优点</td><td>非框架强相关，理论上可以通用 <code>Vue/React</code></td><td>不需要手动实现 URL 的几种序列化模式，可以预见至少有两种：<code>HTML 5 History/Hash</code></td></tr><tr><td></td><td>没有 vue/vue-router 的历史包袱</td><td>不需要手动实现数据监听/响应（虽然现在已然不算难了）</td></tr><tr><td></td><td>可以不管 vue-router 实现 URL 动态设置，可以自动优雅降级</td><td>灵活性很强，实现比较好的封装之后使用成本很低</td></tr><tr><td>缺点</td><td>没有包袱，但同时没有基础，序列化/数据监听都需要手动实现</td><td>存在历史包袱，vue/vue-router 的怪癖一点都绕不过去</td></tr><tr><td></td><td>灵活性不足，只能初始化一次，需要/不需要序列化的数据分割也相当有挑战</td><td>依赖 vue/vue-router，在其更新之时也必须跟着更新</td></tr><tr><td></td><td>不绑定 vue 意味着与 vue 不可能完美契合</td><td>无法通用，在任何一个其他框架（React）上还要再写一套</td></tr></tbody></table><p>最终，在这个十字路口反复踌躇之后，吾辈选择了更加灵活、成本更低的第二种解决方案。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="已解决"><a href="#已解决" class="headerlink" title="已解决"></a>已解决</h3><ul><li>序列化数据到 URL 上导致路由记录会随着改变增加</li><li>即时序列化数据到 URL 上不现实<blockquote><p>这里吾辈对 <a href="https://yarnpkg.com/">yarn</a> 进行了考察发现其也是异步更新 URL</p></blockquote></li><li>序列化到 URL 上时导致的死循环，<code>序列化数据到 URL 上 =&gt; 路由更新触发 =&gt; 初始化数据到 URL 上 =&gt; 触发数据改变 =&gt; 序列化数据到 URL 上。。。</code></li><li>同一个路由携带不同的查询参数的 URL 直接在地址栏输入回车一次不会触发页面数据更新</li><li>URL 最大保存数据 IE 最多支持 <code>2083</code> 长度的 URL，换算为中文即为 <code>231</code> 个，所以不能作为一种通用方式进行</li><li>Vue 插件不能动态混入，而是在各个生命周期中判断是否要处理的</li></ul><h3 id="仍遗留"><a href="#仍遗留" class="headerlink" title="仍遗留"></a>仍遗留</h3><ul><li>JSON 序列化的数据长度较 query param 更大</li></ul><blockquote><p>下面是具体实现及代码，不喜欢的话可以直接跳到最下面的 <a href="#%E6%80%BB%E7%BB%93">总结</a>。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p><a href="https://github.com/rxliuli/example/tree/linter_vue_example/vue_url_persist_vue_example">GitHub</a></p></blockquote><h3 id="基本尝试"><a href="#基本尝试" class="headerlink" title="基本尝试"></a>基本尝试</h3><p>首先，尝试不使用任何封装，直接在 <code>created</code> 生命周期中初始化并绑定 <code>$watch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;<br>    &lt;div&gt;<br>      &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;搜索名:&lt;/label&gt;<br>      &lt;input type=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;form.keyword&quot;</span> id=<span class="hljs-string">&quot;keyword&quot;</span> /&gt;<br>    &lt;/div&gt;<br>    &lt;div&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;checkbox&quot;</span><br>        v-model=<span class="hljs-string">&quot;form.hobbyList&quot;</span><br>        id=<span class="hljs-string">&quot;anime&quot;</span><br>        value=<span class="hljs-string">&quot;anime&quot;</span><br>      /&gt;<br>      &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;anime&quot;</span>&gt;动画&lt;/label&gt;<br>      &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;form.hobbyList&quot;</span> id=<span class="hljs-string">&quot;game&quot;</span> value=<span class="hljs-string">&quot;game&quot;</span> /&gt;<br>      &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;game&quot;</span>&gt;游戏&lt;/label&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;checkbox&quot;</span><br>        v-model=<span class="hljs-string">&quot;form.hobbyList&quot;</span><br>        id=<span class="hljs-string">&quot;movie&quot;</span><br>        value=<span class="hljs-string">&quot;movie&quot;</span><br>      /&gt;<br>      &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;movie&quot;</span>&gt;电影&lt;/label&gt;<br>    &lt;/div&gt;<br>    &lt;p&gt;<br>      &#123;&#123; form &#125;&#125;<br>    &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&#x27;Form1&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      form: &#123;<br>        keyword: <span class="hljs-string">&#x27;&#x27;</span>,<br>        hobbyList: [],<br>      &#125;,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;qb&#x27;</span><br>    <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.$route.query[key] || <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>)<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.form, urlData.form)<br>    <span class="hljs-built_in">this</span>.$watch(<br>      <span class="hljs-string">&#x27;form&#x27;</span>,<br>      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>        urlData.form = val<br>        <span class="hljs-built_in">this</span>.$router.replace(&#123;<br>          query: &#123;<br>            ...this.$route.query,<br>            [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>          &#125;,<br>        &#125;)<br>      &#125;,<br>      &#123;<br>        deep: <span class="hljs-literal">true</span>,<br>      &#125;,<br>    )<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="分离通用性函数"><a href="#分离通用性函数" class="headerlink" title="分离通用性函数"></a>分离通用性函数</h3><p>然后，便是将之分离为单独的函数，方便在所有组件中进行复用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化一些数据需要序列化/反序列化到 url data 上</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlData</span>(<span class="hljs-params">exps</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> key = <span class="hljs-string">&quot;qb&quot;</span>;<br>  <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.$route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>  exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>[exp], urlData[exp]);<br>    <span class="hljs-built_in">this</span>.$watch(<br>      exp,<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>        urlData[exp] = val;<br>        <span class="hljs-built_in">this</span>.$router.replace(&#123;<br>          query: &#123;<br>            ...this.$route.query,<br>            [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>          &#125;,<br>        &#125;);<br>      &#125;,<br>      &#123;<br>        deep: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来需要在 <code>created</code> 生命中调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    initUrlData.call(<span class="hljs-built_in">this</span>, [<span class="hljs-string">&quot;form&quot;</span>]);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="处理深层监听"><a href="#处理深层监听" class="headerlink" title="处理深层监听"></a>处理深层监听</h3><p>如果需要监听的值不是 data 下的顶级字段，而是深层字段的话，便不能直接使用 <code>[]</code> 进行取值和赋值了，而是需要实现支持深层取值/赋值的 <code>get/set</code>。而且，深层监听也意味着一般不会是对象，所以也不能采用 <code>Object.assign</code> 进行合并。</p><p>例如需要监听 <code>page</code> 对象中的 <code>offset, size</code> 两字段</p><p>首先，需要编写通用的 <code>get/set</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析字段字符串为数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>str 字段字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>字符串数组，数组的 `[]` 取法会被解析为数组的一个元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFieldStr</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str<br>    .split(<span class="hljs-regexp">/[\\.\\[]/</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> (<span class="hljs-regexp">/\]$/</span>.test(k) ? k.slice(<span class="hljs-number">0</span>, k.length - <span class="hljs-number">1</span>) : k));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全的深度获取对象的字段</span><br><span class="hljs-comment"> * 注: 只要获取字段的值为 &#123;<span class="hljs-doctag">@type </span>null|undefined&#125;，就会直接返回 &#123;<span class="hljs-doctag">@param </span>defVal&#125;</span><br><span class="hljs-comment"> * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>obj 获取的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fields 字段字符串或数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>[defVal] 取不到值时的默认值，默认为 null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">obj, fields, defVal = <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fields === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    fields = parseFieldStr(fields);<br>  &#125;<br>  <span class="hljs-keyword">let</span> res = obj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> field <span class="hljs-keyword">of</span> fields) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      res = <span class="hljs-built_in">Reflect</span>.get(res, field);<br>      <span class="hljs-keyword">if</span> (res === <span class="hljs-literal">undefined</span> || res === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> defVal;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">return</span> defVal;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全的深度设置对象的字段</span><br><span class="hljs-comment"> * 注: 只要设置字段的值为 &#123;<span class="hljs-doctag">@type </span>null|undefined&#125;，就会直接返回 &#123;<span class="hljs-doctag">@param </span>defVal&#125;</span><br><span class="hljs-comment"> * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>obj 设置的对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fields 字段字符串或数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>[val] 设置字段的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">obj, fields, val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fields === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    fields = parseFieldStr(fields);<br>  &#125;<br>  <span class="hljs-keyword">let</span> res = obj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = fields.length; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">const</span> field = fields[i];<br>    <span class="hljs-built_in">console</span>.log(i, res, field, res[field]);<br>    <span class="hljs-keyword">if</span> (i === len - <span class="hljs-number">1</span>) &#123;<br>      res[field] = val;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    res = res[field];<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;res: &quot;</span>, res);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res !== <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，是替换赋值操作，将之修改为一个专门的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 vue 实例上的字段进行深度赋值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitData</span>(<span class="hljs-params">vm, exp, urlData</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> oldVal = get(vm, exp, <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> newVal = urlData[exp];<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldVal === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; newVal !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-built_in">Object</span>.assign(get(vm, exp), newVal);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    set(vm, exp, newVal);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化一些数据需要序列化/反序列化到 url data 上</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlData</span>(<span class="hljs-params">exps</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> key = <span class="hljs-string">&quot;qb&quot;</span>;<br>  <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.$route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>  exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>    setInitData(<span class="hljs-built_in">this</span>, exp, urlData);<br>    <span class="hljs-built_in">this</span>.$watch(<br>      exp,<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>        urlData[exp] = val;<br>        <span class="hljs-built_in">this</span>.$router.replace(&#123;<br>          query: &#123;<br>            ...this.$route.query,<br>            [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>          &#125;,<br>        &#125;);<br>      &#125;,<br>      &#123;<br>        deep: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，便能单独监听对象中的某个字段了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">initUrlData.call(<span class="hljs-built_in">this</span>, [<span class="hljs-string">&quot;form.keyword&quot;</span>]);<br></code></pre></td></tr></table></figure><blockquote><p>参考：lodash 的函数 <a href="https://lodash.com/docs/4.17.15#get">get</a>/<a href="https://lodash.com/docs/4.17.15#set">set</a></p></blockquote><h3 id="使用防抖避免触发过快"><a href="#使用防抖避免触发过快" class="headerlink" title="使用防抖避免触发过快"></a>使用防抖避免触发过快</h3><p>但目前而言每次同步都是即时的，在数据量较大时，可能会存在一些问题，所以使用防抖避免每次数据更新都即时同步到 URL 上。</p><p>首先，实现一个简单的防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数去抖</span><br><span class="hljs-comment"> * 去抖 (debounce) 去抖就是对于一定时间段的连续的函数调用，只让其执行一次</span><br><span class="hljs-comment"> * 注: 包装后的函数如果两次操作间隔小于 delay 则不会被执行, 如果一直在操作就会一直不执行, 直到操作停止的时间大于 delay 最小间隔时间才会执行一次, 不管任何时间调用都需要停止操作等待最小延迟时间</span><br><span class="hljs-comment"> * 应用场景主要在那些连续的操作, 例如页面滚动监听, 包装后的函数只会执行最后一次</span><br><span class="hljs-comment"> * 注: 该函数第一次调用一定不会执行，第一次一定拿不到缓存值，后面的连续调用都会拿到上一次的缓存值。如果需要在第一次调用获取到的缓存值，则需要传入第三个参数 &#123;<span class="hljs-doctag">@param </span>init&#125;，默认为 &#123;<span class="hljs-doctag">@code </span>undefined&#125; 的可选参数</span><br><span class="hljs-comment"> * 注: 返回函数结果的高阶函数需要使用 &#123;<span class="hljs-doctag">@see </span>Proxy&#125; 实现，以避免原函数原型链上的信息丢失</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>action 真正需要执行的操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>delay 最小延迟时间，单位为 ms</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>init 初始的缓存值，不填默认为 &#123;<span class="hljs-doctag">@see </span>undefined&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>function(...[*]=): Promise&lt;any&gt; &#123;<span class="hljs-doctag">@see </span>action&#125; 是否异步没有太大关联</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">action, delay, init = <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> flag;<br>  <span class="hljs-keyword">let</span> result = init;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">clearTimeout</span>(flag);<br>      flag = <span class="hljs-built_in">setTimeout</span>(<br>        () =&gt; resolve((result = action.apply(<span class="hljs-built_in">this</span>, args))),<br>        delay<br>      );<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(result), delay);<br>    &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <code>$watch</code> 中的函数用 <code>debounce</code> 进行包装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化一些数据需要序列化/反序列化到 url data 上</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlData</span>(<span class="hljs-params">exps</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> key = <span class="hljs-string">&quot;qb&quot;</span>;<br>  <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.$route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>  exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>    setInitData(<span class="hljs-built_in">this</span>, exp, urlData);<br>    <span class="hljs-built_in">this</span>.$watch(<br>      exp,<br>      debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>        urlData[exp] = val;<br>        <span class="hljs-built_in">this</span>.$router.replace(&#123;<br>          query: &#123;<br>            ...this.$route.query,<br>            [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>          &#125;,<br>        &#125;);<br>      &#125;, <span class="hljs-number">1000</span>),<br>      &#123;<br>        deep: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用：<a href="https://juejin.im/post/5b8de829f265da43623c4261">掘金：7 分钟理解 JS 的节流、防抖及使用场景</a><br>参考：lodash 的函数 <a href="https://lodash.com/docs/4.17.15#debounce">debounce</a></p></blockquote><h3 id="处理路由不变但-query-修改的问题"><a href="#处理路由不变但-query-修改的问题" class="headerlink" title="处理路由不变但 query 修改的问题"></a>处理路由不变但 query 修改的问题</h3><p>接下来，就需要处理一种小众，但确实存在的场景了。</p><ul><li>同一个组件被多个路由复用，这些路由仅仅只是一个 path param 改变了。例如 <a href="https://ant.design/components/tabs-cn/">标签页</a></li><li>用户复制 URL 之后，发现其中的查询关键字错了，于是修改了关键字之后又复制了一次，而粘贴两次路由相同 query param 不同的 URL 是不会重新创建组件的</li></ul><p>首先确定基本的思路：在路由改变但组件没有重新创建时将 URL 上的数据为需要的数据进行初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在组件被 vue-router 路由复用时，单独进行初始化数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>route 将要改变的路由对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlDataByRouteUpdate</span>(<span class="hljs-params">exps, route</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>  exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>    setInitData(<span class="hljs-built_in">this</span>, exp, urlData);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 vue 实例的生命周期 <code>beforeRouteUpdate, beforeRouteEnter</code> 重新初始化 <code>data</code> 中的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>    initUrlDataByRouteUpdate.call(<span class="hljs-built_in">this</span>, [<span class="hljs-string">&quot;form&quot;</span>], to);<br>    next();<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>    next(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> initUrlDataByRouteUpdate.call(vm, [<span class="hljs-string">&quot;form&quot;</span>], to));<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>真的以为问题都解决了么？并不然，打开控制台你会发现一些 vue router 的警告</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vue-router.esm.js?8c4f:2051 Uncaught (<span class="hljs-keyword">in</span> promise) NavigationDuplicated &#123;_name: <span class="hljs-string">&quot;NavigationDuplicated&quot;</span>, name: <span class="hljs-string">&quot;NavigationDuplicated&quot;</span>, message: <span class="hljs-string">&quot;Navigating to current location (&quot;</span>/form1/?qb=%7B%22…,%22movie%22,%22game%22%5D%7D%7D<span class="hljs-string">&quot;) is not allowed&quot;</span>, stack: <span class="hljs-string">&quot;Error↵    at new NavigationDuplicated (webpack-int…/views/Form1.vue?vue&amp;type=script&amp;lang=js&amp;:222:40)&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>其实是因为循环触发导致的：<code>序列化数据到 URL 上 =&gt; 路由更新触发 =&gt; 初始化数据到 URL 上 =&gt; 触发数据改变 =&gt; 序列化数据到 URL 上。。。</code>，目前可行的解决方案是在 <code>$watch</code> 中判断数据是否与原来的相同，相同就不进行赋值，避免再次触发 vue-router 的 <code>beforeRouteUpdate</code> 生命周期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化一些数据需要序列化/反序列化到 url data 上</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initUrlData</span>(<span class="hljs-params">exps</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.$route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>  exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>    setInitData(<span class="hljs-built_in">this</span>, exp, urlData);<br>    <span class="hljs-built_in">this</span>.$watch(<br>      exp,<br>      debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>        urlData[exp] = val;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$route.query[key] === <span class="hljs-built_in">JSON</span>.stringify(urlData)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.$router.replace(&#123;<br>          query: &#123;<br>            ...this.$route.query,<br>            [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>          &#125;,<br>        &#125;);<br>      &#125;, <span class="hljs-number">1000</span>),<br>      &#123;<br>        deep: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，控制台不会再有警告了。</p><h3 id="封装起来"><a href="#封装起来" class="headerlink" title="封装起来"></a>封装起来</h3><h4 id="使用-Vue-插件"><a href="#使用-Vue-插件" class="headerlink" title="使用 Vue 插件"></a>使用 Vue 插件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; debounce, get, set &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./common&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueUrlPersist</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 一些选项</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.expListName = <span class="hljs-string">&quot;exps&quot;</span>;<br>    <span class="hljs-built_in">this</span>.urlPersistName = <span class="hljs-string">&quot;qb&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 将 URL 上的数据初始化到 data 上</span><br><span class="hljs-comment">   * 此处存在一个谬误</span><br><span class="hljs-comment">   * 1. 如果对象不使用合并而是赋值，则处理 [干净] 的 URL 就会很棘手，因为无法感知到初始值是什么</span><br><span class="hljs-comment">   * 2. 如果对象使用合并，则手动输入的相同路由不同参数的 URL 就无法处理</span><br><span class="hljs-comment">   *    注：该问题已经通过在 watch 中判断值是否变化而解决，但总感觉还有莫名其妙的坑在前面等着。。。</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">vm</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">expOrFn</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">urlData</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">initVueData</span>(<span class="hljs-params">vm, expOrFn, urlData</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> oldVal = get(vm, expOrFn, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">const</span> newVal = urlData[expOrFn];<br>    <span class="hljs-keyword">if</span> (oldVal === <span class="hljs-literal">undefined</span> || oldVal === <span class="hljs-literal">null</span>) &#123;<br>      set(vm, expOrFn, newVal);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldVal === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; newVal !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-built_in">Object</span>.assign(get(vm, expOrFn), newVal);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在组件被 vue-router 路由复用时，单独进行初始化数据</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">vm</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">expOrFnList</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">route</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">initNextUrlData</span>(<span class="hljs-params">vm, expOrFnList, route</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(route.query[<span class="hljs-built_in">this</span>.urlPersistName] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;urlData: &quot;</span>, urlData);<br>    expOrFnList.forEach(<span class="hljs-function">(<span class="hljs-params">expOrFn</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.initVueData(vm, expOrFn, urlData);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在组件被 vue 创建后初始化数据并监听之，在发生变化时自动序列化到 URL 上</span><br><span class="hljs-comment">   * 注：需要序列化到 URL 上的数据必须能被 JSON.stringfy 序列化</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">vm</span></span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">expOrFnList</span></span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">initUrlData</span>(<span class="hljs-params">vm, expOrFnList</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(vm.$route.query[<span class="hljs-built_in">this</span>.urlPersistName] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>    expOrFnList.forEach(<span class="hljs-function">(<span class="hljs-params">expOrFn</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.initVueData(vm, expOrFn, urlData);<br><br>      vm.$watch(<br>        expOrFn,<br>        debounce(<span class="hljs-number">1000</span>, <span class="hljs-keyword">async</span> (val) =&gt; &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;val 变化了: &quot;</span>, val);<br>          urlData[expOrFn] = val;<br><br>          <span class="hljs-keyword">if</span> (<br>            vm.$route.query[<span class="hljs-built_in">this</span>.urlPersistName] === <span class="hljs-built_in">JSON</span>.stringify(urlData)<br>          ) &#123;<br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br><br>          <span class="hljs-keyword">await</span> vm.$router.replace(&#123;<br>            query: &#123;<br>              ...vm.$route.query,<br>              [<span class="hljs-built_in">this</span>.urlPersistName]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>            &#125;,<br>          &#125;);<br>        &#125;),<br>        &#123;<br>          deep: <span class="hljs-literal">true</span>,<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">Vue, options = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">if</span> (options.expListName) &#123;<br>      <span class="hljs-built_in">this</span>.expListName = options.expListName;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (options.urlPersistName) &#123;<br>      <span class="hljs-built_in">this</span>.urlPersistName = options.urlPersistName;<br>    &#125;<br>    Vue.prototype.$urlPersist = <span class="hljs-built_in">this</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initDataByRouteUpdate</span>(<span class="hljs-params">to</span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> expList = <span class="hljs-built_in">this</span>[_this.expListName];<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(expList)) &#123;<br>        <span class="hljs-built_in">this</span>.$urlPersist.initNextUrlData(<span class="hljs-built_in">this</span>, expList, to);<br>      &#125;<br>    &#125;<br><br>    Vue.mixin(&#123;<br>      <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> expList = <span class="hljs-built_in">this</span>[_this.expListName];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(expList)) &#123;<br>          <span class="hljs-built_in">this</span>.$urlPersist.initUrlData(<span class="hljs-built_in">this</span>, expList);<br>        &#125;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>        initDataByRouteUpdate.call(<span class="hljs-built_in">this</span>, to);<br>        next();<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>        next(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> initDataByRouteUpdate.call(vm, to));<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> VueUrlPersist;<br></code></pre></td></tr></table></figure><p>使用起来和其他的插件没什么差别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> VueUrlPersist <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./views/js/VueUrlPersist&quot;</span>;<br><br><span class="hljs-keyword">const</span> vueUrlPersist = <span class="hljs-keyword">new</span> VueUrlPersist();<br>Vue.use(vueUrlPersist);<br></code></pre></td></tr></table></figure><p>在需要使用的组件中只要声明这个属性就好了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;Form2Tab&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      form: &#123;<br>        keyword: <span class="hljs-string">&quot;&quot;</span>,<br>        sex: <span class="hljs-number">0</span>,<br>      &#125;,<br>      exps: [<span class="hljs-string">&quot;form&quot;</span>],<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而，使用 vue 插件有个致命的缺陷：无论是否需要，都会为每个组件中都混入三个生命周期函数，吾辈没有找到一种可以根据实例中是否包含某个值而决定是否混入的方式。</p><h4 id="使用高阶函数"><a href="#使用高阶函数" class="headerlink" title="使用高阶函数"></a>使用高阶函数</h4><p>所以，我们使用 <code>高阶函数</code> + <code>mixin</code> 的形式看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; debounce, get, set &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./common&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueUrlPersist</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 一些选项</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123; key = <span class="hljs-string">&quot;qb&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.key = key;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 为 vue 实例上的字段进行深度赋值</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">setInitData</span>(<span class="hljs-params">vm, exp, urlData</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> oldVal = get(vm, exp, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">const</span> newVal = urlData[exp];<br>    <span class="hljs-comment">//如果原值是对象且新值也是对象，则进行浅合并</span><br>    <span class="hljs-keyword">if</span> (<br>      oldVal === <span class="hljs-literal">undefined</span> ||<br>      oldVal === <span class="hljs-literal">null</span> ||<br>      <span class="hljs-keyword">typeof</span> oldVal === <span class="hljs-string">&quot;string&quot;</span> ||<br>      <span class="hljs-keyword">typeof</span> oldVal === <span class="hljs-string">&quot;number&quot;</span><br>    ) &#123;<br>      set(vm, exp, newVal);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldVal === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> newVal === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-built_in">Object</span>.assign(get(vm, exp), newVal);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 初始化一些数据需要序列化/反序列化到 url data 上</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>vm vue 实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">initUrlDataByCreated</span>(<span class="hljs-params">vm, exps</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">this</span>.key;<br>    <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(vm.$route.query[key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>    exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.setInitData(vm, exp, urlData);<br>      vm.$watch(<br>        exp,<br>        debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>          urlData[exp] = val;<br>          <span class="hljs-keyword">if</span> (vm.$route.query[key] === <span class="hljs-built_in">JSON</span>.stringify(urlData)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br>          vm.$router.replace(&#123;<br>            query: &#123;<br>              ...vm.$route.query,<br>              [key]: <span class="hljs-built_in">JSON</span>.stringify(urlData),<br>            &#125;,<br>          &#125;);<br>        &#125;, <span class="hljs-number">1000</span>),<br>        &#123;<br>          deep: <span class="hljs-literal">true</span>,<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在组件被 vue-router 路由复用时，单独进行初始化数据</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>vm vue 实例</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>route 将要改变的路由对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">initUrlDataByRouteUpdate</span>(<span class="hljs-params">vm, exps, route</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> urlData = <span class="hljs-built_in">JSON</span>.parse(route.query[<span class="hljs-built_in">this</span>.key] || <span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>    exps.forEach(<span class="hljs-function">(<span class="hljs-params">exp</span>) =&gt;</span> <span class="hljs-built_in">this</span>.setInitData(vm, exp, urlData));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成可以 mixin 到 vue 实例的对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>exps 监视的数据的表达式数组</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;&#123;created(): void, beforeRouteEnter(*=, *, *): void, beforeRouteUpdate(*=, *, *): void&#125;</span></span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">generateInitUrlData</span>(<span class="hljs-params">...exps</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>        _this.initUrlDataByCreated(<span class="hljs-built_in">this</span>, exps);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>        _this.initUrlDataByRouteUpdate(<span class="hljs-built_in">this</span>, exps, to);<br>        next();<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;beforeRouteEnter&quot;</span>);<br>        next(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> _this.initUrlDataByRouteUpdate(vm, exps, to));<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 修改一些配置</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param </span>options 配置项</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-title">config</span>(<span class="hljs-params">options</span>)</span> &#123;<br>    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>, options);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> vueUrlPersist = <span class="hljs-keyword">new</span> VueUrlPersist();<br><span class="hljs-keyword">const</span> generateInitUrlData = vueUrlPersist.generateInitUrlData.bind(<br>  vueUrlPersist<br>);<br><br><span class="hljs-keyword">export</span> &#123; vueUrlPersist, generateInitUrlData, VueUrlPersist &#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> vueUrlPersist;<br></code></pre></td></tr></table></figure><p>使用起来几乎一样简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; generateInitUrlData &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./js/VueUrlPersist&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;Form1&quot;</span>,<br>  mixins: [generateInitUrlData(<span class="hljs-string">&quot;form&quot;</span>)],<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      form: &#123;<br>        keyword: <span class="hljs-string">&quot;&quot;</span>,<br>        hobbyList: [],<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>看起来，使用高阶函数也没有比 Vue 插件麻烦太多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，虽然路途坎坷，不过这个问题还是很有趣的，而且确实能解决实际的问题，所以还是有研究价值的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面相 vue 开发者的 react 入坑指南</title>
    <link href="/p/1f0ca923689549cca19517e74071e0ed/"/>
    <url>/p/1f0ca923689549cca19517e74071e0ed/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>问：为什么吾辈要使用 React？</li><li>答：React 拥有更加庞大的生态，以及对 TypeScript 的更好支持。<br>前者让需求实现变得更加简单，例如目前使用 Vue 做的后台管理系统使用了 Ant Design Vue 这个 UI 库，而它的上游 Ant Design 实际上官方维护的是 React 版本，而 Vue 并不是 <strong>亲儿子</strong>，导致一些问题并不像官方那么快解决。<br>后者强大的类型系统能降低维护成本，虽然开发时代码添加类型会稍加工作量，但可以降低维护成本，便于后续的修改、重构，同时 IDE 对其支持是 JavaScript 无法相提并论的。</li><li>问：那 React 相比于 Vue 而言有什么区别？</li><li>答：更强大、复杂、酷，对于没有现代前端开发经验的人而言可能非常困难，但一旦熟悉，则会非常喜欢它。组件化（<code>React Component/JSX</code>）、函数式（<code>React Hooks</code>）、不可变（<code>immutable</code>）都是非常有趣的思想，理解之后确实都能发现具体使用场景。<blockquote><p>Vue 作者说 <strong>React + Mobx 就是更复杂的 Vue</strong>，这句话确实有道理，下面在 <a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">状态管理</a> 那里也进行了说明，但同时，相比于 <code>Vue + Vuex</code>，避免引入 Redux 的 <code>React + Mobx</code> 将是更简单的。</p></blockquote></li><li>问：有大公司在用么？</li><li>答：作为能够支撑 Facebook 这种级别公司的 Web 产品的基础，显然它拥有相当多的生产环境实践。</li></ul><h2 id="工程与周边生态"><a href="#工程与周边生态" class="headerlink" title="工程与周边生态"></a>工程与周边生态</h2><p>以下皆基于 <code>cra(create-react-app)</code> 创建的 <code>ts + react + mobx + react-router + immer</code> 技术栈进行说明，虽然完全不了解以上内容亦可，但最好了解一下它们是做什么的，下面第一次提及时也会简单说明一下。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用 create-react-app 创建 react 项目，但和 vue-cli 有一点明显区别：不提供很多配置，只是简单的项目生成。</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>此处使用 mobx 对标，mobx 是一个状态管理库，以响应式、可变、简单方便为最大卖点。本质上可以认为为每个页面（页面内的所有组件）提供了一个全局对象，并实现了 vue 中的 <code>computed</code> 和 <code>watch</code>，所以 vue 的作者说 vue 是更简单的 react + mobx 确实有些道理，实际上这两个加起来能做到的事情不比原生 vue 多多少。</p><p>但它们之间也有几点不同</p><ul><li>vue 基于组件级别实现的 <code>computed</code> 和 <code>watch</code>，而 mobx 则是全局的</li><li>vue 是基于组件级别自动初始化和销毁，而 mobx 则是手动的</li><li>vue 基于组件但也受限于组件级别，全局状态仍要使用 vuex 这种 <strong>大炮</strong>，而 mobx 此时则是统一的</li><li>不使用 vuex 的情况下一些组件很难进行拆分，因为拆分后各组件的一些数据仍然需要共享和修改，这种时候单用 vue 的 <code>data/props</code> 就显得有些力不从心</li></ul><p>是否需要支持 es5？</p><ul><li>是：高阶函数</li><li>否：装饰器</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>递归菜单栏</li><li>使用高阶组件包装路由组件 <code>withRouter()</code></li><li>获取当前路由信息：<code>this.props.match</code></li><li>使用编程式的路由导航：<code>this.props.history</code><ul><li>注意 props 的类型变化</li></ul></li></ul><p>异步组件和 vue 稍微有点差别，虽然也是需要 <code>import()</code> 语法，但却需要使用高阶组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncRoute</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  importComponent: () =&gt; PromiseLike&lt;&#123; <span class="hljs-keyword">default</span>: any &#125;&gt; | &#123; <span class="hljs-keyword">default</span>: any &#125;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">any</span>, <span class="hljs-title">any</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props: any</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>(props);<br>      <span class="hljs-built_in">this</span>.state = &#123;<br>        component: <span class="hljs-literal">null</span>,<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">default</span>: component &#125; = <span class="hljs-keyword">await</span> importComponent();<br>      <span class="hljs-built_in">this</span>.setState(&#123;<br>        component: component,<br>      &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> C = <span class="hljs-built_in">this</span>.state.component;<br>      <span class="hljs-keyword">return</span> C ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">C</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span> : <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> AsyncComponent;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AsyncRoute;<br></code></pre></td></tr></table></figure><p>然后使用高阶组件包装即可</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;Route<br>  path=&#123;<span class="hljs-string">&quot;/system/task&quot;</span>&#125;<br>  component=&#123;AsyncRoute(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../../index/HelloWorld&quot;</span>))&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注：高阶组件和高阶函数类似，指的是接收一个组件/返回一个组件的组件。</p></blockquote><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><ul><li>导出：tsx/jsx 使用默认导出，避免需要高阶函数包装的场景</li><li>优先使用函数式组件</li><li>src<ul><li>pages：页面级的组件<ul><li>component：页面级组件</li></ul></li><li>components：非页面相关的通用组件</li><li>assets：静态资源</li></ul></li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>React<ul><li>组件：必须使用大写驼峰，包括使用组件亦然</li><li>store<ul><li>必须使用 .store 后缀以区分普通 ts 文件</li><li>组件级 store 必须与组件名保持一致，例如 <code>Login</code> 组件对应的即为 <code>Login.store.ts</code></li></ul></li></ul></li><li>CSS<ul><li>css 中的 class 必须使用小写驼峰命名法，避免 css module 找不到（cra 不会自动处理转换）</li><li>优先使用 <code>.module.css</code> 而非 <code>.css</code>，避免全局样式污染</li><li>页面级 css 必须与组件名保持一致，例如 <code>Login</code> 组件对应的即为 <code>Login.module.css</code></li><li>非 css module 的代码必须使用 <code>&quot;&quot;</code> 而非 <code>&#123;&#39;&#39;&#125;</code></li></ul></li></ul><h3 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h3><p>cra 默认提供了脚本命令 <code>reject</code>，用于将 cra 封装的配置全部解压出来 – 当然，此操作是不可逆的！但除了这种破坏性的方式之外，也有人找到了和 vue-cli 中类似的方式，不过需要第三方包 <code>react-app-rewired</code> 的支持。</p><p>并在根目录添加配置文件 <code>config-overrides.js</code>，里面暴露出一个函数，即可修改 cra 的默认配置了。</p><p>下面是一个简单的示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WorkerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;worker-plugin&quot;</span>);<br><br><span class="hljs-comment">/* config-overrides.js */</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">override</span>(<span class="hljs-params">config, env</span>) </span>&#123;<br>  <span class="hljs-comment">//region WebWorker 配置</span><br><br>  <span class="hljs-comment">//do stuff with the webpack config...</span><br>  config.output.globalObject = <span class="hljs-string">&quot;this&quot;</span>;<br>  <span class="hljs-keyword">if</span> (!config.plugins) &#123;<br>    config.plugins = [];<br>  &#125;<br>  config.plugins.push(<span class="hljs-keyword">new</span> WorkerPlugin());<br><br>  <span class="hljs-comment">//endregion</span><br><br>  <span class="hljs-keyword">return</span> config;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-parcel-js-进行项目打包"><a href="#使用-parcel-js-进行项目打包" class="headerlink" title="使用 parcel.js 进行项目打包"></a>使用 parcel.js 进行项目打包</h3><p>parcel 是一个新的打包工具，目的是提供开箱即用的零配置打包方案，和 webpack 大不相同的一点就是其不需要接触很多的概念，通过直接指定 html 文件为入口即可引入其他资源，包括但不限于 <code>vue/react/typescript/less</code> 之类的第三方资源，从逻辑上来讲对用户更加友好。</p><blockquote><p><a href="https://parceljs.org/">官网</a>, <a href="https://github.com/parcel-bundler/parcel">GitHub</a></p></blockquote><p>使用 parcel 打包和启动多入口项目非常简单，这是一个基本的多入口打包 <a href="https://github.com/rxliuli/example/tree/master/antd_reactive_example">demo</a> 项目，允许将 App/Web 上类似的功能放在同一个项目中，并且支持集成其他有趣的功能。</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="this-的值"><a href="#this-的值" class="headerlink" title="this 的值"></a>this 的值</h3><p>在 <code>class</code> 中使用箭头函数以直接绑定当前组件的实例，尽量不要使用 <code>function</code>，否则 <code>this</code> 可能是不明确的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  logMsg = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;msg&quot;</span>);<br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;hello world&lt;/h1&gt;<br>        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.logMsg&#125;&gt;打印&lt;/button&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HelloWorld;<br></code></pre></td></tr></table></figure><h3 id="CSS-样式隔离"><a href="#CSS-样式隔离" class="headerlink" title="CSS 样式隔离"></a>CSS 样式隔离</h3><p>cra 创建的项目默认支持 css module，是 react 项目流行的一种 CSS 隔离方案。</p><p>使用步骤</p><ol><li> 为需要的 css 文件使用 <code>.module.css</code> 后缀名</li><li> 通过 <code>import styles from &#39;*.module.css&#39;</code> 在 <code>tsx</code> 中引入</li><li> 在 <code>className=&#123;styles.*&#125;</code> 使用 class 样式</li></ol><p>示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.helloWorld</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;HelloWorld.module.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloWorld</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.helloWorld&#125;</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>此处的 <code>import styles from &#39;*.module.css&#39;</code> 不支持命名导入</li><li>此处实现的逻辑和 Vue 是一致的，只要使用了其中一个样式 <code>class</code>，则整个文件都会引入</li><li>CSS 只要被引入了，就不会被删除，即便组件被销毁了亦然，所以页面内的 CSS 只会增加，不会减少</li></ul><p>如何添加多个，默认使用 cra 创建的项目支持使用模板字符串</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">className=&#123;<span class="hljs-string">`<span class="hljs-subst">$&#123;styles.className1&#125;</span> <span class="hljs-subst">$&#123;styles.className2&#125;</span>`</span>&#125;<br></code></pre></td></tr></table></figure><p>看起来很丑？可以试试 <a href="https://github.com/JedWatson/classnames">classnames</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;classnames&#x27;</span><br><br>className=&#123;classNames(globalStyles.global, globalStyles.margin)&#125;<br></code></pre></td></tr></table></figure><p>但仍然很丑，正如 Sindre Sorhus 所说：<a href="https://twitter.com/sindresorhus/status/1001355913930858502">React 把简单的事情变复杂，复杂的事情变简单</a></p><p>另一种个 API 是 <code>classNames.bind</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;classnames&#x27;</span><br><span class="hljs-keyword">const</span> cx=&#123;classNames.bind(globalStyles)&#125;<br>className=&#123;cx(<span class="hljs-string">&#x27;global&#x27;</span>, <span class="hljs-string">&#x27;margin&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><p>但这会让 WebStorm 损失所有的 CSS 关联，影响了包括代码提示/跳转/重构等功能，考虑到维护成本实在得不偿失。</p><p>还有人提出了 typed css module，为所有的 <code>.module.css</code> 生成 <code>.d.ts</code> 类型定义，但这会和 css in js 一样丧失 css 预处理器的优势 —- 并且，所有的工具链都需要重新支持这种关联，将之认为是 css。</p><blockquote><p>参考</p><ul><li><a href="https://www.javascriptstuff.com/css-modules-by-example/">Css Modules by Example</a></li><li><a href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/">添加 CSS 模块样式表</a></li><li><a href="https://github.com/gajus/babel-plugin-react-css-modules">babel-plugin-react-css-modules</a></li></ul></blockquote><h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><p>在任何一个项目中，都少不了引入图片的需求。而 React 中，并未像 Vue 对 <code>img, audio, video</code> 这些标签进行特殊处理，以支持直接使用路径即可将对应的媒体文件打包进来，React 需要使用 <code>import img from &#39;*&#39;</code> 的<strong>原始</strong>形式让 webpack <strong>知道</strong>这是一个需要打包的资源。</p><p>例如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;img.png&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>&#123;<br>  reutrn(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;img&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;img&quot;</span> /&gt;</span></span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于 SVG 类型的图片，React 支持使用组件的形式引入。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; ReactComponent <span class="hljs-keyword">as</span> IconAudio &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../assets/icon/icon-audio.svg&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>&#123;<br>  reutrn(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IconAudio</span> /&gt;</span></span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>两种方案</p><ol><li> 使用 <code>&#123;props.children&#125;</code>，和 vue 的 <code>slot:default</code> 几乎一样，只是不能通过子组件传递参数。</li><li> 如果需要传递多个命名 <code>slot</code>，则可以直接为 <code>props</code> 属性赋值为组件。例如 <code>title=&#123;&lt;div&gt;hello world&lt;/div&gt;&#125;</code></li><li> 如果需要使用子组件传参的话需要使用函数式组件的形式。例如 <code>title=&#123;value =&gt; &lt;div&gt;&#123;value&#125;&lt;/div&gt;&#125;</code></li></ol><blockquote><p>吐槽：函数式已经是政治正确了。</p></blockquote><p>使用函数式的 <code>slot</code> 时必须检查函数是否存在，如果不存在则不要调用，不像是 vue 中的 <code>slot</code> 是自动处理这一步的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;<br>  <span class="hljs-built_in">this</span>.props.tableOperate &amp;&amp; <span class="hljs-built_in">this</span>.props.tableOperate(<span class="hljs-built_in">this</span>.state.innerValue);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="watch-监听-props"><a href="#watch-监听-props" class="headerlink" title="watch 监听 props"></a>watch 监听 props</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps: PropsType</span>)</span> &#123;<br>  <span class="hljs-comment">// 典型用法（不要忘记比较 props）：</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.value !== prevProps.value) &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      innerValue: <span class="hljs-built_in">this</span>.props.value,<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>相比于 Vue 的生命周期，React 显然更加<strong>复杂</strong>与<strong>混乱</strong>，而且，老实说有时候真的很难用。</p><p>例如非常常见的生命周期 <code>componentWillUpdate</code>，它承担的责任实在是太多了，不仅 <code>watch</code> <code>state/props</code> 中的数据要用这个，连 React Router 的路由变化同样依赖于此。</p><p>下面列出最常用的一些生命周期以及典型用例</p><ul><li><p><code>render</code>：只要 state 变化就会触发重新渲染，等价于 vue 中渲染模板 HTML 中的内容</p></li><li><p><code>shouldComponentUpdate</code>：state 或者 props <strong>变化前</strong>就会执行，时机上早于 <code>render</code>。等价于 vue <code>beforeUpdate</code>，但可以在这个方法内 <code>return false</code> 阻止视图更新。</p></li><li><p><code>componentDidUpdate</code>：state 或者 props <strong>变化后</strong>就会执行，时机上晚于 <code>render</code>。等价于 vue <code>updated</code>。<br>多用于监听一些数据变化执行一些副作用操作，但包含的种类可能会非常多。</p><blockquote><p>注：此处 vue 中将之分为 <code>updated/watch/beforeRouteUpdate</code>，而在 React 中，全部由 <code>componentDidMount</code> 承担这个责任。</p></blockquote></li><li><p><code>componentDidMount</code>：当组件渲染<strong>完成后</strong>就会执行，时机上晚于 <code>render</code>，等价于 vue <code>mounted</code>。<br>多用于执行一些初始化操作，除非逻辑特别简单，否则不要在这个函数里放具体执行逻辑代码，而是专门写初始化函数在这里调用。</p></li><li><p><code>UNSAFE_componentWillMount</code>：在组件渲染<strong>完成前</strong>就会执行，等价于 vue <code>beforeMount</code>，但被废弃了，替代解决方案参考 <a href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E6%B2%A1%E6%9C%89-created-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BF%9D%E8%AF%81%E7%94%A8%E6%88%B7%E7%9C%8B%E4%B8%8D%E5%88%B0%E9%BB%98%E8%AE%A4%E7%A9%BA%E6%95%B0%E6%8D%AE">怎么在没有 <code>created</code> 生命周期的情况下初始化数据并保证用户看不到默认空数据</a>。</p></li><li><p><code>componentWillUnmount</code>: 组件即将被销毁前调用，等价于 vue <code>beforeDestroy</code>。</p></li></ul><h3 id="简化-state-修改"><a href="#简化-state-修改" class="headerlink" title="简化 state 修改"></a>简化 state 修改</h3><p>使用 <code>setState</code> 很烦的一点是当你需要深度为某个属性赋值的时候，要为该属性上面所有的对象全部使用 <code>...</code> 或者其他方式拷贝一遍。</p><p>例如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">this</span>.setState(&#123;<br>  user: &#123;<br>    ...this.state.user,<br>    address: &#123;<br>      ...this.state.user.address,<br>      city: newCity,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>当有多个属性需要赋值时就尤其的繁琐，而 <a href="https://github.com/immerjs/immer">immerjs</a> 正好可以解决这种痛点</p><p>使用 immer 重构之后</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">this</span>.setState(produce(<span class="hljs-built_in">this</span>.state, <span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> &#123;<br>  draft.user.address.city = newCity<br>&#125;)<br></code></pre></td></tr></table></figure><p>代码变得很简单了，虽然看起来是直接赋值，不过 immer 使用了 <code>Proxy</code> 和 <code>Object.freeze</code> 实现了对使用者友好的不可变数据修改，具体参考 。</p><h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><p>React Hooks 是在 React 16.8 之后添加的一项新特性，一如既往，很多人又是吹的天花乱坠。老实说最开始 React Hooks 流行并且在各个地方大肆宣传时，吾辈非常讨厌它，因为它又向函数式靠近了一步—-函数式政治正确真的很讨厌！所以，自正式学习 React 以来，吾辈都没有接触过 React Hooks，都是用 Class Component 实现组件。<br>但现在，架不住好奇心和一些朋友的推荐，吾辈稍微看了一下这个新特性。</p><p>它提供了两个主要的 API：</p><ul><li><code>useState</code>：声明一些可变状态</li><li><code>useEffect</code>：声明一些副作用代码</li></ul><p>使用看起来很简单</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useEffect, useRef, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> HelloHooks: React.FC = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//region 计数器</span><br><br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> [list, setList] = useState&lt;string[]&gt;([])<br>  <span class="hljs-keyword">const</span> countAdd = <span class="hljs-function">() =&gt;</span> setCount(count + <span class="hljs-number">1</span>)<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;count changed: &#x27;</span>, count)<br>    setList(<br>      <span class="hljs-built_in">Array</span>(count)<br>        .fill(<span class="hljs-number">0</span>)<br>        .map(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span> 个元素`</span>),<br>    )<br>    <span class="hljs-comment">//监听 count 变化</span><br>  &#125;, [count])<br><br>  <span class="hljs-comment">//endregion</span><br><br>  <span class="hljs-comment">//region 自动聚焦输入框</span><br><br>  <span class="hljs-keyword">const</span> inputRef = useRef&lt;HTMLInputElement&gt;(<span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> any)<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    inputRef.current.focus()<br>    <span class="hljs-comment">//不监听任何值变化，只在第一次渲染运行</span><br>  &#125;, [])<br><br>  <span class="hljs-comment">//endregion</span><br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        &lt;input<br>          ref=&#123;inputRef&#125;<br>          value=&#123;count&#125;<br>          type=<span class="hljs-string">&quot;number&quot;</span><br>          onChange=&#123;<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> setCount(<span class="hljs-built_in">parseInt</span>(e.target.value))&#125;<br>        /&gt;<br>        &lt;button onClick=&#123;countAdd&#125;&gt;增加&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;ul&gt;<br>        &#123;list.map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> (<br>          &lt;li key=&#123;i&#125;&gt;&#123;v&#125;&lt;/li&gt;<br>        ))&#125;<br>      &lt;/ul&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HelloHooks<br></code></pre></td></tr></table></figure><p>可以看到，上面用 <code>useState/useEffect</code> 两个函数实现了一些常见的功能：<code>state, componentDidMount, componentDidUpdate</code>，<code>useEffect</code> 甚至默认支持类似 vue <code>watch</code> 的使用方式。</p><p>同时，使用 Hooks 可以轻易地封装出 <code>useModel</code>, vue 中的 <code>watch/computed</code> 甚至原生自带了！</p><ul><li><code>useMemo</code>：当依赖变化时计算属性</li><li><code>useCallback</code>：当依赖变化时执行回调</li></ul><p>然而，Hooks 终究不是万能。</p><ul><li>使用 Hooks 封装控制 DOM 相关的代码做不到，例如使用高阶组件实现的根据某些条件控制组件是否加载。</li><li>使用 Hooks 无法实现全部的生命周期，例如 <code>shouldComponentUpdate</code>。</li><li>Hooks <code>useEffect</code> 中调用的外部函数，无法即时获取到所有最新的 <code>state</code>，即便它们与 <code>useEffect</code> 同级（需要使用 <code>useCallback</code> 包装）</li><li>使用 Hooks 会让函数变得很大，对开发人员的要求比之前更高（与 vue 3 的函数式 API 一样，都是由开发者自己完全控制代码块的分割）</li></ul><blockquote><p>更多有关 React Hooks 的介绍，请参考：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">https://zh-hans.reactjs.org/docs/hooks-intro.html</a> 以及 <a href="https://vue-composition-api-rfc.netlify.com/#comparison-with-react-hooks">Vue Composition API 与 React Hooks 的对比</a>。</p></blockquote><!-- ### React PropsReact props 基本上能传递任何东西，所以承担了 vue 中的多个特性。- `props` 传递参数- `$emit` 传递事件- `slot` 传递组件从这点来看，React 真是 **少即是多** 的范例。 --><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="React-有什么缺点"><a href="#React-有什么缺点" class="headerlink" title="React 有什么缺点"></a>React 有什么缺点</h3><ul><li>CSS 局部化有很多方案，但没有一统天下的</li><li>vue 在组件创建/销毁时会自动初始化/销毁状态及监听器，而 mobx 会一直保留需要手动初始化/清理<ul><li>注: 这点还未找到解决方案</li><li>更新：可以使用 context 部分解决这个问题</li></ul></li><li>使用 AntD 时可能遇到样式覆盖不了的问题，需要混合使用 <code>className, style</code> 两个属性。</li><li>react 会在开发阶段报错比较多，主要是一些低级错误，尤其是加上 ts 之后尤其如此</li></ul><h3 id="怎么在没有-created-生命周期的情况下初始化数据并保证用户看不到默认空数据"><a href="#怎么在没有-created-生命周期的情况下初始化数据并保证用户看不到默认空数据" class="headerlink" title="怎么在没有 created 生命周期的情况下初始化数据并保证用户看不到默认空数据"></a>怎么在没有 <code>created</code> 生命周期的情况下初始化数据并保证用户看不到默认空数据</h3><p>在 vue 中，吾辈经常在 created 生命周期中加载数据，避免用户看到默认的空数据，然而，React 中却没有这个生命周期，所以需要额外的处理。</p><blockquote><p>注：其实 vue 中用户也有可能看到空数据，但因为 Ajax 请求数据的速度也比较快，所以默认可以不用处理。</p></blockquote><p>一个可能解决方案是在指定元素外面包一层，在页面数据未加载之前，在元素上方添加一个 Loading 遮罩层提示<strong>正在加载中</strong>，等到数据加载完成后删除浮层。</p><p>下面是一个简单的实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* ComponentLoading.module.css */</span><br><span class="hljs-selector-class">.componentLoadingDialog</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ComponentLoading.tsx</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; Spin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentLoading.module.css&#x27;</span><br><br>type PropsType = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 是否显示 loading?</span><br><span class="hljs-comment">   */</span><br>  isLoading: boolean<br>  tip?: string<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 控制 Ajax 请求未完成前某个区域不展示默认数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">props</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@constructor</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> ComponentLoading: React.FC&lt;PropsType&gt; = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; isLoading, tip = <span class="hljs-string">&#x27;正在加载中。。。&#x27;</span> &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div style=&#123;&#123; <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;relative&#x27;</span> &#125;&#125;&gt;<br>      &#123;isLoading &amp;&amp; (<br>        &lt;div className=&#123;styles.componentLoadingDialog&#125;&gt;<br>          &lt;Spin tip=&#123;tip&#125; /&gt;<br>        &lt;/div&gt;<br>      )&#125;<br><br>      &#123;<span class="hljs-comment">/*注：默认会渲染 children 组件*/</span>&#125;<br>      &#123;props.children&#125;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ComponentLoading<br></code></pre></td></tr></table></figure><h3 id="React-和-vue-3-的对比"><a href="#React-和-vue-3-的对比" class="headerlink" title="React 和 vue 3 的对比"></a>React 和 vue 3 的对比</h3><p>vue 3 新增了 <code>Function-base</code> 的组件，看起来很像 React Hooks，但目前仍然无法在生产中实用。</p><p>目前看来有以下缺点</p><ol><li> IDE 支持不好</li><li> TS 不能解决 Vue 中的一些问题，尤其是对于模板层面简直无能为力</li><li> Vue 3 函数式组件没有覆盖之前所有的功能</li><li> 周边生态目前没有早期支持的迹象</li></ol><p>关于第二和第三点，吾辈认为这是 Vue 使用模板带来的一些天然的问题，几乎不可能解决。</p><p>而 React 和 TS 结合比 Vue 要完善很多，包括类型校验完全使用 TS 而非自定义运行时校验机制。</p><blockquote><p>参考：</p><ul><li><a href="https://vue-composition-api-rfc.netlify.com/#comparison-with-react-hooks">Vue composition api comparison with React Hooks</a></li><li><a href="https://aweiu.com/%E8%B0%81%E8%83%BD%E5%A4%A7%E8%87%B4%E8%AF%B4%E4%B8%8Bvue%E5%92%8Creact%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB%E4%B9%8B%E5%A4%84%EF%BC%9F/">谁能大致说下 vue 和 react 的最大区别之处？</a></li></ul></blockquote><h3 id="开发环境代理"><a href="#开发环境代理" class="headerlink" title="开发环境代理"></a>开发环境代理</h3><p>开发环境配置代理几乎是必用功能。</p><p>简单的情况直接在 <code>package.json</code> 中使用 <code>proxy</code> 字段即可</p><blockquote><p>参考：<a href="https://create-react-app.dev/docs/proxying-api-requests-in-development">Proxying API Requests in Development</a></p></blockquote><p>复杂的情况相比于 vue-cli 将全部配置统一在 <code>vue.config.js</code> 中，cra 看起来仍是分散式的。</p><p>步骤</p><ol><li><p> 安装中间件 <code>yarn add -D http-proxy-middleware @types/</code></p></li><li><p> 创建文件 <code>src/setupProxy.ts</code></p></li><li><p>编写配置</p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> proxy <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http-proxy-middleware&quot;</span>;<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开发环境代理</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">app</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string|*&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> proxyConfig: proxy.Config = &#123;<br>    target: <span class="hljs-string">&quot;https://localhost:8000&quot;</span>,<br>    changeOrigin: <span class="hljs-literal">true</span>,<br>    secure: <span class="hljs-literal">false</span>,<br>    ws: <span class="hljs-literal">true</span>,<br>    <span class="hljs-function"><span class="hljs-title">pathRewrite</span>(<span class="hljs-params">api: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> mockApiList = fs.readJSONSync(<br>        path.resolve(__dirname, <span class="hljs-string">&quot;./config/mockApiList.json&quot;</span>)<br>      );<br>      <span class="hljs-keyword">return</span> (<br>        api +<br>        (mockApiList.some(<span class="hljs-function">(<span class="hljs-params">mockApi: <span class="hljs-built_in">string</span></span>) =&gt;</span> api.includes(mockApi))<br>          ? <span class="hljs-string">&quot;?mock=default&amp;errCode=200&quot;</span><br>          : <span class="hljs-string">&quot;&quot;</span>)<br>      );<br>    &#125;,<br>  &#125;;<br><br>  app.use(proxy(<span class="hljs-string">&quot;/api&quot;</span>, proxyConfig));<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>参考：</p><ul><li><a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a></li><li><a href="https://juejin.im/post/5bd13c5ce51d457a203cebf4">一篇读懂 http-proxy-middleware</a></li></ul></blockquote></li></ol><h3 id="怎么打包成不依赖于部署路径的-dist"><a href="#怎么打包成不依赖于部署路径的-dist" class="headerlink" title="怎么打包成不依赖于部署路径的 dist"></a>怎么打包成不依赖于部署路径的 dist</h3><ol><li><p> 修改 <code>package.json</code> 中字段 <code>homepage</code> 的值为 <code>.</code></p></li><li><p>使用 react router 中的 hash mode，具体而言就是修改 <em>index.tsx</em> 中使用如下代码，关键是 <code>HashRouter</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import React from &quot;react&quot;;<br>import ReactDOM from &quot;react-dom&quot;;<br>import &#123; HashRouter &#125; from &quot;react-router-dom&quot;;<br>import App from &quot;.&#x2F;App.tsx&quot;;<br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;HashRouter&gt;<br>      &lt;App &#x2F;&gt;<br>    &lt;&#x2F;HashRouter&gt;<br>  &lt;&#x2F;React.StrictMode&gt;,<br>  document.getElementById(&quot;app&quot;)<br>);<br></code></pre></td></tr></table></figure><h3 id="为什么-react-hooks-总是有奇怪的问题"><a href="#为什么-react-hooks-总是有奇怪的问题" class="headerlink" title="为什么 react hooks 总是有奇怪的问题"></a>为什么 react hooks 总是有奇怪的问题</h3></li></ol><p>根源在于 react 的 render 函数是多次执行，导致如果没有正确的声明依赖项或者顺序，就会导致出现奇怪的问题。</p><p>典型的依赖声明问题</p><blockquote><p>参考: <a href="https://codesandbox.io/s/react-hooks-useeffect-bixuzhengquedeshengmingyilaibaoguaqineibudiaoyongdeqitahanshudeyilaixiang-4iy1x">https://codesandbox.io/s/react-hooks-useeffect-bixuzhengquedeshengmingyilaibaoguaqineibudiaoyongdeqitahanshudeyilaixiang-4iy1x</a></p></blockquote><p>典型的顺序问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端使用工具强制实行代码规范（Vue）</title>
    <link href="/p/81cc1bbf5d8c4eb28224f752550189f7/"/>
    <url>/p/81cc1bbf5d8c4eb28224f752550189f7/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p><a href="https://github.com/rxliuli/example/tree/master/linter_vue_example">GitHub Demo</a></p></blockquote><p>非强制性的规范都不会成为真正的规范。在之前，我们也会在团队内编写一些开发规范文档，却总是不能真正有效的执行下去，原因何在？</p><ul><li>其一，人是健忘的，就算真正看完了规范文档，也不可能记住每一条规范，并且在代码中正确实践。</li><li>其二，人是懒惰的，即便有着规范，但只要写代码的时候没有强制性，那总是不会在意的。</li></ul><p>那么，使用自动化的工具是为首选，而前端恰好有了一些可用的工具来帮助我们。</p><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>ESLint 是一个对 JS 低级错误进行修复的工具，甚至于，现在连 TypeScript 官方也抛弃 TSLint 转向这个工具了，因为它的生态更大，实现的规则数量远远多于 TSLint，能把 JS 中的大部分低级错误检测出来，并能自动修复其中一部分。</p><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D eslint babel-eslint eslint-plugin-vue @vue/cli-plugin-eslint<br></code></pre></td></tr></table></figure><blockquote><p>依赖解释</p><ul><li><code>eslint</code>: 本体包</li><li><code>babel-eslint</code>: eslint 与 babel 整合包</li><li><code>eslint-plugin-vue @vue/cli-plugin-eslint</code>: eslint 与 vue 整合包</li></ul></blockquote><p>进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .eslintrc.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  root: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">//环境</span><br>  env: &#123;<br>    browser: <span class="hljs-literal">true</span>,<br>    commonjs: <span class="hljs-literal">true</span>,<br>    es6: <span class="hljs-literal">true</span>,<br>    node: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-keyword">extends</span>: [<br>    <span class="hljs-comment">//继承 vue 的标准特性</span><br>    <span class="hljs-string">&quot;plugin:vue/essential&quot;</span>,<br>    <span class="hljs-string">&quot;eslint:recommended&quot;</span>,<br>  ],<br>  rules: &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 禁止不需要的括号，例如 const i = (1 + 1)，但该规则存在的问题是会认为类两侧的圆括号也是不合法的</span><br><span class="hljs-comment">     * 例如: billId =&gt; (StringValidator.isBlank(billId) ? &#x27;否&#x27; : &#x27;是&#x27;)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// &#x27;no-extra-parens&#x27;: &#x27;error&#x27;,</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 禁止魔法值，该规则的主要问题是很多误报</span><br><span class="hljs-comment">     * 例如: offset / size + (offset % size === 0 ? 0 : 1)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-string">&quot;no-magic-numbers&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br><br>    <span class="hljs-comment">//禁止使用 var，强制要求使用 const/let</span><br>    <span class="hljs-string">&quot;no-var&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//不使用未定义的变量</span><br>    <span class="hljs-string">&quot;no-use-before-define&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//不允许在循环中使用 await，请使用 Promise.all</span><br>    <span class="hljs-string">&quot;no-await-in-loop&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//不允许使用 return await，直接返回 Promise 就好</span><br>    <span class="hljs-string">&quot;no-return-await&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//不允许使用 console 对象，因为会打印到控制台上</span><br>    <span class="hljs-string">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//使用 class 中的方法必须使用 this. 前缀</span><br>    <span class="hljs-comment">// &#x27;class-methods-use-this&#x27;: &#x27;error&#x27;,</span><br>    <span class="hljs-comment">//禁止使用 alert, confirm, prompt，该 API 会阻断所有其他操作，但该规则存在的问题是有可能需要之后用上方便统一调用呢？</span><br>    <span class="hljs-string">&quot;no-alert&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止使用 eval，该操作是危险的</span><br>    <span class="hljs-string">&quot;no-eval&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-string">&quot;no-implied-eval&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止使用 new Function 创建函数</span><br>    <span class="hljs-string">&quot;no-new-func&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止使用包装类 String, Number, Boolean</span><br>    <span class="hljs-string">&quot;no-new-wrappers&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止把语句作为计算结果返回，请使用两条语句</span><br>    <span class="hljs-string">&quot;no-return-assign&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止使用不应该的 concat 连接，字符串请使用 + 连接，数组则可以使用 [...arr1, ...arr2]</span><br>    <span class="hljs-string">&quot;no-useless-concat&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止 yoda 比较，不要用 1 === i 而是用 i === 1 更加自然</span><br>    yoda: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止没有用的三元运算符，就算是 ⑨ 也知道这样做有问题 answer === 1 ? true : false</span><br>    <span class="hljs-string">&quot;no-unneeded-ternary&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//禁止无用的计算属性 const obj = &#123; [&#x27;1&#x27;]: 1 &#125;</span><br>    <span class="hljs-string">&quot;no-useless-computed-key&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//如果可以使用解构，那就进行警告，例如 const name = user.name 就应该被替换为 const &#123; name &#125; = user，避免了重复声明，也能进行默认赋值等操作</span><br>    <span class="hljs-string">&quot;prefer-destructuring&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span>,<br>    <span class="hljs-comment">//使用 rest 不定参数代替全局变量 arguments</span><br>    <span class="hljs-string">&quot;prefer-rest-params&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//使用扩展运算符代替 apply 调用</span><br>    <span class="hljs-string">&quot;prefer-spread&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//使用 Symbol 必须使用描述说明它要做什么</span><br>    <span class="hljs-string">&quot;symbol-description&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>    <span class="hljs-comment">//如果可以使用反射，那就是用反射调用，Reflect 代替 delete 关键字删除对象属性</span><br>    <span class="hljs-string">&quot;prefer-reflect&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span>,<br>  &#125;,<br>  parserOptions: &#123;<br>    <span class="hljs-comment">//使用 babel 解析语法</span><br>    parser: <span class="hljs-string">&quot;babel-eslint&quot;</span>,<br>    <span class="hljs-comment">//使用 es2017 的语法</span><br>    ecmaVersion: <span class="hljs-number">2017</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果有需要忽略的文件也可以在 <em>.eslintignore</em> 文件中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ignore">&#x2F;&#x2F; .eslintignore<br>&#96;&#x2F;&#x2F; 忽略掉 TypeScript 类型定义文件<br>*&#x2F;**&#x2F;*.d.ts&#96;<br></code></pre></td></tr></table></figure><p>添加脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;lint:js&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint&quot;</span>,<br>    <span class="hljs-attr">&quot;fix:js&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint --fix&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm run lint:js<br></code></pre></td></tr></table></figure><p>现在，你可以检测到代码中的问题，并修复它了。</p><p>相关链接</p><ul><li><a href="https://eslint.org/">ESLint 官网</a></li><li><a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint">vue eslint 整合包</a></li></ul><blockquote><p>WebStorm 配置 ESLint 即时检查:<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926114439.png" alt="WebStorm 使用 ESLint"><br>参考: <a href="https://stackoverflow.com/questions/28808857">https://stackoverflow.com/questions/28808857</a></p></blockquote><h2 id="StyleLint"><a href="#StyleLint" class="headerlink" title="StyleLint"></a>StyleLint</h2><p>StyleLint 是一个用来对 CSS 进行校验/修复的工具，和 ESLint 类似，但却针对 CSS 方面。我们使用它用来避免一些不好的 CSS 写法，也能避免 code review 时被其他人吐槽。。。</p><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D stylelint stylelint-config-standard stylelint-order stylelint-scss<br></code></pre></td></tr></table></figure><blockquote><p>依赖解释</p><ul><li><code>stylelint</code>: 本体包</li><li><code>stylelint-config-standard</code>: stylelint 标准配置</li><li><code>stylelint-scss</code>: stylelint scss 支持插件包</li><li><code>stylelint-order</code>: stylelint 属性排序插件</li></ul></blockquote><p>进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// stylelint.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  plugins: [<span class="hljs-string">&quot;stylelint-scss&quot;</span>, <span class="hljs-string">&quot;stylelint-order&quot;</span>],<br>  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&quot;stylelint-config-standard&quot;</span>],<br>  rules: &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关键问题在于是否要忽略空检查</span><br><span class="hljs-comment">     * 下面两种都会被判断为错误</span><br><span class="hljs-comment">     * &lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</span><br><span class="hljs-comment">     * a &#123;&#125;</span><br><span class="hljs-comment">     * 上面一种是很常见的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// &#x27;no-empty-source&#x27;: null,</span><br>    <span class="hljs-comment">//禁止注释两侧出现空白（IDEA 默认就没有空白）</span><br>    <span class="hljs-string">&quot;comment-whitespace-inside&quot;</span>: <span class="hljs-string">&quot;never&quot;</span>,<br>    <span class="hljs-comment">//scss 的特定符号将被 css 检查时忽略而在 scss 检查时才会生效</span><br>    <span class="hljs-string">&quot;at-rule-no-unknown&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;scss/at-rule-no-unknown&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">//CSS 声明定义顺序，自定义 class 放在默认元素上面</span><br>    <span class="hljs-string">&quot;order/order&quot;</span>: [<span class="hljs-string">&quot;custom-properties&quot;</span>, <span class="hljs-string">&quot;declarations&quot;</span>],<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CSS 属性顺序</span><br><span class="hljs-comment">     * 1. 控制外部属性</span><br><span class="hljs-comment">     * 2. 盒模型</span><br><span class="hljs-comment">     * 3. 视觉</span><br><span class="hljs-comment">     * 4. 其他</span><br><span class="hljs-comment">     * 5. 未定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-string">&quot;order/properties-order&quot;</span>: [<br>      [<br>        <span class="hljs-comment">//指令</span><br>        <span class="hljs-string">&quot;composes&quot;</span>,<br>        <span class="hljs-string">&quot;@import&quot;</span>,<br>        <span class="hljs-string">&quot;@extend&quot;</span>,<br>        <span class="hljs-string">&quot;@mixin&quot;</span>,<br>        <span class="hljs-string">&quot;@at-root&quot;</span>,<br>        <span class="hljs-comment">//盒模型相关</span><br>        <span class="hljs-string">&quot;display&quot;</span>,<br>        <span class="hljs-string">&quot;flex&quot;</span>,<br>        <span class="hljs-string">&quot;flex-basis&quot;</span>,<br>        <span class="hljs-string">&quot;flex-direction&quot;</span>,<br>        <span class="hljs-string">&quot;flex-flow&quot;</span>,<br>        <span class="hljs-string">&quot;flex-grow&quot;</span>,<br>        <span class="hljs-string">&quot;flex-shrink&quot;</span>,<br>        <span class="hljs-string">&quot;flex-wrap&quot;</span>,<br>        <span class="hljs-string">&quot;grid&quot;</span>,<br>        <span class="hljs-string">&quot;grid-area&quot;</span>,<br>        <span class="hljs-string">&quot;grid-auto-rows&quot;</span>,<br>        <span class="hljs-string">&quot;grid-auto-columns&quot;</span>,<br>        <span class="hljs-string">&quot;grid-auto-flow&quot;</span>,<br>        <span class="hljs-string">&quot;grid-gap&quot;</span>,<br>        <span class="hljs-string">&quot;grid-row&quot;</span>,<br>        <span class="hljs-string">&quot;grid-row-start&quot;</span>,<br>        <span class="hljs-string">&quot;grid-row-end&quot;</span>,<br>        <span class="hljs-string">&quot;grid-row-gap&quot;</span>,<br>        <span class="hljs-string">&quot;grid-column&quot;</span>,<br>        <span class="hljs-string">&quot;grid-column-start&quot;</span>,<br>        <span class="hljs-string">&quot;grid-column-end&quot;</span>,<br>        <span class="hljs-string">&quot;grid-column-gap&quot;</span>,<br>        <span class="hljs-string">&quot;grid-template&quot;</span>,<br>        <span class="hljs-string">&quot;grid-template-areas&quot;</span>,<br>        <span class="hljs-string">&quot;grid-template-rows&quot;</span>,<br>        <span class="hljs-string">&quot;grid-template-columns&quot;</span>,<br>        <span class="hljs-string">&quot;gap&quot;</span>,<br>        <span class="hljs-string">&quot;align-content&quot;</span>,<br>        <span class="hljs-string">&quot;align-items&quot;</span>,<br>        <span class="hljs-string">&quot;align-self&quot;</span>,<br>        <span class="hljs-string">&quot;justify-content&quot;</span>,<br>        <span class="hljs-string">&quot;justify-items&quot;</span>,<br>        <span class="hljs-string">&quot;justify-self&quot;</span>,<br>        <span class="hljs-string">&quot;order&quot;</span>,<br>        <span class="hljs-string">&quot;float&quot;</span>,<br>        <span class="hljs-string">&quot;clear&quot;</span>,<br>        <span class="hljs-string">&quot;box-sizing&quot;</span>,<br>        <span class="hljs-string">&quot;width&quot;</span>,<br>        <span class="hljs-string">&quot;min-width&quot;</span>,<br>        <span class="hljs-string">&quot;max-width&quot;</span>,<br>        <span class="hljs-string">&quot;height&quot;</span>,<br>        <span class="hljs-string">&quot;min-height&quot;</span>,<br>        <span class="hljs-string">&quot;max-height&quot;</span>,<br>        <span class="hljs-string">&quot;margin&quot;</span>,<br>        <span class="hljs-string">&quot;margin-top&quot;</span>,<br>        <span class="hljs-string">&quot;margin-right&quot;</span>,<br>        <span class="hljs-string">&quot;margin-bottom&quot;</span>,<br>        <span class="hljs-string">&quot;margin-left&quot;</span>,<br>        <span class="hljs-string">&quot;padding&quot;</span>,<br>        <span class="hljs-string">&quot;padding-top&quot;</span>,<br>        <span class="hljs-string">&quot;padding-right&quot;</span>,<br>        <span class="hljs-string">&quot;padding-bottom&quot;</span>,<br>        <span class="hljs-string">&quot;padding-left&quot;</span>,<br>        <span class="hljs-comment">//定位相关</span><br>        <span class="hljs-string">&quot;position&quot;</span>,<br>        <span class="hljs-string">&quot;top&quot;</span>,<br>        <span class="hljs-string">&quot;right&quot;</span>,<br>        <span class="hljs-string">&quot;bottom&quot;</span>,<br>        <span class="hljs-string">&quot;left&quot;</span>,<br>        <span class="hljs-string">&quot;z-index&quot;</span>,<br>        <span class="hljs-comment">//边框</span><br>        <span class="hljs-string">&quot;border&quot;</span>,<br>        <span class="hljs-string">&quot;border-color&quot;</span>,<br>        <span class="hljs-string">&quot;border-style&quot;</span>,<br>        <span class="hljs-string">&quot;border-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-top&quot;</span>,<br>        <span class="hljs-string">&quot;border-top-color&quot;</span>,<br>        <span class="hljs-string">&quot;border-top-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-top-style&quot;</span>,<br>        <span class="hljs-string">&quot;border-right&quot;</span>,<br>        <span class="hljs-string">&quot;border-right-color&quot;</span>,<br>        <span class="hljs-string">&quot;border-right-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-right-style&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom-color&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom-style&quot;</span>,<br>        <span class="hljs-string">&quot;border-left&quot;</span>,<br>        <span class="hljs-string">&quot;border-left-color&quot;</span>,<br>        <span class="hljs-string">&quot;border-left-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-left-style&quot;</span>,<br>        <span class="hljs-string">&quot;border-radius&quot;</span>,<br>        <span class="hljs-string">&quot;border-top-left-radius&quot;</span>,<br>        <span class="hljs-string">&quot;border-top-right-radius&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom-right-radius&quot;</span>,<br>        <span class="hljs-string">&quot;border-bottom-left-radius&quot;</span>,<br>        <span class="hljs-string">&quot;border-image&quot;</span>,<br>        <span class="hljs-string">&quot;border-image-source&quot;</span>,<br>        <span class="hljs-string">&quot;border-image-slice&quot;</span>,<br>        <span class="hljs-string">&quot;border-image-width&quot;</span>,<br>        <span class="hljs-string">&quot;border-image-outset&quot;</span>,<br>        <span class="hljs-string">&quot;border-image-repeat&quot;</span>,<br>        <span class="hljs-string">&quot;border-collapse&quot;</span>,<br>        <span class="hljs-string">&quot;border-spacing&quot;</span>,<br>        <span class="hljs-comment">//溢出</span><br>        <span class="hljs-string">&quot;object-fit&quot;</span>,<br>        <span class="hljs-string">&quot;object-position&quot;</span>,<br>        <span class="hljs-string">&quot;overflow&quot;</span>,<br>        <span class="hljs-string">&quot;overflow-x&quot;</span>,<br>        <span class="hljs-string">&quot;overflow-y&quot;</span>,<br>        <span class="hljs-comment">//版式</span><br>        <span class="hljs-string">&quot;color&quot;</span>,<br>        <span class="hljs-string">&quot;font&quot;</span>,<br>        <span class="hljs-string">&quot;font-weight&quot;</span>,<br>        <span class="hljs-string">&quot;font-size&quot;</span>,<br>        <span class="hljs-string">&quot;font-family&quot;</span>,<br>        <span class="hljs-string">&quot;font-style&quot;</span>,<br>        <span class="hljs-string">&quot;font-variant&quot;</span>,<br>        <span class="hljs-string">&quot;font-size-adjust&quot;</span>,<br>        <span class="hljs-string">&quot;font-stretch&quot;</span>,<br>        <span class="hljs-string">&quot;font-effect&quot;</span>,<br>        <span class="hljs-string">&quot;font-emphasize&quot;</span>,<br>        <span class="hljs-string">&quot;font-emphasize-position&quot;</span>,<br>        <span class="hljs-string">&quot;font-emphasize-style&quot;</span>,<br>        <span class="hljs-string">&quot;font-smooth&quot;</span>,<br>        <span class="hljs-string">&quot;line-height&quot;</span>,<br>        <span class="hljs-string">&quot;direction&quot;</span>,<br>        <span class="hljs-string">&quot;letter-spacing&quot;</span>,<br>        <span class="hljs-string">&quot;white-space&quot;</span>,<br>        <span class="hljs-string">&quot;text-align&quot;</span>,<br>        <span class="hljs-string">&quot;text-align-last&quot;</span>,<br>        <span class="hljs-string">&quot;text-transform&quot;</span>,<br>        <span class="hljs-string">&quot;text-decoration&quot;</span>,<br>        <span class="hljs-string">&quot;text-emphasis&quot;</span>,<br>        <span class="hljs-string">&quot;text-emphasis-color&quot;</span>,<br>        <span class="hljs-string">&quot;text-emphasis-style&quot;</span>,<br>        <span class="hljs-string">&quot;text-emphasis-position&quot;</span>,<br>        <span class="hljs-string">&quot;text-indent&quot;</span>,<br>        <span class="hljs-string">&quot;text-justify&quot;</span>,<br>        <span class="hljs-string">&quot;text-outline&quot;</span>,<br>        <span class="hljs-string">&quot;text-wrap&quot;</span>,<br>        <span class="hljs-string">&quot;text-overflow&quot;</span>,<br>        <span class="hljs-string">&quot;text-overflow-ellipsis&quot;</span>,<br>        <span class="hljs-string">&quot;text-overflow-mode&quot;</span>,<br>        <span class="hljs-string">&quot;text-orientation&quot;</span>,<br>        <span class="hljs-string">&quot;text-shadow&quot;</span>,<br>        <span class="hljs-string">&quot;vertical-align&quot;</span>,<br>        <span class="hljs-string">&quot;word-wrap&quot;</span>,<br>        <span class="hljs-string">&quot;word-break&quot;</span>,<br>        <span class="hljs-string">&quot;word-spacing&quot;</span>,<br>        <span class="hljs-string">&quot;overflow-wrap&quot;</span>,<br>        <span class="hljs-string">&quot;tab-size&quot;</span>,<br>        <span class="hljs-string">&quot;hyphens&quot;</span>,<br>        <span class="hljs-string">&quot;unicode-bidi&quot;</span>,<br>        <span class="hljs-string">&quot;columns&quot;</span>,<br>        <span class="hljs-string">&quot;column-count&quot;</span>,<br>        <span class="hljs-string">&quot;column-fill&quot;</span>,<br>        <span class="hljs-string">&quot;column-gap&quot;</span>,<br>        <span class="hljs-string">&quot;column-rule&quot;</span>,<br>        <span class="hljs-string">&quot;column-rule-color&quot;</span>,<br>        <span class="hljs-string">&quot;column-rule-style&quot;</span>,<br>        <span class="hljs-string">&quot;column-rule-width&quot;</span>,<br>        <span class="hljs-string">&quot;column-span&quot;</span>,<br>        <span class="hljs-string">&quot;column-width&quot;</span>,<br>        <span class="hljs-string">&quot;page-break-after&quot;</span>,<br>        <span class="hljs-string">&quot;page-break-before&quot;</span>,<br>        <span class="hljs-string">&quot;page-break-inside&quot;</span>,<br>        <span class="hljs-string">&quot;src&quot;</span>,<br>        <span class="hljs-comment">//视觉</span><br>        <span class="hljs-string">&quot;list-style&quot;</span>,<br>        <span class="hljs-string">&quot;list-style-position&quot;</span>,<br>        <span class="hljs-string">&quot;list-style-type&quot;</span>,<br>        <span class="hljs-string">&quot;list-style-image&quot;</span>,<br>        <span class="hljs-string">&quot;table-layout&quot;</span>,<br>        <span class="hljs-string">&quot;empty-cells&quot;</span>,<br>        <span class="hljs-string">&quot;caption-side&quot;</span>,<br>        <span class="hljs-string">&quot;background&quot;</span>,<br>        <span class="hljs-string">&quot;background-color&quot;</span>,<br>        <span class="hljs-string">&quot;background-image&quot;</span>,<br>        <span class="hljs-string">&quot;background-repeat&quot;</span>,<br>        <span class="hljs-string">&quot;background-position&quot;</span>,<br>        <span class="hljs-string">&quot;background-position-x&quot;</span>,<br>        <span class="hljs-string">&quot;background-position-y&quot;</span>,<br>        <span class="hljs-string">&quot;background-size&quot;</span>,<br>        <span class="hljs-string">&quot;background-clip&quot;</span>,<br>        <span class="hljs-string">&quot;background-origin&quot;</span>,<br>        <span class="hljs-string">&quot;background-attachment&quot;</span>,<br>        <span class="hljs-string">&quot;background-blend-mode&quot;</span>,<br>        <span class="hljs-comment">//动画</span><br>        <span class="hljs-string">&quot;transition&quot;</span>,<br>        <span class="hljs-string">&quot;transition-delay&quot;</span>,<br>        <span class="hljs-string">&quot;transition-timing-function&quot;</span>,<br>        <span class="hljs-string">&quot;transition-duration&quot;</span>,<br>        <span class="hljs-string">&quot;transition-property&quot;</span>,<br>        <span class="hljs-string">&quot;animation&quot;</span>,<br>        <span class="hljs-string">&quot;animation-name&quot;</span>,<br>        <span class="hljs-string">&quot;animation-duration&quot;</span>,<br>        <span class="hljs-string">&quot;animation-play-state&quot;</span>,<br>        <span class="hljs-string">&quot;animation-timing-function&quot;</span>,<br>        <span class="hljs-string">&quot;animation-delay&quot;</span>,<br>        <span class="hljs-string">&quot;animation-iteration-count&quot;</span>,<br>        <span class="hljs-string">&quot;animation-direction&quot;</span>,<br>        <span class="hljs-string">&quot;animation-fill-mode&quot;</span>,<br>        <span class="hljs-comment">//其他</span><br>        <span class="hljs-string">&quot;appearance&quot;</span>,<br>        <span class="hljs-string">&quot;content&quot;</span>,<br>        <span class="hljs-string">&quot;clip&quot;</span>,<br>        <span class="hljs-string">&quot;clip-path&quot;</span>,<br>        <span class="hljs-string">&quot;counter-reset&quot;</span>,<br>        <span class="hljs-string">&quot;counter-increment&quot;</span>,<br>        <span class="hljs-string">&quot;resize&quot;</span>,<br>        <span class="hljs-string">&quot;user-select&quot;</span>,<br>        <span class="hljs-string">&quot;nav-index&quot;</span>,<br>        <span class="hljs-string">&quot;nav-up&quot;</span>,<br>        <span class="hljs-string">&quot;nav-right&quot;</span>,<br>        <span class="hljs-string">&quot;nav-down&quot;</span>,<br>        <span class="hljs-string">&quot;nav-left&quot;</span>,<br>        <span class="hljs-string">&quot;pointer-events&quot;</span>,<br>        <span class="hljs-string">&quot;quotes&quot;</span>,<br>        <span class="hljs-string">&quot;touch-action&quot;</span>,<br>        <span class="hljs-string">&quot;will-change&quot;</span>,<br>        <span class="hljs-string">&quot;zoom&quot;</span>,<br>        <span class="hljs-string">&quot;fill&quot;</span>,<br>        <span class="hljs-string">&quot;fill-rule&quot;</span>,<br>        <span class="hljs-string">&quot;clip-rule&quot;</span>,<br>        <span class="hljs-string">&quot;stroke&quot;</span>,<br>      ],<br>      &#123;<br>        unspecified: <span class="hljs-string">&quot;bottom&quot;</span>,<br>      &#125;,<br>    ],<br>    <span class="hljs-comment">//CSS 属性值顺序</span><br>    <span class="hljs-comment">// &#x27;order/properties-alphabetical-order&#x27;: [],</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;lint:css&quot;</span>: <span class="hljs-string">&quot;stylelint src/**/*.&#123;vue,html,css,scss,sass&#125;&quot;</span>,<br>    <span class="hljs-attr">&quot;fix:css&quot;</span>: <span class="hljs-string">&quot;stylelint --fix src/**/*.&#123;vue,html,css,scss,sass&#125;&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm run lint:css<br></code></pre></td></tr></table></figure><p>相关链接</p><ul><li><a href="https://stylelint.io/">StyleLint 官网</a></li><li><a href="https://stackoverflow.com/questions/54304313/stylelint-fix-in-webstorm">如何在 WebStorm 中使用 StyleLint 自动修复</a></li></ul><blockquote><p>WebStorm 使用<br>WebStorm 配置 StyleLint 即时检查:<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926113520.png" alt="WebStorm 配置即时检查"><br>参考 <a href="https://stackoverflow.com/questions/54304313/">https://stackoverflow.com/questions/54304313/</a></p><p>添加外部工具以进行快速修复<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926113953.png" alt="添加外部工具以进行快速修复"><br>然后添加一个快捷键即可</p></blockquote><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><p>Prettier 是一个代码格式化工具，但并非针对一种语言，对 <code>HTML/CSS/JavaScript/Vue/SCSS</code> 都有效果。可以通过配置文件在不同项目间统一代码格式化，以修正不同编辑器/IDE 之间格式化不同的问题。</p><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D prettier eslint-plugin-prettier eslint-config-prettier prettier-eslint-cli stylelint-config-prettier stylelint-prettier<br></code></pre></td></tr></table></figure><blockquote><p>依赖解释</p><ul><li><code>prettier</code>: 本体包</li><li><code>eslint-plugin-prettier eslint-config-prettier prettier-eslint-cli</code>: prettier 与 eslint 整合包</li><li><code>stylelint-config-prettier stylelint-prettier</code>: prettier 与 stylelint 整合包</li></ul></blockquote><p>进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .prettierrc.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 缩进宽度</span><br>  tabWidth: <span class="hljs-number">4</span>,<br>  <span class="hljs-comment">// 单行最大宽度</span><br>  printWidth: <span class="hljs-number">120</span>,<br>  <span class="hljs-comment">// 去掉代码结尾的分号</span><br>  semi: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 使用单引号替代双引号</span><br>  singleQuote: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 尽量在所有地方都添加尾逗号</span><br>  trailingComma: <span class="hljs-string">&quot;all&quot;</span>,<br>  <span class="hljs-comment">// 换行符</span><br>  endOfLine: <span class="hljs-string">&quot;crlf&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>还需要修改 eslint 与 stylelint 的一些配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .eslintrc.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>  <span class="hljs-keyword">extends</span>: [<br>    <span class="hljs-comment">//继承 vue 的标准特性</span><br>    <span class="hljs-string">&quot;plugin:vue/essential&quot;</span>,<br>    <span class="hljs-string">&quot;eslint:recommended&quot;</span>,<br>    <span class="hljs-comment">//避免与 prettier 冲突</span><br>    <span class="hljs-string">&quot;plugin:prettier/recommended&quot;</span>,<br>  ],<br>  <span class="hljs-comment">// 其他配置。。。</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// stylelint.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&quot;stylelint-config-standard&quot;</span>, <span class="hljs-string">&quot;stylelint-config-prettier&quot;</span>],<br>  <span class="hljs-comment">// 其他配置。。。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>添加脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;prettier-eslint --write \&quot;src/**/*.&#123;js,vue,html,scss,css&#125;\&quot;&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// 其他配置。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm run format<br></code></pre></td></tr></table></figure><p>相关链接</p><ul><li><a href="https://prettier.io/">prettier 官网</a></li><li><a href="https://www.jetbrains.com/help/webstorm/prettier.html">WebStorm 使用 Prettier 官方文档</a></li></ul><blockquote><p>WebStorm 配置使用 Prettier 快速格式化:<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926115309.png" alt="WebStorm 配置使用 Prettier 快速格式化"><br>建议修改为全局使用 Prettier 格式化，避免记忆两个格式化快捷键</p></blockquote><h2 id="husky-与-lint-staged"><a href="#husky-与-lint-staged" class="headerlink" title="husky 与 lint-staged"></a>husky 与 lint-staged</h2><p>强制使用 linter 检查代码，不通过检查则无法提交代码，以使 linter 真正得到有效执行。</p><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -D husky lint-staged<br></code></pre></td></tr></table></figure><blockquote><p>依赖解释</p><ul><li><code>husky</code>: 在项目中添加 git 钩子，在 git 各个生命周期（姑且这样称呼吧）中执行一些自定义操作。我们这里主要是用在 git 提交之前执行 linter 操作，不通过则提交无效。</li><li><code>lint-staged</code>: 简而言之，就是只针对 git 提交的文件进行一些操作，而非整个项目的所有文件。我们这里主要是用在 git 提交之前进行 linter 时只针对提交的文件，以进行渐进式的重构。</li></ul></blockquote><p>进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// .huskyrc.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  hooks: &#123;<br>    <span class="hljs-comment">// git commit 前的钩子</span><br>    <span class="hljs-string">&quot;pre-commit&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span>,<br>    <span class="hljs-comment">// 修复 IDEA 的一些奇怪问题 &lt;https://youtrack.jetbrains.com/issue/IDEA-135454&gt;</span><br>    <span class="hljs-string">&quot;post-commit&quot;</span>: <span class="hljs-string">&quot;git update-index --again&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lint-staged.config.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-string">&quot;src/**/*.&#123;js,vue&#125;&quot;</span>: [<span class="hljs-string">&quot;eslint --fix&quot;</span>, <span class="hljs-string">&quot;git add&quot;</span>],<br>  <span class="hljs-string">&quot;src/**/*.&#123;vue,html,css,scss,sass&#125;&quot;</span>: [<span class="hljs-string">&quot;stylelint --fix&quot;</span>, <span class="hljs-string">&quot;git add&quot;</span>],<br>  <span class="hljs-string">&quot;src/**/*.&#123;js,vue,html,css,scss,sass&#125;&quot;</span>: [<br>    <span class="hljs-string">&quot;prettier-eslint --write&quot;</span>,<br>    <span class="hljs-string">&quot;git add&quot;</span>,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>有人说 <strong>lint-staged</strong> 并行运行多个命令可能会有问题，因为 nodejs 本身在写入文件时不会加锁，导致多线程下可能存在问题（吾辈目前还没遇到过.JPG）</p></blockquote><p>之后，在我们使用 <code>git commit</code> 时就会触发 lint 操作了！</p><p>相关链接</p><ul><li><a href="https://github.com/typicode/husky">husky GitHub</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上，这些工具初次配置起来还是非常麻烦的，但这是一件一劳永逸的事情，所以还是值得花时间去做的。</p><blockquote><p>注:<br>目前还存在的问题是:<br>ESLint 检测出来的部分错误能使用 <strong>A-Enter</strong> 修复<br>Prettier 与 WebStorm 自身格式化不能共存（自动切换）<br>Prettier 在 WebStorm 中无法直接配置导致上面问题存在的必要性<br>StyleLint 不能使用 <strong>A-Enter</strong> 修复且不能与 WebStorm 共存<br>可能的解决方案是找一下是否有一种方式能够让 WebStorm 一个快捷键执行多条命令，或者，写一个可用的插件。</p></blockquote><blockquote><p>参考</p><ul><li><a href="https://juejin.im/post/5c67fcaae51d457fcb4078c9">eslint+husky+prettier+lint-staged 提升前端应用质量</a></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 规范整理</title>
    <link href="/p/95819eb091ac4dfbadbec0aa3eb5ad42/"/>
    <url>/p/95819eb091ac4dfbadbec0aa3eb5ad42/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>圣人走过的道路，荆棘遍布，火焰片片焚烧……</p></blockquote><p>日常 <code>review</code> 代码时看到一些奇怪的代码，这里记录一下重构方案以及原因。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="不要使用拼音命名"><a href="#不要使用拼音命名" class="headerlink" title="不要使用拼音命名"></a>不要使用拼音命名</h3><p>如果不熟悉英语，可以使用 <a href="https://unbug.github.io/codelf/">Codelf</a> 或者 <a href="https://translate.google.com/">Google 翻译</a>，避免使用拼音命名。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这里是用户状态</span><br><span class="hljs-keyword">const</span> yongHuZhuangTai = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userStatus = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="函数中的变量"><a href="#函数中的变量" class="headerlink" title="函数中的变量"></a>函数中的变量</h3><p>js 中普通变量使用 <a href="https://en.wikipedia.org/wiki/Camel_case">小写开头驼峰命名法</a>，而非不区分大小写，或使用下划线命名等等。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用户操作日志备注</span><br><span class="hljs-keyword">const</span> useroperatinglogremark = <span class="hljs-string">&quot;新增用户&quot;</span>;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userOperatingLogRemark = <span class="hljs-string">&quot;新增用户&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>如果需要不想让使用者使用的属性（能够看到），需要使用下划线开头。例如 <code>_value</code>，代表内部的值，外部不应该直接访问（实际上可以做到）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateFormat</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fmt</span>)</span> &#123;<br>    <span class="hljs-comment">// 不想让外部使用</span><br>    <span class="hljs-built_in">this</span>._fmt = fmt;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">format</span>(<span class="hljs-params">date</span>)</span> &#123;<br>    <span class="hljs-comment">// 具体格式化代码</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">parse</span>(<span class="hljs-params">str</span>)</span> &#123;<br>    <span class="hljs-comment">// 具体解析代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要使用无意义的前缀命名"><a href="#不要使用无意义的前缀命名" class="headerlink" title="不要使用无意义的前缀命名"></a>不要使用无意义的前缀命名</h3><p>如果一个对象的变量名已经很好的标识了该对象，那么内部的属性就不能使用对象名作为前缀！</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 活跃的日志信息</span><br><span class="hljs-keyword">const</span> activeLog = &#123;<br>  activeUserId: <span class="hljs-string">&quot;rx&quot;</span>,<br>  activeTime: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> activeLog = &#123;<br>  userId: <span class="hljs-string">&quot;rx&quot;</span>,<br>  time: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="优先使用-const-let"><a href="#优先使用-const-let" class="headerlink" title="优先使用 const/let"></a>优先使用 const/let</h3><p>一般情况下，使用 <code>const/let</code> 声明变量，而不是使用 <code>var</code>。因为使用 <code>var</code> 声明的变量会存在变量提升。</p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 使用 var 声明的变量（初始值为 undefined）</span><br>  <span class="hljs-built_in">console</span>.log(i);<br>  i = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  <span class="hljs-comment">// 此时使用 var 声明的变量 i 相当于在 function 顶部声明，然后在此处进行了赋值操作</span><br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 使用 const 声明的变量（抛出异常 k is not defined）</span><br>  <span class="hljs-comment">// console.log(k)</span><br>  k = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> k = <span class="hljs-number">0</span>;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>关于可以参考 <a href="https://blog.rxliuli.com/p/acfc2875/">let 与 var 在 for 循环中的区别</a></p><h3 id="使用新的函数声明方式"><a href="#使用新的函数声明方式" class="headerlink" title="使用新的函数声明方式"></a>使用新的函数声明方式</h3><p>ES6 推出了一种更简洁的函数声明方式，不需要在写 <code>function</code>，只要 <strong>名字 + ()</strong> 即可在 <code>class</code> 或 <code>Object</code> 中声明函数。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  name: <span class="hljs-string">&quot;rx&quot;</span>,<br>  hello: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-built_in">this</span>.name);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  name: <span class="hljs-string">&quot;rx&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-built_in">this</span>.name);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优先使用箭头函数而非-function"><a href="#优先使用箭头函数而非-function" class="headerlink" title="优先使用箭头函数而非 function"></a>优先使用箭头函数而非 function</h3><p>优先使用 <strong>箭头函数</strong> 而不是使用传统的函数，尤其是使用 <strong>匿名函数</strong> 时，更应如此。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>  <span class="hljs-comment">// 过滤出偶数</span><br>  .filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>  &#125;)<br>  <span class="hljs-comment">// 将偶数翻倍</span><br>  .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>;<br>  &#125;)<br>  <span class="hljs-comment">// 计算总和</span><br>  .reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res, i</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (res += i);<br>  &#125;);<br><br><span class="hljs-built_in">console</span>.log(sum);<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>  <span class="hljs-comment">// 过滤出偶数</span><br>  .filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br>  <span class="hljs-comment">// 将偶数翻倍</span><br>  .map(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i * <span class="hljs-number">2</span>)<br>  <span class="hljs-comment">// 计算总和</span><br>  .reduce(<span class="hljs-function">(<span class="hljs-params">res, i</span>) =&gt;</span> (res += i));<br><br><span class="hljs-built_in">console</span>.log(sum);<br></code></pre></td></tr></table></figure><h3 id="不要使用-if-判断再赋予默认值"><a href="#不要使用-if-判断再赋予默认值" class="headerlink" title="不要使用 if 判断再赋予默认值"></a>不要使用 if 判断再赋予默认值</h3><p>如果函数需要对参数做默认值处理，请不要使用 <code>if</code> 判空之后再修改参数，而是使用 ES6 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters">默认参数</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a>。</p><p>主要优点</p><ul><li>减少代码，JavaScript 是动态语言，维护起来较为麻烦，代码越少，错误越少</li><li>清晰明了，可以让人一眼就能看出这个参数的默认值，而不需要关心函数内部的逻辑</li><li>IDE 大多对此进行了支持，代码提示时便会告诉我们参数是可选的并且有默认值</li></ul><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 格式化日期</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Date&#125;</span> </span>[date] 日期对象。默认为当前时间</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;String&#125;</span> </span>格式化日期字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (date === <span class="hljs-literal">undefined</span>) &#123;<br>    date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;date.getFullYear()&#125;</span>-<span class="hljs-subst">$&#123;date.getMonth() + <span class="hljs-number">1</span>&#125;</span>-<span class="hljs-subst">$&#123;date.getDate()&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;date.getFullYear()&#125;</span>-<span class="hljs-subst">$&#123;date.getMonth() + <span class="hljs-number">1</span>&#125;</span>-<span class="hljs-subst">$&#123;date.getDate()&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里如果展开来讲实在太多，请参考 <a href="https://blog.rxliuli.com/p/5985b64e/">JavaScript 善用解构赋值</a></p><h3 id="优先使用-Map-做键值对映射而非传统的对象"><a href="#优先使用-Map-做键值对映射而非传统的对象" class="headerlink" title="优先使用 Map 做键值对映射而非传统的对象"></a>优先使用 Map 做键值对映射而非传统的对象</h3><p>如果需要 <strong>键值映射</strong>，不要使用一般的对象，而是用 ES6 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>。它不仅可以使用 <strong>任意类型的键</strong>，另外 Map 本身也是 <strong>有序</strong> 的哦</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&quot;琉璃&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;rx&quot;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;liuli&quot;</span>,<br>&#125;;<br><span class="hljs-comment">// 结果为 true，因为属性 1 实际上会被转换为 &#x27;1&#x27;</span><br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-number">1</span>] === obj[<span class="hljs-string">&quot;1&quot;</span>]);<br><span class="hljs-comment">// 结果为 [ &#x27;1&#x27;, &#x27;2&#x27;]，因为是按照属性字符串排序的</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj));<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;琉璃&quot;</span>).set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rx&quot;</span>).set(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;liuli&quot;</span>);<br><span class="hljs-comment">// 结果为 false</span><br><span class="hljs-built_in">console</span>.log(map.get(<span class="hljs-number">1</span>) === map.get(<span class="hljs-string">&quot;1&quot;</span>));<br><span class="hljs-comment">// 结果为 [ 2, 1, &#x27;1&#x27; ]，因为是按照插入顺序排序的</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(map.keys()));<br></code></pre></td></tr></table></figure><h3 id="优先使用模板字符串拼接多个字符串变量"><a href="#优先使用模板字符串拼接多个字符串变量" class="headerlink" title="优先使用模板字符串拼接多个字符串变量"></a>优先使用模板字符串拼接多个字符串变量</h3><p>如果需要拼接多个对象以及字符串时，不要使用 <code>+</code> 进行拼接，使用 es6 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">模板字符串</a> 会更好一点。一般而言，如果需要拼接的变量超过 3 个，那么就应该使用模板字符串了。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name: &quot;</span> + name + <span class="hljs-string">&quot;, age: &quot;</span> + age + <span class="hljs-string">&quot;, sex: &quot;</span> + sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`name: <span class="hljs-subst">$&#123;name&#125;</span>, age: <span class="hljs-subst">$&#123;age&#125;</span>, sex: <span class="hljs-subst">$&#123;sex&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="当独立参数超过-3-个时使用对象参数并解构"><a href="#当独立参数超过-3-个时使用对象参数并解构" class="headerlink" title="当独立参数超过 3 个时使用对象参数并解构"></a>当独立参数超过 3 个时使用对象参数并解构</h3><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`name: <span class="hljs-subst">$&#123;name&#125;</span>, age: <span class="hljs-subst">$&#123;age&#125;</span>, sex: <span class="hljs-subst">$&#123;sex&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">&#123; name, age, sex &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`name: <span class="hljs-subst">$&#123;name&#125;</span>, age: <span class="hljs-subst">$&#123;age&#125;</span>, sex: <span class="hljs-subst">$&#123;sex&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要写多余的-await"><a href="#不要写多余的-await" class="headerlink" title="不要写多余的 await"></a>不要写多余的 await</h3><p>如果 <code>await</code> 是不必要的（在返回语句时，那么就不要用 <code>async</code> 标识函数），这是没有必要的 – 除非，你需要在这个函数内异步操作完成后有其他操作。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!useranme) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!password) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;密码不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 真正发起登录请求</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> userApi.login(user);<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> login = <span class="hljs-function">(<span class="hljs-params">&#123; username, password &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!useranme) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!password) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;密码不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 真正发起登录请求</span><br>  <span class="hljs-keyword">return</span> userApi.login(user);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不要使用-进行比较"><a href="#不要使用-进行比较" class="headerlink" title="不要使用 == 进行比较"></a>不要使用 == 进行比较</h3><p>在 js 中使用 <code>==</code> 比较相当危险，你永远不知道 js 到底是按照什么类型比较的，因为 js 会做各种隐式转换。而如果使用 <code>===</code> 比较，则会同时比较 <strong>值</strong> 和 <strong>类型</strong> 是否都相同，避免了各种不确定的问题。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>扪心自问，你真的知道上面为什么会出现这种结果么？即便知道，对于其他人而言仍然是难以预测的，所以抛弃掉 <code>==</code> 吧，学会使用更好的 <code>===</code> 最好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> == <span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="使用计算属性名替代使用方括号表示法赋值"><a href="#使用计算属性名替代使用方括号表示法赋值" class="headerlink" title="使用计算属性名替代使用方括号表示法赋值"></a>使用计算属性名替代使用方括号表示法赋值</h3><p>目前而言已经有了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D">计算属性名</a> 用以在初始化时计算属性名，所以不需要再先声明对象再使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95">方括号表示法</a> 进行赋值了。</p><p>ES5 写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-string">&quot;user.username&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br>&#125;;<br><br>state[<span class="hljs-built_in">Date</span>.now()] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br><span class="hljs-built_in">console</span>.log(state);<br></code></pre></td></tr></table></figure><p>ES6 写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-string">&quot;user.username&quot;</span>() &#123;&#125;,<br>  [<span class="hljs-built_in">Date</span>.now()]: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(state);<br></code></pre></td></tr></table></figure><h3 id="简单的选项列表优先使用-Map-而非数组"><a href="#简单的选项列表优先使用-Map-而非数组" class="headerlink" title="简单的选项列表优先使用 Map 而非数组"></a>简单的选项列表优先使用 Map 而非数组</h3><p>对于复选框，想必很多人相当熟悉。下面使用 js 模拟一个复选框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> item = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  role: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>],<br>  name: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> options = [<br>  &#123;<br>    roleid: <span class="hljs-string">&quot;1&quot;</span>,<br>    label: <span class="hljs-string">&quot;黄金糕&quot;</span>,<br>  &#125;,<br>  &#123;<br>    roleid: <span class="hljs-string">&quot;2&quot;</span>,<br>    label: <span class="hljs-string">&quot;双皮奶&quot;</span>,<br>  &#125;,<br>  &#123;<br>    roleid: <span class="hljs-string">&quot;3&quot;</span>,<br>    label: <span class="hljs-string">&quot;蚵仔煎&quot;</span>,<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>现在的需求是根据 <code>role</code> 计算显示值 <code>name</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">item.name = item.role<br>  .map(<span class="hljs-function">(<span class="hljs-params">role</span>) =&gt;</span> options.find(<span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> op.roleid === role))<br>  .filter(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s)<br>  .join(<span class="hljs-string">&quot;,&quot;</span>);<br></code></pre></td></tr></table></figure><p>但实际上这里应该使用 <code>Map</code> 替代数组，因为数组的 <code>find</code> 其实非常低效，也需要进行遍历，使用 <code>Map</code> 的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> item = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  role: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>  name: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> options = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;黄金糕&quot;</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;双皮奶&quot;</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;蚵仔煎&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcName</span>(<span class="hljs-params">role</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> role<br>    .map(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> options.get(k))<br>    .filter(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s)<br>    .join(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><br>item.name = calcName(item.role);<br></code></pre></td></tr></table></figure><p>可以看到，获取时使用了 <code>Map#get</code>，在效率上应该是极好的。</p><blockquote><p>附: 该问题来自 <a href="https://segmentfault.com/q/1010000019426996">https://segmentfault.com/q/1010000019426996</a></p></blockquote><h3 id="存放-id-标识列表使用-Set-而非数组"><a href="#存放-id-标识列表使用-Set-而非数组" class="headerlink" title="存放 id 标识列表使用 Set 而非数组"></a>存放 id 标识列表使用 Set 而非数组</h3><p>还是上面的例子，当你需要存取当前选中复选框的值 <code>role</code> 使用数组时，有可能遇到 id 重复的问题，实际上导致每次添加前需要使用 <code>Array#includes</code> 判断是否已存在。这里可以使用 <code>Set</code> 从数据结构层面避免掉可能重复的问题。</p><p>修改后的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> item = &#123;<br>  id: <span class="hljs-number">1</span>,<br>  role: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]),<br>  name: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> options = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;黄金糕&quot;</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;双皮奶&quot;</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;蚵仔煎&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcName</span>(<span class="hljs-params">role</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(role)<br>    .map(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> options.get(k))<br>    .filter(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s)<br>    .join(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><br>item.name = calcName(item.role);<br></code></pre></td></tr></table></figure><p>先判断是否存在执行某些操作也非常方便，可以使用 <code>Set#has</code> 进行判断，当然时间复杂度时 O1。</p><h2 id="逻辑代码"><a href="#逻辑代码" class="headerlink" title="逻辑代码"></a>逻辑代码</h2><h3 id="不要判断一个-Boolean-值并以此返回-Boolean-值"><a href="#不要判断一个-Boolean-值并以此返回-Boolean-值" class="headerlink" title="不要判断一个 Boolean 值并以此返回 Boolean 值"></a>不要判断一个 Boolean 值并以此返回 Boolean 值</h3><p>不要在得到一个 <code>Boolean</code> 的值后使用 <code>if-else</code> 进行判断，然后根据结果返回 <code>true</code> 或 <code>false</code>，这真的显得非常非常蠢！</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> res = username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br>  <span class="hljs-keyword">if</span> (res) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt;<br>  username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="不要使用多余的变量"><a href="#不要使用多余的变量" class="headerlink" title="不要使用多余的变量"></a>不要使用多余的变量</h3><p>如果一个表达式立刻被使用并且只会被使用一次，那就不要使用变量声明，直接在需要的地方使用好了。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> res = username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不要使用嵌套-if"><a href="#不要使用嵌套-if" class="headerlink" title="不要使用嵌套 if"></a>不要使用嵌套 if</h3><p>不要使用多级的 <code>if</code> 嵌套，这会让代码变得丑陋且难以调试，应当优先使用 <strong>提前 return</strong> 的策略。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt;<br>  username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submit</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; username, password &#125; = user;<br>  <span class="hljs-keyword">if</span> (username) &#123;<br>    <span class="hljs-keyword">if</span> (password) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> login(user);<br>      <span class="hljs-keyword">if</span> (res) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;登录成功，即将跳转到首页&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;登录失败，请检查用户名和密码&quot;</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户密码不能为空&quot;</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt;<br>  username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submit</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; username, password &#125; = user;<br>  <span class="hljs-keyword">if</span> (!username) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!password) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户密码不能为空&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> login(user);<br>  <span class="hljs-keyword">if</span> (!res) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;登录失败，请检查用户名和密码&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;登录成功，即将跳转到首页&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要先声明空对象然后一个个追加属性"><a href="#不要先声明空对象然后一个个追加属性" class="headerlink" title="不要先声明空对象然后一个个追加属性"></a>不要先声明空对象然后一个个追加属性</h3><p>有时候会碰到这种情况，先声明一个空对象，然后在下面一个个追加属性，为什么创建对象与初始化不放到一起做呢？</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt;<br>  username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submit</span>(<span class="hljs-params">username, password</span>) </span>&#123;<br>  <span class="hljs-comment">// 数据格式校验处理。。。</span><br><br>  <span class="hljs-keyword">const</span> user = &#123;&#125;;<br>  user.username = username.trim();<br>  user.password = password.trim();<br><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> login(user);<br><br>  <span class="hljs-comment">// 后续的错误处理。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟登录异步请求</span><br><span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (&#123; username, password &#125;) =&gt;<br>  username === <span class="hljs-string">&quot;rx&quot;</span> &amp;&amp; password === <span class="hljs-string">&quot;rx&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submit</span>(<span class="hljs-params">username, password</span>) </span>&#123;<br>  <span class="hljs-comment">// 数据格式校验处理。。。</span><br><br>  <span class="hljs-keyword">const</span> user = &#123;<br>    username: username.trim(),<br>    password: password.trim(),<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> login(user);<br><br>  <span class="hljs-comment">// 后续的错误处理。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不要使用无意义的函数包裹"><a href="#不要使用无意义的函数包裹" class="headerlink" title="不要使用无意义的函数包裹"></a>不要使用无意义的函数包裹</h3><p>使用函数时，如果你想包裹的函数和原来函数的参数/返回值相同，那就直接应该使用函数作为参数，而非在包裹一层。给人的感觉就像是大夏天穿着棉袄吃雪糕 – 多此一举！</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是偶数的函数</span><br><span class="hljs-keyword">const</span> isEven = <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br><span class="hljs-comment">//过滤出所有偶数</span><br><span class="hljs-keyword">const</span> res = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> isEven(i));<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是偶数的函数</span><br><span class="hljs-keyword">const</span> isEven = <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br><span class="hljs-comment">//过滤出所有偶数</span><br><span class="hljs-keyword">const</span> res = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].filter(isEven);<br></code></pre></td></tr></table></figure><h3 id="不要使用三元运算符进行复杂的计算"><a href="#不要使用三元运算符进行复杂的计算" class="headerlink" title="不要使用三元运算符进行复杂的计算"></a>不要使用三元运算符进行复杂的计算</h3><p>三元运算符适合于替代简单的 <code>if-else</code> 的情况，如果碰到较为复杂的情况，请使用 <code>if + return</code> 或者解构/默认参数的方式解决。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> user === <span class="hljs-literal">undefined</span><br>    ? <span class="hljs-string">&quot;username: noname, password: blank&quot;</span><br>    : <span class="hljs-string">&quot;username: &quot;</span> +<br>        (user.username === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&quot;noname&quot;</span> : user.username) +<br>        <span class="hljs-string">&quot;, password: &quot;</span> +<br>        (user.password === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&quot;blank&quot;</span> : user.password);<br>&#125;<br></code></pre></td></tr></table></figure><p>看到上面的代码就感觉到一股烂代码的味道扑面而来，这实在是太糟糕了！实际上只需要两行代码就好了！</p><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUser</span>(<span class="hljs-params">&#123; username = <span class="hljs-string">&quot;noname&quot;</span>, password = <span class="hljs-string">&quot;blank&quot;</span> &#125; = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`username: <span class="hljs-subst">$&#123;username&#125;</span>, password: <span class="hljs-subst">$&#123;password&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如果变量有所关联则使用对象而非多个单独的变量"><a href="#如果变量有所关联则使用对象而非多个单独的变量" class="headerlink" title="如果变量有所关联则使用对象而非多个单独的变量"></a>如果变量有所关联则使用对象而非多个单独的变量</h3><p>如果变量有所关联，例如一个表单，存储的时候不要使用单独的变量，将之存储到一个表单变量中更好。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> username = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#username&#x27;</span>)<br>  <span class="hljs-keyword">const</span> password = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#password&#x27;</span>)<br>  <span class="hljs-keyword">const</span> remeberMe = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#remeberMe&#x27;</span>)<br><br>  <span class="hljs-comment">// 一些校验。。。</span><br>  <span class="hljs-keyword">if</span> (!validate(username, password, remeberMe)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 请求后台</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> userLogin.login(username, password, remeberMe)<br>  <span class="hljs-comment">// 后处理。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> user = &#123;<br>    username : <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#username&#x27;</span>),<br>    password : <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#password&#x27;</span>),<br>    remeberMe : <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#remeberMe&#x27;</span>),<br>  &#125;<br>  <span class="hljs-comment">// 一些校验。。。</span><br>  <span class="hljs-keyword">if</span> (!validate(user)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 请求后台</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> userLogin.login(user)<br>  <span class="hljs-comment">// 后处理。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应该尽量解决编辑器警告"><a href="#应该尽量解决编辑器警告" class="headerlink" title="应该尽量解决编辑器警告"></a>应该尽量解决编辑器警告</h3><p>如果编辑器对我们的代码发出警告，那么一般都是我们代码出现了问题（一般开发人员的能力并不足以比肩编辑器 #MS 那些 dalao 的能力）。所以，如果出现了警告，应该先去解决它 – 如果你确认发生了错误，则通过注释/配置禁用它！</p><h3 id="使用类型定义参数对象"><a href="#使用类型定义参数对象" class="headerlink" title="使用类型定义参数对象"></a>使用类型定义参数对象</h3><p>如果一个函数需要一个对象参数，最好专门定义一个类型，并在注释上说明，便于在使用时 IDE 进行提示，而不需要去查找文档手册。</p><p>错误示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 格式化用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>user 格式化的用户对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; username, password &#125; = user || &#123;&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`user, username: <span class="hljs-subst">$&#123;username&#125;</span>, password: <span class="hljs-subst">$&#123;password&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-comment">// 此处别人并不知道 User 里面到底有什么属性，只能去查看文档</span><br><span class="hljs-keyword">const</span> str = formatUser(&#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;123456&quot;</span> &#125;);<br><span class="hljs-built_in">console</span>.log(str);<br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">username, password</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.username = username;<br>    <span class="hljs-built_in">this</span>.password = password;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 格式化用户</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;User&#125;</span> </span>user 格式化的用户对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; username, password &#125; = user || &#123;&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`user, username: <span class="hljs-subst">$&#123;username&#125;</span>, password: <span class="hljs-subst">$&#123;password&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> str = formatUser(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>));<br><span class="hljs-built_in">console</span>.log(str);<br></code></pre></td></tr></table></figure><h3 id="尽量扁平化代码"><a href="#尽量扁平化代码" class="headerlink" title="尽量扁平化代码"></a>尽量扁平化代码</h3><p>尽量将 <code>a</code> 调用 <code>b</code>, <code>b</code> 调用 <code>c</code>，然后 <code>b</code> 调用 <code>d</code>，优化为依次调用 <code>a, b, c, d</code>。</p><blockquote><p>注意: 这里使用的是<strong>尽量</strong>而非<strong>不要</strong>，深层嵌套不可避免，但在局部上，应该采取扁平化的策略，<strong>提前 return</strong> 避免嵌套 if-else 是个很好的例子。</p></blockquote><h3 id="自执行函数前面必须加分号"><a href="#自执行函数前面必须加分号" class="headerlink" title="自执行函数前面必须加分号"></a>自执行函数前面必须加分号</h3><p>如果我们需要使用自执行函数，则开头必须加上 <code>;</code> 以避免可能出现的歧义。</p><p>错误示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">function</span> returnItself(o) &#123;<br>  <span class="hljs-built_in">return</span> o<br>&#125;<br>returnItself(() =&gt; console.log(1))<br>(() =&gt; &#123;<br>  console.log(2)<br>&#125;)()<br></code></pre></td></tr></table></figure><p>上面这段代码是有问题的，因为后面的自执行函数会被认为是上一句的 <code>returnItself</code> 返回函数的参数，最后的括号会被认为又是一次调用，将会抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">returnItself(...)(...) is not a <span class="hljs-function"><span class="hljs-keyword">function</span></span><br></code></pre></td></tr></table></figure><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnItself</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> o;<br>&#125;<br>returnItself(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>));<br>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>使用分号可以明确告诉 JavaScript 这是一行新的代码，上面的代码已经到此为止了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2016 年里做前端是怎样一种体验</title>
    <link href="/p/9970e725452b49e496324842a7e283dd/"/>
    <url>/p/9970e725452b49e496324842a7e283dd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <a href="https://segmentfault.com/a/1190000007083024">SegmentFault</a>，英文原文在 <a href="https://hackernoon.com/how-it-feels-to-learn-JavaScript-in-2016-d3a717dd577f">How it feels to learn JavaScript in 2016</a><br>吾辈觉得颇为有趣，便转载了一下（也算是前端开发的悲哀之处了吧）<br>附：吾辈觉得至今为止，前端工具链仍然没有好太多，工具链过多导致配置复杂，入门难度极大。<br>附：现在都 2018 了，然而吾辈的公司现在还是用 <code>jQuery</code>，虽然吾辈目前在内部强推了 <code>VueJS</code> #笑哭<br>附：吾辈这里对内容添加了一些样式，便于阅读时不那么疲劳。</p></blockquote><p>问：最近我接手了一个新的 <code>Web</code> 项目，不过老实说我已经好久没碰过这方面的代码了。听说前端的技术栈已经发生了极大的变革，不知道你现在是不是仍然处于最前沿的开发者阵列？<br>答：准确来说，过去俗称的写网页的，现在应该叫做 <code>Front End Engineer</code>，我确实属于这所谓的前端工程师。并且我才从 <code>JSConf</code> 与 <code>ReactConf</code> 面基回来，因此我觉得我觉得我还是了解目前 <code>Web</code> 前端领域最新的面貌的。<br>问：不错不错，我的需求其实也不复杂，就是从后端提供的 <code>REST</code> 风格的 <code>EndPoint</code> 来获取用户活动数据并且将其展示在前端界面上。并且需要以列表形式展示，同时，列表要支持筛选排序等操作，对了，还要保证前端数据和服务端保持一致。按照我现在的理解，我打算用 <code>jQuery</code> 来抓取与展现数据，你觉得咋样？<br>答：不不不，现在估计已经没多少人使用 <code>jQuery</code> 了吧。你可以试试 <code>React</code>，毕竟这是 2016 年了啊。<br>问：额，好吧，那啥是 <code>React</code> 啊？<br>答：这是个非常不错的源自 <code>Facebook</code> 的前端库，它能够帮你便捷地响应界面事件，同时保证项目层级的可控性与还说得过去的性能。<br>问：不错不错，那我是不是就可以用 <code>React</code> 来展示数据了呢？<br>答：话是这么说没错，不过你需要添加 <code>React</code> 与 <code>React DOM</code> 依赖项到你的页面中去。<br>问：等等，<code>React</code> 不是一个库吗？为啥要添加两个依赖呢？<br>答：不要急，前者是 <code>React</code> 的核心库，后面呢算是 <code>Facebook</code> 操作的辅助库，这样就能让你用 <code>JSX</code> 来描述你的界面布局了。<br>问：<code>JSX</code>？啥是 <code>JSX</code>？<br>答：<code>JSX</code> 是一个类似于 <code>XML</code> 的 <code>JavaScript</code> 语法扩展，它是另一种描述 <code>Facebook</code> 的方式，可以认为是 <code>HTML</code> 的替代品。<br>问：等等，<code>HTML</code> 咋啦？<br>答：都 2016 了，直接用 <code>HTML</code> 早就过时了。<br>问：好吧，那是不是我把两个库添加到项目中我就可以使用 <code>React</code> 了？<br>答：额，还要一些小的工具，你需要添加 <code>Babel</code> 到你的项目中，这样你就能用了。<br>问：又是一个库？<code>Babel</code> 又是什么鬼？<br>答：你可以把 <code>Babel</code> 认为是一个转译工具，可以将某个特定版本的 <code>JavaScript</code> 转译为任意版本的 <code>JavaScript</code>。你可以选择不使用 <code>Babel</code>，不过那也就意味着你只能用烦人的 <code>ES5</code> 来编写你的项目了。不过既然都是 2016 了，我建议你还是使用最新的 <code>ES2016+</code> + 语法吧。<br>问：<code>ES5</code>？<code>ES2016+</code>+？我已经迷茫了，<code>ES5</code>，<code>ES2016+</code> + 又是啥？<br>答：<code>ES5</code> 是 <code>ECMAScript 2015</code> 的缩写，也是现在被绝大部分浏览器所支持的 <code>JavaScript</code> 语法。<br>问：<code>ECMAScript</code>？<br>答：是的，你应该知道 <code>JavaScript</code> 最早于 1995 年提出，而后在 1999 年第一个正式版本定稿。之后的十数年里 <code>JavaScript</code> 的发展一直很凌乱，不过经过七个版本之后已经逐步清晰了。<br>问：7 个版本？那么 <code>ES5</code> 与 <code>ES2016+</code> 又是第几个版本呢？<br>答：是的，分别指第五个版本与第七个版本。<br>问：等等，那第六个版本呢？<br>答：你说 <code>ES6</code>？估计我刚才没有讲明白，<code>ECMAScript</code> 的每个版本都是向前兼容的，当你使用 <code>ES2016+</code> + 的时候也就意味着你在使用之前所有版本的所有特性啦。<br>问：原来是这样啊，那为啥一定要用 <code>ES2016+</code> 而不是 <code>ES6</code> 呢？<br>答：是的，你可以使用 <code>ES6</code>，不过如果你要使用 <code>async</code> 与 <code>await</code> 这些特性，你就要去用 <code>ES2016+</code> 了。否则你就还不得不去使用 <code>ES6</code> 的 <code>Generator</code> 来编写异步代码了。<br>问：我现在彻底迷糊了，我只是想简单地从服务端加载些数据而已，之前只需要从 <code>CDN</code> 加载下 <code>jQuery</code> 的依赖库，然后用 <code>Ajax</code> 方法来获取数据即可，为啥我现在不能这么做呢？<br>答：别傻了，每个人都知道一味使用 <code>jQuery</code> 的后果就是让你的代码变得一团乱麻，这都 2016 了，没人再想去面对这种头疼的代码了。<br>问：你说的是有道理，那现在我是不是就把这三个库加载进来，然后用 <code>HTML</code> 的 <code>Table</code> 来展示这些数据？<br>答：嗯，你可以选择一个模块打包工具将这三个依赖库打包到一个文件中。<br>问：额，啥是模块打包工具啊？<br>答：这个名词在不同的环境下指代也不同，不过在 <code>Web</code> 开发中我们一般将支持 <code>AMD</code> 与 <code>CommonJS</code> 的工具称为模块打包工具。<br>问：<code>AMD</code> 与 <code>CommonJS</code> 又是？<br>答：它们是用于描述 <code>JavaScript</code> 库与类之间交互的接口标准，你有听过 exports 与 <code>requires</code> 吗？你可以根据 AMD 或者 CommonJS 的规范来定义多个 <code>JavaScript</code> 文件，然后用类似于 <code>Browserify</code> 的工具来打包它们。<br>问：原来是这样，那 <code>Browserify</code> 是啥呢？<br>答：<code>Browserify</code> 最早是为了避免人们把自己的依赖一股脑放到 <code>NPM Registry</code> 中构建的，它最主要的功能就是允许人们将遵循 <code>CommonJS</code> 规范的模块打包到一个文件中。<br>问：<code>NPM Registry</code>？<br>答：这是一个很大的在线仓库，允许人们将代码与依赖以模块方式打包发布。<br>问：就像 <code>CDN</code> 一样？<br>答：还是有很大差异的，它更像一个允许人们发布与下载依赖库的中心仓库。<br>问：哦，我懂了，就像 <code>Bower</code> 一样啊。<br>答：对哒，不过 2016 年了，同样没啥人用 <code>Bower</code> 了。<br>问：嗯嗯，那我这时候应该从 <code>npm</code> 库中下载依赖了是吧？<br>答：是的，譬如如果你要用 <code>React</code> 的话，你可以直接用 <code>Npm</code> 命令来安装 <code>React</code>，然后导入到你的项目中，现在绝大部分主流的 <code>JavaScript</code> 库都支持这种方式了。<br>问：嗯嗯，就像 <code>Angular</code> 一样啊。<br>答：不过 <code>Angular</code> 也是 2015 年的流行了，现在像 <code>VueJS</code> 或者 <code>RxJS</code> 这样的才是小鲜肉，你想去学习它们吗？<br>问：不急不急，我们还是先多聊聊 <code>React</code> 吧，贪多嚼不烂。我还想确定下，是不是我从 <code>npm</code> 下载了 <code>React</code> 然后用 <code>Browserify</code> 打包就可以了？<br>答：是的。<br>问：好的，不过每次都要下载一大堆依赖然后打包，看起来好麻烦啊。<br>答：是的，不过你可以使用像 <code>Grunt</code> 或者 <code>Gulp</code> 或者 <code>Broccoli</code> 这样的任务管理工具来自动运行 <code>Browserify</code>。对了，你还可以用 <code>Mimosa</code>。<br>问：<code>Grunt</code>？<code>Gulp</code>？<code>Broccoli</code>？<code>Mimosa</code>？我们到底在讨论啥？<br>答：不方，我们在讨论任务管理工具，不过同样的，这些工具也是属于 2015 年的弄潮儿。现在我们流行使用 <code>Webpack</code> 咯。<br>问：<code>Makefiles</code>? 听起来有点像是一个 <code>C</code> 或者 <code>C++</code> 项目啊。<br>答：没错，不过很明显 <code>Web</code> 的演变之路就是把所有事情弄复杂，然后再回归到最基础的方式。估计不出几年你就要在 <code>Web</code> 中写汇编代码了。<br>问：额，你刚才好像提到了 <code>Webpack</code>？<br>答：是的，这是一个兼顾了模块打包工具与任务运行器的打包工具，有点像 <code>Browserify</code> 的升级版本。<br>问：嗷嗷，这样啊，那你觉得哪个更好点呢？<br>答：这个因人而异了，不过我个人是更加偏好于 <code>Webpack</code>，毕竟它不仅仅支持 <code>CommonJS</code> 规范，还支持 <code>ES6</code> 的模块规范。<br>问：好吧，我已经被 <code>CommonJS/ES6</code> 这些东西彻底搞乱了。<br>答：很多人都是这样，多了，你可能还要去了解下 <code>SystemJS</code>。<br>问：天哪，又是一个新名词，啥是 <code>SystemJS</code> 呢？<br>答：不同于 <code>Browserify</code> 与 <code>Webpack 1.x</code>，<code>SystemJS</code> 是一个允许你将多个模块分封于多个文件的动态模块打包工具，而不是全部打包到一个大的文件中。<br>问：等等，不过我觉得按照网络优化规范我们应该将所有的库打包到一个文件中。<br>答：是的，不过 <code>HTTP/2</code> 快要来了，并发的 <code>HTTP</code> 请求已经不是梦。<br>问：额，那时候是不是就不需要添加 <code>React</code> 的依赖库了？<br>答：不一定，你可以将这些依赖库从 <code>CDN</code> 中加载进来，不过你还是需要引入 <code>Babel</code> 的吧。<br>问：额，我刚才好像说错了话。<br>答：是的，如果按照你所说的，你需要在生产环境下将所有的 <code>Babel-core</code> 引入，这样会无端端增加很多额外的性能消耗。<br>问：好吧，那我到底应该怎么做呢？<br>答：我个人建议是用 <code>TypeScript+Webpack+SystemJS+Babel</code> 这一个组合。<br>问：<code>TypeScript</code>？我一直以为我们在说的是 <code>JavaScript</code>！<br>答：是的，<code>TypeScript</code> 是 <code>JavaScript</code> 的超集，基于 ES6 版本的一些封装。你应该还没忘记 <code>ES6</code> 吧？<br>问：我以为我们刚才说到的 <code>ES2016+</code> + 就是 <code>ES6</code> 的超集了。为啥我们还需要 <code>TypeScript</code> 呢？<br>答：因为 <code>TypeScript</code> 允许我们以静态类型语言的方式编写 <code>JavaScript</code>，从而减少运行时错误。都 2016 了，添加些强类型不是坏事。<br>问：原来 <code>TypeScript</code> 是做这个的啊！<br>答：是的，还有一个就是 <code>Facebook</code> 出品的 <code>Flow</code>。<br>问：<code>Flow</code> 又是啥？<br>答：<code>Flow</code> 是 <code>Facebook</code> 出品的静态类型检测工具，基于函数式编程的 <code>OCaml</code> 构建。<br>问：<code>OCamel</code>？<code>函数式编程</code>？<br>答：你没听过吗？<code>函数式编程</code>？<code>高阶函数</code>？<code>Currying</code>? 纯函数？<br>问：我一无所知。<br>答：好吧，那你只需要记得函数式编程在某些方面是优于 <code>OOP</code> 的，并且我们在 2016 年应该多多使用呦。<br>问：等等，我在大学就学过了 <code>OOP</code>，我觉得挺好的啊。<br>答：是的，<code>OOP</code> 确实还有很多可圈可点的地方，不过大家已经认识到了可变的状态太容易引发未知问题了，因此慢慢的所有人都在转向不可变数据与函数式编程。在前端领域我们可以用 <code>Rambda</code> 这样的库来在 <code>JavaScript</code> 中使用函数式编程了。<br>问：你是不是专门一字排开名词来了？<code>Ramda</code> 又是啥？<br>答：当然不是啦，<code>Rambda</code> 是类似于 <code>Lambda</code> 的库，源自 <strong>David Chambers</strong>。<br>问：<strong>David Chambers</strong>？<br>答：<strong>David Chambers</strong> 是个很优秀的程序员，他是 <code>Rambda</code> 的核心贡献者之一。如果你要学习函数式编程的话，你还应该关注下 <strong>Erik Meijer</strong>。<br>问：<strong>Erik Meijer</strong>？<br>答：另一个函数式编程领域的大神与布道者。<br>问：好吧，还会让我们回到 <code>React</code> 的话题吧，我应该怎么使用 <code>React</code> 来抓取数据呢？<br>答：额，<code>React</code> 只是用于展示数据的，它并不能够帮你抓取数据。<br>问：我的天啊，那我怎么来抓取数据呢？<br>答：你应该使用 <code>fetch</code> 来从服务端获取数据。<br>问：<code>fetch</code>？<br>答：是的，<code>fetch</code> 是浏览器原生基于 <code>XMLHttpRequests</code> 的封装。<br>问：那就是 <code>AJAX</code> 咯？<br>答：<code>AJAX</code> 一般指仅仅使用 <code>XMLHttpRequests</code>，而 <code>fetch</code> 允许你基于 <code>Promise</code> 来使用 <code>AJAX</code>，这样就能够避免 <code>Callback hell</code> 了。<br>问：<code>Callback hell</code>?<br>答：是的，每次你向服务器发起某个异步请求的时候，你必须要添加一个异步回调函数来处理其响应，这样一层又一层地回调的嵌套就是所谓的 <code>Callback hell</code> 了。<br>问：好吧，那 <code>Promise</code> 就是专门处理这个哩？<br>答：没错，你可以用 <code>Promise</code> 来替换传统的基于回调的异步函数调用方式，从而编写出更容易理解与测试的代码。<br>问：那我现在是不是直接使用 <code>fetch</code> 就好了啊？<br>答：是啊，不过如果你想要在较老版本的浏览器中使用 <code>fetch</code>，你需要引入 <code>fetch</code> <code>Polyfill</code>，或者使用 <code>Request</code>、<code>Bluebird</code> 或者 <code>Axios</code>。<br>问：来啊，互相伤害吧，你还是直接告诉我我还需要了解多少个库吧！<br>答：这可是 <code>JavaScript</code> 啊，可是有成千上万个库的。而且不少库还很大呢，譬如那个嵌了一张 Guy Fieri 图片的库。<br>问：你是说 Guy Fieri? 我听说过，那 <code>Bluebird</code>、<code>Request</code>、<code>Axios</code> 又是啥呢？<br>答：它们可以帮你执行 <code>XMLHttpRequests</code> 然后返回 <code>Promise</code> 对象。<br>问：难道 <code>jQuery</code> 的 <code>AJAX</code> 方法不是返回 <code>Promise</code> 吗？<br>答：请忘掉 <code>jQuery</code> 吧，用 <code>fetch</code> 配合上 <code>Promise</code>，或者 <code>async/await</code> 能够帮你构造合适的控制流。<br>问：这是你第三次提到 <code>await</code> 了，这到底是个啥啊？<br>答：<code>await</code> 是 <code>ES7</code> 提供的关键字，能够帮你阻塞某个异步调用直到其返回，这样能够让你的控制流更加清晰，代码的可读性也能更上一层楼。你可以在 <code>Babel</code> 中添加 <code>stage-3 preset</code>，或者添加 <code>syntax-async-functions</code> 以及 <code>transform-async-to-generator</code> 这两个插件。<br>问：好麻烦啊。<br>答：是啊，不过更麻烦的是你必须先预编译 <code>TypeScript</code> 代码，然后用 <code>Babel</code> 来转译 <code>await</code>。<br>问：为啥？难道 <code>TypeScript</code> 中没有内置？<br>答：估计在下一个版本中会添加该支持，不过目前的 1.7 版本的 <code>TypeScript</code> 目标是 ES6，因此如果你还想在浏览器中使用 <code>await</code>，你必须要先把 <code>TypeScript</code> 编译为 ES6，然后使用 <code>Babel</code> 转译为 <code>ES5</code>。<br>问：我已经无话可说了。<br>答：好吧，其实你也不用想太多，首先你基于 <code>TypeScript</code> 进行编码，然后将所有使用 <code>fetch</code> 的模块转译为 <code>ES6</code>，然后再使用 <code>Babel</code> 的 <code>stage-3 preset</code> 来对 <code>await</code> 等进行 <code>Polyfill</code>，最后使用 <code>SystemJS</code> 来完成加载。如果你打算使用 <code>fetch</code> 的话，还可以使用 <code>Bluebird</code>、<code>Request</code> 或者 <code>Axios</code>。<br>问：好，这样说就清晰多了，是不是这样我就达到我的目标了？<br>答：额，你的应用需要处理任何的状态变更吗？<br>问：我觉得不要把，我只是想展示数据。<br>答：那还行，否则的话你还需要了解 <code>Flux</code>、<code>Redux</code> 等等一系列的东西。<br>问：我不想再纠结于这些名词了，再强调一遍，我只是想展示数据罢了。<br>答：好吧，其实如果你只是想展示数据的话，你并不需要 <code>React</code>，你只需要一个比较好的模板引擎罢了。<br>问：你在开玩笑？<br>答：不要着急，我只是告诉你你可以用到的东西。<br>问：停！<br>答：我的意思是，即使你仅仅打算用个模板引擎，还是建议使用下 <code>TypeScript</code>+<code>SystemJS</code>+<code>Babel</code>。<br>问：好吧，那你还是推荐一个模板引擎吧！<br>答：有很多啊，你有对哪种比较熟悉吗？<br>问：唔，好久之前用了，记不得了。<br>答：<code>jTemplates</code>?<code>jQote?PURE</code>?<br>问：没听过，还有吗？<br>答：<code>Transparency</code>？<code>JSRender</code>？<code>MarkupJS?KnockoutJS</code>?<br>问：还有吗？<br>答：<code>PlatesJS</code>?<code>jQuery-tmpl?Handlebars</code>?<br>问：好像最后一个有点印象。<br>答：<code>Mustache</code>?<code>underscore</code>？<br>问：好像更晚一点的。<br>答：<code>Jade</code>?<code>DustJS</code>?<br>问：不。<br>答：<code>DotJS</code>?<code>EJS</code>?<br>问：不。<br>答：<code>Nunjucks</code>?<code>ECT</code>?<br>问：不。<br>答：<code>Mah</code>?<code>Jade</code>?<br>问：额，还不是。<br>答？难道是 <code>ES6</code> 原生的字符串模板引擎。<br>问：我估计，这货也需要 <code>ES6</code> 吧。<br>答：是啊。<br>问：需要 <code>Babel</code>？<br>答：是啊。<br>问：是不是还要从 <code>npm</code> 下载核心模块？<br>答：是啊。<br>问：是不是还需要 <code>Browserify</code>、<code>Webpack</code> 或者类似于 <code>SystemJS</code> 这样的模块打包工具？<br>答：是啊。<br>问：除了 <code>Webpack</code>，还需要引入任务管理器。<br>答：是啊。<br>问：我是不是还需要某个函数式编程语言，或者强类型语言？<br>答：是啊。<br>问：然后如果用到 <code>await</code> 的话，还需要引入 <code>Babel</code>？<br>答：是啊。<br>问：然后就可以使用 <code>fetch</code>、<code>Promise</code> 了吧？<br>答：别忘了 <code>Polyfill</code> <code>fetch</code>，Safari 目前还不能原生支持 <code>fetch</code>。<br>问：是不是，学完这些，就 OK 了？<br>答：额，目前来看是的，不过估计过几年我们就需要用 <code>Elm</code> 或者 <code>WebAssembly</code> 咯～<br>问：我觉得，我还是乖乖去写后端的代码吧。<br>答：<code>Python</code> 大法好！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 GreaseMonkey 解除网页复制粘贴限制</title>
    <link href="/p/9a8a075106024e4c94211e779d6f39bd/"/>
    <url>/p/9a8a075106024e4c94211e779d6f39bd/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吾辈发布了一个油猴脚本，可以直接安装 <a href="https://greasyfork.org/zh-CN/scripts/391193">解除网页限制</a> 以获得更好的使用体验。</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在浏览网页时经常会出现的一件事，当吾辈想要复制，突然发现复制好像没用了？（<a href="https://www.zhihu.com/question/23994286">知乎禁止转载的文章</a>）亦或者是复制的最后多出了一点内容（<a href="https://www.jianshu.com/p/0a85e4c7d3d3">简书</a>），或者干脆直接不能选中了（<a href="http://www.360doc.cn/">360doc</a>）。粘贴时也有可能发现一直粘贴不了（<a href="https://auth.alipay.com/login/index.htm">支付宝登录</a>）。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>欲先制敌，必先惑敌。想要解除复制粘贴的限制，就必须要清楚它们是如何实现的。不管如何，浏览器上能够运行的都是 JavaScript，它们都是使用 JavaScript 实现的。实现方式大致都是监听相应的事件（例如 <code>onkeydown</code> 监听 <code>Ctrl-C</code>），然后做一些特别的操作。</p><p>例如屏蔽复制功能只需要一句代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.oncopy = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>是的，只要返回了 false，那么 copy 就会失效。还有一个更讨厌的方式，直接在 <code>body</code> 元素上加行内事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">oncopy</span>=<span class="hljs-string">&quot;javascript: return false&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以看出，一般都是使用 JavaScript 在相应事件中返回 false，来阻止对应事件。那么，既然事件都被阻止了，是否意味着我们就束手无策了呢？吾辈所能想到的解决方案大致有三种方向</p><ul><li>使用 JavaScript 监听事件并自行实现复制/剪切/粘贴功能<ul><li>优点：实现完成后不管是任何网站都能使用，并且不会影响到监听之外的事件，也不会删除监听的同类型事件，可以解除浏览器本身的限制（密码框禁止复制）</li><li>缺点：某些功能自行实现难度很大，例如选择文本</li></ul></li><li>重新实现 <code>addEventListener</code> 然后删除掉网站自定义的事件<ul><li>优点：事件生效范围广泛，通用性高，不仅 _复制/剪切/粘贴_，其他类型的事件也可以解除</li><li>缺点：实现起来需要替换 <code>addEventListener</code> 事件<strong>够早</strong>，对浏览器默认操作不会生效（密码框禁止复制），而且某些网站也无法破解</li></ul></li><li>替换元素并删除 DOM 上的事件属性<ul><li>优点：能够确保网站 js 的限制被解除，通用性高，事件生效范围广泛</li><li>缺点：可能影响到其他类型的事件，复制节点时不会复制使用 <code>addEventListener</code> 添加的事件<blockquote><p>注：此方法不予演示，缺陷实在过大</p></blockquote></li></ul></li></ul><p>总之，如果真的想解除<strong>限制</strong>，恐怕需要两种方式并用才可以呢</p><h2 id="使用-JavaScript-监听事件并自行实现复制-剪切-粘贴功能"><a href="#使用-JavaScript-监听事件并自行实现复制-剪切-粘贴功能" class="headerlink" title="使用 JavaScript 监听事件并自行实现复制/剪切/粘贴功能"></a>使用 JavaScript 监听事件并自行实现复制/剪切/粘贴功能</h2><h3 id="实现强制复制"><a href="#实现强制复制" class="headerlink" title="实现强制复制"></a>实现强制复制</h3><p>思路</p><ol><li> 冒泡监听 <code>copy</code> 事件</li><li> 获取当前选中的内容</li><li> 设置剪切版的内容</li><li> 阻止默认事件处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 强制复制</span><br><span class="hljs-built_in">document</span>.addEventListener(<br>  <span class="hljs-string">&quot;copy&quot;</span>,<br>  (event) =&gt; &#123;<br>    event.clipboardData.setData(<br>      <span class="hljs-string">&quot;text/plain&quot;</span>,<br>      <span class="hljs-built_in">document</span>.getSelection().toString()<br>    );<br>    <span class="hljs-comment">// 阻止默认的事件处理</span><br>    event.preventDefault();<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><h3 id="实现强制剪切"><a href="#实现强制剪切" class="headerlink" title="实现强制剪切"></a>实现强制剪切</h3><p>思路</p><ol><li> 冒泡监听 <code>cut</code> 事件</li><li> 获取当前选中的内容</li><li> 设置剪切版的内容</li><li> 如果是可编辑内容要删除选中部分</li><li> 阻止默认事件处理</li></ol><blockquote><p>可以看到唯一需要增加的就是需要额外处理可编辑内容了，然而代码量瞬间爆炸了哦</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串安全的转换为小写</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>转换后得到的全小写字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerCase</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!str || <span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> str;<br>  &#125;<br>  <span class="hljs-keyword">return</span> str.toLowerCase();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断指定元素是否是可编辑元素</span><br><span class="hljs-comment"> * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要进行判断的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Boolean&#125;</span> </span>是否为可编辑元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEditable</span>(<span class="hljs-params">el</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> inputEls = [<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;datetime&quot;</span>, <span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-string">&quot;textarea&quot;</span>];<br>  <span class="hljs-keyword">return</span> (<br>    el &amp;&amp; (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取输入框中光标所在位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要获取的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number&#125;</span> </span>光标所在位置的下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCusorPostion</span>(<span class="hljs-params">el</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> el.selectionStart;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置输入框中选中的文本/光标所在位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>start 光标所在位置的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为输入框结束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCusorPostion</span>(<span class="hljs-params">el, start, end = start</span>) </span>&#123;<br>  el.focus();<br>  el.setSelectionRange(start, end);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在指定范围内删除文本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;start&#125;</span> </span>开始位置，默认为当前选中开始位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为当前选中结束位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeText</span>(<span class="hljs-params">el, start = el.selectionStart, end = el.selectionEnd</span>) </span>&#123;<br>  <span class="hljs-comment">// 删除之前必须要 [记住] 当前光标的位置</span><br>  <span class="hljs-keyword">var</span> index = getCusorPostion(el);<br>  <span class="hljs-keyword">var</span> value = el.value;<br>  el.value = value.substr(<span class="hljs-number">0</span>, start) + value.substr(end, value.length);<br>  setCusorPostion(el, index);<br>&#125;<br><br><span class="hljs-comment">// 强制剪切</span><br><span class="hljs-built_in">document</span>.addEventListener(<br>  <span class="hljs-string">&quot;cut&quot;</span>,<br>  (event) =&gt; &#123;<br>    event.clipboardData.setData(<br>      <span class="hljs-string">&quot;text/plain&quot;</span>,<br>      <span class="hljs-built_in">document</span>.getSelection().toString()<br>    );<br>    <span class="hljs-comment">// 如果是可编辑元素还要进行删除</span><br>    <span class="hljs-keyword">if</span> (isEditable(event.target)) &#123;<br>      removeText(event.target);<br>    &#125;<br>    event.preventDefault();<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><h3 id="实现强制粘贴"><a href="#实现强制粘贴" class="headerlink" title="实现强制粘贴"></a>实现强制粘贴</h3><ol><li> 冒泡监听 <code>focus/blur</code>，以获得最后一个获得焦点的可编辑元素</li><li> 冒泡监听 <code>paste</code> 事件</li><li> 获取剪切版的内容</li><li> 获取最后一个获得焦点的可编辑元素</li><li> 删除当前选中的文本</li><li> 在当前光标处插入文本</li><li> 阻止默认事件处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取到最后一个获得焦点的元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getLastFocus = (<span class="hljs-function">(<span class="hljs-params">lastFocusEl</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.addEventListener(<br>    <span class="hljs-string">&quot;focus&quot;</span>,<br>    (event) =&gt; &#123;<br>      lastFocusEl = event.target;<br>    &#125;,<br>    <span class="hljs-literal">true</span><br>  );<br>  <span class="hljs-built_in">document</span>.addEventListener(<br>    <span class="hljs-string">&quot;blur&quot;</span>,<br>    (event) =&gt; &#123;<br>      lastFocusEl = <span class="hljs-literal">null</span>;<br>    &#125;,<br>    <span class="hljs-literal">true</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> lastFocusEl;<br>&#125;)(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串安全的转换为小写</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>转换后得到的全小写字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerCase</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!str || <span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> str;<br>  &#125;<br>  <span class="hljs-keyword">return</span> str.toLowerCase();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断指定元素是否是可编辑元素</span><br><span class="hljs-comment"> * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要进行判断的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Boolean&#125;</span> </span>是否为可编辑元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEditable</span>(<span class="hljs-params">el</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> inputEls = [<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;datetime&quot;</span>, <span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-string">&quot;textarea&quot;</span>];<br>  <span class="hljs-keyword">return</span> (<br>    el &amp;&amp; (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))<br>  );<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取输入框中光标所在位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要获取的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number&#125;</span> </span>光标所在位置的下标</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCusorPostion</span>(<span class="hljs-params">el</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> el.selectionStart;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置输入框中选中的文本/光标所在位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>start 光标所在位置的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为输入框结束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCusorPostion</span>(<span class="hljs-params">el, start, end = start</span>) </span>&#123;<br>  el.focus();<br>  el.setSelectionRange(start, end);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在指定位置后插入文本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>value 要插入的值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;start&#125;</span> </span>开始位置，默认为当前光标处</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertText</span>(<span class="hljs-params">el, text, start = getCusorPostion(el)</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> value = el.value;<br>  el.value = value.substr(<span class="hljs-number">0</span>, start) + text + value.substr(start);<br>  setCusorPostion(el, start + text.length);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在指定范围内删除文本</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;start&#125;</span> </span>开始位置，默认为当前选中开始位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为当前选中结束位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeText</span>(<span class="hljs-params">el, start = el.selectionStart, end = el.selectionEnd</span>) </span>&#123;<br>  <span class="hljs-comment">// 删除之前必须要 [记住] 当前光标的位置</span><br>  <span class="hljs-keyword">var</span> index = getCusorPostion(el);<br>  <span class="hljs-keyword">var</span> value = el.value;<br>  el.value = value.substr(<span class="hljs-number">0</span>, start) + value.substr(end, value.length);<br>  setCusorPostion(el, index);<br>&#125;<br><br><span class="hljs-comment">// 强制粘贴</span><br><span class="hljs-built_in">document</span>.addEventListener(<br>  <span class="hljs-string">&quot;paste&quot;</span>,<br>  (event) =&gt; &#123;<br>    <span class="hljs-comment">// 获取当前剪切板内容</span><br>    <span class="hljs-keyword">var</span> clipboardData = event.clipboardData;<br>    <span class="hljs-keyword">var</span> items = clipboardData.items;<br>    <span class="hljs-keyword">var</span> item = items[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (item.kind !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> text = clipboardData.getData(item.type);<br>    <span class="hljs-comment">// 获取当前焦点元素</span><br>    <span class="hljs-comment">// 粘贴的时候获取不到焦点？</span><br>    <span class="hljs-keyword">var</span> focusEl = getLastFocus();<br>    <span class="hljs-comment">// input 居然不是 [可编辑] 的元素？</span><br>    <span class="hljs-keyword">if</span> (isEditable(focusEl)) &#123;<br>      removeText(focusEl);<br>      insertText(focusEl, text);<br>      event.preventDefault();<br>    &#125;<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>脚本全貌</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &quot;use strict&quot;</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 两种思路：</span><br><span class="hljs-comment">   * 1. 自己实现</span><br><span class="hljs-comment">   * 2. 替换元素</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取到最后一个获得焦点的元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">var</span> getLastFocus = (<span class="hljs-function">(<span class="hljs-params">lastFocusEl</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.addEventListener(<br>      <span class="hljs-string">&quot;focus&quot;</span>,<br>      (event) =&gt; &#123;<br>        lastFocusEl = event.target;<br>      &#125;,<br>      <span class="hljs-literal">true</span><br>    );<br>    <span class="hljs-built_in">document</span>.addEventListener(<br>      <span class="hljs-string">&quot;blur&quot;</span>,<br>      (event) =&gt; &#123;<br>        lastFocusEl = <span class="hljs-literal">null</span>;<br>      &#125;,<br>      <span class="hljs-literal">true</span><br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> lastFocusEl;<br>  &#125;)(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 字符串安全的转换为小写</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>转换后得到的全小写字符串</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLowerCase</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!str || <span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str.toLowerCase();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 字符串安全的转换为大写</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>str 字符串</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;String&#125;</span> </span>转换后得到的全大写字符串</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toUpperCase</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!str || <span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str.toUpperCase();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 判断指定元素是否是可编辑元素</span><br><span class="hljs-comment">   * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要进行判断的元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Boolean&#125;</span> </span>是否为可编辑元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEditable</span>(<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> inputEls = [<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;datetime&quot;</span>, <span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-string">&quot;textarea&quot;</span>];<br>    <span class="hljs-keyword">return</span> (<br>      el &amp;&amp; (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取输入框中光标所在位置</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要获取的输入框元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Number&#125;</span> </span>光标所在位置的下标</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCusorPostion</span>(<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> el.selectionStart;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 设置输入框中选中的文本/光标所在位置</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>start 光标所在位置的下标</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为输入框结束</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCusorPostion</span>(<span class="hljs-params">el, start, end = start</span>) </span>&#123;<br>    el.focus();<br>    el.setSelectionRange(start, end);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在指定位置后插入文本</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>value 要插入的值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;start&#125;</span> </span>开始位置，默认为当前光标处</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertText</span>(<span class="hljs-params">el, text, start = getCusorPostion(el)</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = el.value;<br>    el.value = value.substr(<span class="hljs-number">0</span>, start) + text + value.substr(start);<br>    setCusorPostion(el, start + text.length);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在指定范围内删除文本</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Element&#125;</span> </span>el 需要设置的输入框元素</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;start&#125;</span> </span>开始位置，默认为当前选中开始位置</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-type">&#123;end&#125;</span> </span>结束位置，默认为当前选中结束位置</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeText</span>(<span class="hljs-params">el, start = el.selectionStart, end = el.selectionEnd</span>) </span>&#123;<br>    <span class="hljs-comment">// 删除之前必须要 [记住] 当前光标的位置</span><br>    <span class="hljs-keyword">var</span> index = getCusorPostion(el);<br>    <span class="hljs-keyword">var</span> value = el.value;<br>    el.value = value.substr(<span class="hljs-number">0</span>, start) + value.substr(end, value.length);<br>    setCusorPostion(el, index);<br>  &#125;<br><br>  <span class="hljs-comment">// 强制复制</span><br>  <span class="hljs-built_in">document</span>.addEventListener(<br>    <span class="hljs-string">&quot;copy&quot;</span>,<br>    (event) =&gt; &#123;<br>      event.clipboardData.setData(<br>        <span class="hljs-string">&quot;text/plain&quot;</span>,<br>        <span class="hljs-built_in">document</span>.getSelection().toString()<br>      );<br>      event.preventDefault();<br>    &#125;,<br>    <span class="hljs-literal">true</span><br>  );<br><br>  <span class="hljs-comment">// 强制剪切</span><br>  <span class="hljs-built_in">document</span>.addEventListener(<br>    <span class="hljs-string">&quot;cut&quot;</span>,<br>    (event) =&gt; &#123;<br>      event.clipboardData.setData(<br>        <span class="hljs-string">&quot;text/plain&quot;</span>,<br>        <span class="hljs-built_in">document</span>.getSelection().toString()<br>      );<br>      <span class="hljs-comment">// 如果是可编辑元素还要进行删除</span><br>      <span class="hljs-keyword">if</span> (isEditable(event.target)) &#123;<br>        removeText(event.target);<br>      &#125;<br>      event.preventDefault();<br>    &#125;,<br>    <span class="hljs-literal">true</span><br>  );<br><br>  <span class="hljs-comment">// 强制粘贴</span><br>  <span class="hljs-built_in">document</span>.addEventListener(<br>    <span class="hljs-string">&quot;paste&quot;</span>,<br>    (event) =&gt; &#123;<br>      <span class="hljs-comment">// 获取当前剪切板内容</span><br>      <span class="hljs-keyword">var</span> clipboardData = event.clipboardData;<br>      <span class="hljs-keyword">var</span> items = clipboardData.items;<br>      <span class="hljs-keyword">var</span> item = items[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">if</span> (item.kind !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">var</span> text = clipboardData.getData(item.type);<br>      <span class="hljs-comment">// 获取当前焦点元素</span><br>      <span class="hljs-comment">// 粘贴的时候获取不到焦点？</span><br>      <span class="hljs-keyword">var</span> focusEl = getLastFocus();<br>      <span class="hljs-comment">// input 居然不是 [可编辑] 的元素？</span><br>      <span class="hljs-keyword">if</span> (isEditable(focusEl)) &#123;<br>        removeText(focusEl);<br>        insertText(focusEl, text);<br>        event.preventDefault();<br>      &#125;<br>    &#125;,<br>    <span class="hljs-literal">true</span><br>  );<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selection</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> dom;<br>    <span class="hljs-built_in">document</span>.onmousedown = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      dom = event.target;<br>      <span class="hljs-comment">// console.log(&#x27;点击: &#x27;, dom)</span><br>      <span class="hljs-keyword">debugger</span>;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;光标所在处: &quot;</span>, getCusorPostion(dom));<br>    &#125;;<br>    <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;移动: &quot;</span>, dom);<br>    &#125;;<br>    <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;松开: &quot;</span>, dom);<br>    &#125;;<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="重新实现-addEventListener-然后删除掉网站自定义的事件"><a href="#重新实现-addEventListener-然后删除掉网站自定义的事件" class="headerlink" title="重新实现 addEventListener 然后删除掉网站自定义的事件"></a>重新实现 <code>addEventListener</code> 然后删除掉网站自定义的事件</h2><blockquote><p>该实现来灵感来源自 <a href="https://greasyfork.org/en/scripts/41075">https://greasyfork.org/en/scripts/41075</a>，几乎完美实现了解除限制的功能</p></blockquote><p>原理很简单，修改原型，重新实现 <code>EventTarget</code> 和 <code>docuement</code> 的 <code>addEventListener</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         解除网页限制</span><br><span class="hljs-comment">// @namespace    http://github.com/rxliuli</span><br><span class="hljs-comment">// @version      1.0</span><br><span class="hljs-comment">// @description  破解禁止复制/剪切/粘贴/选择/右键菜单的网站</span><br><span class="hljs-comment">// @author       rxliuli</span><br><span class="hljs-comment">// @include      https://www.jianshu.com/*</span><br><span class="hljs-comment">// @grant        GM.getValue</span><br><span class="hljs-comment">// @grant        GM.setValue</span><br><span class="hljs-comment">// 这里的 @run-at 非常重要，设置在文档开始时就载入脚本</span><br><span class="hljs-comment">// @run-at       document-start</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 监听所有的 addEventListener, removeEventListener 事件</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">var</span> documentAddEventListener = <span class="hljs-built_in">document</span>.addEventListener;<br>  <span class="hljs-keyword">var</span> eventTargetAddEventListener = EventTarget.prototype.addEventListener;<br>  <span class="hljs-keyword">var</span> documentRemoveEventListener = <span class="hljs-built_in">document</span>.removeEventListener;<br>  <span class="hljs-keyword">var</span> eventTargetRemoveEventListener =<br>    EventTarget.prototype.removeEventListener;<br>  <span class="hljs-keyword">var</span> events = [];<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用来保存监听到的事件信息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">el, type, listener, useCapture</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.el = el;<br>      <span class="hljs-built_in">this</span>.type = type;<br>      <span class="hljs-built_in">this</span>.listener = listener;<br>      <span class="hljs-built_in">this</span>.useCapture = useCapture;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 自定义的添加事件监听函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>type 事件类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;EventListener&#125;</span> </span>listener 事件监听函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> <span class="hljs-type">&#123;useCapture&#125;</span> </span>是否需要捕获事件冒泡，默认为 false</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">type, listener, useCapture = <span class="hljs-literal">false</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> $addEventListener =<br>      _this === <span class="hljs-built_in">document</span><br>        ? documentAddEventListener<br>        : eventTargetAddEventListener;<br>    events.push(<span class="hljs-keyword">new</span> Event(_this, type, listener, useCapture));<br>    $addEventListener.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 自定义的根据类型删除事件函数</span><br><span class="hljs-comment">   * 该方法会删除这个类型下面全部的监听函数，不管数量</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>type 事件类型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListenerByType</span>(<span class="hljs-params">type</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> $removeEventListener =<br>      _this === <span class="hljs-built_in">document</span><br>        ? documentRemoveEventListener<br>        : eventTargetRemoveEventListener;<br>    <span class="hljs-keyword">var</span> removeIndexs = events<br>      .map(<span class="hljs-function">(<span class="hljs-params">e, i</span>) =&gt;</span> (e.el === _this || e.type === <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] ? i : -<span class="hljs-number">1</span>))<br>      .filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i !== -<span class="hljs-number">1</span>);<br>    removeIndexs.forEach(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">var</span> e = events[i];<br>      $removeEventListener.apply(e.el, [e.type, e.listener, e.useCapture]);<br>    &#125;);<br>    removeIndexs.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).forEach(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> events.splice(i, <span class="hljs-number">1</span>));<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearEvent</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> eventTypes = [<br>      <span class="hljs-string">&quot;copy&quot;</span>,<br>      <span class="hljs-string">&quot;cut&quot;</span>,<br>      <span class="hljs-string">&quot;select&quot;</span>,<br>      <span class="hljs-string">&quot;contextmenu&quot;</span>,<br>      <span class="hljs-string">&quot;selectstart&quot;</span>,<br>      <span class="hljs-string">&quot;dragstart&quot;</span>,<br>    ];<br>    <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;*&quot;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>      eventTypes.forEach(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> el.removeEventListenerByType(type));<br>    &#125;);<br>  &#125;<br><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">document</span>.addEventListener = EventTarget.prototype.addEventListener = addEventListener;<br>    <span class="hljs-built_in">document</span>.removeEventListenerByType = EventTarget.prototype.removeEventListenerByType = removeEventListenerByType;<br>  &#125;)();<br><br>  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    clearEvent();<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><hr><p>最后，JavaScript hook 技巧是真的很多，果然写 Greasemonkey 脚本这方面用得很多呢 (๑&gt;ᴗ&lt;๑)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何超过大多数人</title>
    <link href="/p/9b18e52888d44aa5905de808668217a8/"/>
    <url>/p/9b18e52888d44aa5905de808668217a8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://coolshell.cn/articles/19464.html">https://coolshell.cn/articles/19464.html</a><br>对国内互联网的批判真的是相当尖锐啊 (ノ￣ ω ￣)ノ</p></blockquote><p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的 “武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径…… 然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力…… 然而，你错了，这篇文章还真就是一篇 “秘籍”，只要你把这些 “秘籍” 用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个 “人生导师” 可以写得好。毕竟，我的生命过到了十六进制 2B 的年纪，踏入这个社会已超过 20 年，舍我其谁呢？！</p><p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html">如何写出无法维护的代码</a>》一文的风格…… 嘿嘿</p><h2 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h2><p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些 “技巧” 你要多多了解一下。</p><p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p><ul><li>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识…… 要做到这一步，你就需要把 “百度一下” 挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种 “如何看待……” 这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</li><li>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向…… 是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</li><li>把今日头条和抖音这样的 APP 推荐给大家…… 你只需要让你有朋友成功地安装这两个 APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</li><li>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，…… 这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些 SB 或是很极端的观点，造成大家的一睦讨论后，就早早离场……</li><li>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了…… 这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</li></ul><p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p><ul><li>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</li><li>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</li><li>不断地给他们各种各样 “有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书 “收藏家”……</li><li>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用 “死记硬背” 的方式来学习，甚至直接让他们失去信心，直接放弃……</li><li>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</li><li>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</li><li>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</li><li>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</li><li>让他们觉得 “读完书”、“读过书” 就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</li></ul><p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p><ul><li>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</li><li>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入 “赌博类” 或是 “传销类” 的地方，比如：股市、数字货币…… 要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</li><li>告诉他们，一些看上去很难的事都是有捷径的，比如：21 天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</li><li>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</li><li>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</li><li>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</li><li>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</li><li>告诉他们你的行业太累太辛苦，干不到 30 岁。让他们早点转行，不要耽误人生和青春……</li><li>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</li><li>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的…… 这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</li><li>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</li></ul><p><strong>最后友情提示一下，上述的这些 “最佳实践” 你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是 “欲练神功，必先自宫” 的道理。</strong></p><h2 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h2><p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p><p>一般来说，超过别人一般来说就是两个维度：</p><ol><li> <strong>在认知、知识和技能上</strong>。这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html">21 天教你学会 C++</a>》）</li><li> <strong>在领导力上</strong>。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html">技术人员发展之路</a>》）</li></ol><p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把 “零碎的认知” 转换成 “系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的 “关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90% 的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p><h3 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h3><p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p><ol><li><p> <strong>信息渠道</strong>。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人 hack 其中的信息（也就是 “中间人攻击”），而这些找不出信息源的人，只能 “被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习 C 语言，放着原作者 K&amp;R 的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p></li><li><p> <strong>信息质量</strong>。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p></li><li><p> <strong>信息密度</strong>。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践…… 一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix 编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像 <a href="https://medium.com/netflix-techblog">Netflix 的官方 blog</a> 和 <a href="https://www.allthingsdistributed.com/">AWS CTO 的 blog</a> 等等地方也会经常有一些这样的文章。</p></li></ol><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p><ol><li><p> <strong>知识树（图）</strong>。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基” 是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p></li><li><p> <strong>知识缘由</strong>。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p></li><li><p> <strong>方法套路</strong>。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。<strong>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路</strong>。</p></li></ol><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p><ol><li><p> <strong>精益求精</strong>。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p></li><li><p> <strong>让自己犯错</strong>。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p></li><li><p> <strong>找高手切磋</strong>。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p></li></ol><h3 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h3><p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p><ol><li><p> <strong>识别自己的特长和天赋</strong>。首先，每个人 DNA 都可能或多或少都会有一些比大多数人 NB 的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p></li><li><p> <strong>识别自己的兴趣和事业</strong>。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus 就是在学校里对 minx 着迷了，于是整出个 Linux 来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫 “真 ∙ 兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是 “真 ∙ 兴趣”，这也就是你的 “野心” 和 “好胜心” 所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p></li><li><p> <strong>建立高级的习惯和方法</strong>。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来…… 自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p></li><li><p> **勤奋努力执着坚持 **。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的 “一万小时定律” 了（参看《<a href="https://coolshell.cn/articles/2250.html">21 天教你学会 C++</a>》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要 1 年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p></li></ol><p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p><p>（全文完）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么要用现代前端</title>
    <link href="/p/b11f3c6f1486497f9f07a08e885be6ec/"/>
    <url>/p/b11f3c6f1486497f9f07a08e885be6ec/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前端近两年来发展迅速，随着 <a href="https://nodejs.org/">nodejs</a> 的广泛使用，大批 <a href="https://npmjs.com/">npm</a> 的框架/库层出不穷，npm 上 JavaScript 库的数量甚至超过了 <a href="https://mvnrepository.com/">Maven 中央仓库</a>。<br>然而即便如此，仍然有很多公司固守在传统的前端切 UI，后端通过模板视图填充视图的技术。一方面固然是为了避免新技术踩坑，另一方面，居然有人在 <a href="https://github.com/denoland/deno">deno</a> 下说出了：<a href="https://github.com/denoland/deno/issues/25">求不要更新了，老子学不动了</a>，并引发了大量讨论。</p><blockquote><p>deno 是 nodejs 的作者开发的下一代 JavaScript 运行时。</p></blockquote><h2 id="现代前端"><a href="#现代前端" class="headerlink" title="现代前端"></a>现代前端</h2><p>前端发展史</p><blockquote><ol><li> 1996 年，样式表标准 <code>CSS</code> 第一版发布。</li><li> 2001 年，微软公司时隔 5 年之后，发布了 IE 浏览器的下一个版本 <code>Internet Explorer 6</code>。这是当时最先进的浏览器，它后来统治了浏览器市场多年。</li><li> 2002 年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 <code>Firefox</code>。</li><li> 2003 年，苹果公司发布了 <code>Safari</code> 浏览器的第一版。</li><li> 2004 年，Google 公司发布了 <code>Gmail</code>，促成了互联网应用程序（<code>Web Application</code>）这个概念的诞生。由于 Gmail 是在 4 月 1 日发布的，很多人起初以为这只是一个玩笑。</li><li> 2004 年，<code>WHATWG</code> 组织成立，致力于加速 HTML 语言的标准化进程。</li><li> 2005 年，<code>Ajax</code> 方法（Asynchronous JavaScript and XML）正式诞生，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2 月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 <code>Web 2.0</code> 时代的来临。</li><li> 2006 年，<code>jQuery</code> 函数库诞生，作者为 John Resig。jQuery 为操作网页 <code>DOM</code> 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。</li><li> 2008 年，<code>V8</code> 编译器诞生.</li><li> 2009 年，<code>Node.js</code> 项目诞生，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于 <code>服务器端编程</code>，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。</li><li> 2013 年 5 月，Facebook 发布 UI 框架库 <code>React</code>，引入了新的 <code>JSX</code> 语法，使得 UI 层可以用组件开发。</li><li> 2015 年 3 月，Facebook 公司发布了 <code>React Native</code> 项目，将 React 框架移植到了手机端，可以用来开发手机 <code>App</code>。它会将 JavaScript 代码转为 <code>iOS</code> 平台的 <code>Objective-C</code> 代码，或者 <code>Android</code> 平台的 <code>Java</code> 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。</li><li> 2015 年 <code>vuejs</code> 发布 1.0 版本</li><li> 2016 年 <code>vuejs2.x</code> 版本发布</li><li> 新生事物仍在不断涌现…</li></ol></blockquote><p>上面就是前端的大概发展史，看完之后，不难发现，有一些关键的历史时刻，对前端开发产生了重大影响。例如 IE6 的发布（统治了浏览器市场很多年），JQuery 的诞生，Ajax 的流行。而现在，新的拐点出现了 – nodejs 的流行。现代前端仍然在快速发展中，前后端分离，SSR，PWA 都是近两年才出现的概念。如果没有上车，后面就再难追上了。例如像十年前不使用 Spring 开发的应用，在现代 Java Web 后端的环境中，没有 Spring 简直寸步难行。</p><p>上面说了一些现代前端的历史，那么使用它具体有什么好处呢？</p><h3 id="JavaScript-模块化"><a href="#JavaScript-模块化" class="headerlink" title="JavaScript 模块化"></a>JavaScript 模块化</h3><p>仔细想想，我们的 HTML, CSS 和 JavaScript 是如何结合使用的？</p><p>是的，我们按照规范分离了 HTML, CSS 和 JavaScript，并在 HTML 中使用 <code>&lt;link /&gt;</code> 和 <code>&lt;scirpt&gt;&lt;/script&gt;</code> 标签引入 CSS 和 JavaScript。那么，不同的 JavaScript 之间如何交互呢？我们只能通过暴露顶级变量（<code>window 作用域</code>）来进行交互。<br>是呀，稍有经验的 JavaScript 开发者都会 <strong>抽取函数</strong>，然而一个 JavaScript 中太多的函数仍然容易产生混乱。</p><p>例如下面这段代码，点击不同的按钮，显示不同的面板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 避免使用 if-else<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tab&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第一个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第二个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第三个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;extends-form&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/if-else.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js/if-else.js</span><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> index = el.dataset.index;<br>    <span class="hljs-keyword">const</span> header = el.parentElement.innerText.trim();<br>    <span class="hljs-comment">// 如果为 1 就添加一个文本表单</span><br>    <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">              &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">              &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">          `</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>          fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>            resolve(event.target.result);<br>          &#125;;<br>          fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            reject(error);<br>          &#125;;<br>          fr.readAsDataURL(file);<br>        &#125;);<br>      &#125;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (!file) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>        &#125;);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;3&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">          &lt;ul id=&quot;search-result&quot;&gt;&lt;/ul&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>      <span class="hljs-built_in">document</span><br>        .querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>)<br>        .addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> searchText = event.target.value;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>            .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>            .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>            .join();<br>        &#125;);<br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用现代前端的 JavaScript 模块化重构如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// common.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 状态机</span><br><span class="hljs-comment"> * 用于避免使用 if-else 的一种方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateMachine</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getBuilder</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> clazzMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态注册器</span><br><span class="hljs-comment">     * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>      <span class="hljs-comment">// noinspection JSMethodCanBeStatic</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 注册一个 class，创建子类时调用，用于记录每一个 [状态 =&gt; 子类] 对应</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param </span>state 作为键的状态</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param </span>clazz 对应的子类型</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;*&#125;</span> </span>返回 clazz 本身</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">state, clazz</span>)</span> &#123;<br>        clazzMap.set(state, clazz)<br>        <span class="hljs-keyword">return</span> clazz<br>      &#125;<br><br>      <span class="hljs-comment">// noinspection JSMethodCanBeStatic</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 获取一个标签子类对象</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>state 状态索引</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;QuestionType&#125;</span> </span>子类对象</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params">state</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> clazz = clazzMap.get(state)<br>        <span class="hljs-keyword">if</span> (!clazz) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>        <span class="hljs-comment">//构造函数的参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> clazz(...Array.from(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>))<br>      &#125;<br>    &#125;()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> StateMachine<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// TabBuilder.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> StateMachine.getBuilder();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Tab.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-comment">// 基类里面的初始化方法放一些通用的操作</span><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.initHTML()&#125;</span></span><br><span class="hljs-string">    `</span>;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = html;<br>  &#125;<br><br>  <span class="hljs-comment">// 给出一个方法让子类实现，以获得不同的 HTML 内容</span><br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Tab;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Tab1.js</span><br><span class="hljs-keyword">import</span> builder <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TabBuilder.js&quot;</span>;<br><span class="hljs-keyword">import</span> Tab <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Tab&quot;</span>;<br><br><span class="hljs-keyword">const</span> Tab1 = builder.register(<br>  <span class="hljs-number">1</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-comment">// 实现 initHTML，获得选项卡对应的 HTML</span><br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>    &#125;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Tab2.js</span><br><span class="hljs-keyword">import</span> builder <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TabBuilder.js&quot;</span>;<br><span class="hljs-keyword">import</span> Tab <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Tab&quot;</span>;<br><br><span class="hljs-keyword">const</span> Tab2 = builder.register(<br>  <span class="hljs-number">2</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重写 init 初始化方法，并首先调用基类通用初始化的方法</span><br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>.init(header);<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (!file) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>        &#125;);<br>      &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 子类独有方法</span><br>    <span class="hljs-function"><span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>        fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>          resolve(event.target.result);<br>        &#125;;<br>        fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>          reject(error);<br>        &#125;;<br>        fr.readAsDataURL(file);<br>      &#125;);<br>    &#125;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Tab2.js</span><br><span class="hljs-keyword">import</span> builder <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TabBuilder.js&quot;</span>;<br><span class="hljs-keyword">import</span> Tab <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Tab&quot;</span>;<br><br><span class="hljs-keyword">const</span> Tab3 = builder.register(<br>  <span class="hljs-number">3</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">        &lt;ul id=&quot;search-result&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>.init(header);<br>      <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>      <span class="hljs-built_in">document</span><br>        .querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>)<br>        .addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> searchText = event.target.value;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>            .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>            .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>            .join();<br>        &#125;);<br>    &#125;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> builder <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TabBuilder.js&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Tab1&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Tab2&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./Tab3&quot;</span>;<br><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span><br>    <span class="hljs-comment">// 调用方式不变</span><br>    builder<br>      .getInstance(<span class="hljs-built_in">Number</span>.parseInt(el.dataset.index))<br>      .init(el.parentElement.innerText.trim())<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>虽然看起来代码/文件变得更多了，然而实际上不同的状态区分更加明显，代码也更容易维护了。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>如果我们想要让传统前端项目兼容 <code>IE11</code>，那么恐怕不得不使用 <code>JQuery</code> 以及 <code>ES5</code> 以前的语法（ES5 也支持的不完全）。如果想要使用 <code>ES6/ES7/ES8</code> 的话恐怕不仅在 IE11 上无法保证兼容性，既便 Web 标准的前沿实现者 Google Chrome，它的旧版本对新特性的支持恐怕也不算好（Google Chrome 开发团队的实力毋庸置疑，然而如果一个标准是在浏览器发布之后才出现的话，旧版本浏览器却是不可能兼容了）。</p><blockquote><p>附: 最近两年 JavaScript 的标准几乎是一年一个版本，不过都没有再像 <code>ES6</code> 如此激进了</p></blockquote><p>那么，如果使用现代前端就能解决这个问题了么？是的，它现代前端项目基本上都会引入的一个库 – <a href="https://babeljs.io/">Babel</a>。</p><p>Babel 官网首页用一句话说明了 Babel 的定位</p><blockquote><p>Babel is a JavaScript compiler.<br>Use next generation JavaScript, today.</p></blockquote><p>意为：<br><strong>Babel 是一个 JavaScript 编译器。</strong><br><strong>立刻使用下一代 JavaScript。</strong></p><p>是的，你没听错，Babel 给自身的定义是 JavaScript 编译器。众所周知，JavaScript 是运行在浏览器上（现在也可以运行在 NodeJS）的解释型弱类型的脚本语言，是没有编译器的。而 Babel 就是帮我们将 ES6 之后的 JavaScript 代码编译成 ES5 的代码，以兼容较旧版本的浏览器。</p><p>例如下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  (<span class="hljs-function">(<span class="hljs-params">_i</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(_i), <span class="hljs-number">0</span>);<br>    i = _i;<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，传统前端不能使用 Babel 了么？答案是可以的，然而因为是在浏览器端编译 JavaScript，所以速度比较慢，具体可以参考吾辈写的 <a href="https://blog.rxliuli.com/p/e73e3322/">在传统项目中使用 babel 编译 ES6</a>。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p><a href="https://zh.wikipedia.org/zh-cn/MVVM">Wiki</a></p></blockquote><p><code>MVVM</code>（<code>Model–view–viewmodel</code>）是一种软件架构模式。</p><p>MVVM 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或 GUI 代码实现的。MVVM 的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。</p><p>说人话就是 MVVM 能让我们不再关心 DOM 的更改，专注于操作数据，DOM 会根据数据自动渲染，我们不再需要关心它。</p><p>事实上，我们的不同的代码虽然分离了，但逻辑上却不然，JavaScript 仍然需要操作 DOM 和 Style，而这项工作是非常繁琐而且易错的。<br>曾经我们使用 JQuery 来进行 DOM 交互，同时保证兼容性，以及更好的 Ajax 工具。现在，现代前端的很多框架就是为了解决数据与 DOM 同步的，不管是 <code>React</code> 的 <code>JSX</code>，还是 <code>VueJS</code> 的 <code>单文件组件</code>。</p><p><code>JSX</code>：React 的理念是 既然 JavaScript 能够操作 HTML/CSS，那就把所有的控制权交给 JavaScript 就好了，在 React JSX 中，一切都是 JavaScript，即便是 JSX 的 DSL 也只是一个看起来像 HTML 的 JavaScript 代码而已。像下面的代码，事实上就是 JavaScript，直接写 <code>&lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;</code> 只是语法糖，背后真正运行的还是 JavaScript。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloMessage</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Taylor&quot;</span> /&gt;</span></span>, mountNode);<br></code></pre></td></tr></table></figure><p>假如使用 vuejs 的话写起来大概是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vuejs">&lt;template&gt;<br>  &lt;div&gt;Hello &#123;name&#125;&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#39;HelloWord&#39;,<br>  props: &#123;<br>    name: &#123;<br>      type: String<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> HelloMessage <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./HelloMessage&quot;</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&quot;#app&quot;</span>,<br>  components: &#123; HelloMessage &#125;,<br>  template: <span class="hljs-string">&quot;&lt;App/&gt;&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>它们之间的思想有许多共同之处，都推崇组件化开发，把 <code>HTML/CSS/JavaScript</code> 混合起来形成组件（类似于 Java 中将属性和函数封装为类），然后组合成更大的组件，形成组件树，并最终构成 WebApp。吾辈目前推荐先看 VueJS，毕竟是国人开发，中文文档最为完善，在三大前端框架中也属于最简单的一个（ReactJS 是最困难也是生态最好的一个）。</p><h3 id="生态丰富"><a href="#生态丰富" class="headerlink" title="生态丰富"></a>生态丰富</h3><p>NPM 的生态相当丰富，现代前端几乎所有的库都通过 NPM 发布。至今，NPM 上已经有超过 70W+ 的包，在数量上甚至远超了 Maven 中央仓库。正是因为 NPM 发布包相当简单（吾辈都发布了几个），造成了如今无比繁荣的生态（想想 Maven 感觉都是泪。。。）</p><blockquote><p>包管理器对比数据可以参考 <a href="http://www.modulecounts.com/">http://www.modulecounts.com/</a></p></blockquote><p>使用 NPM 安装和使用包相当简单，使用 <code>npm i [package]</code> 就能直接安装一个包，使用 ES6 <code>import</code> 语法就能在自己的 JavaScript 文件中快速引用一个包。</p><p>下面列出一些常用的 NPM 库</p><ul><li><a href="https://yarnpkg.com/">yarn</a>: Facebook 家的前端包管理器</li><li><a href="https://babeljs.io/">babel</a>: 现代前端的 JQuery，解决兼容性</li><li><a href="https://vuejs.org/">vuejs</a>: 华人开发的前端 MVVM 框架</li><li><a href="http://stylus-lang.com/">stylus</a>: CSS 预处理器</li><li><a href="https://eslint.org/">eslint</a>: 前端代码规范检查</li><li><a href="https://webpack.js.org/">webpack</a>: 现代前端必备的打包工具</li><li><a href="https://www.rollupjs.com/">rollup</a>: JavaScript SDK 打包工具</li><li><a href="https://lodash.com/">lodashjs</a>: 流行的函数式工具库</li><li><a href="https://www.axios.com/">axios</a>: 符合 ES6 Promise 风格的 Ajax 库</li><li><a href="https://vuetifyjs.com/">vuetify</a>: 基于 vuejs 的前端 <code>material</code> 风格的 UI 库</li><li><a href="https://github.com/SheetJS/js-xlsx">js-xlsx</a>: 前端 Excel 处理工具</li><li><a href="https://www.npmjs.com/package/debug">debug</a>: debug 日志辅助工具</li><li><a href="https://www.npmjs.com/package/uglify-js">uglifyjs</a>: JavaScript 压缩工具</li><li><a href="https://www.npmjs.com/package/http-server">http-server</a>: 静态 http 服务器</li><li><a href="https://hexo.io/">hexo</a>: 现代前端开发的博客系统</li><li><a href="https://www.highcharts.com/">highcharts</a>: 丰富强大的图表库</li><li><a href="https://masonry.desandro.com/">masonry</a>: 无限滚动瀑布流</li><li><a href="https://highlightjs.org/">highlightjs</a>: 代码高亮</li><li><a href="https://www.npmjs.com/package/rx-util">rx-util</a>: 写 Greasemonkey 脚本时自定义的工具库</li><li>还有更多。。。</li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p>现代前端已经和后端类似，将原本混沌的 HTML/CSS/JavaScript 细分为了许多的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">├── dist <span class="hljs-comment">// 打包后的静态文件</span><br>├── .editorconfig <span class="hljs-comment">// 编辑器配置</span><br>├── .eslintrc.js <span class="hljs-comment">// eslint 配置格式</span><br>├── .git <span class="hljs-comment">// git 仓库</span><br>├── .gitignore <span class="hljs-comment">// git 忽略文件</span><br>├── babel.config.js <span class="hljs-comment">// babel 配置</span><br>├── LICENSE <span class="hljs-comment">// 许可证</span><br>├── node_module <span class="hljs-comment">// 项目依赖</span><br>├── package.json <span class="hljs-comment">// npm 定义文件</span><br>├── public <span class="hljs-comment">// 一些公共的资源</span><br>│   ├── favicon.ico<br>│   └── index.html<br>├── README.md <span class="hljs-comment">// 项目说明</span><br>├── src <span class="hljs-comment">// 源代码目录</span><br>│   ├── App.vue <span class="hljs-comment">// 根组件</span><br>│   ├── main.js <span class="hljs-comment">// 项目入口</span><br>│   ├── api <span class="hljs-comment">// api 接口，和 views 中的文件夹对应</span><br>│   ├── components <span class="hljs-comment">// 公共的组件</span><br>│   ├── plugins <span class="hljs-comment">// vuejs 插件</span><br>│   │   └── vuetify.js<br>│   ├── router <span class="hljs-comment">// vuejs 路由管理</span><br>│   │   └── index.js<br>│   ├── store <span class="hljs-comment">// vuejs 状态管理</span><br>│   │   └── index.js<br>│   ├── utils <span class="hljs-comment">// 工具函数</span><br>│   └── views <span class="hljs-comment">// 各个页面</span><br>├── tests<br>│   └── unit <span class="hljs-comment">// 单元测试</span><br>│       ├── .eslintrc.js<br>│       └── example.spec.js<br>├── vue.config.js <span class="hljs-comment">// vuejs 的配置</span><br>└── yarn.lock <span class="hljs-comment">// yarn 配置文件</span><br></code></pre></td></tr></table></figure><p>当初第一次看到这个目录时真是被吓到了，使用 <code>yarn</code> 一下子 20000 个依赖文件就下载下来了。然而其实这只是将传统前端分的更细一点而已，对后期维护的好处也是不言而喻的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，现代前端流行之后，前后端分离已然是大势所趋，前端开发如果还仅仅是 <strong>切图仔</strong> 的话，迟早会因为跟不上时代而被淘汰。就吾辈而言，亦希望有更多人入坑现代前端，体会现代前端的强大!</p><blockquote><p>附：吾辈个人而言认为现代前端主要的优势 <a href="#JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96">模块化</a>/<a href="%E5%B7%A5%E7%A8%8B%E5%8C%96">工程化</a> 和 <a href="#MVVM">MVVM</a>。前者使大型 WebApp 的开发变成可能，后者则改变了数据与 DOM 之间的交互方式。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2018 React Redux 入门教程</title>
    <link href="/p/b3d6d618a14348a5aa2542fcdf0a308a/"/>
    <url>/p/b3d6d618a14348a5aa2542fcdf0a308a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吾辈已转 mobx，放弃使用 redux 了。<br><a href="http://www.superbug.me/2018/02/06/react-redux-tutorial-for-beginners-learning-redux-in-2018/">译文链接</a>, <a href="https://www.codementor.io/valentino/react-redux-tutorial-for-beginners-learning-redux-in-2018-fek71ojgh">原文链接</a><br>老实说学习 Redux 真的很有挫败感，虽然 Redux 的源码很小（&lt; 2kb），然而其文档却庞大无比，老实说让人害怕！即便吾辈看了阮一峰写的 <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">Redux 入门教程</a>，然而还是在第二篇就 GG 了。纵然了解了概念，然而却不知如何使用，便是如此了。。。这篇翻译过来的教程吾辈感觉还不错，所以也便是转发一下好啦<br>吾辈也跟着教程写了一个 <a href="https://github.com/rxliuli/react-start/tree/dev/src/components/redux">Redux Demo</a>，仅供参考。</p></blockquote><p>我希望这是学习 React Redux 最简单的入门教程。</p><p>我一开始学习 Redux 的时候我想找到最浅显易懂的入门教程。</p><p>尽管有大量的资源，但是我对于 Redux 的一些概念依旧搞不清楚。</p><p>我知道什么是 state ，但是 actions， action creators 和 reducers 又是什么鬼？我被搞晕掉了。</p><p>然后我也搞不明白 React 和 Redux 是怎样结合起来的。</p><p>前端时间开始着手写 React Redux 教程的过程中我理解了许多。</p><p>我通过写这篇教程自学 Redux 的基本概念。我也希望这可以帮助所有正在学习 React 和 Redux 的人。</p><h2 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h2><p>如果满足下列条件，那么本教程正是你要找的：</p><ul><li>良好的 Javascript, ES6, React 基础</li><li>你希望以最简单的方式学习 Redux</li></ul><h2 id="你可以学到什么"><a href="#你可以学到什么" class="headerlink" title="你可以学到什么"></a>你可以学到什么</h2><p>通过这篇教程你可以学到：</p><ul><li>Redux 是什么</li><li>怎样结合 React 使用 Redux</li></ul><h2 id="搭建-React-开发环境"><a href="#搭建-React-开发环境" class="headerlink" title="搭建 React 开发环境"></a>搭建 React 开发环境</h2><p>看这篇教程你需要有扎实的 Javascript, ES6, React 基础。</p><p>开始之前，让我们来简单搭建一个 React 开发环境。</p><p>你可以选择 webpack 3 或者 Parcel。</p><p>如果选用 Parcel 你可以参考这个链接 Setting up React with Parcel ，或者从我的 Github 上克隆仓库：</p><p>git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:valentinogagliardi/minimal-react-parcel.git</p><p>如果你想用 webpack 3 可以参考这个教程 How to set up React, Webpack 3, and Babel ，或者从我的 Github 上克隆仓库：</p><p><code>git clone git@github.com:valentinogagliardi/minimal-react-webpack.git</code></p><h2 id="什么是-state-？"><a href="#什么是-state-？" class="headerlink" title="什么是 state ？"></a>什么是 state ？</h2><p>理解 Redux 之前你首先需要理解什么是 state 。</p><p>如果你曾经写过 React 的 state , 应该不足为奇。</p><p>我猜你应该写过如下的 React 状态组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      articles: [<br>        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;React Redux Tutorial for Beginners&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;,<br>        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Redux e React: cos&#x27;è Redux e come usarlo con React&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> &#125;,<br>      ],<br>    &#125;;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; articles &#125; = <span class="hljs-built_in">this</span>.state;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;ul&gt;<br>        &#123;articles.map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> (<br>          &lt;li key=&#123;el.id&#125;&gt;&#123;el.title&#125;&lt;/li&gt;<br>        ))&#125;<br>      &lt;/ul&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述组件是基于 Javascript ES6 class 的。</p><p>每个 React 状态组件持有自己的 state 。在 React 中 state 持有数据。组件渲染这组数据展示给用户。</p><p>React 提供了一个 setState 方法来更新组件内部的 state 。</p><p>我们通常这么用：</p><ol><li> 从组件内部持有的 state 中获取数据渲染</li><li> 通过 React 的 setState 方法更新 state</li></ol><h2 id="Redux-解决了什么问题-？"><a href="#Redux-解决了什么问题-？" class="headerlink" title="Redux 解决了什么问题 ？"></a>Redux 解决了什么问题 ？</h2><p>应用规模比较小的时候，在 React 组件内部维护 state 很方便。</p><p>但在复杂一点的业务场景下这么做就不太合适了。组件中会填满各种管理更新 state 的方法，臃肿不堪。前端不应该知道业务逻辑。</p><p>那么，有没有其它管理 state 的方式呢？Redux 就是其中的一个解决方案。</p><p>Redux 解决了一开始我们可能还不太清楚的问题：它为每一个 React 组件明确提供它所需要的 state 。</p><p>Redux 统一在一个地方维护 state 。</p><p>通过 Redux ，获取和管理 state 的逻辑也和 React 隔离开来。</p><p>这中方式的好处可能还不太明显。当你用上它后就会发现它的威力。</p><p>下一节内容我们聊一下为什么以及什么时候我们需要用 Redux。</p><h2 id="我要学-Redux-么-？"><a href="#我要学-Redux-么-？" class="headerlink" title="我要学 Redux 么 ？"></a>我要学 Redux 么 ？</h2><p>想学习 Redux 但是没搞定？</p><p>Redux 的确吓坏了许多初学者。但是不必因此而感到担心。</p><p>Redux 没有那么难。关键是：不要随波逐流地去使用它。</p><p>你开始学习 Redux 应该是出于自发的动机和热情。</p><p>我学习 Redux 是因为：</p><p>我 100% 地渴望知道 Redux 是怎么工作的<br>我想要提升我的 React 技能<br>我想成为更牛 X 的 React 开发者<br>React/Redux 当下是黄金组合<br>Redux 是一种思想，它和框架无关。学习了它可以在任何地方（比如 Vue JS，Angular 中）使用。</p><h2 id="我要用-Redux-么-？"><a href="#我要用-Redux-么-？" class="headerlink" title="我要用 Redux 么 ？"></a>我要用 Redux 么 ？</h2><p>没有 Redux 构建复杂的 React 应用也是可行的。只是有一些成本。</p><p>用 Redux 也是有一定成本的：它加入了另外一个抽象层。但是我我认为是利大于弊的。</p><p>另一个困惑初学者的问题是：我怎么判断什么时候我需要使用 Redux 呢？</p><p>如果你没有经验判定是否需要用 Redux 来管理 state ，我有如下建议使用的场景：</p><p>多个 React 组件需要访问同一个 state 但是又没有父子关系<br>需要通过 props 向下向多个组件传递 state</p><p>如果还是找不到感觉，别怕，我也一样。</p><p>Dan Abramov 说过『 Flux 就像眼镜：你需要的时候你自然会知道 』。</p><p>事实上对于我而言也正是如此。</p><p>Dan Abramov 写了篇很棒的文章来帮助我们理解： Redux 的使用场景</p><p>dev.to 上也有一篇 Dan 关于这一问题的 讨论</p><p>看一下 Mark Erikson 整理的 Redux 学习资源</p><p>顺便说下，Mark 的博客被视为 Redux 的最佳实践</p><p>Dave Ceddia 也分享过关于 Redux 干了什么？以及它的使用场景 的话题。</p><p>在深入学习之前，花些时间去搞明白 Redux 解决了什么问题。然后再决定要不要学。</p><p>要清楚在小型的应用中使用 Redux 没什么好处。只有在大型应用下才能发挥它的威力。但不管如此，学习 Redux 解决问题的思路总不是什么坏事。</p><p>下一节，我们介绍一下内容：</p><p>Redux 的基本原则<br>Redux 和 React 怎么结合</p><h2 id="了解-Redux-store"><a href="#了解-Redux-store" class="headerlink" title="了解 Redux store"></a>了解 Redux store</h2><p>Actions， Reducers 我都知道。但有件事我搞不明白：这些动态的片段是怎么结合到一起的？</p><p>有小黄人相助不成？</p><p>是 store 把所有流动的片段协调地结合到 Redux 中。在 Redux 中 store 就像人类的大脑：这是种魔法。</p><p>Redux store 是一切的基础：整个应用的 state 都在 store 中维护。</p><p>如果我们把 Redux 的工作模式想象成人类的大脑。 state 就相当于存在于大脑（store）中的一段回忆。</p><p>所以开始使用 Redux 的时候我们需要创建一个 store 来存放 state。</p><p>切换到你的开发目录，安装 Redux：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> minimal-react-webpack/<br><br>npm i redux --save-dev<br></code></pre></td></tr></table></figure><p>创建一个目录来存放 store 相关逻辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir -p src/js/store<br></code></pre></td></tr></table></figure><p>在 src/js/store 中创建 index.js 并初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/store/index.js</span><br><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br><span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../reducers/index&quot;</span>;<br><br><span class="hljs-keyword">const</span> store = createStore(rootReducer);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>createStore 就是创建 Redux store 的方法。</p><p>createStore 接收一个 reducer 作为第一个参数，就是代码中的 rootReducer。</p><p>你也可以传递一个初始 state 进 createStore。 但是大多数时候你不必这么做。传递初始 state 在服务端渲染时比较有用。当然，state 来自 reducers。</p><p>现在我们知道 reducer 做了啥了。reducer 生成了 state 。 state 并不是手动创建的。</p><p>带着这些概念我们继续我们第一个 Redux reducer。</p><h2 id="了解-Redux-reducers"><a href="#了解-Redux-reducers" class="headerlink" title="了解 Redux reducers"></a>了解 Redux reducers</h2><p>初始 state 在 服务端渲染 中很有用，它必须完全从 reducers 中产生。</p><p>reducer 是个什么鬼？</p><p>reducer 就是个 javascript 函数。它接收两个参数：当前的 state 和 action 。</p><p>Redux 的第三条原则中强调：state 必须是不可变的。这也是为什么 reducer 必须是一个纯函数。纯函数就是指给有明确的输入输出的函数。</p><p>在传统的 React 应用中我们通过 setState 方法来改变 state 。 在 Redux 中不可以这么做。</p><p>创建一个 reducer 不难，就是个包含两个参数的 javascript 普通函数。</p><p>在我们的例子中，我们将创建一个简单的 reducer， 并向他传递初始 state 作为第一个参数。第二个参数我们将提供一个 action 。到目前为止 reducer 除了返回初始状态什么都不会做。</p><p>创建 reducer 根目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir -p src/js/reducers<br></code></pre></td></tr></table></figure><p>然后在 src/js/reducers 创建一个名为 index.js 的新文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/reducers/index.js</span><br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  articles: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> state;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;<br></code></pre></td></tr></table></figure><p>我承诺这是篇尽可能简明的教程。所以我们仅有一个 reducer ：它除了返回初始 state 什么都不处理。</p><p>注意下初始 state 是怎样作为 默认参数 传递的。</p><p>下一节我们将结合一个 action 来让这个应用更加有趣。</p><h2 id="了解-Redux-actions"><a href="#了解-Redux-actions" class="headerlink" title="了解 Redux actions"></a>了解 Redux actions</h2><p>reducers 无疑是 Redux 中最重要的概念。reducers 用来生产应用的 state 。</p><p>但是 reducers 怎么知道什么时候去生产下一个 state 呢？</p><p>Redux 的第二条原则中说：改变 state 的唯一方式就是向 store 发送一个信号 。 这个 信号 指的就是 action 。</p><p>怎么改变这个不可更改的状态呢？你不能。返回的 state 是当前 state 的副本结合新数据后的一个全新的 state 。这点必须要明确。</p><p>比较欣慰的是 actions 就是简单的 javascript 对象。它长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">type: ‘ADD_ARTICLE’,<br><br>payload: &#123; <span class="hljs-attr">name</span>: ‘React Redux Tutorial <span class="hljs-keyword">for</span> Beginners’, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><p>每一个 action 都要有一个 type 属性来描述要对 state 做怎样的改变。</p><p>你也可以指定一个叫 payload 的属性。在上面的例子中， payload 指代一篇新的文章。reducer 接下来将把这篇新文章加到 state 中去。</p><p>最佳实践是将每一个 action 都通过函数包裹起来。这个函数就是 action creator。</p><p>让我们来把这些都串起来创建一个简单的 action 。</p><p>创建 actions 目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir -p src/js/actions<br></code></pre></td></tr></table></figure><p>在 src/js/actions 目录中创建名为 index.js 的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/actions/index.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addArticle = <span class="hljs-function">(<span class="hljs-params">article</span>) =&gt;</span> (&#123;<br>  type: <span class="hljs-string">&quot;ADD_ARTICLE&quot;</span>,<br>  payload: article,<br>&#125;);<br></code></pre></td></tr></table></figure><p>type 属性就是个简单的字符串。reducer 将根据这个字符串决定怎么处理生成下一个 state 。</p><p>由于字符串很容易重复产生冲突，所以最好在常量中统一定义 action types 。</p><p>这个方法可以避免一些很难排查的错误。</p><p>创建一个新目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir -p src/js/constants<br></code></pre></td></tr></table></figure><p>然后在 src/js/constants 目录下创建名为 action-types.js 的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/constants/action-types.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_ARTICLE = <span class="hljs-string">&quot;ADD_ARTICLE&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后打开 src/js/actions/index.js 用常量来替换字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/actions/index.js</span><br><br><span class="hljs-keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants/action-types&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addArticle = <span class="hljs-function">(<span class="hljs-params">article</span>) =&gt;</span> (&#123;<br>  type: ADD_ARTICLE,<br><br>  payload: article,<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们进一步完成了一个可运行的 Redux 应用。 接下来让我们重构下我们的 reducer 吧！</p><h2 id="重构-reducer"><a href="#重构-reducer" class="headerlink" title="重构 reducer"></a>重构 reducer</h2><p>进入下一步之前，让我们总结一下 Redux 的主要概念：</p><p>Redux store 就像大脑：它负责将所有流动的片段有机地整合进 Redux 中<br>应用中的 state 在 store 中以唯一且不可变对象的形式存在<br>一旦 store 接收到一个 action 他就会触发一个 reducer<br>reducer 返回下一个 state</p><p>reducer 是怎样构成的？</p><p>reducer 是一个 javascript 函数，它接收两个参数：state 和 action。</p><p>reducer 一般会包含一个 switch 语句（傻一点的话也可以用：if /else）。</p><p>reducer 根据 action type 产生下一个 state 。此外，当没有匹配到 action type 时它至少也要返回初始 state 。</p><p>当 action type 匹配到一个 case 分支的时候， reducer 将计算下一个 state 并返回一个全新的对象。下面是个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// …</span><br><br><span class="hljs-keyword">switch</span> (action.type) &#123;<br>  <span class="hljs-keyword">case</span> ADD_ARTICLE:<br>    <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">articles</span>: [...state.articles, action.payload] &#125;;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-comment">// …</span><br></code></pre></td></tr></table></figure><p>我们之前创建的 reducer 只返回了初始 state 什么都没做。让我们做点什么。</p><p>打开 src/js/reducers/index.js 按如下例子更新 reducer:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants/action-types&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  articles: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> ADD_ARTICLE:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">articles</span>: state.articles.push(action.payload) &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;<br></code></pre></td></tr></table></figure><p>发现了什么？</p><p>尽管代码逻辑没有错，但这违背了 Redux 的主要原则： 不可变 。</p><p><code>Array.prototype.push</code> 不是一个纯函数，它改变了原来的数组。</p><p>解决的方式很简单。用 <code>Array.prototype.concat</code> 替换 <code>Array.prototype.push</code> 来保持原始数组是不可变的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants/action-types&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  articles: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> ADD_ARTICLE:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">articles</span>: state.articles.concat(action.payload) &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;<br></code></pre></td></tr></table></figure><p>还不够！可以用 扩展运算符 优化一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ADD_ARTICLE &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../constants/action-types&quot;</span>;<br><br><span class="hljs-keyword">const</span> initialState = &#123;<br>  articles: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> ADD_ARTICLE:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">articles</span>: [...state.articles, action.payload] &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;<br></code></pre></td></tr></table></figure><p>上述例子中初始 state 完全没受干扰。</p><p>最初的文章数组并没有改变。</p><p>初始 state 对象也没有改变。返回的 state 是初始 state 的一个副本。</p><p>在 Redux 中有两个关键点来防止类似的改变。</p><p>针对数组可以用 concat (), slice (), 和 … 操作符<br>针对对象可以用 Object.assign () and … 操作符</p><p>扩展运算符 在 webpack 3 中还是个实验性功能。需要安装一个 babel 插件来防止语法错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i —save-dev babel-plugin-transform-object-rest-spread<br></code></pre></td></tr></table></figure><p>打开 .babelrc 更改配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-string">&quot;react&quot;</span>],<br>  <span class="hljs-attr">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;transform-object-rest-spread&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>小贴士： reducer 随着应用的增长会变得臃肿。你可以拆分 reducer 进不同的函数，然后通过 combineReducers 将他们结合起来。</p><p>下一节我们将通过 console 控制台把玩一下 Redux 。搞起！</p><h2 id="Redux-store-中的方法"><a href="#Redux-store-中的方法" class="headerlink" title="Redux store 中的方法"></a>Redux store 中的方法</h2><p>这节内容将会很快过完，我保证。</p><p>我想借助浏览器的控制台让你快速理解下 Redux 是怎样工作的。</p><p>Redux 本身是一个很小的类库 （2KB）。它暴露了 一些简单的 API 让我们来管理 state 。其中最重要的方法就是：</p><ul><li>getState 用于获取应用的 state</li><li>dispatch 用于触发一个 action</li><li>subscribe 用于监听 state 的变化</li></ul><p>我们将借助浏览器的管理控制台试验上述方法。</p><p>我们需要创建全局变量将我们先前创建的 store 和 action 暴露出来。</p><p>打开 src/js/index.js 按如下所示更新代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../js/store/index&quot;</span>;<br><br><span class="hljs-keyword">import</span> &#123; addArticle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../js/actions/index&quot;</span>;<br><br><span class="hljs-built_in">window</span>.store = store;<br><br><span class="hljs-built_in">window</span>.addArticle = addArticle;<br></code></pre></td></tr></table></figure><p>然后运行一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm start<br></code></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/">http://localhost:8080/</a> 并按 F12 打开管理控制台。</p><p>由于我们全局暴露了 store ， 所以我们可以进入它的方法。试一下！</p><p>首先访问当前 state:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">store.getState();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&#123;articles: Array(0)&#125;<br></code></pre></td></tr></table></figure><p>没有文章。事实上我们还没有更新初始 state 。</p><p>让这变得更有趣些我们可以通过 subscribe 方法监听 state 的变化。</p><p>subscribe 方法接收一个回调函数，当 action 触发的时候该回调函数就会执行。触发 action 就意味着通知 store 我们想改变 state 。</p><p>通过如下操作注册回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">store.subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Look ma, Redux!!&quot;</span>));<br></code></pre></td></tr></table></figure><p>要想改变 state 我们需要触发一个 action 。要触发一个 action 我们就需要调用 dispatch 方法 。</p><p>我们已经有了一个 action ：addArticle 用来向 state 中新增文章。</p><p>让我们触发一下这个 action ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">store.dispatch( addArticle(&#123; <span class="hljs-attr">name</span>: ‘React Redux Tutorial <span class="hljs-keyword">for</span> Beginners’, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;))<br></code></pre></td></tr></table></figure><p>执行上述代码后你将看到：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Look ma, Redux!!<br></code></pre></td></tr></table></figure><p>验证一下 state 有没有变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">store.getState();<br></code></pre></td></tr></table></figure><p>输出会是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">&#123;articles: Array(1)&#125;<br></code></pre></td></tr></table></figure><p>这就是个最简单的 Redux 原型。</p><p>难么？</p><p>稍微花点时间练习一下 Redux 的三个方法。在控制台中玩一把：</p><ul><li>getState 用于获取应用的 state</li><li>dispatch 用于触发一个 action</li><li>subscribe 用于监听 state 的变化</li></ul><p>这就是开始入坑所需要知道的全部内容。</p><p>有信心进入下一步了么？让我们把 React 和 Redux 串起来吧。</p><h2 id="把-React-和-Redux-结合起来"><a href="#把-React-和-Redux-结合起来" class="headerlink" title="把 React 和 Redux 结合起来"></a>把 React 和 Redux 结合起来</h2><p>学习了 Redux 后我发现它并没有想象中那么复杂。</p><p>我知道我可以通过 getState 方法获取当前 state ；通过 dispatch 触发一个 action ； 通过 subscribe 监听 state 的变化。</p><p>目前我还不知道怎么将 React 和 Redux 组合起来使用。</p><p>我问自己：我需要在 React component 中调用 getState 方法么？ 在 React component 我怎么去触发 action ？ 等等一些列问题。</p><p>Redux 是框架无关的。你可以在纯 Javascript 中使用它。或者结合 Angular，Redux 一起使用。 有许多第三方库可以实现把 Redux 和任何你喜欢的框架结合起来使用。</p><p>对于 React 而言， react-redux 就是这么一个第三方库。</p><p>首先让我们通过下面的命令安装一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i react-redux —save-dev<br></code></pre></td></tr></table></figure><p>为了演示 React 和 Redux 是如何协同工作的，我们将构建一个超级简单的应用。这个应用由如下组件组成：</p><ul><li>一个 App 组件</li><li>一个展示文章的 List 组件</li><li>一个新增文章的 Form 组件</li></ul><p>（这是个玩具应用，仅仅用来展示文章列表，新增文章条目。但是可以算一个学习 Redux 不错的开端。）</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 是一个 React 和 Redux 绑定库。这个类库将 React 和 Redux 高效地连接起来。</p><p>react-redux 的 connect 方法做了什么呢？ 毫无疑问是将 React 的组件和 Redux 的 store 连接起来了。</p><p>你可以根据需要向 connect 方法传递两个或者三个参数。需要知道的最基本的东西就是：</p><ul><li>mapStateToProps 函数</li><li>mapDispatchToProps 函数</li></ul><p>react-redux 中 mapStateToProps 做了什么呢？就像它的名字一样：它将部分 Redux state 和 React 组件中的 Props 连接了起来。通过这层连接，React 组件就可以从 store 中获取它所需要的 state 了。</p><p>react-redux 中 mapDispatchToProps 又做了什么呢？和 mapStateToProps 类似，只不过它是连接的 actions 。它将 部分 Redux action 和 React 组件中的 Props 连接了起来。通过这层连接，React 组件就可以从触发 actions 了。</p><p>都清楚了么？如果没有，停下来重读一遍。我知道许多内容需要时间消化。我要着急，早晚会搞明白的。</p><p>接下来的部分我们就要大显生手了！</p><h2 id="App-组件-和-Redux-store"><a href="#App-组件-和-Redux-store" class="headerlink" title="App 组件 和 Redux store"></a>App 组件 和 Redux store</h2><p>我们知道 mapStateToProps 将部分 Redux state 和 React 组件中的 Props 连接了起来。你可能想问：连接 React 和 Redux 这么做就够了吗？不，还不够。</p><p>要连接 React 和 Redux 我们还要用到 Provider。</p><p>Provider 是 react-redux 提供的一个高阶组件。</p><p>直白地说，就是 Provider 将整个 React 应用封装起来，是它能够感知到整个 Redux store 的存在。</p><p>为什么这么做？我们知道在 Redux 中 store 管理着一切。React 必须通过 store 来访问 state ， 触发 actions 。</p><p>了解了以上这些，就打开 src/js/index.js ，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../js/store/index&quot;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../js/components/App&quot;</span>;<br>render(<br>  &lt;Provider store=&#123;store&#125;&gt;<br>    &lt;App /&gt;<br>  &lt;/Provider&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>看到没有？Provider 将整个应用包裹起来。并将 store 作为属性传入。</p><p>现在让我们创建一个 App 组件。没什么特别的：App 组件导入一个 List 组件并渲染。</p><p>创建一个目录来存放组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">mkdir -p src/js/components<br></code></pre></td></tr></table></figure><p>在 src/js/components 目录下创建名为 App.js 的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/components/App.js</span><br><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./List&quot;</span>;<br><br><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> Articles;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>花时间看下组件的构成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./List&quot;</span>;<br><br><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span></span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>然后继续创建 List 组件。</p><p>List 组件 和 Redux state</p><p>目前为止我们没做特殊的操作。</p><p>但是 List 组件需要和 Redux store 产生交互。</p><p>简单总结一下：连接 React 组件 和 Redux 的关键就是 connect 方法。</p><p>Connect 方法接收至少一个参数。</p><p>由于我们想让 List 获取文章列表，因此我们需要让 state.articles 和组件连接起来。怎么做呢？用 mapStateToProps 参数来实现。</p><p>在 src/js/components 目录下创建名为 List.js 的文件。写入如下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/components/List.js</span><br><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><br><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">articles</span>: state.articles &#125;;<br>&#125;;<br><span class="hljs-keyword">const</span> ConnectedList = <span class="hljs-function">(<span class="hljs-params">&#123; articles &#125;</span>) =&gt;</span> (<br>  &lt;ul className=<span class="hljs-string">&quot;list-group list-group-flush&quot;</span>&gt;<br>    &#123;articles.map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> (<br>      &lt;li className=<span class="hljs-string">&quot;list-group-item&quot;</span> key=&#123;el.id&#125;&gt;<br>        &#123;el.title&#125;<br>      &lt;/li&gt;<br>    ))&#125;<br>  &lt;/ul&gt;<br>);<br><span class="hljs-keyword">const</span> List = connect(mapStateToProps)(ConnectedList);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> List;<br></code></pre></td></tr></table></figure><p>List 组件接收一个名为 articles 的属性， 它是一个 articles 数组的副本。这个数组寄生于我们之前创建的 Redux state 内。它来自 reducer :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> initialState = &#123;<br>  articles: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> ADD_ARTICLE:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">articles</span>: [...state.articles, action.payload] &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后我们就可以用这个属性在 JSX 中生成一个文章列表了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  articles.map(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> (<br>    &lt;li className=<span class="hljs-string">&quot;list-group-item&quot;</span> key=&#123;el.id&#125;&gt;<br>      &#123;el.title&#125;<br>    &lt;/li&gt;<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小提示</strong> 可以用 React PropTypes 对属性进行校验。</p><p>最后组件被导出为 List。List 是无状态组件和 Redux store 连接之后的产物。</p><p>无状态组件没有内部 state 。数据是通过属性传入的。</p><p>依旧很困惑？我也是。理解 connect 的工作原理需要花点时间。别害怕，慢慢来。</p><p>我建议你停下来花点时间看下 connect 和 mapStateToProps 。</p><p>搞懂了我们就进入下一章的学习。</p><h2 id="Form-组件-和-Redux-actions"><a href="#Form-组件-和-Redux-actions" class="headerlink" title="Form 组件 和 Redux actions"></a>Form 组件 和 Redux actions</h2><p>Form 组件比 List 组件稍微复杂一点。它是用于创建文章的表单。</p><p>另外它是一个状态组件。</p><p>状态组件是指在组件内部维护自身 state 的组件 。</p><p>状态组件？我们一直说要用 Redux 来管理 state 。 为什么现在又说要让 Form 自己去维护 state ?</p><p>即使在使用 Redux 的时候，使用有状态的组件也是完全可以的，两者并不冲突。</p><p>并不是所有的 state 都必须在 Redux 中管理。</p><p>在这个例子中我不想其他任何组件知道 Form 组件内部的 state 。</p><p>这么做很好。</p><p>这个组件做什么事呢？</p><p>该组件包含了一些在表单提交时更新本地 state 的逻辑。</p><p>另外它接收一个 Redux action 作为属性传入其中。用这种方式它可以通过触发 addArticle action 来更新全局的 state。</p><p>在 src/js/components 下建一个名为 Form.js 的文件。它看起来像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/js/components/Form.js</span><br><br><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<br><span class="hljs-keyword">import</span> uuidv1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uuid&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; addArticle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../actions/index&quot;</span>;<br><br><span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    addArticle: <span class="hljs-function">(<span class="hljs-params">article</span>) =&gt;</span> dispatch(addArticle(article)),<br>  &#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectedForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      title: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.handleChange = <span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.handleSubmit = <span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; [event.target.id]: event.target.value &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    event.preventDefault();<br>    <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-built_in">this</span>.state;<br>    <span class="hljs-keyword">const</span> id = uuidv1();<br>    <span class="hljs-built_in">this</span>.props.addArticle(&#123; title, id &#125;);<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;&quot;</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-built_in">this</span>.state;<br><br>    <span class="hljs-keyword">return</span> (<br>      &lt;form onSubmit=&#123;<span class="hljs-built_in">this</span>.handleSubmit&#125;&gt;<br>        &lt;div className=<span class="hljs-string">&quot;form-group&quot;</span>&gt;<br>          &lt;label htmlFor=<span class="hljs-string">&quot;title&quot;</span>&gt;Title&lt;/label&gt;<br><br>          &lt;input<br>            type=<span class="hljs-string">&quot;text&quot;</span><br>            className=<span class="hljs-string">&quot;form-control&quot;</span><br>            id=<span class="hljs-string">&quot;title&quot;</span><br>            value=&#123;title&#125;<br>            onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125;<br>          /&gt;<br>        &lt;/div&gt;<br><br>        &lt;button type=<span class="hljs-string">&quot;submit&quot;</span> className=<span class="hljs-string">&quot;btn btn-success btn-lg&quot;</span>&gt;<br>          SAVE<br>        &lt;/button&gt;<br>      &lt;/form&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> Form = connect(<span class="hljs-literal">null</span>, mapDispatchToProps)(ConnectedForm);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Form;<br></code></pre></td></tr></table></figure><p>怎么描述这个组件呢？除了 mapDispatchToProps 和 connect 它就是标准的 React 的那套东西。</p><p>mapDispatchToProps 将 Redux actions 和 React 属性 连接起来。这样组件就可以向外发送 action 了。</p><p>你可以看下 action 是怎样在 handleSubmit 方法中被触发的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    event.preventDefault();<br>    <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-built_in">this</span>.state;<br>    <span class="hljs-keyword">const</span> id = uuidv1();<br>    <span class="hljs-built_in">this</span>.props.addArticle(&#123; title, id &#125;); <span class="hljs-comment">// Relevant Redux part!!</span><br>  <span class="hljs-comment">// ...</span><br>  &#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>最后组件被导出为 Form 。 Form 就是组件和 Redux store 连接之后的产物。</p><p>注意：当 mapStateToProps 不存在的时候，connect 的第一个参数必须为 null，就像例子中的 Form 一样。 否则，你会得到 TypeError: dispatch is not a function. 的警告。</p><p>我们的组件部分就都结束了。</p><p>更新下 App , 把 Form 组件加进来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./List&quot;</span>;<br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Form&quot;</span>;<br><br><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> (<br>  &lt;div className=<span class="hljs-string">&quot;row mt-5&quot;</span>&gt;<br>    &lt;div className=<span class="hljs-string">&quot;col-md-4 offset-md-1&quot;</span>&gt;<br>      &lt;h2&gt;Articles&lt;/h2&gt;<br>      &lt;List /&gt;<br>    &lt;/div&gt;<br>    &lt;div className=<span class="hljs-string">&quot;col-md-4 offset-md-1&quot;</span>&gt;<br>      &lt;h2&gt;Add a <span class="hljs-keyword">new</span> article&lt;/h2&gt;<br>      &lt;Form /&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm start<br></code></pre></td></tr></table></figure><p>打开 <a href="http://localhost:8080/">http://localhost:8080</a></p><p>你将看到如下界面：</p><p>没什么特别的，但可以展示 React 和 Redux 是如何工作的。</p><p>左边的 List 组件和 Redux store 相连。它将在你新建文章的时候刷新渲染。</p><p>哈哈！</p><p>你可以在 这里 查看源码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你可以从这篇教程中学到一些东西。我尽力把例子写的足够简单。我希望可以在下面的评论中倾听你的反馈。</p><p>Redux 有许多模板和移动部件。别灰心。拿起来把玩，花点时间去吸收它所有的概念。</p><p>我逐步从零开始慢慢地理解了 Redux 。相信你也可以做到。</p><p>当然，也请花点时间想清楚为什么需要在你的项目中引用 Redux。</p><p>无论怎样：学习 Redux 都是 100% 值得的。</p><p>Redux 并不是状态管理的唯一方式。<a href="Mobx">Mobx</a> 是另一个有趣的可选方案。我也在关注 Apollo Client。谁将胜出？只有时间知道答案。</p><h2 id="函数式编程的一些资源"><a href="#函数式编程的一些资源" class="headerlink" title="函数式编程的一些资源"></a>函数式编程的一些资源</h2><p>Redux 使大多数初学者感到害怕，是因为它是围绕函数式编程和纯函数展开的。</p><p>我只能是推荐一些资源给大家，因为函数式编程超出了本指南的范围。 下面是一些函数式编程和纯函数相关的资源：</p><ul><li><a href="https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/ch1.html">Professor Frisby’s Mostly Adequate Guide to Functional Programming</a></li><li><a href="https://github.com/getify/Functional-Light-JS">Functional-Light-JS</a></li></ul><h2 id="Redux-中的异步-actions"><a href="#Redux-中的异步-actions" class="headerlink" title="Redux 中的异步 actions"></a>Redux 中的异步 actions</h2><p>我不确定谈论异步 actions 是否合适。</p><p>大多数 Redux 初学者都很难仅学习纯粹的 Redux。 在 Redux 中处理复杂的异步 action 还是比较费劲的。</p><p>当你了解了 Redux 的核心概念后可以去读一下 Matt Stow 写的 <a href="https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3">A Dummy’s Guide to Redux and Thunk in React</a>。这是篇关于 Redux 怎样用 redux-thunk 处理 API 请求的非常不错的介绍。</p><p>谢谢阅读，码得愉快～</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>程序员对 996 的反抗引来全球关注，它是如何以程序员自己的方式建立起来？</title>
    <link href="/p/dd7f934b4f984d66b60d603896747363/"/>
    <url>/p/dd7f934b4f984d66b60d603896747363/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自: <a href="https://m.douban.com/note/712945658/?dt_dapp=1">https://m.douban.com/note/712945658/?dt_dapp=1</a>，原文应该来自 <a href="https://www.qdaily.com/">好奇心日报</a>，但目前已被删除。<br>国内的各大互联网公司争相屏蔽 <a href="https://996.icu/">996.ICU</a> 及其 <a href="https://github.com/996icu/996.ICU">GitHub</a>，甚至在 <a href="https://github.com/996icu/996.ICU/issues">GitHub Issues</a> 大肆雇佣水军发布乱七八糟的东西导致 Issues 被关闭。<br>包括百度上无法搜索到官网，中文搜索结果中甚至搜索不到 GitHub。QQ/360/百度/UC 这些常见的国内浏览器直接添加本地规则禁止访问，但 Chrome/Firefox 则安然无恙（所以真的无法理解程序员为什么会用 360？）</p></blockquote><p>一场关于劳工权益的抗议在过去一周里爆发，让中国互联网公司习惯的 996（早九点、晚九点、一周六天）加班时间成为中国乃至全球关注的焦点。</p><p>有程序员发起了一个抵制 996 工作制的项目 <a href="https://996.icu/">996.ICU</a>。讨论从技术社区开始，在互联网公司的微信群流传开来，蔓延到豆瓣、知乎，很快上了微博热搜，在百度的搜索热度达到平日的十倍。《中国青年报》、《南方日报》的报道被项目发起人标注进了项目的说明页面。</p><p>一周下来，事件的影响在海外逐渐升温。最早跟进报道的英文媒体是关注中国的《南华早报》，它在 3 月 29 日对此事的报道被 Python 之父 <a href="https://twitter.com/gvanrossum">Guido van Rossum</a> 转发并附上一句评论：“<strong>996 工作制是不人道的。</strong>”</p><p>全球程序员聚集讨论区 Hacker News 和相应 Reddit 论坛，996 也成了一个热门话题。The Verge、Financial Times 分别在 4 月 2 日和 4 月 3 日跟进，《连线》等媒体也已经在采访参与者。</p><p>和前两年以悲剧方式获得全球关注的中国制造业从业者不同，程序员看起来是最不容易为工作环境走向对抗的一个群体。外界对他们的印象主要是收入高、习惯天天加班、办公室放着行军床、生活简单就想着买房结婚。一个典型的中产阶级行业，而中产阶级往往被认为是革命中重要但同时也是阻力最大的阶层。</p><p>但不同于其它也要日常加班，强度更大收入更少的行业，程序员有一个说话的渠道。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>996.icu 网站的域名最早由一个年轻的程序员注册。</p><p>在技术论坛 V2EX 上，这位用户曾在一个关于工作薪酬讨论的帖子里提到自己毕业于北京一所 211 大学，在一家与百度、阿里、腾讯同级的大型互联网公司工作，刚转正没多久，每月薪酬在一万多元。</p><p>之前，他都在论坛里发帖讨论技术，讨论同一个公司不同的团队之间为什么薪资会有差别。但最近，他所在的公司开始实行 996 工作制。</p><p>3 月 20 日，他在论坛的域名推广版宣布注册了一个域名 <a href="http://996.icu/">http://996.icu</a>，口号是：“工作 996，生病 ICU。”</p><p>3 月 26 日后，他在一个职场话题下回复道：“我才感到 996 多么毁人，除了工作就是休息，跟家人沟通都少了。”在那个回帖里，他再次推荐了 996.ICU 网站。</p><p><a href="http://996.icu/">996.ICU</a> 就是一个网站，自上而下分成 996 介绍、十七条劳动权益相关法规和相关事件报道三个部分。这三部分自第一天就在，虽然内容在过去一周日渐丰富起来。</p><p><a href="http://996.icu/"><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190407205931.png" alt="996 icu"></a></p><p>网站作者还在介绍后面加上了一句“Developers’ Lives Matter”（开发者的命也是命），模仿美国对抗种族不平等运动的“Black Lives Matter”（黑人的命也是命）。</p><p>它的影响力并不来自这个网页。而是来自同样在 3 月 26 日上线的 <a href="https://github.com/996icu/996.ICU">GitHub</a> 项目。</p><p>项目由一个叫 996icu 的匿名 ID 发起，和域名持有者的关系不得而知。但从每天对最多 260 个建议的快速处理来看，这个账号即便是那位年轻程序员创建，现在很可能也不是他一个人在用。</p><p>今天，软件开发已经不需要凡事都重新发明一个轮子，用开源的代码可以快速完成一个功能。</p><p>而 GitHub 就是存放这些代码的最大平台。程序员们在 GitHub 上管理自己的项目，发起讨论、提交修改建议。</p><p>目前 GitHub 有<a href="http://www.sohu.com/a/276484595_671058">三千万程序员用户</a>，托管了大约 8000 万个代码仓库，平均每秒创建的存储库就有 1.6 个。2018 年，<a href="https://techcrunch.com/2012/07/14/what-exactly-is-github-anyway/">微软宣布 75 亿美元收购 GitHub</a>。</p><p>GitHub 上之前也有关于中国互联网公司加班问题的项目，两个月前一个主题是 <a href="https://github.com/shengxinjing/programmer-job-blacklist">“程序员找工作黑名单”</a> 的项目上线，这个黑名单在两个月内获得了超过 18000 次“加星点赞”（Star）。</p><p>但这看起来更像是程序员在找工作时的一份操作指南。而 996.ICU 则更直接、更简单，从一开始就是一份反 996 工作制的宣言。</p><p>这让它迅速引起共鸣。</p><p>996 一直没有好名声。最早可以追溯到 <a href="http://it.sohu.com/20140405/n397797427.shtml">2014 阿里巴巴怀孕员工加班回家后大出血去世</a> 的新闻报道。2016 年，<a href="http://finance.cnr.cn/gs/20160901/t20160901_523105136.shtml">58 同城就因为对 2 万多员工强制 996</a> 遭到不少抵制。</p><p>今年 1 月，<a href="http://www.linkshop.com.cn/web/archives/2019/418163.shtml">杭州有赞 CEO</a> 在公司年会上突然宣布全公司强制执行 996，有赞高管表示如果工作家庭不好平衡，可以选择离婚。</p><p>更近的，京东 3 月初开始执行 995 工作制度。面对质疑，<a href="http://tech.163.com/19/0312/13/EA2QGIOK00097U7R.html">京东公关总监刘力回应不会强制要求，但鼓励员工全情投入</a>。</p><p>中国互联网公司加班不被认为是特例，但以往有高回报盼头。2017 年，软件业平均薪资 13.3 万，连续两年超过金融业成为全国最赚钱的行业。阿里巴巴纽交所挂牌上市，一夜之间产生了 1 万多名千万富翁。</p><p>2018 年开始的上市潮没能重现另一个阿里巴巴。小米 2014 年估值达到 450 亿美元，2018 年上市前预期公司市值能有 800 - 1000 亿美元，四年老员工手中股票价值有望翻倍。但等到 2019 年年初员工可以卖股票的时候，小米市值缩水至 315 亿美元，股票价值也比 2014 年缩水 30%。</p><p>而小米已经是过去一年上市公司里表现很好的。<a href="https://www.jiemian.com/article/2703824.html">蘑菇街直接以稀释员工股权的手段将员工持股价值缩水为 1/25</a>。蘑菇街挂牌价为 14 美元，1 万股理应价值 96.6 万元，但稀释 25 倍后只有 4 万元。</p><p>甚至工作也不一定能保证。互联网行业早几年处于风口，大量风险投资涌入。创业公司不在乎利润，可以开更高薪水来挖人。</p><p>但现在形势变了。2018 年，中国 VC/PE 募资规模 341.12 亿美元，<a href="https://36kr.com/p/5150552">同比骤降 74.59%</a>。靠烧钱做大规模的互联网公司上市后也面对盈利问题。缺乏资金来源，为了减少亏损，裁员成为一个普遍的做法。</p><p>去年 8 月，美图、拉勾网各裁员 20%。10 月，锤子科技解散成都分公司，为它从北京搬去成都的程序员也失去工作。11 月，趣店裁员 200 人，不从北京搬去杭州也得走，同月斗鱼裁员 70 人。12 月，知乎裁员 20%，300 人被要求当天离开公司；科大讯飞裁员 20%，回应为末位淘汰；摩拜裁员 30%，称为正常调整。今年 2 月，滴滴裁员 15%，2000 人离职；京东先裁员 20% 员工，2 月又裁员 10% 副总裁级别高管。3 月，腾讯中层裁去 20%，<a href="http://m.kanshangjie.com/Index/Show?id=161549">腾讯总裁刘炽平称</a> 为年轻化主动革新。</p><p>高强度的工作变得强度更高、曾经可以指望的上市故事愈加渺茫，甚至能工作多少年也在大裁员背景下变得难以确定。</p><p>在这样的背景之下，996.ICU 项目上线一小时内就收获了超过 2000 颗星星，一天内加星数超过一万，登上了 GitHub 实时热门榜。</p><p>更多人注意到了。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>Anony 就是在 3 月 26 日 996.ICU 上线一小时的时候开始关注的。他自称是一个普通的码农，平时喜欢逛 GitHub。他说自己平时逛 GitHub 就“类似于你们刷微博”。</p><p>尽管 Anony 所在公司没有实行 996 工作制，他还是持续对这个项目的进展保持关注，也参与了修改措辞的工作。</p><p>在 996.ICU 的讨论区（Issues 区）里，加星即将破十万前，有人留言说，没想到以这种方式参与了大型开源项目。</p><p>在社交网络上人们分享自己关于 996 工作的经历、见解以及解决方案。但在程序员社区里，一切都按照程序员们开发开源软件的方式推进着。</p><p>想象一栋充满无数会议室的大楼，每间会议室里的白板上写着一项软件的所有代码。GitHub 可以让程序员走入其中开放的会议室，观看白板上的代码（Watch），点赞（Star），并按自己的想法进行修改。</p><p>但随意修改会扰乱白板上的代码，Github 方便用户将白板上的代码库整体复制到自己账户下，修改不影响项目代码。修改完成后，程序员可以提交“拉回请求”（Pull Request）给项目维护者进行合并，将自己的修改加入项目。</p><p>这是目前开源软件在线协作的工作方法，而 996.ICU 的进化过程完全遵照此方法进行。</p><p>GitHub 上最初的 996.ICU 项目很简单：一段 26 行的 Markdown 格式网页文档。</p><p>一段段劳动法摘录、五一国际劳动节的由来、国际歌歌词、英文版本是最早的一批更新。</p><p>996.ICU 项目的补充、完善，都是由参与者以提交“拉回”请求的方式推进，逐渐成为今天的样子。</p><p>这和在论坛留言不一样，如果一个人看到代码就产生不适感，那就无法在这里提出修改请求。</p><p>各种细节被快速完善。有人提交请求，称主页面上的案例之一京东的英文版本如果直译 JINGDONG 无法让外国投资者理解，要改成 <a href="jd.com">JD.COM</a>。</p><p>大小写、空格、错误链接、全角半角符号错用等问题都被更新，放进 Markdown 格式的文档里，还有人上传了自制的 Logo。</p><p>法语、德语、意大利语、日语、韩语、葡萄牙语、巴西葡萄牙语、泰语、繁体中文、越南语、俄语、希腊语等主要语言版本翻译都在项目上线第二天提交。还有人写了<a href="https://github.com/996icu/996.ICU/pull/16430/files%E3%80%81">颇正式的文言文版本</a>：“996”事制，即日早九至岗，直至晚九点事，每周工作六日。2016 年九初起，续有网爆料称，58 同城行全员 996 事制，且周末加班无文……</p><p>3 月 28 日是进展飞快第一天，项目有了两个关联项目：<a href="https://github.com/fengT-T/996_list">996 公司黑名单</a> 和 <a href="https://github.com/formulahendry/955.WLB">955 公司白名单</a>。</p><p>黑名单上都是实行了 996 或过度加班的公司，国内的大互联网公司基本在列，京东以超过 1200 票遥遥领先。作者还提出建议，希望在提名的时候加上部门、省区、工资范围，总之给出的信息越详细越好。</p><p>黑名单的作者原先将投票设置在一个论坛上，并没有考虑到会有那么多人参与投票，以至于网站太卡，人们只关注到了排名在前面的大公司。目前，这位作者正在建设新的网站，他在项目说明里写道：“因为太卡大家都只关注到了前面的大公司，希望大家能够注意到 996 的群体实际上很大，不仅仅有 BAT ，还有很多小公司。”</p><p>而白名单上的公司更多是外企。</p><p>955 公司白名单作者 formulahendry 在上海一家大外企做程序员，他的 GitHub 页面有超过 600 个关注者，还坚持用英文写过一段时间技术博客。</p><p>像几乎所有外企一样，formulahendry 并不需要 996。他对《好奇心日报》称，996 就完全没有个人的生活时间，最近这个现象越来越普遍，并不是一个好的趋势，他反对 996 的理由与许多人类似：比起一周工作 40 小时，一周工作 72 小时的 996 单位时间的产出不高。</p><p>注意到 996.ICU 之后，他觉得与其吐槽 996，不如看看有哪些公司实行 955（一周工作五天，朝九晚五） 的公司。</p><p>项目上线第二天，他创建白名单投票，项目的名字 WLB 是他自创的缩写，意思是 Work Life balance，即生活与工作的平衡。WLB 一天内加星数超过了 1000，上线第二天上了 GitHub 实时热门榜。</p><p>投票的雏形是基于 formulahendry 对上海 IT 公司的了解，在接下来的几天里，他利用下班在班车上的时间以及周末的时间维护着项目更新。</p><p>虽然 formulahendry 建了白名单，但是项目被创建出来之后就不再是他一个人能决定的事：一切都得按照 GitHub 的方式来。</p><p>996 公司黑名单则吸引了更多的参与：一个公司被添加到黑名单的方式与开源项目代码审核没什么太大区别，每个人都可以提交论据，只是提交论据的方式对非程序员来说有一定门槛。论据包括媒体报道、知乎讨论、公司官网公告等。</p><p>华为 和 <a href="https://github.com/formulahendry/955.WLB">字节跳动等公司</a> 是否能够上榜都引发了众多讨论。在要求“删除黑名单字节跳动”的请求下有 51 组对话，要求删除的人和不同意删除的人各自举证。</p><p>发起删除请求的用户给出了两点理由：</p><ol><li> 公司虽然下班晚，上班也晚，算上午饭、晚饭后的休息时间，实际工作时长并没有一天 12 小时；公司实行大小周，但是小周周日加班给加班费；</li><li> 猝死事件的程序员是刚从腾讯跳槽到字节跳动不久，不能武断归咎于字节跳动加班。</li></ol><p>反驳方指出“说的好像 955 的公司不午休不吃饭一样。”接着还有反驳者给出加班费计算方法的猫腻，比如周日加班按 1.2 倍工资而不是 2 倍工资计算。</p><p>一个请求能否通过，实际上是以一种简单的投票实现的。删除字节跳动的请求有 8 人支持，269 人反对。最后 996.ICU 项目负责人拒绝了删除字节跳动的请求。</p><p>虽然项目负责账号可以对请求作出判断，但由于开源项目的可复制性，如果项目发起人背离社区大多数人的诉求，程序员们可以很容易转而支持另一个在这个基础上分出来的项目。</p><p>从一个个人项目，演变为社区项目之后，决定项目发展的就不再是发起人，而是所有参与贡献的人共同决定的结果。这些都是开源软件开发的基本方式。</p><p>就像比如 Linux 系统最早是 Linus 一个人的作品。但随着全球开发者的加入，有 1.5 万开发者和超过 1400 家公司添砖加瓦。现在 Linux 远不是 Linus 所能控制的，它的管理由一个专门的基金会所负责。</p><p>996.ICU 也没什么区别。不论是谁启动了这个项目，现在它已经不再是一个人决定的事。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>讨论变得敏感，是从 3 月 29 日项目的 issues 被关闭开始。</p><p>仓库下的讨论区（Issues）突然被关闭，也引发了不少讨论，比如 issues 太多（过了十万）、太多广告，还有人贴出白宫请愿的号召截图怀疑是政治原因。几小时后，作者贴出解释称是主动选择关闭。</p><p>不过这对讨论没有太大影响。项目上线之初，有人发出各地微信群的二维码，与此同时就有人回应说程序员应该用程序员的工具，而不是用 QQ、微信来沟通。于是程序员常用的即时通信工具 Slack、游戏即时通信工具 Discord 都被用起来、国内不能直接访问的通讯工具 Telegram 上也出现了 996.ICU 讨论组。</p><p>996.ICU 的 Slack 讨论频道在五天内吸引了 1000 多名成员，成员自发将 Slack 群组划分成了公告、招聘、讨论、中文、英文、城市等数个频道。在 Slack 频道里讨论最多的，是劳动权益受到侵害之后如何维权。</p><p><a href="https://www.zhihu.com/question/317847010/answer/636013957">一名拥有二十年经验的程序员陈皓</a> 在知乎回答了问题：“如果想抵制 996，除了利用 GitHub 发起抗议，还有哪些巧妙的方案？”，提出通过法律手段、政府信访、集体抗议等途径。</p><p>在 Slack 群组讨论中，他的解决方案遇到了不少阻力，一些成员质疑劳动仲裁的效率，还有一些成员则担忧信访手段可能招致政府机关的强制手段。</p><p>在完善了措辞、不同语言版本和黑名单、白名单之后。996.ICU 从上周末开始的最大进展是“反 996 软件授权协议”从想法到落地。</p><p>3 月 27 日，<a href="https://github.com/996icu/996.ICU/pull/15642">一个想法被热切讨论后采用</a>：设计一种关于劳动保护的软件授权协议——996ICU 协议，如果这个协议被兼容进各个开源项目的授权协议，实行 996 工作制的公司不得使用该开源项目，就可能给公司带来实际的约束作用。</p><p>劳动法一直在，但执行是问题。大互联网公司往往为一个城市解决数万就业，有些还提供数十甚至上百亿利税。理论上地方法院，比如深圳当地法院应该公平对待腾讯、华为和它们的员工，但这是理论上。</p><p>而软件授权协议是软件行业内的一个约束。简单来说，软件授权协议就像是一本书的版权声明。在项目开发中开源软件的使用不可避免，使用开源软软件不需要付费，但是需要遵守作者写在授权协议中的条款，如果公司或个人使用了开源代码，但是没有遵守条款，作者可以据此提起诉讼，要求赔偿、停止使用代码。</p><p>这个想法被上千人点赞，400 多人参与了该协议的讨论。</p><p>但协议怎么写还没人想好，一开始只有这样三行：</p><p>The 996ICU License (996ICU)Copyright © 2019 3 月 30 日晚间，伊利诺伊大学厄巴纳 - 香槟分校法学博士 Katt Gu 花了一夜时间起草了授权协议。这个版本在常用的 <a href="https://github.com/kattgu7/Anti-996-License/wiki">MIT 开源授权协议基础之上</a> 改编。协议一共三条，在所有协议都会有的惯例版权声明条款，Katt Gu 增加了两条内容：</p><ul><li><p>个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或经营地（以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和标准。如果该司法管辖区没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可执行，则个人或法人实体必须遵守国际劳工标准的核心公约。</p></li><li><p>个人或法人不得以任何方式诱导或强迫其全职或兼职员工或其独立承包人以口头或书面形式同意直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和标准保护的权利或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该等个人或法人实体也不得以任何方法限制其雇员或独立承包人向版权持有人或监督许可证合规情况的有关当局报告或投诉上述违反许可证的行为的权利。</p></li></ul><p>Katt Gu 关注新技术立法，也著有关于 <a href="https://scholar.google.com/citations?user=PTcpQwcAAAAJ&hl=en&oi=ao">中国特定领域法律与实践鸿沟</a> 的论文。</p><p>3 月 29 日晚上，Katt Gu 的丈夫，一直关注软件版权演进的创业者 Suji Yan 在看到 996.ICU 之后催促她起草一份协议。Gu 回忆说最初她并不愿意。</p><p>“因为我本人是一个工作狂，但是仔细想想这是一个关乎自愿选择的事。”Gu 对《好奇心日报》表示，她的顾虑还来源于专业，这份协议起草涉及 IP 法、劳动法以及国际公约等领域的研究，她从未有过相关经验。</p><p>起草协议之前，一位律师告诉她，要做好这份协议，得先研究十年劳动法、再研究十年 IP 法，或者在几个涉及的领域各找十个专家来讨论、研究，再拟定草稿。</p><p>但是 Katt Gu 觉得协议的实用效果远小于宣传效果，今天最重要的那些开源协议一开始也不是以那样的立法方式做出来的。</p><p>经过一夜研究，她决定以最简单的通用法（Common Law）为基础，草拟一份协议草案。而起草的模版则是简单且应用广泛的 MIT 开源协议。</p><p>这份协议以及协议期待产生的效果，都是相当理想化的。</p><p>根据 Suji Yan 所设想的最理想状态，协议可以对中国互联网公司有一个约束。他的逻辑是今天软件开发基本上已经不可能不用开源代码——微软一度都是开源软件的最大贡献者。当足够多的开源项目用了 996ICU 协议，企业强制 996 就等于自己的产品违反协议，开源代码拥有者就可以起诉该公司。哪怕在中国大陆起诉艰难，这些公司基本都在香港或美国上市，也可以在其它地区发起诉讼。</p><p>不过解释完之后，他自己也说“这当然是一个极其理想化的设想”。</p><p>“本来觉得我们不做会有别人做，但是现在觉得还是需要更多人关注。”Katt Gu 说协议公布之后收到一封感谢邮件，“感觉就像看医生收到那种‘妙手回春’的锦旗。”</p><p>对协议约束力持怀疑态度的人很普遍，而反对者也不少。比如目前 GitHub 上第三大项目的创作者尤雨溪在微博上表示自己个人反对和谴责 996，但是也反对在开源项目许可证中包含 Discriminatory Clause（禁止部分用户使用的条款），或是利用开源项目做任何形式的政治博弈。</p><p>“我个人有个人的看法，但项目是中立的。Vue 的许可证不会禁止任何人使用，现在不会，以后也不会。”他在微博上写道。Vue.js 是一个开发网页用户界面的框架。</p><p>但添加反 996 许可证的项目 <a href="https://github.com/996icu/996.ICU/blob/master/awesomelist/projects.md">在不断增多</a>。目前已经有 75 个开源项目添加了许可证，其中大部分是个人开发者维护的项目，但也有多个点赞数在四五千以上，有一定规模、被很多公司使用的开源软件项目加入。而和 Vue 相关的数个插件项目也加入了反 996 许可协议——任何项目开源扩大之后，就不再是作者一个人决定的了。</p><p>Katt Gu 称接下来自己的协议修改要它与更多的主流开源软件协议兼容，这样才有希望被更多开源项目所接纳。</p><p>“我自己只想把这个协议写好，写好估计就没有我啥事了，如果要写细，可能要花两三年。”Katt Gu 说做完这个应该就不会管了。Suji Yan 则补充了一句：“还给社区。”</p><p>社区有一个大目标。4 月 1 日，有人号召把反 996 协议加入 GitHub <a href="http://choosealicense.com/">官方收录协议</a> 当中，这样新开源项目就可以很容易把协议加入项目。</p><p>更长远的目标是让它被 GitHub 高亮显示，这样任何项目在创建选择协议时都有机会看到它。</p><p>这些都不容易，尤其是在主页高亮，需要超过 1000 个公开项目使用该协议，3 个明星项目使用、OSI 和 GNU 批准。</p><p>作为开源软件的推动力量，理查德·斯托曼（ Richard Stallman）在 1985 年发表《GNU 宣言》，提出所有软件都应该贯彻自由软件的精神——运行、复制、发布、研究、修改和改进该软件的自由。</p><p>但从一开始，这个运动就没有停留在技术或者免费用软件的层面，发起者认为大众都能接触到的应用都应完全掌控在用户自己手中。如果 996.ICU 的贡献者们计划成功，这将是开源软件届第一个被认可的约定劳动权益的协议。</p><p>一周不到，对 996.ICU 的反击已经来了。</p><p>没有公司敢直接攻击 GitHub。2015 年的持续攻击 <a href="http://choosealicense.com/">没有成功</a>。现在它是微软的财产，商业公司攻击它就更不明智。</p><p>攻击者们用了自己最习惯的手段，屏蔽。</p><p>3 月 30 日开始，Slack 讨论群组中开始有人报错：北京地区微信内无法打开 996.ICU 的 GitHub 页面，更多的测试显示，这不是孤例。</p><p>QQ 浏览器称这个唯一公开诉求就是让公司遵守劳动法的网站包含欺诈信息。微信显示的理由则是“该网页包含违法或违规内容，为维护绿色上网环境，已停止访问”。阿里巴巴旗下的 UC 浏览器和 360 浏览器都将该页面认定为包含违法信息的网站。最独特的猎豹浏览器打开这个页面会弹出提示称“网站含有大量淫秽色情信息”。</p><p>使用百度搜索 996，中文版搜索结果里找不到 996.icu 网站和对应 GitHub 页面的链接。</p><p>和以往不同的是，这一次它们并不能直接封杀 996.ICU 的存在，也没法让讨论它的渠道消失。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 避免使用 if-else 的方法</title>
    <link href="/p/fd2ee073c51c4c169ebff5a32795d375/"/>
    <url>/p/fd2ee073c51c4c169ebff5a32795d375/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在日常编写 JavaScript 代码的过程中，或许会遇到一个很常见的问题。根据某个状态，进行判断，并执行不同的操作。吾辈并不是说 <code>if-else</code> 不好，简单的逻辑判断 <code>if-else</code> 毫无疑问是个不错的选择。然而在很多时候似乎我们习惯了使用 <code>if-else</code>，导致代码不断庞大的同时复杂度越来越高，所有的 JavaScript 代码都乱作一团，后期维护时越发困难。</p><blockquote><p><a href="https://github.com/rxliuli/avoid-if-else-example">GitHub</a>, <a href="https://avoid-if-else.rxliuli.com/">演示地址</a></p></blockquote><p>例如下面这段代码，点击不同的按钮，显示不同的面板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript 避免使用 if-else<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tab&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第一个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第二个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">data-index</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form-tab-radio&quot;</span> /&gt;</span><br>          第三个选项卡<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;extends-form&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/if-else.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// js/if-else.js</span><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> index = el.dataset.index;<br>    <span class="hljs-keyword">const</span> header = el.parentElement.innerText.trim();<br>    <span class="hljs-comment">// 如果为 1 就添加一个文本表单</span><br>    <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">              &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">              &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">              &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">          `</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>          fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>            resolve(event.target.result);<br>          &#125;;<br>          fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            reject(error);<br>          &#125;;<br>          fr.readAsDataURL(file);<br>        &#125;);<br>      &#125;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (!file) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>        &#125;);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;3&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">          &lt;ul id=&quot;search-result&quot;&gt;&lt;/ul&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>      <span class="hljs-built_in">document</span><br>        .querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>)<br>        .addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> searchText = event.target.value;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>            .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>            .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>            .join();<br>        &#125;);<br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>那么，我们可以如何优化呢？</p><h2 id="抽取函数"><a href="#抽取函数" class="headerlink" title="抽取函数"></a>抽取函数</h2><p>稍有些经验的 developer 都知道，如果一个函数过于冗长，那么就应该将之分离成多个单独的函数。</p><p>所以，我们的代码变成了下面这样</p><p>实现思路</p><ol><li> 抽取每个状态对应执行的函数</li><li> 根据状态使用 <code>if-else/switch</code> 判断然后调用不同的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 抽取函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchFirst</span>(<span class="hljs-params">header</span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">          <span class="hljs-subst">$&#123;header&#125;</span></span><br><span class="hljs-string">          &lt;div&gt;</span><br><span class="hljs-string">            &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">            &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">          &lt;/div&gt;</span><br><span class="hljs-string">          &lt;div&gt;</span><br><span class="hljs-string">            &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">            &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">          &lt;/div&gt;</span><br><span class="hljs-string">          &lt;div&gt;</span><br><span class="hljs-string">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">          &lt;/div&gt;</span><br><span class="hljs-string">        `</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchSecond</span>(<span class="hljs-params">header</span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;header&#125;</span></span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>      fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>        resolve(event.target.result);<br>      &#125;;<br>      fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        reject(error);<br>      &#125;;<br>      fr.readAsDataURL(file);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchThree</span>(<span class="hljs-params">header</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = <span class="hljs-string">`</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;header&#125;</span></span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">        &lt;ul id=&quot;search-result&quot;&gt;&lt;/ul&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>).addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> searchText = event.target.value;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>      .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>      .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>      .join();<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchTab</span>(<span class="hljs-params">el</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> index = el.dataset.index;<br>  <span class="hljs-keyword">const</span> header = <span class="hljs-string">`&lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;el.parentElement.innerText.trim()&#125;</span>&lt;/h2&gt;&lt;/header&gt;`</span>;<br>  <span class="hljs-comment">// 如果为 1 就添加一个文本表单</span><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>    switchFirst(header);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>    switchSecond(header);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-string">&quot;3&quot;</span>) &#123;<br>    switchThree(header);<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> switchTab(el));<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ES6-class：有限状态机"><a href="#ES6-class：有限状态机" class="headerlink" title="ES6 class：有限状态机"></a>ES6 class：有限状态机</h2><p>如果你知道 ES6 的 <code>class</code> 的话，应该也了解到目前 js 可以使用 <code>class</code> 模拟面向对象的继承，以及多态。</p><p>实现思路</p><ol><li> 创建一个基类，并在其中声明一个需要被子类重写的方法</li><li> 根据不同的状态创建不同的子类，并分别实现基类的方法</li><li> 添加一个 <code>Builder</code> 类，用于根据不同的状态判断来创建不同的子类</li><li> 调用者使用 <code>Builder</code> 类构造出来的对象调用父类中声明的方法</li></ol><p>具体实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 有限状态机</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-comment">// 基类里面的初始化方法放一些通用的操作</span><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.initHTML()&#125;</span></span><br><span class="hljs-string">    `</span>;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = html;<br>  &#125;<br><br>  <span class="hljs-comment">// 给出一个方法让子类实现，以获得不同的 HTML 内容</span><br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-comment">// 实现 initHTML，获得选项卡对应的 HTML</span><br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">      &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>  &#125;<br>  <span class="hljs-comment">// 重写 init 初始化方法，并首先调用基类通用初始化的方法</span><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(header);<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">if</span> (!file) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">this</span>.readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>      &#125;);<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// 子类独有方法</span><br>  <span class="hljs-function"><span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>      fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>        resolve(event.target.result);<br>      &#125;;<br>      fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        reject(error);<br>      &#125;;<br>      fr.readAsDataURL(file);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">        &lt;ul id=&quot;search-result&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(header);<br>    <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>    <span class="hljs-built_in">document</span><br>      .querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>)<br>      .addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> searchText = event.target.value;<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>          .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>          .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>          .join();<br>      &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabBuilder</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取一个标签子类对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>index 索引</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Tab&#125;</span> </span>子类对象</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params">index</span>)</span> &#123;<br>    <span class="hljs-comment">// Tab 构造类，用于根据不同的状态 index 构造不同的 Tab 对象</span><br>    <span class="hljs-keyword">const</span> tabMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<br>      <span class="hljs-built_in">Object</span>.entries(&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> Tab1(),<br>        <span class="hljs-number">2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> Tab2(),<br>        <span class="hljs-number">3</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> Tab3(),<br>      &#125;)<br>    );<br>    <span class="hljs-keyword">return</span> tabMap.get(index)();<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span><br>    <span class="hljs-comment">// 首先通过 Builder 构造类获取 Tab 子类实例，然后调用初始化方法 init</span><br>    TabBuilder.getInstance(el.dataset.index).init(<br>      el.parentElement.innerText.trim()<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>主要优势</p><ul><li>分离了状态与执行函数之间的关联，具体执行由具体的子类决定</li><li>子类允许包含独有的属性/方法</li><li>可扩展性更好，随时可以扩展任意多个子类</li></ul><h2 id="ES6-class：无限状态机"><a href="#ES6-class：无限状态机" class="headerlink" title="ES6 class：无限状态机"></a>ES6 class：无限状态机</h2><p>上面使用 class 继承多态实现的状态机虽然很好，但却并不能应对 <strong>不确定</strong> 具体有多少种状态的情况。因为每个子类都与父类有着强关联，直接在 Builder 类中进行了声明。那么，有没有一种方式，可以在添加/删除后不影响基类或者构造类呢？</p><ol><li> 创建一个基类，并在其中声明一个需要被子类重写的方法</li><li> 添加一个 <code>Builder</code> 类，具体子类对应的状态由子类的某个属性决定</li><li>根据不同的状态创建不同的子类，并分别实现基类的方法，调用 <code>Builder</code> 类的方法注册自身<blockquote><p>此处因为 js 无法通过反射拿到所有子类，所以子类需要在 <code>Builder</code> 类注册自己</p></blockquote></li><li> 使用 <code>Builder</code> 构造子类对象，并调用基类声明的方法</li></ol><p>具体实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 无限状态机</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab</span> </span>&#123;<br>  <span class="hljs-comment">// 基类里面的初始化方法放一些通用的操作</span><br>  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;header&gt;&lt;h2&gt;<span class="hljs-subst">$&#123;header&#125;</span>&lt;/h2&gt;&lt;/header&gt;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.initHTML()&#125;</span></span><br><span class="hljs-string">    `</span>;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#extends-form&quot;</span>).innerHTML = html;<br>  &#125;<br><br>  <span class="hljs-comment">// 给出一个方法让子类实现，以获得不同的 HTML 内容</span><br>  <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 状态机</span><br><span class="hljs-comment"> * 用于避免使用 if-else 的一种方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateMachine</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getBuilder</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> clazzMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态注册器</span><br><span class="hljs-comment">     * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> (<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>      <span class="hljs-comment">// noinspection JSMethodCanBeStatic</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 注册一个 class，创建子类时调用，用于记录每一个 [状态 =&gt; 子类] 对应</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param </span>state 作为键的状态</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param </span>clazz 对应的子类型</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;*&#125;</span> </span>返回 clazz 本身</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">state, clazz</span>)</span> &#123;<br>        clazzMap.set(state, clazz);<br>        <span class="hljs-keyword">return</span> clazz;<br>      &#125;<br><br>      <span class="hljs-comment">// noinspection JSMethodCanBeStatic</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 获取一个标签子类对象</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>state 状态索引</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;QuestionType&#125;</span> </span>子类对象</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params">state</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> clazz = clazzMap.get(state);<br>        <span class="hljs-keyword">if</span> (!clazz) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//构造函数的参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> clazz(...Array.from(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>));<br>      &#125;<br>    &#125;)();<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 状态注册器</span><br><span class="hljs-comment"> * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> builder = StateMachine.getBuilder();<br><br><span class="hljs-keyword">const</span> Tab1 = builder.register(<br>  <span class="hljs-number">1</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-comment">// 实现 initHTML，获得选项卡对应的 HTML</span><br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;age&quot;&gt;年龄&lt;/label&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">          &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>    &#125;<br>  &#125;<br>);<br><br><span class="hljs-keyword">const</span> Tab2 = builder.register(<br>  <span class="hljs-number">2</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;avatar&quot;&gt;头像&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;&lt;img id=&quot;avatar-preview&quot; src=&quot;&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">      `</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重写 init 初始化方法，并首先调用基类通用初始化的方法</span><br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>.init(header);<br>      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar&quot;</span>).addEventListener(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> file = evnet.target.files[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (!file) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!file.type.includes(<span class="hljs-string">&quot;image&quot;</span>)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.readLocalFile(file).then(<span class="hljs-function">(<span class="hljs-params">link</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#avatar-preview&quot;</span>).src = link;<br>        &#125;);<br>      &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 子类独有方法</span><br>    <span class="hljs-function"><span class="hljs-title">readLocalFile</span>(<span class="hljs-params">file</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader();<br>        fr.onload = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>          resolve(event.target.result);<br>        &#125;;<br>        fr.onerror = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>          reject(error);<br>        &#125;;<br>        fr.readAsDataURL(file);<br>      &#125;);<br>    &#125;<br>  &#125;<br>);<br><br><span class="hljs-keyword">const</span> Tab3 = builder.register(<br>  <span class="hljs-number">3</span>,<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tab3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tab</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">initHTML</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">      &lt;div&gt;</span><br><span class="hljs-string">        &lt;label for=&quot;search-text&quot;&gt;搜索文本&lt;/label&gt;</span><br><span class="hljs-string">        &lt;input type=&quot;text&quot; name=&quot;search-text&quot; id=&quot;search-text&quot; /&gt;</span><br><span class="hljs-string">        &lt;ul id=&quot;search-result&quot; /&gt;</span><br><span class="hljs-string">      &lt;/div&gt;</span><br><span class="hljs-string">    `</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">header</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>.init(header);<br>      <span class="hljs-keyword">const</span> initData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项内容`</span>);<br>      <span class="hljs-built_in">document</span><br>        .querySelector(<span class="hljs-string">&quot;#search-text&quot;</span>)<br>        .addEventListener(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evnet</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> searchText = event.target.value;<br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#search-result&quot;</span>).innerHTML = initData<br>            .filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.includes(searchText))<br>            .map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;v&#125;</span>&lt;/li&gt;`</span>)<br>            .join();<br>        &#125;);<br>    &#125;<br>  &#125;<br>);<br><br><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#tab input[name=&quot;form-tab-radio&quot;]&#x27;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> &#123;<br>  el.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span><br>    <span class="hljs-comment">// 调用方式不变</span><br>    builder<br>      .getInstance(<span class="hljs-built_in">Number</span>.parseInt(el.dataset.index))<br>      .init(el.parentElement.innerText.trim())<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><p>主要优势</p><ul><li>可扩展性最好，添加/修改/删除子类不影响父类及构造类</li></ul><hr><p>那么，关于 JavaScript 中如何避免使用 if-else 到这里就结束啦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何编写无法维护的代码</title>
    <link href="/p/dc16ebcc6afe4f0aaed0f9a40b59f73d/"/>
    <url>/p/dc16ebcc6afe4f0aaed0f9a40b59f73d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>屁股决定脑袋</p></blockquote><h2 id="让自己稳拿铁饭碗；"><a href="#让自己稳拿铁饭碗；" class="headerlink" title="让自己稳拿铁饭碗；-)"></a>让自己稳拿铁饭碗；-)</h2><blockquote><p>转自 <a href="https://coderlmn.github.io/frontEndCourse/unmaintainable.html?hmsr=toutiao.io">https://coderlmn.github.io/frontEndCourse/unmaintainable.html?hmsr=toutiao.io</a>，这里仅修复了部分错别字，优化了代码显示。<br><strong>–Roedy Green</strong>（老码农翻译，略有删节）</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能。– 拿破仑</p></blockquote><p>为了造福大众，在 Java 编程领域创造就业机会，兄弟我在此传授大师们的秘籍。这些大师写的代码极其难以维护，后继者就是想对它做最简单的修改都需要花上数年时间。而且，如果你能对照秘籍潜心修炼，你甚至可以给自己弄个铁饭碗，因为除了你之外，没人能维护你写的代码。再而且，如果你能练就秘籍中的<strong>全部</strong>招式，那么连你自己都无法维护你的代码了！</p><p>你不想练功过度走火入魔吧。那就不要让你的代码<strong>一眼看去</strong>就完全无法维护，只要它<strong>实质上是</strong>那样就行了。否则，你的代码就有被重写或重构的风险！</p><h2 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h2><blockquote><p><em>Quidquid latine dictum sit, altum sonatur.</em><br>(随便用拉丁文写点啥都会显得高大上。)</p></blockquote><p>想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用。</p><p>他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量和让他难以找到他想找的代码。但更重要的是，要让他不能有把握<strong>忽略</strong>任何东西。</p><p>程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。</p><p>你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行。</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><blockquote><p>“当我使用一个单词的时候” Humpty Dumpty 曾经用一种轻蔑的口气说，” 它就是我想表达的意思，不多也不少。“<br>- Lewis Carroll – 《爱丽丝魔镜之旅》， 第 6 章</p></blockquote><p>编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员。</p><h3 id="妙用宝宝起名大全"><a href="#妙用宝宝起名大全" class="headerlink" title="妙用宝宝起名大全"></a>妙用宝宝起名大全</h3><p>买本宝宝起名大全，你就永远不缺变量名了。比如 <code>Fred</code> 就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试 <code>adsf</code> 或者 <code>aoeu</code> 之类。</p><h3 id="单字母变量名"><a href="#单字母变量名" class="headerlink" title="单字母变量名"></a>单字母变量名</h3><p>如果你给变量起名为 a,b,c，用简单的文本编辑器就没法搜索它们的引用。而且，没人能猜到它们的含义。</p><h3 id="创造性的拼写错误"><a href="#创造性的拼写错误" class="headerlink" title="创造性的拼写错误"></a>创造性的拼写错误</h3><p>如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对 (例如 SetPintleOpening 和 SetPintalClosing) ，我们就能有效地将 grep 或 IDE 搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如 colour – 英国英语，和 color – 美国英语)。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>在命名函数和变量的时候，充分利用抽象单词，例如 it, everything, data, handle, stuff, do, routine, perform 和数字，例如 e.g. <code>routineX48</code>, <code>PerformDataFunction</code>, <code>DoIt</code>, <code>HandleStuff</code> 还有 <code>do_args_method。</code></p><h3 id="首字母大写的缩写"><a href="#首字母大写的缩写" class="headerlink" title="首字母大写的缩写"></a>首字母大写的缩写</h3><p>用首字母大写缩写（比如 GNU 代表 GNU’s Not Unix) 使代码简洁难懂。真正的汉子 (无论男女) 从来不说明这种缩写的含义，他们生下来就懂。</p><h3 id="辞典大轮换"><a href="#辞典大轮换" class="headerlink" title="辞典大轮换"></a>辞典大轮换</h3><p>为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如 display, show, present。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名 (例如，对于 “写入文件”, “在纸上书写” 和 “屏幕显示” 都用 print 来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的 _信息隐藏原则_。</p><h3 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h3><p>随机地把单词中间某个音节的首字母大写。例如 <code>ComputeReSult()</code>。</p><h3 id="重用命名"><a href="#重用命名" class="headerlink" title="重用命名"></a>重用命名</h3><p>在语言规则允许的地方，尽量把类、构造器、方法、成员变量、参数和局部变量都命名成一样。更高级的技巧是在 {} 块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个示例的范围。特别是在 Java 代码中，可以把普通方法伪装成构造器。</p><h3 id="使用非英语字母"><a href="#使用非英语字母" class="headerlink" title="使用非英语字母"></a>使用非英语字母</h3><p>在命名中偷偷使用不易察觉的非英语字母，例如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">typedef <span class="hljs-keyword">struct</span> &#123; <span class="hljs-built_in">int</span> i; &#125; ínt;<br></code></pre></td></tr></table></figure><p>看上去没啥不对是吧？嘿嘿嘿… 这里的第二个 ínt 的 <code>í</code> 实际上是东北欧字母，并不是英语中的 <code>i</code>。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。</p><h3 id="巧妙利用编译器对于命名长度的限制"><a href="#巧妙利用编译器对于命名长度的限制" class="headerlink" title="巧妙利用编译器对于命名长度的限制"></a>巧妙利用编译器对于命名长度的限制</h3><p>如果编译器只区分命名的前几位，比如前 8 位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成 <code>var_unit_update()</code>，有时候又写成 <code>var_unit_setup()</code>，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个变量 <code>var_unit</code>。</p><h3 id="下划线，一位真正的朋友"><a href="#下划线，一位真正的朋友" class="headerlink" title="下划线，一位真正的朋友"></a>下划线，一位真正的朋友</h3><p>可以拿 _ 和 __ 作为标示符。</p><h3 id="混合多语言"><a href="#混合多语言" class="headerlink" title="混合多语言"></a>混合多语言</h3><p>随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿。</p><h3 id="扩展-ASCII-字符"><a href="#扩展-ASCII-字符" class="headerlink" title="扩展 ASCII 字符"></a>扩展 ASCII 字符</h3><p>扩展 ASCII 字符用于变量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入。</p><h3 id="其他语言的命名"><a href="#其他语言的命名" class="headerlink" title="其他语言的命名"></a>其他语言的命名</h3><p>使用外语字典作为变量名的来源。例如，可以用德语单词 <em>punkt</em> 代替 _point_。除非维护代码的程序员也像你一样熟练掌握了德语。不然他就只能尽情地在代码中享受异域风情了。</p><h3 id="数学命名"><a href="#数学命名" class="headerlink" title="数学命名"></a>数学命名</h3><p>用数学操作符的单词来命名变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">openParen = (slash + asterix) / equals;<br>(左圆括号 = (斜杠 + 星号)/ 等号；)<br></code></pre></td></tr></table></figure><h3 id="令人眩晕的命名"><a href="#令人眩晕的命名" class="headerlink" title="令人眩晕的命名"></a>令人眩晕的命名</h3><p>用带有完全不相关的感情色彩的单词来命名变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">marypoppins = (superman + starship) / god;<br>(欢乐满人间 = (超人 + 星河战队)/ 上帝；)<br></code></pre></td></tr></table></figure><p>这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔。</p><h3 id="何时使用-i"><a href="#何时使用-i" class="headerlink" title="何时使用 i"></a>何时使用 i</h3><p>永远不要把 <code>i</code> 用作最内层的循环变量。 用什么命名都行，就是别用 <code>i</code>。把 <code>i</code> 用在其他地方就随便了，用作非整数变量尤其好。</p><h3 id="惯例-–-明修栈道，暗度陈仓"><a href="#惯例-–-明修栈道，暗度陈仓" class="headerlink" title="惯例 – 明修栈道，暗度陈仓"></a>惯例 – 明修栈道，暗度陈仓</h3><p>忽视 <a href="http://java.sun.com/docs/codeconv/">Java 编码惯例</a>，Sun 就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它。例如， <em>inputFilename</em> 和 <em>inputfileName</em> 两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以痛扁其他人，说他们违反了惯例。</p><h3 id="小写的-l-看上去很像数字-1"><a href="#小写的-l-看上去很像数字-1" class="headerlink" title="小写的 l 看上去很像数字 1"></a>小写的 l 看上去很像数字 1</h3><p>用小写字母 l 标识 long 常数。例如 10l 更容易被误认为是 101 而不是 10L 。 禁用所有能让人准确区分 uvw wW gq9 2z 5s il17|!j oO08 `‘“ ;,. m nn rn {[()]} 的字体。要做个有创造力的人。</p><h3 id="把全局命名重用为私有"><a href="#把全局命名重用为私有" class="headerlink" title="把全局命名重用为私有"></a>把全局命名重用为私有</h3><p>在 A 模块里声明一个全局数组，然后在 B 模块的头文件里在声明一个同名的私有数组，这样看起来你在 B 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况。</p><h3 id="误导性的命名"><a href="#误导性的命名" class="headerlink" title="误导性的命名"></a>误导性的命名</h3><p>让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫 <code>isValid(x)</code> 的方法在判断完参数 x 的合法性之后，还顺带着把它转换成二进制并保存到数据库里。</p><h2 id="伪装"><a href="#伪装" class="headerlink" title="伪装"></a>伪装</h2><blockquote><p>当一个 bug 需要越长的时间才会暴露，它就越难被发现。<br>- Roedy Green（本文作者）</p></blockquote><p>编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式。</p><h3 id="把代码伪装成注释，反之亦然"><a href="#把代码伪装成注释，反之亦然" class="headerlink" title="把代码伪装成注释，反之亦然"></a>把代码伪装成注释，反之亦然</h3><p>下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;array_len; j+ =<span class="hljs-number">8</span>)<br>  &#123;<br>  total += array[j+<span class="hljs-number">0</span> ];<br>  total += array[j+<span class="hljs-number">1</span> ];<br>  total += array[j+<span class="hljs-number">2</span> ]; <span class="hljs-comment">/* Main body of</span><br><span class="hljs-comment">  total += array[j+3]; * loop is unrolled</span><br><span class="hljs-comment">  total += array[j+4]; * for greater speed.</span><br><span class="hljs-comment">  total += array[j+5]; */</span><br>  total += array[j+<span class="hljs-number">6</span> ];<br>  total += array[j+<span class="hljs-number">7</span> ];<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果不是用绿色标出来，你能注意到这三行代码被注释掉了么？</p><h3 id="用连接符隐藏变量"><a href="#用连接符隐藏变量" class="headerlink" title="用连接符隐藏变量"></a>用连接符隐藏变量</h3><p>对于下面的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> local_var xy_z</span><br></code></pre></td></tr></table></figure><p>可以把 “xy_z” 打散到两行里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> local_var xy\</span><br>_z <span class="hljs-comment">// local_var OK</span><br></code></pre></td></tr></table></figure><p>这样全局搜索 xy_z 的操作在这个文件里就一无所获了。 对于 C 预处理器来说，第一行最后的 “” 表示继续拼接下一行的内容。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><blockquote><p>任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。<br>- Samuel Butler (1835 - 1902)</p><p>不正确的文档往往比没有文档还糟糕。<br>- Bertrand Meyer</p></blockquote><p>既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失。</p><h3 id="在注释中撒谎"><a href="#在注释中撒谎" class="headerlink" title="在注释中撒谎"></a>在注释中撒谎</h3><p>实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了。</p><h3 id="只记录显而易见的东西"><a href="#只记录显而易见的东西" class="headerlink" title="只记录显而易见的东西"></a>只记录显而易见的东西</h3><p>往代码里掺进去类似于 <code>/* 给 i 加 1 */</code> 这样的注释，但是永远不要记录包或者方法的整体设计这样的干货。</p><h3 id="记录-How-而不是-Why"><a href="#记录-How-而不是-Why" class="headerlink" title="记录 How 而不是 Why"></a>记录 How 而不是 Why</h3><p>只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个 bug，修复者就搞不清这里的代码应有的功能。</p><h3 id="该写的别写"><a href="#该写的别写" class="headerlink" title="该写的别写"></a>该写的别写</h3><p>比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有 25 处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码门都没有，除非他们能把每一行代码都读懂。</p><h3 id="计量单位"><a href="#计量单位" class="headerlink" title="计量单位"></a>计量单位</h3><p>永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如英尺、米、加仑等。计量单位对数豆子不是太重要，但在工程领域就相当重要了。同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效。如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换。</p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>永远不要记录代码中的坑。如果你怀疑某个类里可能有 bug，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来。切记电影《小鹿斑比》里那句台词 “如果你不能说好听的话，那就什么也不要说。”。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句” 这里需要修改 “的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记难得糊涂四个字，这样大家都不会感觉受到了批评。</p><h3 id="说明变量"><a href="#说明变量" class="headerlink" title="说明变量"></a>说明变量</h3><p>永远不要 对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛。如果老板强迫你写注释，就把方法体代码混进去，但绝对不要对变量声明写注释，即使是临时变量！</p><h3 id="在注释里挑拨离间"><a href="#在注释里挑拨离间" class="headerlink" title="在注释里挑拨离间"></a>在注释里挑拨离间</h3><p>为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 优化后的内层循环</span><br><span class="hljs-comment">这套技巧对于 SSI 软件服务公司的那帮蠢材来说太高深了，他们只会</span><br><span class="hljs-comment">用 &lt;math.h&gt; 里的笨例程，消耗 50 倍的内存和处理时间。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clever_SSInc</span></span><br><span class="hljs-class">    </span>&#123;<br>    ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><blockquote><p>编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。<br>- Roedy Green<br>编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像 Java 这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由 C 和 Java 组成的 Algol 语言系列，Abundance 甚至 Smalltalk 对于数组等结构的处理，都是大有可为的。</p></blockquote><h3 id="Java-类型"><a href="#Java-类型" class="headerlink" title="Java 类型"></a>Java 类型</h3><p>Java 的类型机制是上帝的礼物。你可以问心无愧地使用它，因为 Java 语言本身就需要它。每次你从一个 Collection 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从 <code>short</code> 变成 <code>int</code>，所有匹配的造型也都要从 <code>(short)</code>改成 <code>(int)</code>。</p><h3 id="利用-Java-的冗余"><a href="#利用-Java-的冗余" class="headerlink" title="利用 Java 的冗余"></a>利用 Java 的冗余</h3><p>Java 要求你给每个变量的类型写两次表述。 Java 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Bubblegum b = <span class="hljs-keyword">new</span> Bubblegom();<br></code></pre></td></tr></table></figure><p>不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">swimmer = swimner + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="永远不做校验"><a href="#永远不做校验" class="headerlink" title="永远不做校验"></a>永远不做校验</h3><p>永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误。</p><h3 id="有礼貌，无断言"><a href="#有礼貌，无断言" class="headerlink" title="有礼貌，无断言"></a>有礼貌，无断言</h3><p>避免使用 assert() 机制，因为它可能把三天的 debug 盛宴变成 10 分钟的快餐。</p><h3 id="避免封装"><a href="#避免封装" class="headerlink" title="避免封装"></a>避免封装</h3><p>为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的。</p><h3 id="复制粘贴修改"><a href="#复制粘贴修改" class="headerlink" title="复制粘贴修改"></a>复制粘贴修改</h3><p>以效率的名义，使用 复制 + 粘贴 + 修改。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用。</p><h3 id="使用静态数组"><a href="#使用静态数组" class="headerlink" title="使用静态数组"></a>使用静态数组</h3><p>如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比 512 X 512 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 double 类型的数组。</p><h3 id="傻瓜接口"><a href="#傻瓜接口" class="headerlink" title="傻瓜接口"></a>傻瓜接口</h3><p>编写一个名为 “WrittenByMe” 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的 Java 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 WrittenByMe。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口 (例如 WrittenByJoe)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了。</p><h3 id="巨型监听器"><a href="#巨型监听器" class="headerlink" title="巨型监听器"></a>巨型监听器</h3><p>永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的 if…else 来判断是哪一个按钮被点击就行了。</p><p>好事成堆 TM<br>狂野地使用封装和 OO 思想。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">myPanel.add( getMyButton() );<br><span class="hljs-function"><span class="hljs-keyword">private</span> JButton <span class="hljs-title">getMyButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-keyword">return</span> myButton;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这段很可能看起来不怎么好笑。别担心，只是时候未到而已。</p><h3 id="友好的朋友"><a href="#友好的朋友" class="headerlink" title="友好的朋友"></a>友好的朋友</h3><p>在 C++ 里尽量多使用 friend 声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字 private 和 protected 来表明你的类封装得很好。</p><h3 id="使用三维数组"><a href="#使用三维数组" class="headerlink" title="使用三维数组"></a>使用三维数组</h3><p>大量使用它们。用扭曲的方式在数组之间移动数据，比如，用 arrayA 里的行去填充 arrayB 的列。这么做的时候，不管三七二十一再加上 1 的偏移值，这样很灵。让维护代码的程序员抓狂去吧。</p><h3 id="混合与匹配"><a href="#混合与匹配" class="headerlink" title="混合与匹配"></a>混合与匹配</h3><p>存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个 “Java Bean”。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效。</p><h3 id="没有秘密"><a href="#没有秘密" class="headerlink" title="没有秘密"></a>没有秘密</h3><p>把每个方法和变量都声明为 public。毕竟某个人某天可能会需要用到它。一旦方法被声明为 public 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则。</p><h3 id="全堆一块"><a href="#全堆一块" class="headerlink" title="全堆一块"></a>全堆一块</h3><p>把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在 1976 年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你 “不想要重新发明轮子”（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动。</p><h3 id="就是-Final"><a href="#就是-Final" class="headerlink" title="就是 Final"></a>就是 Final</h3><p>把你所有的叶子类都声明为 final。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 java.lang.String 被定义成 final 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度。</p><h3 id="避免布局"><a href="#避免布局" class="headerlink" title="避免布局"></a>避免布局</h3><p>永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对坐标值。如果老板强迫你使用布局，那就写一个巨型的 GridBagLayout 并在里面用绝对坐标进行硬编码。</p><h3 id="全局变量，怎么强调都不过分"><a href="#全局变量，怎么强调都不过分" class="headerlink" title="全局变量，怎么强调都不过分"></a>全局变量，怎么强调都不过分</h3><p>如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出。</p><h3 id="再一次说说全局变量"><a href="#再一次说说全局变量" class="headerlink" title="再一次说说全局变量"></a>再一次说说全局变量</h3><p>全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。C++ 程序员可以百尺竿头更进一步，把所有变量都弄成全局的。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件通常是以 关键字 = 值 的形式出现。在加载时这些值被放入 Java 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和 Java 变量。甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的 5 倍。</p><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p>对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有 10 个属性（成员 / 方法），可以考虑写一个基类，里面只有一个属性，然后产生 9 层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部 10 个属性。如果可能，把每个类的声明都放在不同的文件里。</p><h2 id="编码迷局"><a href="#编码迷局" class="headerlink" title="编码迷局"></a>编码迷局</h2><h3 id="迷惑-C"><a href="#迷惑-C" class="headerlink" title="迷惑 C"></a>迷惑 C</h3><p>从互联网上的各种混乱 C 语言竞赛中学习，追随大师们的脚步。</p><h3 id="追求极致"><a href="#追求极致" class="headerlink" title="追求极致"></a>追求极致</h3><p>总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> *p;<br><span class="hljs-keyword">switch</span> (n)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    p = <span class="hljs-string">&quot;one&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    p = <span class="hljs-string">&quot;two&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    p = <span class="hljs-string">&quot;three&quot;</span>;<br>    printf(<span class="hljs-string">&quot;%s&quot;</span>, p);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一致性的小淘气"><a href="#一致性的小淘气" class="headerlink" title="一致性的小淘气"></a>一致性的小淘气</h3><p>当你需要一个字符常量的时候，可以用多种不同格式： ‘ ‘, 32, 0x20, 040。在 C 或 Java 里 10 和 010 是不同的数（0 开头的表示 16 进制），你也可以充分利用这个特性。</p><h3 id="造型"><a href="#造型" class="headerlink" title="造型"></a>造型</h3><p>把所有数据都以 void * 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩。</p><h3 id="嵌套-Switch"><a href="#嵌套-Switch" class="headerlink" title="嵌套 Switch"></a>嵌套 Switch</h3><p>Switch 里边还有 Switch，这种嵌套方式是人类大脑难以破解的。</p><h3 id="利用隐式转化"><a href="#利用隐式转化" class="headerlink" title="利用隐式转化"></a>利用隐式转化</h3><p>牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。</p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>在所有语法允许的地方都加上分号，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a);<br><span class="hljs-keyword">else</span>;<br>    &#123;<br>    <span class="hljs-keyword">int</span> d;<br>    d = c;<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><h3 id="使用八进制数"><a href="#使用八进制数" class="headerlink" title="使用八进制数"></a>使用八进制数</h3><p>把八进制数混到十进制数列表里，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> []<br>    &#123;<br>    <span class="hljs-number">111</span>,<br>    <span class="hljs-number">120</span>,<br>    <span class="hljs-number">013</span>,<br>    <span class="hljs-number">121</span>,<br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>尽可能深地嵌套。优秀的程序员能在一行代码里写 10 层 ()，在一个方法里写 20 层 {}。</p><h3 id="C-数组"><a href="#C-数组" class="headerlink" title="C 数组"></a>C 数组</h3><p>C 编译器会把 <code>myArray[i]</code> 转换成 <code>_(myArray + i)</code>，它等同于 <code>_(i + myArray)</code> 也等同于 <code>i[myArray]</code>。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> p%q; &#125;<br>...<br>myfunc(<span class="hljs-number">6291</span>, <span class="hljs-number">8</span>)[Array];<br></code></pre></td></tr></table></figure><p>遗憾的是，这一招只能在本地 C 类里用，Java 还不行。</p><h3 id="放长线钓大鱼"><a href="#放长线钓大鱼" class="headerlink" title="放长线钓大鱼"></a>放长线钓大鱼</h3><p>一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于 255 个字符行宽的限制。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>我这里要向你传授一个编程中鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在 main () 里放一个 try/catch，里边直接调用 System.exit() 就行了。在每个方法头要贴上标准的抛出集合定义，到底会不会抛出异常你就不用管了。</p><h3 id="使用异常的时机"><a href="#使用异常的时机" class="headerlink" title="使用异常的时机"></a>使用异常的时机</h3><p>在非异常条件下才要使用异常。比如终止循环就可以用 <code>ArrayIndexOutOfBoundsException</code>。还可以从异常里的方法返回标准的结果。</p><h3 id="狂热奔放地使用线程"><a href="#狂热奔放地使用线程" class="headerlink" title="狂热奔放地使用线程"></a>狂热奔放地使用线程</h3><p>如题。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在程序里留些 bug，让后继的维护代码的程序员能做点有意思的事。精心设计的 bug 是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码。</p><h3 id="永不测试"><a href="#永不测试" class="headerlink" title="永不测试"></a>永不测试</h3><p>永远不要测试负责处理错误、当机或操作系故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。如果用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的。</p><h3 id="永远不要做性能测试"><a href="#永远不要做性能测试" class="headerlink" title="永远不要做性能测试"></a>永远不要做性能测试</h3><p>嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了。</p><h3 id="永远不要写任何测试用例"><a href="#永远不要写任何测试用例" class="headerlink" title="永远不要写任何测试用例"></a>永远不要写任何测试用例</h3><p>永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的 90%，然后把 90% 的测试用在这些路径上。毕竟说起来，这种方法可能只测试到了大约你代码的 60%，这样你就节省了 40% 的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的 “市场特性” 不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节。</p><h3 id="测试是给懦夫用的"><a href="#测试是给懦夫用的" class="headerlink" title="测试是给懦夫用的"></a>测试是给懦夫用的</h3><p>勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行。</p><p>如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的。</p><h2 id="编程语言的选择"><a href="#编程语言的选择" class="headerlink" title="编程语言的选择"></a>编程语言的选择</h2><p>计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言是不人性的。尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用 FORTRAN 或者 COBOL，再不行就用 C 还有 BASIC，实在不行再用 C++。</p><h3 id="FORTRAN"><a href="#FORTRAN" class="headerlink" title="FØRTRAN"></a>FØRTRAN</h3><p>用 FORTRAN 写所有的代码。如果老板问你为啥，你可以回答说有很多它非常有用的库，你用了可以节约时间。不过，用 FORTRAN 写出可维护代码的概率是 0，所以，要达到不可维护代码编程指南里的要求就容易多了。</p><h3 id="用-ASM"><a href="#用-ASM" class="headerlink" title="用 ASM"></a>用 ASM</h3><p>把所有的通用工具函数都转成汇编程序。</p><h3 id="用-QBASIC"><a href="#用-QBASIC" class="headerlink" title="用 QBASIC"></a>用 QBASIC</h3><p>所有重要的库函数都要用 QBASIC 写，然后再写个汇编的封包程序来处理 large 到 medium 的内存模型映射。</p><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步。</p><h3 id="宏汇编调用-C"><a href="#宏汇编调用-C" class="headerlink" title="宏汇编调用 C"></a>宏汇编调用 C</h3><p>如果你有个汇编模块被 C 调用，那就尽可能经常从汇编模块再去调用 C，即使只是出于微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的汇编秘籍。</p><h2 id="与他人共事之道"><a href="#与他人共事之道" class="headerlink" title="与他人共事之道"></a>与他人共事之道</h2><h3 id="老板才是真行家"><a href="#老板才是真行家" class="headerlink" title="老板才是真行家"></a>老板才是真行家</h3><p>如果你的老板认为他 20 年的 FORTRAN 编程经验对于现代软件开发具有很高的指导价值，你务必严格采纳他的所有建议。投桃报李，你的老板也会信任你。这会对你的职业发展有利。你还会从他那里学到很多搞乱程序代码的新方法。</p><h3 id="颠覆技术支持"><a href="#颠覆技术支持" class="headerlink" title="颠覆技术支持"></a>颠覆技术支持</h3><p>确保代码中到处是 bug 的有效方法是永远不要让维护代码的程序员知道它们。这需要颠覆技术支持工作。永远不接电话。使用自动语音答复 “感谢拨打技术支持热线。需要人工服务请按 1，或在嘀声后留言。”，请求帮助的电子邮件必须忽略，不要给它分配服务追踪号。对任何问题的标准答复是 “我估计你的账户被锁定了，有权限帮你恢复的人现在不在。”</p><h3 id="沉默是金"><a href="#沉默是金" class="headerlink" title="沉默是金"></a>沉默是金</h3><p>永远不要对下一个危机保持警觉。如果你预见到某个问题可能会在一个固定时间爆发，摧毁西半球的全部生命，不要公开讨论它。不要告诉朋友、同事或其他你认识的有本事的人。在任何情况下都不要发表任何可能暗示到这种新的威胁的内容。只发送一篇正常优先级的、语焉不详的备忘录给管理层，保护自己免遭秋后算账。如果可能的话，把这篇稀里糊涂的信息作为另外一个更紧急的业务问题的附件。这样就可以心安理得地休息了，你知道将来你被强制提前退休之后一段时间，他们又会求着你回来，并给你对数级增长的时薪！</p><h3 id="每月一书俱乐部"><a href="#每月一书俱乐部" class="headerlink" title="每月一书俱乐部"></a>每月一书俱乐部</h3><p>加入一个计算机每月一书俱乐部。选择那些看上去忙着写书不可能有时间真的去写代码的作者。去书店里找一些有很多图表但是没有代码例子的书。浏览一下这些书，从中学会一些迂腐拗口的术语，用它们就能唬住那些自以为是的维护代码的程序员。你的代码肯定会给他留下深刻印象。如果人们连你写的术语都理解不了，他们一定会认为你非常聪明，你的算法非常深奥。不要在你的算法说明里作任何朴素的类比。</p><h2 id="自立门户"><a href="#自立门户" class="headerlink" title="自立门户"></a>自立门户</h2><p>你一直想写系统级的代码。现在机会来了。忽略标准库， <a href="http://www.roll-your-own.com/">编写你自己的标准</a>，这将会是你简历中的一个亮点。</p><h3 id="推出你自己的-BNF-范式"><a href="#推出你自己的-BNF-范式" class="headerlink" title="推出你自己的 BNF 范式"></a>推出你自己的 BNF 范式</h3><p>总是用你自创的、独一无二的、无文档的 BNF 范式记录你的命令语法。永远不要提供一套带注解的例子（合法命令和非法命令之类）来解释你的语法体系。那样会显得完全缺乏学术严谨性。确保没有明显的方式来区分终结符和中间符号。永远不要用字体、颜色、大小写和其他任何视觉提示帮助读者分辨它们。在你的 BNF 范式用和命令语言本身完全一样的标点符号，这样读者就永远无法分清一段 (…), […], {…} 或 “…” 到底是你在命令行里真正输入的，还是想提示在你的 BNF 范式里哪个语法元素是必需的、可重复的、或可选的。不管怎么样，如果他们太笨，搞不清你的 BNF 范式的变化，就没资格使用你的程序。</p><h3 id="推出你自己的内存分配"><a href="#推出你自己的内存分配" class="headerlink" title="推出你自己的内存分配"></a>推出你自己的内存分配</h3><p>地球人儿都知道，调试动态存储是复杂和费时的。与其逐个类去确认它没有内存溢出，还不如自创一套存储分配机制呢。其实它无非是从一大片内存中 malloc 一块空间而已。用不着释放内存，让用户定期重启动系统，这样不就清除了堆么。重启之后系统需要追踪的就那么一点东西，比起解决所有的内存泄露简单得不知道到哪里去了！而且，只要用户记得定期重启系统，他们也永远不会遇到堆空间不足的问题。一旦系统被部署，你很难想象他们还能改变这个策略。</p><h2 id="其他杂七杂八的招"><a href="#其他杂七杂八的招" class="headerlink" title="其他杂七杂八的招"></a>其他杂七杂八的招</h2><blockquote><p><em>如果你给某人一段程序，你会让他困惑一天；如果你教他们如何编程，你会让他困惑一辈子。</em>– Anonymous</p></blockquote><h3 id="1-不要重编译"><a href="#1-不要重编译" class="headerlink" title="1. 不要重编译"></a>1. 不要重编译</h3><p>让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 – 每个模块都照此办理。<strong>但是不要费劲巴拉地再编译一次了。</strong> 你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。</p><h3 id="2-挫败调试工具"><a href="#2-挫败调试工具" class="headerlink" title="2. 挫败调试工具"></a>2. 挫败调试工具</h3><p>对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句 和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。</p><h3 id="3-公制和美制"><a href="#3-公制和美制" class="headerlink" title="3. 公制和美制"></a>3. 公制和美制</h3><p>在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！</p><h3 id="4-持续改进"><a href="#4-持续改进" class="headerlink" title="4. 持续改进"></a>4. 持续改进</h3><p>要持续不懈地改进。要常常对你的代码做出 “改进”，并强迫用户经常升级 – 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又 “完善 “了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 – 毕竟，为什么要告诉他们本来永远也不会注意到的一些 bug 呢？</p><h3 id="5-”-关于-“"><a href="#5-”-关于-“" class="headerlink" title="5. ” 关于 “"></a>5. ” 关于 “</h3><p>” 关于 “一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的 email 地址等。这样，所有的用户很快就会运行在不同的版本上，在安装 N+1 版之前就试图安装 N+2 版。</p><h3 id="6-变更"><a href="#6-变更" class="headerlink" title="6. 变更"></a>6. 变更</h3><p>在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 – 这会让他们保持警惕，戒骄戒躁。</p><h3 id="7-无需技能"><a href="#7-无需技能" class="headerlink" title="7. 无需技能"></a>7. 无需技能</h3><p>写无法维护代码不需要多高的技能。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。</p><h3 id="8-只带一把锤子"><a href="#8-只带一把锤子" class="headerlink" title="8. 只带一把锤子"></a>8. 只带一把锤子</h3><p>一招鲜吃遍天，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。</p><h3 id="9-规范体系"><a href="#9-规范体系" class="headerlink" title="9. 规范体系"></a>9. 规范体系</h3><p>有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于 MFC 的应用时，就坚持使用 STL 编码风格。</p><h3 id="10-翻转通常的-True-False-惯例"><a href="#10-翻转通常的-True-False-惯例" class="headerlink" title="10. 翻转通常的 True False 惯例"></a>10. 翻转通常的 True False 惯例</h3><p>把常用的 true 和 false 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">#define TRUE <span class="hljs-number">0</span><br>#define FALSE <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (var == TRUE)<br><span class="hljs-keyword">if</span> (var != FALSE)<br></code></pre></td></tr></table></figure><p>某些人肯定会迫不及待地跳出来 “修正” 这种明显的冗余，并且在其他地方照着常规去使用变量 var：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (var)<br></code></pre></td></tr></table></figure><p>还有一招是为 <code>TRUE</code> 和 <code>FALSE</code> 赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 1 和 2 或者 -1 和 0 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在 Java 里也可以用这一招，定义一个叫 <code>TRUE</code> 的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为 Java 里已经有了内建的标识符 <code>true</code>。</p><h3 id="11-第三方库"><a href="#11-第三方库" class="headerlink" title="11. 第三方库"></a>11. 第三方库</h3><p>在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些好的工具仍然一无所知，却还是可以在你简历的 “其他工具” 一节中写上这些没用过的库。</p><h3 id="12-不要用库"><a href="#12-不要用库" class="headerlink" title="12. 不要用库"></a>12. 不要用库</h3><p>假装不知道有些库已经直接在你的开发工具中引入了。如果你用 VC++ 编程，忽略 MFC 或 STL 的存在，手工编写所有字符串和数组的实现；这样有助于保持你的指针技术，并自动阻止任何扩展代码功能的企图。</p><h3 id="13-创建一套-Build-顺序"><a href="#13-创建一套-Build-顺序" class="headerlink" title="13. 创建一套 Build 顺序"></a>13. 创建一套 Build 顺序</h3><p>把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留 SmartJ ，它会让 <code>make</code> 脚本形同废物。类似地，偷偷地定义一个 <code>javac</code> 类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用 <code>sun.tools.javac.Main</code> 编译类来进行编译。</p><h3 id="14-Make-的更多玩法"><a href="#14-Make-的更多玩法" class="headerlink" title="14. Make 的更多玩法"></a>14. Make 的更多玩法</h3><p>用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork () 才是他需要修改的那个。</p><h3 id="15-搜集编码规范"><a href="#15-搜集编码规范" class="headerlink" title="15. 搜集编码规范"></a>15. 搜集编码规范</h3><p>尽可能搜集所有关于编写可维护代码的建议，例如 <a href="http://www.squarebox.co.uk/javatips.html">SquareBox 的建议</a> ，然后明目张胆地违反它们。</p><h3 id="16-规避公司的编码规则"><a href="#16-规避公司的编码规则" class="headerlink" title="16. 规避公司的编码规则"></a>16. 规避公司的编码规则</h3><p>某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K_ONE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K_TWO 2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> K_THOUSAND 999</span><br></code></pre></td></tr></table></figure><h3 id="17-编译器警告"><a href="#17-编译器警告" class="headerlink" title="17. 编译器警告"></a>17. 编译器警告</h3><p>一定要保留一些编译器警告。在 make 里使用 “-” 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，make 工具还是会重新把整个包 build 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的 bug，何必还多此一举让编译器来检查错误呢？</p><h3 id="18-把-bug-修复和升级混在一起"><a href="#18-把-bug-修复和升级混在一起" class="headerlink" title="18. 把 bug 修复和升级混在一起"></a>18. 把 bug 修复和升级混在一起</h3><p>永远不要推出什么 “bug 修复 “ 版本。一定要把 bug 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 bug 的存在并开始称他们为特性。那些真心希望改变这些” 特性 “的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。</p><h3 id="19-在你的产品发布每个新版本的时候都改变文件结构"><a href="#19-在你的产品发布每个新版本的时候都改变文件结构" class="headerlink" title="19. 在你的产品发布每个新版本的时候都改变文件结构"></a>19. 在你的产品发布每个新版本的时候都改变文件结构</h3><p>没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。</p><h3 id="20-抵消-Bug"><a href="#20-抵消-Bug" class="headerlink" title="20. 抵消 Bug"></a>20. 抵消 Bug</h3><p>不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩 3D 棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。</p><h3 id="21-使用旋转锁"><a href="#21-使用旋转锁" class="headerlink" title="21. 使用旋转锁"></a>21. 使用旋转锁</h3><p>不要用真正的同步原语，多种多样的旋转锁更好 – 反复休眠然后测试一个 (non-volatile 的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便，” 通用 “性强，” 灵活 “多变，实为居家旅行必备。</p><h3 id="22-随意安插-sync-代码"><a href="#22-随意安插-sync-代码" class="headerlink" title="22. 随意安插 sync 代码"></a>22. 随意安插 sync 代码</h3><p>把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（critical section）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很” 关键 “（也是 critical）的！</p><h3 id="23-优雅降级"><a href="#23-优雅降级" class="headerlink" title="23. 优雅降级"></a>23. 优雅降级</h3><p>如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何交易过程中对内存中的驱动加锁，并在交易完成后释放或解锁。这样一旦应用非正常终止，I/O 缓存又没有被解锁，NT 服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。</p><h3 id="24-定制脚本语言"><a href="#24-定制脚本语言" class="headerlink" title="24. 定制脚本语言"></a>24. 定制脚本语言</h3><p>在你的 C/S 应用里嵌入一个在运行时按字节编译的脚本命令语言。</p><h3 id="25-依赖于编译器的代码"><a href="#25-依赖于编译器的代码" class="headerlink" title="25. 依赖于编译器的代码"></a>25. 依赖于编译器的代码</h3><p>如果你发现在你的编译器或解释器里有个 bug，一定要确保这个 bug 的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！</p><h3 id="26-一个货真价实的例子"><a href="#26-一个货真价实的例子" class="headerlink" title="26. 一个货真价实的例子"></a>26. 一个货真价实的例子</h3><p>下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 C 函数里展示的高超技巧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">Realocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*buf, <span class="hljs-keyword">int</span> os, <span class="hljs-keyword">int</span> ns)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span>*temp;<br>    temp = <span class="hljs-built_in">malloc</span>(os);<br>    <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">void</span>*)temp, (<span class="hljs-keyword">void</span>*)buf, os);<br>    <span class="hljs-built_in">free</span>(buf);<br>    buf = <span class="hljs-built_in">malloc</span>(ns);<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, ns);<br>    <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">void</span>*)buf, (<span class="hljs-keyword">void</span>*)temp, ns);<br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重新发明了标准库里已有的简单函数。</li><li><em>Realocate</em> 这个单词拼写错误。所以说，永远不要低估创造性拼写的威力。</li><li>无缘无故地给输入缓冲区产生一个临时的副本。</li><li>无缘无故地造型。 memcpy () 里有 (void*)，这样即使我们的指针已经(void*) 了也要再造型一次。另外这样可以传递任何东西作为参数，加 10 分。</li><li>永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看来，要程序运行一段时间才行。</li><li>把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在 Unix 上产 core dump，Windows 就不会。</li><li>很显然，os 和 ns 的含义分别是”old size”和”new size”。</li><li>给 buf 分配内存之后，memset 初始化它为 0。不要使用 calloc ()，因为某些人会重写 ANSI 规范，这样将来保不齐 calloc () 往 buf 里填的就不是 0 了。（虽然我们复制过去的数据量和 buf 的大小是一样的，不需要初始化，不过这也无所谓啦）</li></ul><h3 id="27-如何修复-“unused-variable”-错误"><a href="#27-如何修复-“unused-variable”-错误" class="headerlink" title="27. 如何修复 “unused variable” 错误"></a>27. 如何修复 “unused variable” 错误</h3><p>如果你的编译器冒出了 “unused local variable” 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">i = i;<br></code></pre></td></tr></table></figure><h3 id="28-大小很关键"><a href="#28-大小很关键" class="headerlink" title="28. 大小很关键"></a>28. 大小很关键</h3><p>差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他们踩翻在地。</p><h3 id="29-一张图片顶-1000-句话，一个函数就是-1000-行"><a href="#29-一张图片顶-1000-句话，一个函数就是-1000-行" class="headerlink" title="29. 一张图片顶 1000 句话，一个函数就是 1000 行"></a>29. 一张图片顶 1000 句话，一个函数就是 1000 行</h3><p>把每个方法体写的尽可能的长 – 最好是你写的任何方法或函数都没有少于 1000 行代码的，而且里边深度嵌套，这是必须的。</p><h3 id="30-少个文件"><a href="#30-少个文件" class="headerlink" title="30. 少个文件"></a>30. 少个文件</h3><p>一定要保证一个或多个关键文件是找不到的。利用 includes 里边再 includes 就能做到这一点。例如，在你的 main 模块里，你写上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdcode.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>Stdcode.h 是有的。但是在 stdcode.h 里，还有个引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;a:\\refcode.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>然后，refcode.h 就没地方能找到了。</p><h3 id="31-到处可写，无处可读"><a href="#31-到处可写，无处可读" class="headerlink" title="31. 到处可写，无处可读"></a>31. 到处可写，无处可读</h3><p>至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在 C 或 C++ 里还是可以这样做的。</p><blockquote><p><strong>原始博文发布于：</strong> <a href="http://mindprod.com/unmain.html">Roedy Green’s Mindproducts</a>。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论国内的通货膨胀率</title>
    <link href="/p/79577e180afd4e59b502cc7af0c54964/"/>
    <url>/p/79577e180afd4e59b502cc7af0c54964/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在知乎上面看到的一个长篇评论，对国内的通货膨胀讲解的有理有据，便于此转载一下，供人参考。</p><blockquote><p>原文地址: <a href="https://www.zhihu.com/question/21470072">https://www.zhihu.com/question/21470072</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>小猫猫</p><p>最近有三个信息正在证明我的一个判断，2017 年通货紧缩周期形成后，2018 年将进入自我加速阶段；</p><p>1，按美元计算，2017 年现金收益率高达 11%</p><p>2，任志强先生透露许多房企开年就没钱了，在拼命找钱</p><p>3，某高官在最近达沃斯论坛表态，中国将致力缩小和平衡外贸顺差</p><p>一，假设你 2017 年初有 100 万现金，投入保守型理财，年收益率约 4%，年初人民币约 6.9 元 = 1 美元，年底升值到约 6.4 元，升值超过 7%，这样，你年收益将高达 11%，</p><p>除个别房价上涨的城市外，这是国内理财的最好收益了，而房子你却无法兑现。。。</p><p>大多数网友都没有留意这个现金收益率的历史意义，因为这是 40 年来从未有过的事，</p><p>想想看，从 1978 年到 1998 年，尽管房价没有上涨多少，但物价不断快速上涨，你的现金收益远远落后于物价涨幅。</p><p>想想看，从 1998 年起，不但物价继续涨，房价更是一路飙升，你手里的现金看着看着就变了水。。。</p><p>然而，2017 年，悄悄地就颠倒了这个持续 40 年的历史，现金为王时代来临。。。而且可以预计的是，2018 年不但将延续，而且可能还会加速。。。</p><p>二，据凤凰台报道，任志强先生最近讲话透露，一些房企一开年就国内外到处融资，甚至在出售资产，许多房企没钱了，在拼命找钱。</p><p>这就怪了，刚刚过去的 2017 年可是中国房地产历史上的最大丰收年，销售额和销售面积双双创新高，千亿级房企已经多达 10 多家，如此大好形势，房地产企业怎么会却缺钱呢，这逻辑不通啊，</p><p>任志强先生可是长期活跃在地产界的大佬，对中国的房地产状况可是了如指掌，所述一定是事实。。。</p><p>这是为什么？</p><p>这就是房地产泡沫即将破裂的明显迹象，是通货紧缩正在自我加速的典型现象。。。</p><p>因为，在过去的一年中，房企收获最丰，但负债增加也最多，著名房企万科的资产负债率在销售额突破 5000 亿的同时，负债率也上升了 2 个百分点。。。</p><p>负债率上升意味着资金流动性更加紧张，此时更需要融资，更需要银行贷款，可银行呢，正在缓缓对房地产企业贷款融资关上大门。。。</p><p>许多网友一定会说，这是房地产调控政策的原因，是银监会管控结果。。。</p><p>是吗，这个问题并不好判断，如果房价泡沫由此开始破裂，到底是政策调控的结果，还是房地产泡沫已经到了不得不破的程度。。。</p><p>接下来我简要介绍一个著名日本电影《穿越泡沫时代》。。。大家就知道为什么难以判断了。。。</p><p>未完，待续</p><p>hnpjcw 2018-01-28 13:25<br>好吧，继续学习。<br>尽天事听天人命 2018-01-28 13:32<br>16，17 年房子都已经去库存了，应该赚得盆满钵满，怎么还缺钱？贪心不足，摊子越铺越大？<br>剩余 17 条<br>评论 看全部<br>x8596t<br>2018-01-28 15:04<br>26026 楼<br>继续 385</p><p>日本电影《穿越泡沫时代》拍摄于 2007 年，就是说，拍摄于中国还没有房价泡沫概念之前，或者说，电影作者完全没有受到今天中国房地产泡沫影响，但描述的现象竟然与今天的中国惊人一致。。。</p><p>镜头一，1990 年 3 月 30 日，日本财政部宣布，一项关于限制银行对不动产贷款的条例生效，财务省发言人说，实施这个条例是为了限制地产投机，土地价格降了，大家就买得起房了。。。</p><p>镜头二，真弓小姐从 2007 年穿越到 1990 年房价泡沫高企的日本经济繁荣时代，见到一位刚毕业的大学生，大学生高兴的说，他找到了著名长银银行工作，真弓告诉他，这个银行将会倒闭，</p><p>这个大学生惊讶的回答，银行怎么会倒闭，不可能。</p><p>镜头三，真弓小姐参加了泡沫时代的一个同学聚会，刚报到就得到了一叠免费乘坐出租车的免费卷，接着还得到了一位初次见面的未来明星大方送给她的一条项链，还幸运抽到了奖金 200 万日元。</p><p>仅仅一天什么都没干，就得到了这么多，真弓小姐禁不住高喊；泡沫经济万岁</p><p>镜头四；一群官员，国内外商人正在密谋出台限制不动产银行贷款条例，也是穿越过来的真弓小姐的母亲告诉与会者，千万不要出台这个条例，否则泡沫破裂，房价下跌，银行破产，经济将进入大萧条。。。</p><p>与会财政省官员说，要的就是这个效果，如是把真弓母亲抓起来，要强行通过条咧。。。</p><p>镜头五，经过一番激烈斗争，新任财政省官员宣布；这个限制房地产投机贷款条例宣布撤销，因为这个条例会对经济产生很大的收紧作用，会有很多银行破产。。。</p><p>然而，非常令人深思的是；有记者提问，那面对高房价，财政省打算什么都不做吗？</p><p>新任财政省官员环顾左右而言它；我们目前的繁荣不可能不付代价的结束，泡沫最终会破裂。。。</p><p>当记者紧紧追问财政省将会做些什么时；财政省官员答复，他要回家了。。。</p><p>网友们看看，这些镜头与当今中国的状况是多么的惊人一致；</p><p>银行绝不可能倒闭</p><p>泡沫时代是多么繁荣，钱是多么容易赚</p><p>精英鼓吹，底线是房价泡沫不能破，房价泡沫破裂是美国阴谋，美国发力就可以刺破中国房价泡沫。。。</p><p>2017 年一连串的限购，限售，禁止贷款流入房地产市场的监管政策，条例出台。。。。</p><p>按日本经验，这一系列限制房地产政策出台是可能刺破房价泡沫的，繁荣将会结束，银行将会破产。。。</p><p>不过从这个日本电影判断，至今在日本有一种质疑的舆论，质疑当时的日本政府一系列限制地产的政策是否正确，如果不刺破，是否日本的经济繁荣就能继续。。。</p><p>我解读这个日本电影，。。。看来刺破泡沫是有政治风险的。。。</p><p>所以，由此我得出结论，恐怕没有任何行政力量会愿意主动刺破泡沫，一定会尽最大努力延续泡沫繁荣经济的。。。</p><p>因为，美联储主席格林斯潘说过；泡沫只有破裂后，才知道是泡沫，换句话就是；</p><p>谁知道，今天中国的房地产到底是不是泡沫呢，不是还有经济精英说，房价还没有泡沫，房价还会永远涨。。。哈哈，网友们，你们说呢？<br>继续 387</p><p>今天讨论一个重要的经济原理，消费，投资与经济增长的关系。</p><p>近几年，统计局官员总是摇头晃脑的说，消费占 GDP 比重不断提高，这是经济结构改善，是消费逐渐成为推动经济增长主要动力。。。云云。</p><p>例如，2016 年消费占 GDP 比重达到 64.6%，比 2015 年提高了 9.7 个百分点。。。统计局官员总是把这些当好消息告诉我们。。。</p><p>我十分不解这些经济精英的经济学知识是在哪里学来的？</p><p>1，消费是不可能推动经济增长的，只有投资才能推动经济增长。</p><p>2，消费占 GDP 比重提高决不代表经济结构改善。</p><p>为什么？先从第 1 点说起；</p><p>举例 1，某家庭农场年农产品收入 100 万，那这个家庭该如何安排消费与投资呢？理论上有如下几种安排；</p><p>1,100 万全部吃光用光，这样该农场第二年就没法延续生产了，因为第 2 年的生产需要一定的投入，包括种子，化肥，农药，更新和维修农具，水利灌溉设施等等，这些都需要钱，需要投资。</p><p>所以，如果该农场不投资，不要说第 2 年会增产，连再生产都不可能。</p><p>2，80 万用于消费，20 万用于投资，简单再生产得以继续进行。</p><p>所以，没有投资就不会有经济增长，连简单再生产都无法进行。</p><p>再看所谓消费占比提高是经济结构改善，经济原理证明同样不符合逻辑。</p><p>举例 2，该农场全家节衣缩食，50 万用于消费，50 万用于投资，购买了先进农业机械，第 2 年生产率提高，收入增多。不但可以提高生活水平，还可以滚动高效发展。</p><p>比如，该农场节衣缩食拿出 50 万购买先进农具等，收入从 100 万提高到 120 万，即使还是按 50% 比例消费，50% 比例投资，不但实际消费提高了 10 万，投资也提高了 10 万，生活改善，还为下一年的农场发展奠定基础。</p><p>从以上 2 个例子，我们很容易就理解了如下两条经济原理。</p><p>1，没有投资就没有经济发展</p><p>2，勤俭节约，适当减少消费，提高投资比例更有利于经济发展，所谓消费比例提高就是经济结构改善是逻辑不通的。</p><p>难道中国的经济学家这么笨，连这点道理都不明白，网友一定一头雾水，一定抱着深深的怀疑看待我这个观点。。。</p><p>其实，点破了很简单；</p><p>这个所谓消费占 GDP 比重上升是从美国那里学的，因为美国经济消费占 GDP 比重高达 70% 以上，美国是高收入发达国家，我们要成为高收入国家，当然也要提高消费比重。。。</p><p>这真的让人哭笑不得，不禁使我想起了古代著名的削足适履的故事。。。</p><p>未完待续</p><p>老鼠飞上天 2018-01-30 19:22<br>“勤俭节约，适当减少消费，提高投资比例更有利于经济发展” 的目的是为了将来更好的消费。所以，生产和消费终究是要平衡的。<br>ty_XEN 2018-01-30 19:25<br>刻舟求剑，呵呵！同意！<br>剩余 15 条<br>评论 看全部<br>x8596t<br>2018-01-30 20:22<br>26123 楼<br>继续 388</p><p>接着 387 聊；为什么学美国提高消费占 GDP 比重是削足适履；</p><p>道理很简单，因为中美两国发展阶段不同。</p><p>美国消费比重高是经济全球化的结果，是美国的无可奈何的选择。</p><p>二战后，美国经济快速发展，生活水平提高，劳动力变得昂贵，于是大量向发展中国家转移制造业，制造业逐渐空心化，消费比重当然不得不提高，否则经济就垮下去了，</p><p>所以美国这 20 多年来，不断鼓励老百姓借贷消费，以维持经济增长，结果仍然是经济增长缓慢，基础设施等得不到更新，。。</p><p>这就是许多中国人跑到美国去，大喊美国落后，中国基础设施先进的原因。。。这就是美国经济消费比例高，投资比例小的原因造成的。。。</p><p>反观中国，我们仍然处于中等收入的发展阶段，这个阶段不但制造业不能丢，还得大力投资，还得加快发展，改变严重的地方贫富差距，完善基础设施等等。。。为中国尽快成为高收入国家奠定基础。。。</p><p>换句话说，中国还没有到要提高消费比重阶段，还不应该提倡消费，反而还应该提倡勤俭节约，积累资本，增加投资。。。</p><p>为什么中国现在就进入了消费比重不断提高的经济状况了呢，这其实不是什么好的经济现象。。。</p><p>原因是什么呢，其实很简单，就是债务太高，因为多年来总是吃光用光，投资全靠借，弄得债台高筑。。。</p><p>俗话说，不听老人言，吃亏在眼前，</p><p>亚当斯密早在 200 多年前的《国富论》中告诫我们说；勤劳不能积累资本，只有节俭才能积累资本。。。</p><p>同时还告诫我们说，不要从银行借贷投资，不要从银行借贷消费，银行的借贷只应该用于解决商人的资金流动性，盘活商人的准备金。。。</p><p>例如，某商人有 100 万流动资金，但他往往不能全部投入，得留一部分作为备用金，以防万一，亚当斯密赞成银行给这位商人借贷流动资金，这样该商人就可以把全部 100 万用于经营了，就提高了资金运用效率。。。</p><p>许多网友一定认为这亚当斯密理论太老化了，不适应今天的经济发展了。。。</p><p>真的吗，我下面举出 2 个实际例子，网友大家评；</p><p>举例 1，前 30 年计划经济时，是没有银行借贷业务的，就是说，不能从银行借贷投资，借贷消费的。。。</p><p>所以，那时要投资就得勤俭节约，积累资金用于投资，发展经济，所以，那时有个广为人知的口号 “为国家建设节约每一分钱”</p><p>这种硬碰硬的经济发展方式，导致 30 年后留下了一个十分良好的发展基础，这就是；既无内债又无外债。。。干干净净，无债一身轻。。。</p><p>有网友一定说，那时经济发展慢，现在虽然欠债，但发展快，是吗？恐怕要打个疑问号。</p><p>我们实事求是的比较一下；</p><p>举例 2，</p><p>假设 1949 年到 1979 年 30 年中国经济从 1000 亿发展到 2000 亿，经济总量提高了 1 倍。但没有 1 分钱债务。</p><p>假设按不变价算，从 1979 年到 2009 年 30 年，经济总量从 2000 亿提高到 8000 亿，经济总量提高了 4 倍，但负债 6000 亿，结果是；去掉这 6000 亿债务还是只增长 2000 亿，不会比前 30 年强。。。</p><p>有网友一定不服气；不对不对，债务虽然很高，但主要是国内债务，是左手与右手，左</p><p>口袋与右口袋的关系。。。</p><p>真的吗，国内债务是左手与右手的关系吗，或者说，还不还无所谓。。。。</p><p>真的吗，我们从今天起，就大手一挥，所有债务一风吹。。。。</p><p>到底是不是无所谓，是不是可以一风吹。。。我们接下来讨论，甚至辩论。。。</p><p>未完，待续</p><p>夏尘埃 2013 2018-01-30 20:33<br>请教楼主，看新闻开发商竞拍价格第一后继续自己给自己加价拿地是什么意思？<br>xieyu007007 2018-01-30 21:05<br>套路，不敢不加价，你懂的<br>剩余 12 条<br>评论 看全部<br>x8596t<br>2018-01-31 04:38<br>26137 楼<br>@第一 MP 2018-01-30 23:02:10</p><p>楼主所言差矣，有空再辩。先指出一点，前 30 年经济增长一倍，后 30 年增长 4 倍，去掉债务和前 30 年一样…… 这犯了最基本的错误，不能用货币量和 Gdp 量对比，因为单位是货币单位，而不是购买力。经济发展的结果不是一个 Gdp 数字，而是物质财富，近 30 年的物质财富是前 30 年的上百倍，只是价格大大降低，最终用货币量衡量差异不明显。这就是所谓的 “百姓福祉”，负作用是污染等…… 大家就想想现在你家里有啥东西，79 年家里有啥东西…………</p><hr><p>你对前 30 年充满了偏见；</p><p>1，按国家统计局数据，年平均 GDP 增速，前 30 年只比后 30 年低一个百分点。何来什么几百倍。</p><p>2，电视机，手机等都是科技发明进步，再落后的非洲国家也在用手机。</p><p>3,1979 年与 1949 年比那也是天翻地覆的变化，</p><p>4，如果你去过印度，你就知道前 30 年是如何伟大了。</p><p>5，前 30 年给中国留下了两弹一星，完整的科研工业体系，基本普及高小，初中教育，医疗卫生体系，获得如此巨大成就却没有给后面的留下一分钱债务。。。</p><p>假设，1979 年留下的是一个债台高筑的经济体，你认为还有可能搞什么改革开放吗？？</p><p>第一 MP 2018-01-31 04:53<br>我对前 30 年没有偏见，前 30 年和后 30 年的差异是百姓生活的财富差别，这个可以让大家来感觉…… 两弹一星恰恰是你前述所有例子的反证，即没有任何收益的资本投入，只不过是国家资本。抛开安全因素，纯从经济学来说，两弹一星就是你说的货币黑洞，朝鲜仍有这个黑洞<br>第一 MP 2018-01-31 05:08<br>1979 如果留下的是一个债务重重的经济体，还会有现在的改革开放吗？…… 没错啊，假设 49 年改革开放，估计 1979 年就债务重重了，不就是改革开放提前了吗？呵呵。最终不就是要进步吗<br>剩余 19 条<br>评论 看全部<br>x8596t<br>2018-01-31 14:22<br>26164 楼<br>继续 389</p><p>今天聊 2 个问题；</p><p>1，国内债务是不是左手与右手，债务可以一风吹</p><p>2，近年消费占 GDP 比重上升，是经济结构改善吗，消费成为推动经济增长主要动力是好现象吗？</p><p>先看第 1 个问题；</p><p>不用说什么深奥的大道理，只需凭生活常识就可以明白。</p><p>2017 年大约有 20 多万亿理财产品，也就是 20 万亿债务，不还了，一风吹了，那就是有无数人的 20 多万亿现金没了，可能吗，你同意吗。</p><p>2017 年全银行系统有贷款余额 120 万亿，如果不还了，一风吹了，结果就是所有银行倒闭无数次，更重要的是 120 万亿货币也没了，也就是现有 170 万亿货币总量只剩下 50 万亿了。。。</p><p>所以说国内债务不要紧的专家就是砖家，普通百姓恐怕是在用骨头想。。。</p><p>相反，外债倒是好办，免掉就免掉了，只会占便宜，例如中国免掉非洲国家那么多债务，欠债国家就占便宜了。。。</p><p>我们再看第 2 个问题；</p><p>我们用数据说话；</p><p>2015 年，M2 净增额 16.4 万亿，居民贷款 3.8 万亿，占货币净增额的比例；23%</p><p>2016 年，M2 净增额 15.8 万亿，居民贷款 6.3 万亿，占货币净增额的比例；40%</p><p>2017 年，M2 净增额 12.6 万亿，居民贷款 7.1 万亿，占货币净增额的比例；56%</p><p>网友看看，居民贷款占比快速上升，一年比一年高，与这几年消费占 GDP 比重不断升高完全一致</p><p>这就道出了一个公开的秘密，即；消费占 GDP 比重是靠普通百姓大幅增加借债取得的。</p><p>也就是说，老百姓用大幅透支自己的未来收入，提高了消费占 GDP 比重，</p><p>这就是经济精英口中的经济结构改善？</p><p>这就是经济精英口中的消费成为经济增长主要推动力？</p><p>这只能说明，中国老百姓很可爱，很善良，很爱国，宁愿用将来的节衣缩食来支持所谓经济结构改善，成为推动经济增长的主要动力。。。。</p><p>天理良心何在。。。</p><p>以上数据可都是来自国家统计局，我可没有加油添醋，只是分析角度不一样，网友们认为这种分析角度对吗。。。</p><p>接下来我们还可以从另一个角度分析 GDP。。。</p><p>未完，待续</p><p>ty_133106929 2018-01-31 14:27<br>这一段不错？？拜读<br>夏尘埃 2013 2018-01-31 14:42<br>如楼主所言，贷款投资基建不可以，贷款消费不可以，那经济增长何去何从呢？<br>剩余 15 条<br>评论 看全部<br>x8596t<br>2018-02-01 13:50<br>26191 楼<br>继续 390</p><p>今天我们从另一个角度看 GDP，即；从老百姓的实际生活角度看。。。</p><p>对普通百姓来说，是不会关心 GDP 增速的，老百姓只关心自己的生活水平能否实实在在提高，实际收入能否跑赢物价涨幅，跑赢多少。。。</p><p>从过去 30 多年的实际看，中国 GDP 一直高速增长，总体来说，老百姓收入还是跑赢物价涨幅的，就是说老百姓的生活水平这几十年有了极大提高。。。（请网友注意，我这里说的是收入跑赢物价涨幅，与以前说过的银行利率跑赢物价涨幅是两个不同概念）</p><p>问题是老百姓并不满意，或者说还有相当部分老百姓感到忧虑，或者说有如下三大不良后果；</p><p>1，收入跑赢了 CPI 物价涨幅，但却跑输了房价涨幅，甚至是大幅跑输了房价，</p><p>以北京为例，10 年前 1 个月工资再不济也能买 0.2 个平米房子吧，现在恐怕连 0.1 个平米也买不到了吧。。。</p><p>这就造成了相当数量的高负债房奴几乎生活在还贷压力和房价下跌的恐惧之中。生活一点都不轻松。。。</p><p>2，延迟退休，养老金亏空的忧虑和恐惧，严重损害了普通老百姓的长远利益。。</p><p>别小看养老金不够发的问题，今天绝大部分西方发达国家几乎都深陷不得不动用大量财政资金来弥补养老亏空和福利的黑洞中。。。成为西方国家财政不可持续的关键因素之一。。。</p><p>原因很简单，这就是西方市场经济国家长期运用凯恩斯理论，刻意用温和通货膨胀刺激经济增长的必然结果。因为长期的通货膨胀导致货币价值不断下降，也必然导致积累的巨量的养老金价值下降。。。</p><p>例如，30 年前当你月工资 100 元时，按 28% 比例交 28 元养老金，但 30 年后这 28 元养老金已经贬值到几乎一钱不值，等于白交了。。。</p><p>用凯恩斯理论发展创造 GDP 的后果是非常残酷的，网友们到西方国家去，你们可以看到大量白发苍苍的老头老太太还在工作，而中国的许多中年妇女已经在每天跳广场舞了。。。</p><p>比较起来，中国妇女 50 岁退休是不是太幸福了，然而这个幸福竟然将伴随所谓几十年高速经济发展的赞歌声中而结束。。。真是莫大的讽刺啊。。。。</p><p>3，无论是政府还是普通百姓无一不是债台高筑，特别是西方老百姓，遗憾的是中国老百姓近年也急起直追。。。不说了，说起来那些高负债房奴满眼都是泪。。。</p><p>好了，当我们明白依托凯恩斯理论的 GDP 发展效果和弊病后，再具体分析一下中国 2017 年 GDP。。。看看会给我们带来那些启发。。。<br>继续 391</p><p>今天紧贴时事，聊一个最时髦话题，为什么这半年来人民币会疯狂升值，这出乎许多人的预料，包括经济精英。。。</p><p>与此同时，美元变得越来越宝贵，资本管制是越来越严格，国外消费 1000 元以上要报央行，一年最高 10 万元限额。。等等。</p><p>我要给这个最新经济现象一个有点难听的名称；美元荒</p><p>这个 “美元荒” 是继 “钱荒” 后的又一个信号，是客观经济规律给中国经济的又一个重要信号，通知中国经济必须放弃行政力量与客观经济规律规律的抗衡了，再不放弃，客观经济规律就会让你按下葫芦浮起瓢，顾得了这头，顾不了那头。。。</p><p>网友们应该记得，仅仅 3 到 4 年前，中国还在嫌美元太多，官员感叹，外汇储备太多，头痛，老百姓在国外买买买，，牛气冲天，转眼之间又变成美元太少，闹起 “美元荒” 了。</p><p>这到底是怎么回事，为什么会这样，下一步会发生什么，让我们从最基本的经济原理谈起。。。</p><p>懂得一些最基本经济原理是非常重要的，为什么古代 “秀才不出门，全知天下事”，就是因为秀才掌握了知识，所以能够根据道听途说得来的信息，判断天下的大趋势。。。</p><p>美元荒是反常经济现象，其根源就在中国经济精英界长期坚持的对外贸易错误观点；</p><p>这个错误观点就是；出口多好。出口顺差好，以至于行政力量长期只关注 GDP，而不重视对外贸易均衡和人民币汇率对国家经济的决定性作用。。。</p><p>我们还是以举例的方式来说明一些基本经济原理；</p><p>举例 1，在黄金白银作货币时代，大清朝对英帝国大量出口丝绸，茶叶等，大量白银源源不断流于入中国。。。</p><p>与此同时，大清朝闭关锁国，制造种种障碍禁止英国的先进商品进口，从而造成中英贸易不平衡。。。</p><p>英帝国只好来邪的，默许英国商人出口鸦片来实现中英贸易平衡。。。结果导致了著名的鸦片战争。。。</p><p>请网友注意，鸦片战争签订不平等条约中最重要条款就是开放中国沿海 10 多个城市港口，与外国自由贸易。。。</p><p>在今天的人看来，不就是开放对外贸易吗，咋看都不像是不平等条约啊。。。</p><p>这个例子充分说明，两国之间的贸易一定要平衡，如果一国对另一国长期贸易顺差，那对逆差国是不公平的，如果长期逆差，会遭到逆差国反抗，甚至战争的。。。</p><p>以上例子说的是黄金白银为货币的时代，那么今天的纸币体系时代呢？</p><p>未完，待续</p><p>hnpjcw 2018-02-02 14:27<br>学习了。<br>ty_XEN 2018-02-02 14:59<br>太好了，期待下文！<br>剩余 11 条<br>评论 看全部<br>x8596t<br>2018-02-02 15:38<br>26219 楼<br>继续 382</p><p>接着聊 “美元荒”</p><p>在纸币体系时代，对外贸易有个很大不同特点；</p><p>在黄金白银时代，你出口越多，顺差越大，你获取的黄金白银就越多，你就越占便宜，因为你得到的是有价值的真金白银，而不是纸币，而纸币的价值是由该国政府决定的，多印刷，该国纸币价值就降低。。。</p><p>所以，在纸币时代，就更要讲究进出口平衡了，否则你多出口，得到的是人家的纸币，是没有多大意义的，实际是吃亏的、、、</p><p>以中美贸易为例，中国对美国贸易长期顺差，多年来，每年对美贸易顺差少则 1 到 2 千亿，多则 3 到 4 千亿美元，这其实都是美元纸币，对中国经济是没有多大实际意义的，</p><p>可，中国经济精英像着了迷一样，喜欢美元纸币，。。</p><p>2005 年，美国贸易代表来到中国，试图强迫人民币升值，甚至建议人民币一次性升值 25%，相关官员连连摆手，不可能，那怎么得了，那会有多少血汗工厂关闭，多少工人失业啊。。。</p><p>结果达成妥协，人民币缓慢升值。。。由于升值力度不够，对美贸易顺差仍然高居不下，外汇储备继续飙升，到 2014 年，外汇储备达到创纪录的约 4 万亿美元。。。</p><p>然而，这 4 万亿美元哪里来的呢，事实证明大部分是从美联储印钞机来的。。。不信，请看下列数据；</p><p>2008 年中国外汇储备突破 1 万亿美元，达到 10600 亿美元。到 2014 年增加到 4 万亿美元，净增约 3 万亿美元。</p><p>2008 年美联储开动印钞机救市，美联储资产负债表中的美元基础货币从约 9000 亿美元上升到 2014 年的约 4.5 万亿美元，净增约 3.6 万亿美元。</p><p>这是偶然的巧合吗，事实是；美联储印刷的 3.5 万亿美元纸币确实大部分到了中国。。。</p><p>想想看，中国这 3 万亿美元外汇储备可是无数打工者的血汗劳动换来的，是无数个集装箱，装载着无数中国产实体商品，浩浩荡荡运到美国换来的。。。</p><p>而美国呢，美联储仅仅开动印钞机，印了 3 万亿美元给中国，轻轻松松换来中国巨额实物商品，美国人占大便宜了。。。。</p><p>可，遗憾的是，美国占了便宜还卖乖，年年指责中国操纵汇率，要求中国开放市场，特别是中国农业深受其害，作为大豆之乡的中国，大豆首先沦陷。。。</p><p>说起中美贸易，真是满眼都是泪啊，。。。</p><p>然而事情还远未就此结束，特朗普政府上台后，变本加厉。。。。</p><p>未完，待续</p><p>碧海蓝天已被使用 2018-02-02 16:43<br>同意楼主观点，楼主知识渊博，佩服佩服。<br>ty_终于白首 872 2018-02-02 17:12<br>这回不是马上超美了！看看血月今年注定是不平凡的一年，满朝文武拿绿卡！老百姓苦了<br>剩余 13 条<br>评论 看全部<br>x8596t<br>2018-02-03 13:13<br>26252 楼<br>继续 393</p><p>前面聊 “美元荒” 的 392 错成了 382.</p><p>为什么说，与前任美国总统不同，特朗普政府会变本加厉压制中国，会不惜重大代价也要缩小中国对美贸易顺差呢？</p><p>道理不复杂，这就是因为美联储的缩表，也就是美联储不再开动印钞机给美国政府输血了。</p><p>那，为什么缩表就会导致特朗普政府要尽力缩小对外贸易逆差呢，特别是来自中国的逆差，。。</p><p>举例；假设 2018 年美国出口 7000 亿美元，进口 1 万亿美元，逆差 3000 亿美元，</p><p>按照以前的做法，美联储开动印钞机印刷了 3000 亿美元投入市场，意味着这 3000 亿美元间接支付了 3000 亿美元逆差，否则，这 3000 亿美元就得从存量资金中支付，也就是得从老百姓口袋中支付。。。</p><p>这就导致美国老百姓的实际消费会减少 3000 亿美元，直接就拉低美国的 GDP，当然特朗普就不会干了，</p><p>而来自中国的 3000 多亿美元逆差占全美贸易逆差 5000 亿美元的约 70%，理所当然，特朗普政府会盯住中国不放了。。。</p><p>为了美国的 GDP，精明商人特朗普早就拨拉着算盘算好了，一些中国经济精英还在试图用所谓双输，双赢的道理像说服前任美国总统一样，说服特朗普，恐怕只能是一厢情愿了。</p><p>面对超 3 万亿美元的巨额中国外汇储备，已经关闭印钞机的美国不惦念，谁惦念，中国有句老话；这钱啊，不怕贼偷，就怕贼惦念。。。。哈哈。</p><p>现在我们再来看中国。。。</p><p>未完，待续</p><p>评论 看全部<br>x8596t<br>2018-02-03 14:41<br>26256 楼<br>继续 394</p><p>接着 393 聊，我们来看中国的对美贸易顺差，解释一下为什么今天中国闹 “美元荒” 的真实原因；</p><p>先看下列两组数据；</p><p>第一组；从 2014 年到 2017 年中国对美贸易顺差数据</p><p>2014 年，对美贸易顺差约 2400 亿美元</p><p>2015 年，对美贸易顺差约 3700 亿美元</p><p>2016 年，对美贸易顺差约 3400 亿美元，</p><p>2017 年，估计对美贸易顺差也在 3000 亿美元以上。</p><p>四年合计；对美贸易顺差总额约 1.25 万亿美元。</p><p>众所周知，按 GDP 核算公式；顺差就直接增加了中国 GDP，相反逆差的美国 GDP 就被直接拉低了。。。</p><p>1.25 万亿美元啊，这对中美两国都是巨额，假设某个经济谋士拨拉着算盘，把这个帐算给特朗普看，特朗普岂不勃然大怒，咬牙切齿。。。</p><p>如果换成早几年，美联储 QE 量化宽松，大印美元时，美国还会偷着乐，可美国关闭印钞机已经 2 年多了，现在支付中国的可不是兑了水的美元啊，可是真金白银了啊。。。</p><p>再看第二组数据；2014 年和 2017 年 M2 货币总量与外汇储备的比值</p><p>2014 年中国 M2 总量约 122 万亿，外汇储备约 4 万亿美元，当年平均汇率；1 美元 = 6.14 元</p><p>换算成比值；122 万亿 ÷（4 万亿 X6.14）=4.96 元</p><p>这意味着人民币还有很大的升值压力。因为实际汇率高于比值 1.18 元</p><p>2017 年中国 M2 总量约 167 万亿，外汇储备约 3.1 万亿美元，按当年平均汇率；大约 1 美元 = 6.4 元。</p><p>换算成比值；167 万亿 ÷（3.1 万亿 X6.4）=8.41 元</p><p>这意味着人民币有很大的贬值压力，因为实际汇率低于比值 2.01 元。</p><p>网友们看清楚了，人民币汇率处于一种相互矛盾的状态中。</p><p>从对美贸易顺差看，人民币币值被严重低估，人民币有着巨大的升值潜力。</p><p>相反，从 M2 总额与外汇储备币值看，人民币却是被严重高估，人民币有着巨大的贬值压力。</p><p>这到底信哪一个，问题是，这两个都是真实的，信了这个就信不了那个，反之亦然。。。</p><p>这就导致我们看到了极不正常的人民币汇率波动现象；</p><p>2015 年 811 汇改，人民币从 6.2 元一路贬值到 2017 年初的 6.95 元，央行不得不釜底抽薪，收缩境外人民币，以牺牲人民币国际化进程为代价止住了贬值。</p><p>不料，从 2017 年 5 月起，到 2018 年 1 月，人民币又一路疯狂升值，从 6.95 元一路升值到今天的 6.30 元。。。</p><p>有经济精英一定会说，这很好，很正常吗，央行要的就是汇率双向波动吗。。。</p><p>真的吗？我一句话就要让这些经济精英目瞪口呆，哑口无言。。。。</p><p>很简单，因为这人民币升值和贬值的原因竟然都是同一个；“缺美元” 或叫 “美元荒”</p><p>这就是天下奇闻了，无论升值贬值都是缺美元，这太奇怪了，因为按原理只有贬值才是缺美元啊，怎么升值也会缺美元呢？</p><p>我估计，问遍世界上的经济学家，他们只能感叹，奇迹啊，奇迹啊，这奇迹真的只有中国才能创造。。。</p><p>所以有中国经济学家常常引以为傲，中国经济奇迹是西方经济学不能解释的，这是又一证明。。。哈哈。</p><p>那么到底是什么原因会造成这种经济现象呢？</p><p>我曾经做个形象的比喻，把客观经济规律比作幼小树苗，把行政权力比作大石头，大石头不断压迫树苗，但树苗却一定会顽强抗衡，一定会绕过大石头，顽强地从石头缝隙里弯弯曲曲生长出来，不过虽然生长出来了，但一定是扭扭曲曲的。。。。</p><p>ty_自留地 66 2018-02-03 15:11<br>有道理<br>大狗熊 2018-02-03 15:12<br>继续<br>剩余 19 条<br>评论 看全部<br>x8596t<br>2018-02-04 13:51<br>26278 楼<br>@atian110 2018-02-04 11:15:19</p><p>在第十六届企业发展高层论坛上的讲话</p><p>楼继伟</p><p>2018 年 1 月 28 日</p><p>谢谢主持人的介绍，各位来宾，女士们，先生们：</p><p>大家下午好！非常高兴参加此次论坛。按照会议安排，围绕新时代宏观经济形势这个主题，我主要从以下三个方面谈谈个人的观点。</p><p>第一，年度经济指标是超预期的，反映出良性变化的趋势。</p><p>2017 年主要经济指标都在可接受的范围，部分指标甚至在上限区。从经济总量看，GDP 达到 82.7 万亿元，增长 6…….</p><hr><p>继续 395</p><p>非常感谢这位 ati110 网友，我正打算就楼先生提供的经济数据聊一下中美日三国经济发展趋势，恰遇网友提供这个资料，真是人多力量大啊。。。</p><p>我们先以楼先生提供的数据，列出中美日三国的最重要宏观经济数据如下；</p><p>日本；拆借利率；0.01%，政府债务；250%/GDP，M2；200%/GDP，总债务；400/GDP</p><p>美国；拆借利率；1.1%， 政府债务；100%/GDP，M2；91%/GDP，总债务；300/GDP</p><p>中国；拆借利率；4.09%，政府债务；50%.GDP，M2；200%/GDP, 总债务；300/GDP</p><p>依据以上数据，我们基本可以判断，中美日三国经济状况都没能跳出凯恩斯理论框框，即；都不同程度的掉入了流动性陷阱。</p><p>让我们一个个看；</p><p>先看日本；</p><p>日本的流动性陷阱特征最为明显和典型，银行拆借利率竟然是负数，-0.01，这在市场经济中是不可想象的，甚至也超越了凯恩斯理论，凯恩斯想到了零利率，却万万没想到还有负利率，由此可见日本掉入流动性陷阱之深。。。</p><p>日本在 20 多年前房价泡沫破裂后，就逐步掉入流动性陷阱，利率逐步降至零，甚至负利率，毫无疑问，零利率就是流动性陷阱的最典型特征，因为零利率下就不会有什么经济增长和物价上涨，经济基本就是死水一潭。。。</p><p>这个道理很简单；资本是逐利的，零利率意味着资本没有利益了，没利益资本就不会投资，就不会活跃，经济发展当然就会停滞。。。</p><p>最近 5 年，安倍政府采用极端的货币宽松手段，但也没能把日本经济拉出流动性陷阱泥潭，这负的拆借利率就是证明。。。</p><p>有网友会说，最近 2 年，日本 GDP 还有了 2% 左右的增速，可网友注意没有，这是以日元贬值为代价的，</p><p>安倍政府这几年大量货币宽松，导致日元从 1 美元 = 80 多日元，贬值到 1 美元 = 约 110 日元，这种以日元贬值为代价的 GDP 增长，导致按美元计算的 GDP 实际没啥增长，最近几年日本人均 GDP 在世界排名是下降的，这就是证明，证明日本经济根本就没有跳出流动性陷阱，依靠货币宽松搞出的 GDP 增长实际只是货币泡沫。。。</p><p>这就是凯恩斯理论的威力，摆在日本面前只有一条出路；将通货紧缩进行到底，消灭债务，消灭货币，经济才能真正恢复健康，否则经济发展就只能停滞。。。</p><p>但是，日本经济并非没有亮点，日本经济唯一的亮点就是；失业率低，几乎处于充分就业状况，这就怪了，经济不好，这就业怎么会好呢。。。</p><p>大家记得，有中国经济精英还煞有介事的计算过，GDP 增长一个百分点，就可以创造就业 150 万，因为中国每年有超过 1000 万人新增就业，所以 GDP 增速要 7% 左右。。。云云。。。</p><p>然而，日本就业率状况证明中国经济精英的这种观点并不正确，我估计也不会有一个中国经济学者能正确解释日本经济低迷，为何还能充分就业。。。</p><p>这个问题先放一边，我会找机会与网友深入探讨。。。</p><p>我们继续看美国。。。</p><p>未完待续</p><p>碧海蓝天已被使用 2018-02-04 17:52<br>楼主博学，没有比较就没有鉴别，日本有充分的就业是不是人口少的缘故？<br>晔小生 2018-02-04 23:50<br>评论 碧海蓝天已被使用：日本的人口数量低，但是日本的人口密度比中国高很多。日本的就业率高，可能是人口老龄化，制造业这些旧产业一直稳步发展，而且一些新兴产业的涌现。日本的就业率很高，但也并非如报道那样全覆盖的，里面有很多就业人员工资很低的<br>剩余 4 条<br>评论 看全部<br>x8596t<br>2018-02-04 15:56<br>26282 楼<br>继续 396</p><p>现在我们来聊美国的经济发展趋势。</p><p>看上去，美国的经济情况比日本要好得多，无论是总债务还是政府债务要少的多，GDP 增速还有 2 到 3%，M2 也只有 GDP 的 91%。。。</p><p>但美国经济有两大软肋；1 是巨大的泡沫股市，2 是已经永远还不清的政府债务，</p><p>美国股市泡沫如同悬在美国经济头上的达摩斯剑，随时都可能掉下来，美国经济就会好日子不再，直接掉入像日本一样的低利率流动性陷阱。。。</p><p>而支撑美国股市泡沫的又是美国的不断增长的财政开支，一旦财政开支停止增长，或者增长慢了，美国股市就可能随时崩盘，上个星期五，道琼斯指数狂跌 700 点，就是客观经济规律给美国经济的一个警告。。。</p><p>与此同时，美国财政开支的增长越来越不可持续，美国中央银行美联储已经对美国政府关闭了印钞机，</p><p>评论 看全部<br>x8596t<br>2018-02-04 17:05<br>26283 楼<br>继续 396 第二部分；</p><p>刚才不小心点错了键，还没写完就发出来了，网友见谅。。。</p><p>美联储对美国政府关闭印钞机后，美国财政赤字就只能靠全世界老百姓和政府购买美国国债，就是说，美国国债唯一来源就是存量资金了。。。</p><p>这就引发我们必须讨论和学习的一大经济原理，搞明白这一大经济原理后，我们就会明白，美国经济同样无别路可走，只有一条路，将通货紧缩进行到底，或者说，美国股市泡沫必破。。。</p><p>为什么？是什么样的经济原理有这么大的能耐。。。</p><p>其实很简单，这就是以凯恩斯理论为基础的纸币体系的基本特性决定了。。。。</p><p>这个特性就是，现代市场的所谓经济增长必定是货币数量的增长，或者说没有货币数量的增长就没有经济增长。。。</p><p>例如；美国 2017 年有 GDP 总额 19 万亿美元，增长 3% 就是增长净额为；5700 亿美元，这 5700 亿美元必须对应货币数量的增长。。。</p><p>因为这 5700 亿美元 GDP 增长分为三大块；劳动者工资，资本家利润，政府税收，</p><p>例如，工资增长 2000 亿美元，利润增加 2000 亿美元，税收增加 1700 亿美元，这都得体现在货币数量的增长上。。。</p><p>这就冒出一个天大的问题，美国的货币总量一定得比前一年增加 5700 亿美元，否则工人，资本家，政府就无法得到足额的收入增长。。。对不对。</p><p>那么，这货币增量从哪里来呢？</p><p>按纸币体系原理，只有两个来源；1，美联储印钞机，2，美国各个商业银行创造信用货币。</p><p>这要在中国，增长点货币实在小菜一碟，来个 PSL 印个 1 万亿，PPP 项目银行贷款 2 万亿，三万亿货币就增发出来了，也就是发个红头文件就轻易搞定。。。哈哈</p><p>可在美国却没那么容易，因为美联储，商业银行都是私人性质，都是不能亏本，不能庞氏借债的。。。</p><p>例如，美联储之所以对美国政府关闭印钞机，原因就是看你美国政府还不上了，利息都还不起了，那对不起，不借了，要缩表了。。。</p><p>例如，美国地方政府要借新债还旧债，要搞什么债务置换，对不起，美国商业银行打死也不会同意，因为美国商业银行都是私人银行，这消息传出去，引起储户挤兑，那银行是要破产的。。。</p><p>但美元作为世界货币，美国政府还有一大优势，这就是把散落在世界各地的美元收集起来，同时大幅缩减对外贸易逆差，也就是减少美元流失。。。</p><p>这就是为什么美国总统特朗普一面大肆吹牛，要给每个中产家庭减税 4000 亿美元，同时要大幅减税，吸引苹果公司，微软等美国企业的海外资金流入美国的原因。。。</p><p>与此同时，特朗普还盯上了中国的巨额外汇储备和贸易顺差，中美贸易对决不可避免。。。</p><p>不过理想很丰满，现实很骨感，特朗普虽然野心勃勃，但美国财政现实很可能让他碰个满头包。。。</p><p>为什么，道理很简单；</p><p>要美元回流美国，就得减税，就得加息，现在美国政府债务高达 20 万亿，加一个点利息就增加 2000 亿，预计 2018 年美国财政利息开支将暴增到 5000 多亿美元，庞氏借债已经非常明显，</p><p>如果特朗普政府一意孤行的借债借下去，要不了多久就会遭遇国债违约的风险，这时的特朗普政府就只有乞求美国国会提高预算，要求美联储开动印钞机救美国政府了。。</p><p>可美国的经济制度不是中国式的经济制度，只要美国国债违约消息传出，不等国会投票通过预算，美国股市泡沫可能就破裂了。。。</p><p>史上最大美国股市泡沫破裂，美国经济一头掉进日本式的流动性陷阱就是大概率了。。。</p><p>到时，再能干的特朗普总统也只能仰天长叹，生不逢时啊。。。</p><p>以上议论，许多网友一定听得一愣一愣的，半信半疑，将信将疑，这需要我们进一步把纸币体系和金银货币体系推动经济增长的经济原理探讨清楚，网友就明白了。。。</p><p>未完，待续<br>继续 397</p><p>接着 396 聊，为什么美国经济最终跳不出凯恩斯理论框框，必定掉入日本式的低利率流动性陷阱。。。</p><p>这得从金银货币体系与现代纸币体系推动经济增长的经济原理说起；</p><p>当今世界，老百姓都习惯了货币超发，认为货币面额只能越来越大，从来没有想过，纸币其实也是可以朝面额越来越小方向发行的。。。</p><p>例如人民币，几十年前最大面额是 10 元，后来就增加了 20,50,100 元面额，面额越来越大，似乎天经地义，一些网友甚至还煞有介事的质问；经济越来越发展，商品越来越多，不发行一定货币怎么行，。。。</p><p>有没有网友想过，其实人民币也可以朝小面额方向发行的，例如，发行分币以下的厘，豪之类的更小面额的纸币。。。</p><p>什么叫解放思想，打破纸币只能朝大面额发行的思想框框，树立纸币也可以朝小面额发行的创新思想就是最新的思想解放潮流。。。，现在不是提倡创新吗。。。哈哈</p><p>一些网友一定提出质疑，纸币朝小面额发行怎么发展经济。。。</p><p>其实，货币面值越来越小才是适合人类经济发展规律的，货币面额越来越大，反而是违背人类经济发展客观规律的。。。</p><p>为什么？</p><p>因为商品价值由其所含社会平均必要劳动时间决定，隋着科学技术的发展，劳动生产率不断提高，生产一件商品所耗费的劳动时间就会越来越少，商品价值就越来越低，价格当然就越来越低了。。</p><p>例如，10 年前一个 100 工人鞋厂，年产 10 万双鞋，10 年后，采用先进制鞋设备，同样 100 个工人年产鞋提高到 100 万双，这样每双鞋耗费的劳动时间就只有 10 分之一了，价值降低了，价格也就应该下降了，。。对不对。</p><p>所以，货币面额越来越小才是符合经济发展客观规律的。。。</p><p>那么如果采用朝面额越来越小的方向发行货币，商品价格越来越便宜，那经济又是如何发展的呢？</p><p>未完，待续</p><p>别崩着我 2018-02-05 15:41<br>楼主你就在这里忽悠吧<br>滑雪爱好者 2017 2018-02-05 16:13<br>评论 别崩着我：你别听啊，欠儿的进来一楼楼追完然后嘲讽一句，滚<br>剩余 4 条<br>评论 看全部<br>x8596t<br>2018-02-05 14:46<br>26310 楼<br>继续 398</p><p>接着聊，货币面值越来越小是怎样推动经济发展的；</p><p>举例 1；</p><p>甲猎人擅长捕猎野兔，平均每 2 小时劳动时间可捕获一只，标价 2 元。</p><p>乙猎人擅长捕猎野鸡，平均每 2 小时劳动时间可捕获一只，标价 2 元。</p><p>甲猎人卖出野兔 1 只，获得 2 元，从乙哪里购得野兔 1 只，甲乙猎人各用 2 小时劳动时间获得一只野兔，或一只野鸡。</p><p>举例 2；</p><p>甲猎人改进捕猎工具，劳动生产率提高，平均每 1 个劳动小时可以捕猎 1 只野兔了，标价 1 元，因为甲的劳动生产率提高，捕猎野兔耗费的劳动时间降低，也就是商品价值降低，所以每只野兔降价为 1 元。</p><p>乙猎人也一样提高了劳动生产率，平均每 1 个劳动小时可以捕猎一只野鸡了。野鸡降价，标价 1 元。</p><p>甲卖掉 2 小时捕猎的 2 只野兔，获得 2 元，从乙哪里买来 2 只野鸡，甲用同样 2 小时的劳动时间，却多换得 1 只野鸡，甲的生活水平提高了，也就是经济发展了。</p><p>反之，对乙猎人也是一样，由于劳动生产率提高，尽管野鸡价格降低了，但同样的 2 小时劳动时间却可以换得更多商品了。。。</p><p>这样，甲乙都会努力提高劳动生产率，劳动积极性更高了，经济也就不断发展了。。。</p><p>因为，因为，因为，甲乙猎人发现，只要劳动生产率提高，即使商品价格下跌，照样可以提高生活水平啊。。。</p><p>从以上 2 个例子，我们明白如下科学道理；</p><p>1，经济发展的决定性因素是劳动生产率提高，只要劳动生产率提高，即使商品降价，同样可以促进经济发展。</p><p>2，货币只是商品交易媒介，与经济发展其实没有关系，货币数量增加，价格上涨不一定代表经济发展了，相反，货币总量不变，商品增加，价格下跌，反而更能代表经济发展，甚至是经济发展更为健康的标志。。。</p><p>我们把以上两个例子扩展到现代经济体制下的一个国家，道理也是一样。。。</p><p>即；我们既可以用超发货币的办法发展经济，也可以用通货紧缩的办法发展经济，也就是说，货币面额朝不断增大的方向发行可以发展经济，也可以朝货币面值不断缩小的方向发行来发展经济，</p><p>最为重要的是，这种通货紧缩发展经济的办法更健康，可持续，因为这是符合人类经济发展规律的，而通货膨胀发展经济的办法是违背客观经济规律的。。。</p><p>而凯恩斯理论是依靠通货膨胀办法发展经济的，是违背人类经济发展客观规律的，最终必将把人类经济引入流动性陷阱的死胡同。。。</p><p>特别要提醒网友的是，连凯恩斯本人都承认，按他的理论发展经济，最终难逃流动性陷阱。。。</p><p>所以，我点赞凯恩斯先生，毕竟是个经济科学家，能够实事求是。。。凯恩斯先生对人类经济，特别是对资本主义经济发展贡献是伟大的，无与伦比的。。。</p><p>所以，今天美国经济，无论特朗普多么能干，经济政策刀刀见血，也是无力回天，而且越是折腾，美国股市崩盘还会越快。。。越会加速掉入日本式流动性陷阱。。。</p><p>时势造英雄，时势也可以灭英雄。。。哈哈</p><p>接下来我们再聊中国。。。</p><p>未完，待续</p><p>ty_134772404 2018-02-05 14:55<br>我就想知道中国 2.3.4 线城市的房价何时崩盘<br>hnpjcw 2018-02-05 15:12<br>崩盘的定义呢？<br>剩余 20 条<br>评论 看全部<br>x8596t<br>2018-02-06 04:33<br>26332 楼<br>@金陵徒步者 2018-02-05 19:20:39</p><p>我没有经济理论来反驳 LZ 的通缩发展经济的设想，但是我基于常识，提出几个问题：</p><p>LZ 通缩发展经济理论 是按通货膨胀形态进行倒推的。看起来好像没有错误哦，但为什么那么多政府 和 经济学家没有想到呢？ 凯恩斯那么聪明，难道就没有考虑过把事情颠倒过来操作？？？ 为什么世界范围没有实施的案例？？？？</p><p>原因很简单：通缩不可能发展经济！！！！！！ 通缩下，获利最大的行为是存储货币，自然就会降低消费，经……</p><hr><p>人类经济发展科分为三大阶段；</p><p>1，商品 - 货币 - 商品，这个阶段的货币只是交易媒介。</p><p>2，资本 1 - 商品 - 资本 2，这个阶段是资本主义生产阶段，这个阶段货币转化为资本，货币的主要功能转变为谋取利润服务。资本的逐利性成为推动经济发展的第一动力。。。</p><p>3，劳动 - 劳动，这个阶段作为交易媒介的货币也会逐步消失，人们将直接进行劳动的交换。。。</p><p>这个阶段是建立在生产力，科学技术高度发达的基础上，接下来会与网友详细探讨这个经济发展阶段。。。</p><p>网友们长期生活在市场经济中，已经习惯了资本主义生产方式和交换方式，思维已经定格，所以，一时半时是很难理解通货紧缩是如何发展经济的。。。</p><p>你说得没错，探讨这个阶段难免会牵扯到比特币和区块链技术，。。。争议太激烈，慢慢来吧，来日方长，大家共同探讨，共同学习，共同提高。。。</p><p>x8596t 楼主: 2018-02-06 04:38<br>顺便说一下，你说为什么没有经济学者探讨这个问题，道理很简单，现在的经济学，经济学家都是为资本主义服务的，探讨通货紧缩下如何发展经济的结论只能是否定资本主义，他们当然没法探讨了，凯恩斯主义就是为挽救资本主义而兴起的一门经济学。。。<br>pxlee21cn 2018-02-06 10:46<br>楼主思想超前 N 年。劳动 - 劳动，比特币和区块链要去中心化，然而政府不会放取手中的利益， 肯定拼命抵制。<br>剩余 6 条<br>评论 看全部<br>x8596t<br>2018-02-06 14:00<br>26353 楼<br>继续 399</p><p>今天聊一个非常重要，事关网友切身利益的大事，这就是失业问题，因为我预计，2 到 3 年后火热的房价话题将不再被大家关注，人们将越来越关注失业。。。</p><p>早几年，有中国经济精英说，GDP 每增加一个百分点，就可以解决约 150 万人失业，中国每年新增就业人口约 1000 多万，所以 GDP 增速要保持在 7% 左右才能解决就业问题。。。云云。</p><p>可美日近年来在 GDP 增速仅为 1 到 2% 左右的情况下，却几乎达到了 4% 左右的失业率，4% 在经济学上已经可以视为充分就业了。。。</p><p>事实证明，中国经济精英的 GDP 与失业关系的理论是不正确的，因为美日的实践证明，低 GDP 增速下也可以实现高就业。。。</p><p>这是什么原因呢，是什么样的经济原理在起作用呢？还没有看到任何一个经济专家学者对此做过解释，我估计他们也解释不出。。。</p><p>今天，我就与网友深入探讨一下，欢迎网友批评指正，加入讨论。。。</p><p>这个经济原理其实很简单，这就是低利率，零利率的经济环境促成的结果。。</p><p>那为什么低利率，零利率环境下可以出现低经济增长，高就业呢？</p><p>我曾经在前面相关帖文中提出过这样的观点，即；造成失业的主要原因是资本的逐利性，逻辑推理如果要提高就业，就需要去除资本的逐利性。。。</p><p>而美国日本多年来执行低利率，零利率，甚至负利率，这就在一定程度上去除了资本的逐利性，或者说，制造了资本难以获取利润，资本生存艰难的经济环境。。。</p><p>1，零利率消除了大量不劳而获的人群，逼迫所有的人都得劳动，只有劳动才能生存。</p><p>例如，中国财政 2017 年支出国债利息 6130 亿元，加上地方政府利息支出。合计总利息支出大约为 2.5 万亿。。。</p><p>2.5 万亿是什么概念，如果工资 2000 元月，那么将有 1 亿人口可以不劳而获的靠利息收入生活。。。</p><p>一亿人啊，这还仅仅只算政府这一块的利息支出，算上全国各行业，那将是天文数字。</p><p>在零利率情况下呢，这 1 亿人就没法靠利息不劳动而生活了，他们就必须靠劳动获得收入生存了。</p><p>2，在零利率环境下，资本也不得不放弃追求高利润，力图以最小的利润率求生存了。</p><p>按资本逐利性原则，市场利率高。资本追求的利润率也就会高，反之资本追求的利润率就低。。。</p><p>例如，当银行利率 5%，企业均利润率 2 时，资本家就会放弃企业，资本就会转而去追求</p><p>银行高利率了。</p><p>反之，当银行利率为零时，资本就只能放弃追求高利润率，转而以保持极低的利润率求生存了。</p><p>未完，待续</p><p>箐箐河边草 2016 2018-02-06 14:12<br>这意思是日本负利率好处大大的 实现完全就业了 ⊙?⊙！<br>jianpu2015 2018-02-06 14:16<br>评论 x8596t：同样债台高筑，那国内是否也可以实行低利率？<br>剩余 5 条<br>评论 看全部<br>x8596t<br>2018-02-06 15:15<br>26355 楼<br>继续 400</p><p>前面 399 说到，低利率，零利率经济环境下会出现如下两种情况；</p><p>1，大量靠利息不劳而获的人群被消除，人人都得靠劳动生存。</p><p>2，资本追逐利润率目标降低，资本的逐利性大幅下降，资本将以保持最低利润率求生存。</p><p>所以，在零利率环境下，劳动者和资本家都得为生存而努力，一个要找工作求生存，一个以资本最低利润率求生存，双方抱团取暖。。。</p><p>这样，经过一段时间的磨合，相互结合，经济就稳定了，劳动就业率就会上升。。。</p><p>与此同时，消费也会趋于稳定，因为人人靠劳动获取收入，收入的大部分会用在消费上，进而导致资本的生存空间也稳定下来。。。</p><p>不过零利率环境付出的代价就是低经济增长，因为资本无法追逐到高利润，资本活跃度降低，投资意愿降低，经济死水一潭。。。</p><p>所以，此时要想提高经济增长率，就得抬高利率，抬高通货膨胀，以满足资本的逐利性，。。</p><p>不过自相矛盾的是，此时的美日经济体都是债台高筑，任何提高利率的做法几乎都是不作就不会死。。。</p><p>例如，日本政府负债高达 GDP 的 250%，任何加息几乎都是自杀行为，都是在引爆债务炸弹。</p><p>例如，美国债务总额高达 20 万亿，利率每上升一个点就得增加 2000 亿美元，如果按照特朗普，美联储的计划，真的把利息升到正常利率 3.5% 左右，那美国国债利率将升高到 4.5% 左右，一年美国政府光利息开支就会超过 9000 亿美元。。。</p><p>而现在美国财政赤字一年高达 1.3 万亿美元，增加的债务将大部分被用来偿付利息，结果必然导致美国国会的反对，会不断提高特朗普政府预算批准难度。。。</p><p>当国会议员看到特朗普政府减税，加息必定导致美国政府永远也还不清债务了，美国政府越来越高的财务预算将很难获得国会批准了，最近美国政府因为国会迟迟不通过提高债务上限而关门，就是国会对美国政府的警告。。。</p><p>美国是个多权分立的国家，因为美国政府的庞氏借债，美联储已经关闭印钞机了，很有可能，美国国会也将对特朗普的预算计划说不了。。。</p><p>这可不像中国，几个国会，政府，央行巨头一碰面，那有预算不能通过的，哪有央行敢不开动印钞机的，这大概就是一些经济精英鼓吹的中国模式的优势吧。。。哈哈。</p><p>所以，美日如果不将通货紧缩进行到底，彻底消除债务，消减贫富分化，调整经济结构，就别想真正恢复经济增长。。。</p><p>好，扯远了，现在我们回到失业问题的讨论上来。。。</p><p>毫无疑问，美日低利率环境下，低经济增长，高就业的实践会对中国可能遭到经济危机时，如何应对大规模失业将有十分要的理论和实践意义。。。</p><p>未完，待续</p><p>小龙栖尧 2018-02-06 15:33<br>没有连续加息，中国的房子估计又要反弹了<br>无心插柳 oy 2018-02-06 15:41<br>房价和 m2 有关 加息是为了稳汇率 当然加息了 各种债务会被引爆 ！目前估计谁也解决不了这难题，只有静观其变，实际上就是拖吧<br>剩余 5 条<br>评论 看全部<br>x8596t<br>2018-02-07 16:24<br>26394 楼<br>继续 401</p><p>我觉得可以聊聊比特币和区块链技术了。。。</p><p>一是因为比特币暴跌到 6000 美元，现在谈，一些网友就没那么反感了。。。</p><p>二是因为事关网友的人生发展选择，事关网友，特别是年轻网友的学习，就业。。。</p><p>当今世界和中国正处于一个新的历史潮流拐点，每个人都不得不作出选择，选择正确，人生道路就可能顺风顺水，事半功倍，错了就可能坎坎坷坷，事倍功半了。。。</p><p>例如，1979 年，你考上大学，你是选择马列主义专业，还是选择金融专业，那对你的前途影响就大了。</p><p>例如，大清朝末年，你是选择读四书五经，考秀才，还是选择学习蒸汽动力原理，蒸汽机制造，那你的前途就相差天远地远了。。。</p><p>回到当今现实中；</p><p>学习金融</p><p>学习比特币和区块链技术。</p><p>如果你选择学金融，对不起，你将来可能很难找到对口工作，除了改行，别无选择，</p><p>因为我预测，一旦危机来临，失业大军中最大比例可能就是当今红得发紫的所谓经济金融界</p><p>很明显，是学金融还是学比特币，区块链技术，毫无疑问，我是赞成年轻网友学习比特币和区块链技术的。。。</p><p>为什么？</p><p>未完，待续</p><hr><p>注意: 目前而言比特币，区块链之类的技术泡沫已经破裂了，无事勿扰，有事烧纸！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
